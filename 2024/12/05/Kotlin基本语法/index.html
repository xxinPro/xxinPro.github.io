<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.jpg"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.ico"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.ico"><link rel="mask-icon" href="/images/logo.svg" color="#222"><meta name="google-site-verification" content="INib61UyYabZlsc0LPzbi5O2qlux9S7YlcvrRdmFOmU"><meta name="msvalidate.01" content="A117C8AE0DF96AAEC2BC9D4914C0B404"><meta name="yandex-verification" content="2c7e88b2e774befb"><meta name="baidu-site-verification" content="codeva-Hhmgc2znuV"><meta name="360-site-verification" content="99dc35dba24d3316a5c4165a21d1c8b2"><meta name="sogou_site_verification" content="n0MrA7DawS"><meta name="bytedance-verification-code" content="T5+8Lbmr5HPdlA87vM/H"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.css" integrity="sha256-gkQVf8UKZgQ0HyuxL/VnacadJ+D2Kox2TCEBuNQg5+w=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"blog.xxin.xyz","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":null},"fold":{"enable":true,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":true,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true}}</script><script src="/js/config.js"></script><meta name="description" content="Kotlin入门"><meta property="og:type" content="article"><meta property="og:title" content="Kotlin基本语法"><meta property="og:url" content="https://blog.xxin.xyz/2024/12/05/Kotlin%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/index.html"><meta property="og:site_name" content="小信笔记"><meta property="og:description" content="Kotlin入门"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2024-12-05T04:25:47.000Z"><meta property="article:modified_time" content="2026-01-05T13:26:22.605Z"><meta property="article:author" content="xxin"><meta property="article:tag" content="Kotlin入门"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://blog.xxin.xyz/2024/12/05/Kotlin%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://blog.xxin.xyz/2024/12/05/Kotlin%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/","path":"2024/12/05/Kotlin基本语法/","title":"Kotlin基本语法"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>Kotlin基本语法 | 小信笔记</title><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">小信笔记</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">逃避思考，热爱幻想</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-links"><a href="/links/" rel="section"><i class="fa fa-link fa-fw"></i>友链</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="nav-number">1.</span> <span class="nav-text">修饰符</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E%E5%8F%98%E9%87%8F"><span class="nav-number">2.</span> <span class="nav-text">声明变量</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E6%8E%A7%E5%88%B6"><span class="nav-number">3.</span> <span class="nav-text">逻辑控制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#if"><span class="nav-number">3.1.</span> <span class="nav-text">if</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#when"><span class="nav-number">3.2.</span> <span class="nav-text">when</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#for"><span class="nav-number">3.3.</span> <span class="nav-text">for</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#while"><span class="nav-number">3.4.</span> <span class="nav-text">while</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%87%BD%E6%95%B0"><span class="nav-number">4.</span> <span class="nav-text">函数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3"><span class="nav-number">5.</span> <span class="nav-text">类和接口</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E%E7%B1%BB"><span class="nav-number">5.1.</span> <span class="nav-text">声明类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">5.2.</span> <span class="nav-text">构造函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">5.2.1.</span> <span class="nav-text">主构造函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AC%A1%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">5.2.2.</span> <span class="nav-text">次构造函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF"><span class="nav-number">5.3.</span> <span class="nav-text">继承</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB"><span class="nav-number">5.4.</span> <span class="nav-text">数据类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%95%E4%BE%8B%E7%B1%BB"><span class="nav-number">5.5.</span> <span class="nav-text">单例类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3"><span class="nav-number">5.6.</span> <span class="nav-text">接口</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%9B%86%E5%90%88"><span class="nav-number">6.</span> <span class="nav-text">集合</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#List"><span class="nav-number">6.1.</span> <span class="nav-text">List</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Set"><span class="nav-number">6.2.</span> <span class="nav-text">Set</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Map"><span class="nav-number">6.3.</span> <span class="nav-text">Map</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">7.</span> <span class="nav-text">Lambda表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="nav-number">7.1.</span> <span class="nav-text">函数式接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0"><span class="nav-number">7.2.</span> <span class="nav-text">函数作为参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="nav-number">7.3.</span> <span class="nav-text">函数作为返回值</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="xxin" src="https://q1.qlogo.cn/g?b=qq&nk=3033528136&s=640"><p class="site-author-name" itemprop="name">xxin</p><div class="site-description" itemprop="description">路漫漫其修远兮，吾将上下而求索。</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">196</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">10</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">25</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/xxinPro" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;xxinPro" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class="links-of-author-item"><a href="https://wpa.qq.com/msgrd?v=3&uin=3033528136&site=qq&menu=yes" title="QQ → https:&#x2F;&#x2F;wpa.qq.com&#x2F;msgrd?v&#x3D;3&amp;uin&#x3D;3033528136&amp;site&#x3D;qq&amp;menu&#x3D;yes" rel="noopener me" target="_blank"><i class="fab fa-qq fa-fw"></i>QQ</a> </span><span class="links-of-author-item"><a href="mailto:x@xxin.xyz" title="E-Mail → mailto:x@xxin.xyz" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a></span></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://blog.xxin.xyz/2024/12/05/Kotlin%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="https://q1.qlogo.cn/g?b=qq&nk=3033528136&s=640"><meta itemprop="name" content="xxin"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="小信笔记"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索。"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="Kotlin基本语法 | 小信笔记"><meta itemprop="description" content="<center>Kotlin入门</center>"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Kotlin基本语法</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2024-12-05 12:25:47" itemprop="dateCreated datePublished" datetime="2024-12-05T12:25:47+08:00">2024-12-05</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Kotlin/" itemprop="url" rel="index"><span itemprop="name">Kotlin</span></a> </span></span><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>10k</span></span></div><div class="post-description"><center>Kotlin入门</center></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h1><div class="table-container"><table><thead><tr><th>修饰符</th><th>说明</th></tr></thead><tbody><tr><td>private</td><td>只能在当前类中访问</td></tr><tr><td>protected</td><td>只能在当前类和子类中访问</td></tr><tr><td>public</td><td>任何类都可以访问（默认）</td></tr><tr><td>internal</td><td>只能在当前模块中访问</td></tr></tbody></table></div><h1 id="声明变量"><a href="#声明变量" class="headerlink" title="声明变量"></a>声明变量</h1><p><code>Kotlin</code>使用<code>val</code>声明<span class="self-color-red">不可变</span>变量，使用<code>var</code>声明<span class="self-color-red">可变</span>变量</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> name: String = <span class="string">&quot;小明&quot;</span></span><br><span class="line"><span class="keyword">var</span> age: <span class="built_in">Int</span> = <span class="number">18</span></span><br></pre></td></tr></table></figure><p><code>kotlin</code>类型推导机制：自动推导变量的数据类型，不需要显式指定</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> name = <span class="string">&quot;小明&quot;</span></span><br><span class="line"><span class="keyword">var</span> age = <span class="number">18</span></span><br></pre></td></tr></table></figure><p>但是如果延迟赋值，就必须显式指定类型</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只声明不赋值</span></span><br><span class="line"><span class="keyword">val</span> name: String</span><br><span class="line"><span class="keyword">val</span> age: <span class="built_in">Int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 赋值</span></span><br><span class="line">name = <span class="string">&quot;小明&quot;</span></span><br><span class="line">age = <span class="number">18</span></span><br></pre></td></tr></table></figure><p><code>kotlin</code>中默认不允许变量为<code>null</code>，如有必要，必须使用<code>?</code>修饰</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> name: String? = <span class="literal">null</span></span><br><span class="line"><span class="keyword">var</span> age: <span class="built_in">Int</span>? = <span class="literal">null</span></span><br></pre></td></tr></table></figure><h1 id="逻辑控制"><a href="#逻辑控制" class="headerlink" title="逻辑控制"></a>逻辑控制</h1><h2 id="if"><a href="#if" class="headerlink" title="if"></a>if</h2><p><code>if</code>语法常规使用和<code>Java</code>基本一致</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getType</span><span class="params">(any : <span class="type">Any</span>)</span></span> : String &#123;</span><br><span class="line">    <span class="keyword">if</span> (any <span class="keyword">is</span> String) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;String&quot;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (any <span class="keyword">is</span> Number) &#123;</span><br><span class="line">        <span class="comment">// double float long int short byte 都是Number的子类</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Number&quot;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (any <span class="keyword">is</span> <span class="built_in">Char</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Char&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Unknown&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>if-else</code>语句可以作为表达式给变量赋值，每个条件代码块中的最后一行代码作为该条件的返回值</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> isRange: <span class="built_in">Boolean</span> = <span class="keyword">if</span> (value <span class="keyword">in</span> <span class="number">0.</span><span class="number">.100</span>) &#123;</span><br><span class="line">    <span class="literal">true</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面的 0..100 可以看作数学闭区间，即 [0, 100]</span></span><br><span class="line"><span class="keyword">val</span> r1: IntRange = <span class="number">0.</span><span class="number">.100</span></span><br><span class="line"><span class="comment">// 对于左闭右开区间，即 [0, 100)</span></span><br><span class="line"><span class="keyword">val</span> r2: IntRange = <span class="number">0</span> until <span class="number">100</span></span><br></pre></td></tr></table></figure><p>进一步简化</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> isRange: <span class="built_in">Boolean</span> = <span class="keyword">if</span> (value <span class="keyword">in</span> <span class="number">0.</span><span class="number">.100</span>) <span class="literal">true</span> <span class="keyword">else</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><h2 id="when"><a href="#when" class="headerlink" title="when"></a>when</h2><p><code>when</code>语句可以替代<code>if</code>、<code>else if</code>、<code>else</code>，并且也可以有返回值</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getType</span><span class="params">(any: <span class="type">Any</span>?)</span></span> : String &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">when</span> (any) &#123;</span><br><span class="line">        <span class="keyword">is</span> String     -&gt; &#123;<span class="string">&quot;String&quot;</span>&#125;</span><br><span class="line">        <span class="keyword">is</span> Number     -&gt; &#123;<span class="string">&quot;Number&quot;</span>&#125;</span><br><span class="line">        <span class="keyword">is</span> <span class="built_in">Char</span>       -&gt; &#123;<span class="string">&quot;Char&quot;</span>&#125;</span><br><span class="line">        (any == <span class="literal">null</span>) -&gt; &#123;<span class="string">&quot;null&quot;</span>&#125;</span><br><span class="line">        <span class="keyword">else</span>          -&gt; &#123;<span class="string">&quot;Unknown&quot;</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进一步简化<br></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getType</span><span class="params">(any: <span class="type">Any</span>?)</span></span> = <span class="keyword">when</span> (any) &#123;</span><br><span class="line">    <span class="keyword">is</span> String -&gt; <span class="string">&quot;String&quot;</span></span><br><span class="line">    <span class="keyword">is</span> Number -&gt; <span class="string">&quot;Number&quot;</span></span><br><span class="line">    <span class="keyword">is</span> <span class="built_in">Char</span>   -&gt; <span class="string">&quot;Char&quot;</span></span><br><span class="line">    <span class="literal">null</span>      -&gt; <span class="string">&quot;null&quot;</span></span><br><span class="line">    <span class="keyword">else</span>      -&gt; <span class="string">&quot;Unknown&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><p><code>for</code>多用于遍历</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单列集合遍历</span></span><br><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> list) &#123;</span><br><span class="line">    println(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 双列集合遍历</span></span><br><span class="line"><span class="keyword">val</span> map = mapOf(<span class="string">&quot;a&quot;</span> to <span class="number">1</span>, <span class="string">&quot;b&quot;</span> to <span class="number">2</span>, <span class="string">&quot;c&quot;</span> to <span class="number">3</span>)</span><br><span class="line"><span class="keyword">for</span> ((key, value) <span class="keyword">in</span> map) &#123;</span><br><span class="line">    println(<span class="string">&quot;<span class="variable">$key</span> -&gt; <span class="variable">$value</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="while"><a href="#while" class="headerlink" title="while"></a>while</h2><p><code>while</code>多用于循环</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">5</span>) &#123;</span><br><span class="line">    println(i)</span><br><span class="line">    i++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p><code>Kotlin</code>使用<code>fun</code>声明函数</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;test&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果未注明返回值类型，会自动推导为<code>Unit</code>类型，即无返回值<br></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span>: <span class="built_in">Unit</span> &#123;</span><br><span class="line">    println(<span class="string">&quot;test&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>返回值类型放在形参列表后面，使用<code>:</code>分隔</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getString</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数只有一个表达式时，可以省略花括号和<code>return</code>关键字，用一个等号代替</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getString</span><span class="params">()</span></span>: String = <span class="string">&quot;Hello&quot;</span></span><br></pre></td></tr></table></figure><p>使用<code>=</code>号时，由于类型推导机制的存在，可以省略返回值类型</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getString</span><span class="params">()</span></span> = <span class="string">&quot;Hello&quot;</span></span><br></pre></td></tr></table></figure><p>函数也可以作为参数传递给其他函数</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> func = <span class="function"><span class="title">fun</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    printString(func)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接受一个函数作为参数</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printString</span><span class="params">(func : () -&gt; <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    println(func.invoke())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="类和接口"><a href="#类和接口" class="headerlink" title="类和接口"></a>类和接口</h1><h2 id="声明类"><a href="#声明类" class="headerlink" title="声明类"></a>声明类</h2><p>声明类使用<code>class</code></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>() &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类中没有属性和方法时，可以省略构造器括号和花括号<br></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span></span><br></pre></td></tr></table></figure><p></p><p><code>Kotlin</code>中创建对象不需要使用<code>new</code>关键字</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> user = User()</span><br></pre></td></tr></table></figure><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p><code>Kotlin</code>中构造函数分为<span class="self-color-red">主</span>构造函数和<span class="self-color-red">次</span>构造函数</p><h3 id="主构造函数"><a href="#主构造函数" class="headerlink" title="主构造函数"></a>主构造函数</h3><p>主构造函数写在类名后面，使用<code>constructor(...)</code>关键字声明，<code>constructor</code>关键字可以省略，括号中是主构造函数的形参列表</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">constructor</span>()</span><br></pre></td></tr></table></figure><p>如果类没有显式声明任何<span class="self-color-red">主、次</span>构造函数构造函数，则会自动生成无参的主构造函数，如下三种写法实际上完全一致</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">constructor</span>()</span><br></pre></td></tr></table></figure><p>主构造函数没有<span class="self-color-red">函数体</span>，如果要在主构造函数中写逻辑，需要写在<code>init</code>结构体中</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>(<span class="keyword">var</span> name: String, <span class="keyword">var</span> age: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        printInfo()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">printInfo</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;name: <span class="variable">$name</span>, age: <span class="variable">$age</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主构造函数中使用<code>var</code>或<code>val</code>声明的形参，和常规成员变量的调用完全一致</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>(<span class="keyword">var</span> name: String, <span class="keyword">var</span> age: <span class="built_in">Int</span>)</span><br></pre></td></tr></table></figure><p>但如果主构造函数中的形参没有<code>var</code>或<code>val</code>声明，则只能在<code>init</code>结构体和类中调用</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>(name: String, age: <span class="built_in">Int</span>)&#123;</span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        <span class="comment">// 主构造函数中的形参在结构体中被使用</span></span><br><span class="line">        println(<span class="string">&quot;name = <span class="variable">$name</span>, age = <span class="variable">$age</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="次构造函数"><a href="#次构造函数" class="headerlink" title="次构造函数"></a>次构造函数</h3><p>声明次构造函数使用<code>constructor</code>关键字，允许有多个<span class="self-color-red">次</span>构造函数，而无<span class="self-color-red">主</span>构造函数</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意此时的类名后没有括号，说明没有显式声明主构造函数</span></span><br><span class="line"><span class="comment">// 而类中又声明了次构造函数，所以不会自动生成主构造函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="comment">// 由于在构造函数中一定会对两个成员变量进行赋值</span></span><br><span class="line">    <span class="comment">// 所以在声明时可以省略赋予初始值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> name: String</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> age: <span class="built_in">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 this 调用两个参数的构造函数</span></span><br><span class="line">    <span class="keyword">constructor</span>(name: String) : <span class="keyword">this</span>(name, <span class="number">18</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给属性赋值</span></span><br><span class="line">    <span class="keyword">constructor</span>(name: String, age: <span class="built_in">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">        <span class="keyword">this</span>.age = age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当一个类同时有主、次构造函数时，所有次构造函数必须<span class="self-color-red">直接</span>或<span class="self-color-red">间接</span>的调用主构造函数</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>() &#123;</span><br><span class="line">    <span class="comment">// 此时在主构造函数中未对两个成员变量进行赋值</span></span><br><span class="line">    <span class="comment">// 所以在声明时必须赋予初始值，或者使用 ? 表示可为null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> name: String? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> age: <span class="built_in">Int</span>? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 this 调用两个参数的构造函数</span></span><br><span class="line">    <span class="keyword">constructor</span>(name: String) : <span class="keyword">this</span>(name, <span class="number">18</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给属性赋值</span></span><br><span class="line">    <span class="keyword">constructor</span>(name: String, age: <span class="built_in">Int</span>) : <span class="keyword">this</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">        <span class="keyword">this</span>.age = age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p><code>Kotlin</code>中的类默认不可继承，类和其中的方法都是<code>final</code>的，在类名前添加<code>open</code>关键字使类可以被继承</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">User</span></span><br></pre></td></tr></table></figure><p>类的继承使用<code>:</code>符号，<code>Kotlin</code>中所有类默认继承<code>Any</code>类</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">IKun</span>() : Any()</span><br></pre></td></tr></table></figure><p>父类<code>User</code>之所以带有<code>()</code>，是因为在类继承时子类的构造函数会调用父类的构造函数，如果父类没有显式定义构造函数，子类继承时调用父类的无参构造函数</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">IKun</span> : <span class="type">User</span>()</span><br></pre></td></tr></table></figure><p>如果父类有多个构造函数，子类继承时只需要选择调用一个构造函数即可，通过<code>()</code>中的参数来区分调用哪个构造函数</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类的主构造函数无形参</span></span><br><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">User</span>() &#123;</span><br><span class="line">    <span class="comment">// 一个形参的次构造函数</span></span><br><span class="line">    <span class="keyword">constructor</span>(name: String) : <span class="keyword">this</span>() &#123;</span><br><span class="line">        println(<span class="string">&quot;User的构造方法1&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 两个形参的次构造函数</span></span><br><span class="line">    <span class="keyword">constructor</span>(name: String, age: <span class="built_in">Int</span>) : <span class="keyword">this</span>(name) &#123;</span><br><span class="line">        println(<span class="string">&quot;User的构造方法2&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类继承父类，调用父类空参的主构造函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IKun</span>(name: String) : User()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类继承父类，调用父类一个形参的次构造函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IKun</span>(name: String) : User(name)</span><br></pre></td></tr></table></figure><p>如果子类中只有次构造函数，没有主构造函数，那么继承父类时不能使用<code>()</code>，而是在次构造函数中使用<code>super</code>关键字调用父类的构造函数</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">IKun</span> : <span class="type">User</span> &#123;</span><br><span class="line">    <span class="keyword">constructor</span>() : <span class="keyword">super</span>() &#123;</span><br><span class="line">        println(<span class="string">&quot;IKun constructor&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数据类"><a href="#数据类" class="headerlink" title="数据类"></a>数据类</h2><p><code>Kotlin</code>中提供了数据类，使用<code>data</code>关键字声明，会自动生成<code>equals()</code>、<code>hashCode()</code>、<code>toString()</code>方法</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">User</span>(<span class="keyword">private</span> <span class="keyword">val</span> name: String, <span class="keyword">private</span> <span class="keyword">val</span> age: <span class="built_in">Int</span>)</span><br></pre></td></tr></table></figure><h2 id="单例类"><a href="#单例类" class="headerlink" title="单例类"></a>单例类</h2><p><code>Kotlin</code>中提供了单例类，使用<code>object</code>关键字声明，会自动生成一个实例，并且是线程安全的</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> Singleton &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">singletonTest</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;singletonTest&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在其他<code>kotlin</code>类中调用</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Singleton.singletonTest()</span><br></pre></td></tr></table></figure><p>经过反编译发现，等同于</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> INSTANCE: Singleton = Singleton()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">singletonTest</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;singletonTest&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>java</code>类中的调用<code>object</code>关键字声明的类，用如下方式</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Singleton.INSTANCE.singletonTest()</span><br></pre></td></tr></table></figure><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>声明接口使用<code>interface</code>关键字，接口没有构造函数</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IKun</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">sing</span><span class="params">()</span></span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">dance</span><span class="params">()</span></span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">rap</span><span class="params">()</span></span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">basketball</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现接口使用<code>:</code>符号，实现多个接口使用<code>,</code>分隔，重写方法或成员变量时，需要使用<code>override</code>关键字</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">XiaoHeiZi</span> : <span class="type">IKun</span> &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">sing</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;我会唱&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">dance</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;我会跳&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">rap</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;我会rap&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">basketball</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;我会篮球&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用接口中的方法</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> iKun: IKun = XiaoHeiZi()</span><br><span class="line">iKun.sing()</span><br><span class="line">iKun.dance()</span><br><span class="line">iKun.rap()</span><br><span class="line">iKun.basketball()</span><br></pre></td></tr></table></figure><h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>创建只读<code>List</code>使用<code>listOf()</code>函数。在<code>kotlin</code>中，<code>List</code>是只读的<br>创建可变<code>MutableList</code>， 使用<code>mutableListOf()</code>函数。在<code>kotlin</code>中，<code>MutableList</code>是<code>List</code>的子接口，可以进行增删改操作</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> mutableList: MutableList&lt;String&gt; = mutableListOf(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> list: List&lt;String&gt; = listOf(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>)</span><br></pre></td></tr></table></figure><p>获取<code>list</code>中的第一个或最后一个元素，分别使用<code>.first()</code>和<code>.last()</code>函数。不过<code>.first()</code>和<code>.last()</code>不是<code>List</code>特有的函数，而是<code>kotlin.collections</code>包中定义的扩展函数，适用于所有实现<code>Collection</code>的类</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> firstItem: String = list.first()</span><br><span class="line"><span class="keyword">val</span> lastItem: String = list.last()</span><br></pre></td></tr></table></figure><p>获取<code>list</code>中元素的数量，使用<code>.count()</code>函数</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> itemCount: <span class="built_in">Int</span> = list.count()</span><br></pre></td></tr></table></figure><p>检测元素是否在<code>list</code>中，使用<code>in</code>关键字，其背后实际上是通过<code>contains(E)</code>实现的</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> containsA: <span class="built_in">Boolean</span> = <span class="string">&quot;a&quot;</span> <span class="keyword">in</span> list</span><br><span class="line"><span class="keyword">val</span> containsC: <span class="built_in">Boolean</span> = <span class="string">&quot;c&quot;</span> <span class="keyword">in</span> list</span><br></pre></td></tr></table></figure><p><code>add</code>和<code>remove</code>就不说了</p><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>同<code>List</code>，创建只读<code>Set</code>使用<code>setOf()</code>函数。在<code>kotlin</code>中，<code>Set</code>是只读的<br>创建可变<code>MutableSet</code>， 使用<code>mutableSetOf()</code>函数。在<code>kotlin</code>中，<code>MutableSet</code>是<code>Set</code>的子接口，可以进行增删改操作</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> mutableSet: MutableSet&lt;String&gt; = mutableSetOf(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> <span class="keyword">set</span>: Set&lt;String&gt; = setOf(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>创建只读<code>Map</code>使用<code>mapOf()</code>函数。在<code>kotlin</code>中，<code>Map</code>是只读的<br>创建可变<code>MutableMap</code>， 使用<code>mutableMapOf()</code>函数。在<code>kotlin</code>中，<code>MutableMap</code>是<code>Map</code>的子接口，可以进行增删改操作</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> mutableMap: MutableMap&lt;String, String&gt; = mutableMapOf(<span class="string">&quot;a&quot;</span> to <span class="string">&quot;1&quot;</span>, <span class="string">&quot;b&quot;</span> to <span class="string">&quot;2&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> map: Map&lt;String, String&gt; = mapOf(<span class="string">&quot;a&quot;</span> to <span class="string">&quot;1&quot;</span>, <span class="string">&quot;b&quot;</span> to <span class="string">&quot;2&quot;</span>)</span><br></pre></td></tr></table></figure><p>向可变<code>MutableMap</code>中添加或修改键值对，可以使用如下类似给数组赋值的语法，其背后实际上是通过<code>put(K, V)</code>方法实现的</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mutableMap[<span class="string">&quot;c&quot;</span>] = <span class="string">&quot;3&quot;</span>   <span class="comment">// 添加键值对</span></span><br><span class="line">mutableMap[<span class="string">&quot;a&quot;</span>] = <span class="string">&quot;one&quot;</span> <span class="comment">// 修改键值对</span></span><br></pre></td></tr></table></figure><p>从可变<code>map</code>中移除元素，使用<code>.remove()</code>函数</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mutableMap.remove(<span class="string">&quot;b&quot;</span>)</span><br></pre></td></tr></table></figure><p>获取<code>map</code>中元素的数量，使用<code>.count()</code>函数</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> itemCount: <span class="built_in">Int</span> = map.count()</span><br></pre></td></tr></table></figure><p>检测<code>map</code>中是否已包含特定键，使用<code>.containsKey()</code>函数</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> containsKeyA: <span class="built_in">Boolean</span> = map.containsKey(<span class="string">&quot;a&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> containsKeyC: <span class="built_in">Boolean</span> = map.containsKey(<span class="string">&quot;c&quot;</span>)</span><br></pre></td></tr></table></figure><p>检测键或值是否在<code>map</code>中，使用<code>in</code>操作符</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> containsKeyA: <span class="built_in">Boolean</span> = <span class="string">&quot;a&quot;</span> <span class="keyword">in</span> map.keys</span><br><span class="line"><span class="keyword">val</span> containsValue1: <span class="built_in">Boolean</span> = <span class="string">&quot;1&quot;</span> <span class="keyword">in</span> map.values</span><br></pre></td></tr></table></figure><p>获取<code>map</code>的键或值的集合，分别使用<code>keys</code>和<code>values</code>属性</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> keys: Set&lt;String&gt; = map.keys</span><br><span class="line"><span class="keyword">val</span> values: Collection&lt;String&gt; = map.values</span><br></pre></td></tr></table></figure><h1 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h1><p><code>Lambda</code>表达式的结构如下</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123; 参数名<span class="number">1</span>: 参数类型, 参数名<span class="number">2</span>: 参数类型 -&gt; 函数体 &#125;</span><br><span class="line"><span class="comment">// 例如</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> lambda = &#123; s1: String, s2: String -&gt;</span><br><span class="line">    println(<span class="string">&quot;<span class="subst">$&#123;s1&#125;</span>，我是练习时长两年半的个人练习生cxk&quot;</span>)</span><br><span class="line">    println(<span class="string">&quot;<span class="subst">$&#123;s2&#125;</span>唱跳rap篮球&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2><p>函数式接口是指只包含一个抽象方法的接口，在<code>Kotlin</code>中，函数式接口使用<code>fun interface</code>关键字声明</p><p><code>Java</code>中的函数式接口使用<code>@FunctionalInterface</code>注解声明</p><p>如果一个函数所需的参数是<code>函数式接口</code>，那么可以直接将<code>Lambda</code>表达式作为参数传递给函数</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 函数式接口，用于定义内容传输的回调方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="keyword">interface</span> OnContentTransmitter &#123;</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 传输指定的内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">transmitContent</span><span class="params">(content: <span class="type">String</span>)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行器，用于执行传输操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TransmitExecutor</span>(<span class="keyword">private</span> <span class="keyword">val</span> onContentTransmitter: OnContentTransmitter) &#123;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行传输操作，传输内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">executeTransmit</span><span class="params">()</span></span> &#123;</span><br><span class="line">        onContentTransmitter.transmitContent(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建<code>TransmitExecutor</code>对象时，需要传入<code>OnContentTransmitter</code>的匿名类，如下</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TransmitExecutor (<span class="keyword">object</span> : OnContentTransmitter &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">transmitContent</span><span class="params">(content: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        println(content)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).executeTransmit()</span><br></pre></td></tr></table></figure><p>使用<code>Lambda</code>表达式可以简化代码</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> lambda = &#123; content: String -&gt;</span><br><span class="line">    println(content)</span><br><span class="line">&#125;</span><br><span class="line">TransmitExecutor(lambda).executeTransmit()</span><br></pre></td></tr></table></figure><p><code>Lambda</code>表达式不必声明为变量，直接写入</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TransmitExecutor(&#123; content: String -&gt;</span><br><span class="line">    println(content)</span><br><span class="line">&#125;).executeTransmit()</span><br></pre></td></tr></table></figure><p><code>Lambda</code>表达式的参数类型可以省略，编译器会自动推导</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TransmitExecutor(&#123; content -&gt;</span><br><span class="line">    println(content)</span><br><span class="line">&#125;).executeTransmit()</span><br></pre></td></tr></table></figure><p>如果<code>Lambda</code>表达式是最后一个参数，那么可以将其放在括号外面；如果<code>Lambda</code>表达式是唯一一个参数，那么可以省略括号</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TransmitExecutor &#123; content -&gt;</span><br><span class="line">    println(content)</span><br><span class="line">&#125;.executeTransmit()</span><br></pre></td></tr></table></figure><p>此外如果<code>Lambda</code>表达式只有一个参数，参数可以使用<code>it</code>关键字代替</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TransmitExecutor &#123;</span><br><span class="line">    println(it)</span><br><span class="line">&#125;.executeTransmit()</span><br></pre></td></tr></table></figure><p>同样如果一个函数需要的参数是函数式接口时，和上面的步骤一致</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行传输操作</span></span><br><span class="line"><span class="comment"> * 调用传入的 [OnContentTransmitter] 接口实例的 [OnContentTransmitter.transmitContent] 方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">execute</span><span class="params">(onContentTransmitter: <span class="type">OnContentTransmitter</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 调用回调接口的方法，传入要传输的内容</span></span><br><span class="line">    onContentTransmitter.transmitContent(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行传输操作，传入一个 Lambda 表达式实现的内容传输回调</span></span><br><span class="line">execute &#123;</span><br><span class="line">    <span class="comment">// 打印传输的内容</span></span><br><span class="line">    println(it)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数作为参数"><a href="#函数作为参数" class="headerlink" title="函数作为参数"></a>函数作为参数</h2><p><code>Lambda</code>表达式可以作为参数传递给函数，如下，在子线程中执行传入的函数</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">execute</span><span class="params">(func: (<span class="type">content</span>: <span class="type">String</span>) -&gt; <span class="type">Boolean</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> result: <span class="built_in">Boolean</span> = func.invoke(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    println(<span class="string">&quot;执行结果 = <span class="variable">$result</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正常调用时</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">execute (<span class="function"><span class="title">fun</span> <span class="params">(content: <span class="type">String</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (TextUtils.isEmpty(content))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    println(content)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>通过<code>Lambda</code>表达式简化代码</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">execute &#123;</span><br><span class="line">    <span class="keyword">if</span> (TextUtils.isEmpty(it))</span><br><span class="line">        <span class="keyword">return</span><span class="symbol">@execute</span> <span class="literal">false</span></span><br><span class="line">    println(it)</span><br><span class="line">    <span class="keyword">return</span><span class="symbol">@execute</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数作为返回值"><a href="#函数作为返回值" class="headerlink" title="函数作为返回值"></a>函数作为返回值</h2><p><code>Lambda</code>表达式也可以作为函数的返回值，如下函数的返回值也是函数，可以简化</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 函数的返回值是</span></span><br><span class="line"><span class="comment"> * (str: String, like: String) -&gt; Unit</span></span><br><span class="line"><span class="comment"> * 这么一个函数类型的返回值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getFunc</span><span class="params">()</span></span>: (name: String, like: String) -&gt; <span class="built_in">Unit</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="title">fun</span><span class="params">(name: <span class="type">String</span>, like: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;全民制作人大家好，我是练习时长两年半的个人练习生<span class="variable">$name</span>，我喜欢<span class="variable">$like</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Lambda简化</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getFunc</span><span class="params">()</span></span>: (name: String, like: String) -&gt; <span class="built_in">Unit</span> &#123;</span><br><span class="line">    <span class="keyword">return</span>  &#123; name, like -&gt;</span><br><span class="line">        println(<span class="string">&quot;全民制作人大家好，我是练习时长两年半的个人练习生<span class="variable">$name</span>，我喜欢<span class="variable">$like</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用时</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getFunc().invoke(<span class="string">&quot;cxk&quot;</span>, <span class="string">&quot;唱、跳、rap、篮球&quot;</span>)</span><br><span class="line"><span class="comment">// 或者（不好看）</span></span><br><span class="line">getFunc()(<span class="string">&quot;cxk&quot;</span>, <span class="string">&quot;唱、跳、rap、篮球&quot;</span>)</span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="post-tags"><a href="/tags/Kotlin%E5%85%A5%E9%97%A8/" rel="tag"><i class="fa fa-tag"></i> Kotlin入门</a></div><div class="post-nav"><div class="post-nav-item"><a href="/2024/09/13/%E6%8E%92%E5%BA%8F/" rel="prev" title="排序"><i class="fa fa-angle-left"></i> 排序</a></div><div class="post-nav-item"><a href="/2025/01/09/%E6%9F%A5%E6%89%BE%E6%A0%91/" rel="next" title="查找树">查找树 <i class="fa fa-angle-right"></i></a></div></div></footer></article></div></div></main><footer class="footer"><div class="footer-inner"><div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">鲁ICP备19064654号-5</a></div><div class="copyright">&copy; 2019 – <span itemprop="copyrightYear">2026</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">xxin</span></div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script src="https://cdn.bootcdn.net/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="https://cdn.bootcdn.net/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.umd.js" integrity="sha256-a+H7FYzJv6oU2hfsfDGM2Ohw/cR9v+hPfxHCLdmCrE8=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script><script src="https://cdn.bootcdn.net/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script><script src="/js/third-party/search/local-search.js"></script><script src="/js/third-party/fancybox.js"></script><script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"ams","js":{"url":"https://cdn.bootcdn.net/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script><script src="/js/third-party/math/mathjax.js"></script></body></html>