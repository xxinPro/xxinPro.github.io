<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>AES加解密</title>
    <url>/2022/03/03/AES%E5%8A%A0%E8%A7%A3%E5%AF%86/</url>
    <content><![CDATA[&ensp;&ensp;&ensp;&ensp;根据加密字符串生成加密密钥    /**     * 生成加密密钥     * @param key 密钥String     * @return 密钥byte[]     */    private static SecretKeySpec getKeyBytes(String key)&#123;        SecretKeySpec secretKeySpec = null;        try &#123;            KeyGenerator keyGenerator = KeyGenerator.getInstance(&quot;AES&quot;);//            强随机数生成器，在Linux等系统生成的key可能是不同的//            SecureRandom secureRandom = new SecureRandom(key.getBytes(StandardCharsets.UTF_8));//            指定算法名称，不同系统生成相同的key            SecureRandom sha1PRNG = SecureRandom.getInstance(&quot;SHA1PRNG&quot;);            sha1PRNG.setSeed(key.getBytes(StandardCharsets.UTF_8));//            AES要求密钥的长度为128            keyGenerator.init(128, sha1PRNG);//            生成一个密钥            SecretKey secretKey = keyGenerator.generateKey();            secretKeySpec = new SecretKeySpec(secretKey.getEncoded(), &quot;AES&quot;);        &#125; catch (NoSuchAlgorithmException e) &#123;            e.printStackTrace();        &#125;        return secretKeySpec;    &#125;
&ensp;&ensp;&ensp;&ensp;不过使用以上生成加密密钥的方式我还是出现了错误，在Android端和Linux服务器端生成的加密密钥不一致，最后是迫不得已用了这种方式private static SecretKeySpec getKeyBytes(String key) throws UnsupportedEncodingException &#123;    SecretKeySpec secretKeySpec = new SecretKeySpec(key.getBytes(StandardCharsets.UTF_8), &quot;AES&quot;);    return secretKeySpec;&#125;
&ensp;&ensp;&ensp;&ensp;字节组转换为Base64编码/** * 字节数组转Base64编码 * @param bytes 字节组 * @return base64编码 */private static String bytesToBase64(byte[] bytes) &#123;    return Base64.getEncoder().encodeToString(bytes);&#125;
&ensp;&ensp;&ensp;&ensp;base64编码转换为字节组/** * Base64编码转字节数组 * @param base64 base64编码 * @return 字节组 * @throws IOException 异常抛出 */private static byte[] base64ToBytes(String base64) throws IOException &#123;    return Base64.getDecoder().decode(base64.getBytes(StandardCharsets.UTF_8));&#125;
&ensp;&ensp;&ensp;&ensp;加密方法    /**     * 加密     * @param text 需要加密的text内容     * @param key 加密密钥     * @return 加密后的值     */    public static String encrypt(String text, String key)&#123;        String encryptValue = null;        try &#123;//            创建密码器            Cipher cipher = Cipher.getInstance(&quot;AES/ECB/PKCS5Padding&quot;);//            初始化密码器为加密模式            cipher.init(Cipher.ENCRYPT_MODE, getKeyBytes(key));//            获取需要加密的text的字节组            byte[] textBytes = text.getBytes(StandardCharsets.UTF_8);//            加密            byte[] doFinal = cipher.doFinal(textBytes);//            加密值转base64编码            encryptValue = bytesToBase64(doFinal);        &#125; catch (NoSuchAlgorithmException | NoSuchPaddingException | InvalidKeyException | IllegalBlockSizeException | BadPaddingException e) &#123;            e.printStackTrace();        &#125;        return encryptValue;    &#125;
&ensp;&ensp;&ensp;&ensp;解密方法    /**     * 解密     * @param text 需要解密的base64编码     * @param key 解密密钥值     * @return 解密结果     */    public static String decrypt(String text, String key)&#123;        String decryptValue = null;        try &#123;//            创建密码器            Cipher cipher = Cipher.getInstance(&quot;AES/ECB/PKCS5Padding&quot;);//            初始化密码器为解密模式            cipher.init(Cipher.DECRYPT_MODE, getKeyBytes(key));//            解密            byte[] doFinal = cipher.doFinal(base64ToBytes(text));            decryptValue = new String(doFinal);        &#125; catch (NoSuchAlgorithmException | NoSuchPaddingException | InvalidKeyException | IllegalBlockSizeException | BadPaddingException | IOException e) &#123;            e.printStackTrace();        &#125;        return decryptValue;    &#125;
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java开发手记</tag>
      </tags>
  </entry>
  <entry>
    <title>2022年3月31号站点更新详细</title>
    <url>/2022/03/31/2022%E5%B9%B43%E6%9C%8831%E5%8F%B7%E7%AB%99%E7%82%B9%E6%9B%B4%E6%96%B0%E8%AF%A6%E7%BB%86/</url>
    <content><![CDATA[
更新了hexo-generator-searchdb
更新了hexo-generator-sitemap
更新了hexo-generator-baidu-sitemap
更新了eslint
更新了hexo
更新了hexo-renderer-ejs
更新了hexo-server
更新了next


hexo-generator-searchdb&ensp;&ensp;此插件用于生成搜索索引文件，其中包含您的文章的所有必要数据，您可以使用这些数据为您的博客编写本地搜索引擎。支持 XML 和 JSON 格式输出。&ensp;&ensp;在hexo配置文件中添加的的字段由search:  path: search.xml  field: post  limit: 10000  format: html&ensp;&ensp;变为search:  path: search.xml # 文件路径  field: post # 你要搜索的搜索范围，你可以选择    # post（默认）- 将仅涵盖您博客的所有帖子。    # page - 只会覆盖您博客的所有页面。    # all - 将涵盖您博客的所有帖子和页面。  content: true # 是否包含每篇文章的全部内容  format: html # 页面内容的形式    # html (默认) - 被缩小的原始 html 字符串。    # striptags - 原始 html 字符串被缩小，并删除所有标签。    # raw - 每个帖子或页面的降价文本。
github地址：https://github.com/next-theme/hexo-generator-searchdb
hexo-generator-sitemap&ensp;&ensp;生成google抓取的站点地图&ensp;&ensp;在hexo配置文件中添加字段sitemap: #谷歌站点地图  path: sitemap.xml #文件路径  # 在需要排除的帖子配置中添加sitemap: false
github地址：https://github.com/hexojs/hexo-generator-sitemap
hexo-generator-baidu-sitemap&ensp;&ensp;生成百度抓取的站点地图&ensp;&ensp;在hexo配置文件中添加字段baidusitemap: # 百度站点地图  path: baidusitemap.xml #文件路径github地址：https://github.com/coneycode/hexo-generator-baidu-sitemap
其它&ensp;&ensp;eslint更新到了8.12.0&ensp;&ensp;hexo更新到了6.1.0&ensp;&ensp;hexo-renderer-ejs更新到了2.0.0&ensp;&ensp;hexo-server更新到了3.0.0&ensp;&ensp;next版本更新到了8.10.1
本地npm-check-updates&ensp;&ensp;安装了npm-check-updates插件ncu #检查需要更新依赖ncu -u #检查并且更新依赖的package.jsonnpm install #安装最新的依赖包github地址：https://github.com/raineorshine/npm-check-updates
修复错误&ensp;&ensp;添加了nodejs高版本兼容&ensp;&ensp;在 \node_modules\stylus\lib\nodes\index.js 文件中加入exports.lineno = null;exports.column = null;exports.filename = null;
]]></content>
      <categories>
        <category>便笺</category>
      </categories>
      <tags>
        <tag>站点日志</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-Activity</title>
    <url>/2021/09/21/Android-Activity/</url>
    <content><![CDATA[①Activity页面跳转使用场景：多用于内部跳转
显式跳转&ensp;&ensp;一、支持：内部跳转//  显式跳转，传入Context，传入字节码文件  Intent intent = new Intent(this,HomeActivity.class);//  可以通过setClass设置跳转位置  intent.setClass(getActivity(),HomeActivity.class);//  跳转时传递参数  intent.putExtra(&quot;key&quot;,&quot;value&quot;);//  跳转  startActivity(intent);
&ensp;&ensp;二、支持：内部跳转+外部跳转//  传入Context，传入字节码文件  Intent intent = new Intent();//  动态设置跳转的位置，参数一:包名，参数2:完整类名  intent.setClassName(&quot;tk.wechat&quot;,&quot;tk.wechat.HomeActivity&quot;);//  注意：setClassName内部也是调用的setComponent，下面包名和类名会跳转至模拟器系统闹钟//  intent.setComponent(new ComponentName(&quot;com.android.deskclock&quot;,&quot;com.android.deskclock.DeskClock&quot;));  startActivity(intent);
隐式跳转&ensp;&ensp;支持：内部跳转+外部跳转，使用场景：多用于外部跳转
被跳转的页面需要在AndroidManifest.xml清单文件中为activity配置过滤信息        &lt;activity android:name=&quot;.HomeActivity&quot;&gt;            &lt;intent-filter&gt;&lt;!--                action必须有，且只能有一个，一般情况下自定义action值--&gt;&lt;!--                当两个软件的action值冲突时，由用户选择跳转一个--&gt;                &lt;action android:name=&quot;tk.wechat.homeActivity&quot;/&gt;&lt;!--                category类别，是一种额外描述，可以作为过滤条件设置多个，使隐式跳转时更准确定位action--&gt;&lt;!--                要实现隐式跳转，category中至少有一个值为android.intent.category.DEFAULT，否则匹配不到--&gt;&lt;!--                category值不可自定义，由系统提供多个可选值--&gt;                &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt;                &lt;category android:name=&quot;android.intent.category.ALTERNATIVE&quot;/&gt;            &lt;/intent-filter&gt;        &lt;/activity&gt;
跳转时调用  Intent intent = new Intent();//  设置action动作，action的值应该要与我们的目标action对应  intent.setAction(&quot;tk.wechat.homeActivity&quot;);//  category类别，作为过滤条件更准确的定位action//  java代码中可以不写，默认添加Intent.CATEGORY_DEFAULT  intent.addCategory(Intent.CATEGORY_ALTERNATIVE);//  跳转时传递参数  intent.putExtra(&quot;key&quot;,&quot;value&quot;);  startActivity(intent);
&ensp;&ensp;注意：清单文件中Activity的category 标签必须添加一个android.intent.category.DEFAULT值，因为隐式跳转时java代码中会默认添加Intent.CATEGORY_DEFAULT(android.intent.category.DEFAULT)，所以如果清单文件的category中没有android.intent.category.DEFAULT就会匹配不到对应的action
Date:数据处理目标页面需要有数据处理能力，是可选的附加条件
可选类型

android:mimeType
android:mimeGroup
android:scheme
android:ssp
android:sspPrefix
android:sspPattern
android:host
android:port
android:path
android:pathPrefix
android:pathPattern

跳转传递值通过putExtra传递设置传递参数  Intent intent = new Intent();//  跳转到MainActivity2  intent.setClass(MainActivity.this,MainActivity2.class);//  设置传递参数  intent.putExtra(&quot;msg1&quot;,&quot;消息1&quot;);  startActivity(intent);
在目标页接收//  得到传递的intent  Intent intent = this.getIntent();//  得到传递的参数  String str = intent.getExtras().getString(&quot;msg1&quot;);  Toast.makeText(this,str,Toast.LENGTH_SHORT).show();
使用Bundle传递创建Bundle对象，并设置Bundle传递的值，然后把Bundle传递过去  Intent intent = new Intent();//  设置目标Activity  intent.setClass(MainActivity.this,MainActivity2.class);//  创建Bundle对象  Bundle bundle = new Bundle();//  key和value  bundle.putString(&quot;msg1&quot;,&quot;Bundle传递的消息&quot;);//  再通过putExtras把Bundle对象传递过去  intent.putExtras(bundle);  startActivity(intent);
接收Bundle中传递的值//  得到传递的intent  Intent intent = this.getIntent();//  取Bundle中的String值  String str = intent.getExtras().getString(&quot;msg1&quot;);  Toast.makeText(this,str,Toast.LENGTH_SHORT).show();
②Activity生命周期
启动Activity：系统会先调用onCreate方法，然后调用onStart方法，最后调用onResume，Activity进入运行状态。
当前Activity被其他Activity覆盖其上或被锁屏：系统会调用onPause方法，暂停当前Activity的执行。
当前Activity由被覆盖状态回到前台或解锁屏：系统会调用onResume方法，再次进入运行状态。
当前Activity转到新的Activity界面或按Home键回到主屏，自身退居后台：系统会先调用onPause方法，然后调用onStop方法，进入停滞状态。
用户后退回到此Activity：系统会先调用onRestart方法，然后调用onStart方法，最后调用onResume方法，再次进入运行状态。
当前Activity处于被覆盖状态或者后台不可见状态，即第2步和第4步，系统内存不足，杀死当前Activity，而后用户退回当前Activity：再次调用onCreate方法、onStart方法、onResume方法，进入运行状态。
用户退出当前Activity：系统先调用onPause方法，然后调用onStop方法，最后调用onDestory方法，结束当前Activity。


拓展：getContext 和 getActivity的区别
MainActivity.this: 表示MainActivity对象，一般用在内部类中指示外面的this，如果在内部类直接用this，指示的是内部类本身。因为MainActivity继承Activity，而Activity继承Context，所以它也可以用来提供Activity的Contex；
this: 表示当前对象，一般而言，在哪个类中调用，就是指向该对象。
getContext(): 获取当前Context的实例，如果使用场景是Activity则相当于 this, 如果使用场景是一个Server 那么获取的实例就是一个ApplicationContext()
getActivity(): Fragment上的方法，相当于this或Activity.this，是获取当前Activity的实例，生命周期随当前的Activity销毁而销毁

]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-AlertDialog</title>
    <url>/2021/09/09/Android-AlertDialog/</url>
    <content><![CDATA[实现方式//构建Dialog的各种参数AlertDialog.Bulider bulider = new AlertDialog.Bulider(context); //添加iconBulider.setIcon(int iconId);//添加标题Bulider.setTitle(CharSequence title);//添加消息Bulider.setMessage(CharSequence message);//设置自定义布局Bulider.setView(View view);//确定按钮Bulider.setPositiveButton(text,OnClickListener);//中间按钮Bulider.setNegativeButton(text,OnClickListener);//取消按钮Bulider.setNeutralButton(text,OnClickListener);//创建DialogBulider.create();//显示对话框Bulider.show();
普通dialog代码部分
protected void MyClick()&#123;    btn.setOnClickListener(new View.OnClickListener() &#123;        @Override        public void onClick(View view) &#123;            AlertDialog.Builder dialog =  new AlertDialog.Builder(MainActivity.this);            dialog.setTitle(&quot;标题&quot;)                    .setIcon(R.mipmap.ic_launcher)                    .setMessage(&quot;对话框内容&quot;)                    .setPositiveButton(&quot;确定按钮&quot;, new DialogInterface.OnClickListener() &#123;                        @Override                        public void onClick(DialogInterface dialogInterface, int i) &#123;                        &#125;                    &#125;)                    .setNegativeButton(&quot;中间按钮&quot;, new DialogInterface.OnClickListener() &#123;                        @Override                        public void onClick(DialogInterface dialogInterface, int i) &#123;                        &#125;                    &#125;)                    .setNeutralButton(&quot;取消按钮&quot;, new DialogInterface.OnClickListener() &#123;                        @Override                        public void onClick(DialogInterface dialogInterface, int i) &#123;                        &#125;                    &#125;)                    .create()                    .show();        &#125;    &#125;);&#125;
展示图

将页面作为dialog先创建一个xml布局，命名为dialog&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout android:layout_height=&quot;match_parent&quot;    android:layout_width=&quot;match_parent&quot;    android:orientation=&quot;vertical&quot;    android:gravity=&quot;center&quot;    android:background=&quot;#ff023198&quot;    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;    &lt;TextView        android:layout_width=&quot;wrap_content&quot;        android:text=&quot;测试&quot;        android:textColor=&quot;#ffffffff&quot;        android:textSize=&quot;22sp&quot;        android:textStyle=&quot;bold&quot;        android:layout_height=&quot;wrap_content&quot;/&gt;&lt;/LinearLayout&gt;
代码部分protected void MyClick()&#123;    btn.setOnClickListener(new View.OnClickListener() &#123;        @Override        public void onClick(View view) &#123;            AlertDialog.Builder dialog =  new AlertDialog.Builder(MainActivity.this);            dialog.setTitle(&quot;标题&quot;)                    .setIcon(R.mipmap.ic_launcher)                    .setMessage(&quot;对话框内容&quot;)                    .setPositiveButton(&quot;确定按钮&quot;, new DialogInterface.OnClickListener() &#123;                        @Override                        public void onClick(DialogInterface dialogInterface, int i) &#123;                        &#125;                    &#125;)                    .setNegativeButton(&quot;中间按钮&quot;, new DialogInterface.OnClickListener() &#123;                        @Override                        public void onClick(DialogInterface dialogInterface, int i) &#123;                        &#125;                    &#125;)                    .setNeutralButton(&quot;取消按钮&quot;, new DialogInterface.OnClickListener() &#123;                        @Override                        public void onClick(DialogInterface dialogInterface, int i) &#123;                        &#125;                    &#125;)//                这里可以是布局文件或view对象，如果是view对象，需要先获取布局文件//                View view1 = getLayoutInflater().inflate(R.layout.dialog,null);//                将view1放在setView参数中                    .setView(R.layout.dialog)                    .create()                    .show();        &#125;    &#125;);&#125;
展示图

日期选择器DatePickerDialog继承自AlertDialog主要用于向用户提供包含年月日的日期数据并且允许用户对数据进行修改
它的监听器DatePickerDialog.OnDateSetListener();
弹出日期选择对话框组件//  用于获取当前日期  Calendar calendar = Calendar.getInstance();//  创建一个日期选择器对象  DatePickerDialog datePickerDialog = new DatePickerDialog(          HomeActivity1.this,//context上下文          new DatePickerDialog.OnDateSetListener() &#123;//日期选择监听器              @Override              public void onDateSet(DatePicker view, int year, int month, int dayOfMonth) &#123;                  Toast.makeText(HomeActivity1.this,year + &quot;-&quot; + (month + 1) + &quot;-&quot; + dayOfMonth,Toast.LENGTH_SHORT).show();              &#125;          &#125;,          calendar.get(Calendar.YEAR),//传入当前年          calendar.get(Calendar.MONDAY),//传入当前月(0-11)          calendar.get(Calendar.DAY_OF_MONTH));//传入当前日  datePickerDialog.show();//显示日期选择器
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-Banner</title>
    <url>/2021/10/14/Android-Banner/</url>
    <content><![CDATA[Banner1.4.10github地址: https://github.com/youth5201314/banner/tree/release-1.4.10
引入Banner1在build.gradle的dependencies中加入dependencies&#123;    compile &#x27;com.youth.banner:banner:1.4.10&#x27;  //最新版本&#125;
如果是本地arr文件文件如何引入arr文件
使用Banner1在布局中添加在布局中插入Banner控件&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout android:layout_height=&quot;match_parent&quot;    android:id=&quot;@+id/linear1&quot;    android:layout_width=&quot;match_parent&quot;    android:orientation=&quot;vertical&quot;    android:gravity=&quot;center&quot;    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;    &lt;com.youth.banner.Banner        android:id=&quot;@+id/banner&quot;        android:layout_marginLeft=&quot;20dp&quot;        android:layout_marginRight=&quot;20dp&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;160dp&quot;/&gt;&lt;/LinearLayout&gt;
创建图片加载器重写图片加载器，继承ImageLoader类
MysetImageLoader继承ImageLoaderpackage com.a.practice;import android.content.Context;import android.widget.ImageView;import com.bumptech.glide.Glide;import com.youth.banner.loader.ImageLoader;public class MysetImageLoader extends ImageLoader &#123;    @Override//    在这个方法中加载图片    public void displayImage(Context context, Object o, ImageView imageView) &#123;//        返回的图片路径为Object类型强转为Image        Glide.with(context).load(o).into((ImageView) imageView);    &#125;    @Override    public ImageView createImageView(Context context) &#123;//        返回一个新的ImageView控件        return new ImageView(context);    &#125;&#125;
调用图片加载器在Activity中调用图片加载器
1.初始化Banner控件，创建Banner所需的List集合private Banner banner;//初始化banner控件private List&lt;String&gt; urls = new ArrayList&lt;&gt;();//图片地址的集合private List&lt;String&gt; titles = new ArrayList&lt;&gt;();//图片标题的集合urls.add(&quot;https://pics2.baidu.com/feed/a8014c086e061d95bae4a9350d7a45d763d9cab6.png?token=a817a8157f425a71e0730e89fba08644&amp;s=EC3807D166031CF67E2D059B0300E012&quot;);urls.add(&quot;https://img1.baidu.com/it/u=2837730020,691715572&amp;fm=26&amp;fmt=auto&quot;);urls.add(&quot;https://img0.baidu.com/it/u=1768887447,1227450589&amp;fm=26&amp;fmt=auto&quot;);titles.add(&quot;刑天铠甲&quot;);titles.add(&quot;飞影铠甲&quot;);titles.add(&quot;金刚铠甲&quot;);banner = findViewById(R.id.banner);
2.调用图片加载器//  设置图片加载器  MysetImageLoader mysetImageLoader = new MysetImageLoader();  banner.setImageLoader(mysetImageLoader);
3.设置banner的其它一些属性
banner.start()一定要放在最后banner.setBannerStyle(BannerConfig.CIRCLE_INDICATOR_TITLE);//设置banner的指示器样式banner.setImages(urls);//设置图片的数据源banner.setBannerTitles(titles);//设置标题数据源banner.setBannerAnimation(Transformer.DepthPage);//设置banner的动画效果banner.isAutoPlay(true);//是否自动轮播banner.setDelayTime(1500);//设置轮播切换时间banner.setIndicatorGravity(BannerConfig.CENTER);//设置指示器显示位置banner.start();//开始渲染
4.记得在清单文件中添加网络权限&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;
默认图片加载器如果只想实现图片轮播功能，那大可不必继承，直接调用ImageLoader
//        设置图片加载器        banner.setImageLoader(new ImageLoader() &#123;            @Override//            在这个方法中加载图片            public void displayImage(Context context, Object o, ImageView imageView) &#123;//                返回的图片路径为Object类型强转为Image                Glide.with(context).load(o).into((ImageView) imageView);            &#125;            @Override            public ImageView createImageView(Context context) &#123;//                返回一个新的ImageView控件                return new ImageView(context);            &#125;        &#125;);
效果展示
其它相关设置常量


常量名称
描述
所属方法




BannerConfig.NOT_INDICATOR
不显示指示器和标题
setBannerStyle


BannerConfig.CIRCLE_INDICATOR
显示圆形指示器
setBannerStyle


BannerConfig.NUM_INDICATOR
显示数字指示器
setBannerStyle


BannerConfig.NUM_INDICATOR_TITLE
显示数字指示器和标题
setBannerStyle


BannerConfig.CIRCLE_INDICATOR_TITLE
显示圆形指示器和标题（垂直显示）
setBannerStyle


BannerConfig.CIRCLE_INDICATOR_TITLE_INSIDE
显示圆形指示器和标题（水平显示）
setBannerStyle


BannerConfig.LEFT
指示器居左
setIndicatorGravity


BannerConfig.CENTER
指示器居中
setIndicatorGravity


BannerConfig.RIGHT
指示器居右
setIndicatorGravity




动画常量类（setBannerAnimation方法调用）


常量类名




Transformer.Default


Transformer.Accordion


Transformer.BackgroundToForeground


Transformer.ForegroundToBackground


Transformer.CubeIn


Transformer.CubeOut


Transformer.DepthPage


Transformer.FlipHorizontal


Transformer.FlipVertical


Transformer.RotateDown


Transformer.RotateUp


Transformer.ScaleInOut


Transformer.Stack


Transformer.Tablet


Transformer.ZoomIn


Transformer.ZoomOut


Transformer.ZoomOutSlide




方法


方法名
描述
版本限制




setBannerStyle(int bannerStyle)
设置轮播样式（默认为CIRCLE_INDICATOR）
无


setIndicatorGravity(int type)
设置指示器位置（没有标题默认为右边,有标题时默认左边）
无


isAutoPlay(boolean isAutoPlay)
设置是否自动轮播（默认自动）
无


setViewPagerIsScroll(boolean isScroll)
设置是否允许手动滑动轮播图（默认true）
1.4.5开始


update(List&lt;?&gt; imageUrls,List titles)
更新图片和标题
1.4.5开始


update(List&lt;?&gt; imageUrls)
更新图片
1.4.5开始


startAutoPlay()
开始轮播
1.4开始，此方法只作用于banner加载完毕--&gt;需要在start()后执行


stopAutoPlay()
结束轮播
1.4开始，此方法只作用于banner加载完毕--&gt;需要在start()后执行


start()
开始进行banner渲染（必须放到最后执行）
1.4开始


setOffscreenPageLimit(int limit)
同viewpager的方法作用一样
1.4.2开始


setBannerTitle(String[] titles)
设置轮播要显示的标题和图片对应（如果不传默认不显示标题）
1.3.3结束


setBannerTitleList(List titles)
设置轮播要显示的标题和图片对应（如果不传默认不显示标题）
1.3.3结束


setBannerTitles(List titles)
设置轮播要显示的标题和图片对应（如果不传默认不显示标题）
1.4开始


setDelayTime(int time)
设置轮播图片间隔时间（单位毫秒，默认为2000）
无


setImages(Object[]/List&lt;?&gt; imagesUrl)
设置轮播图片(所有设置参数方法都放在此方法之前执行)
1.4后去掉数组传参


setImages(Object[]/List&lt;?&gt; imagesUrl,OnLoadImageListener listener)
设置轮播图片，并且自定义图片加载方式
1.3.3结束


setOnBannerClickListener(this)
设置点击事件，下标是从1开始
无（1.4.9以后废弃了）


setOnBannerListener(this)
设置点击事件，下标是从0开始
1.4.9以后


setOnLoadImageListener(this)
设置图片加载事件，可以自定义图片加载方式
1.3.3结束


setImageLoader(Object implements ImageLoader)
设置图片加载器
1.4开始


setOnPageChangeListener(this)
设置viewpager的滑动监听
无


setBannerAnimation(Class&lt;? extends PageTransformer&gt; transformer)
设置viewpager的默认动画,传值见动画表
无


setPageTransformer(boolean reverseDrawingOrder, ViewPager.PageTransformer transformer)
设置viewpager的自定义动画
无




Attributes属性（banner布局文件中调用）


Attributes
forma
describe




delay_time
integer
轮播间隔时间，默认2000


scroll_time
integer
轮播滑动执行时间，默认800


is_auto_play
boolean
是否自动轮播，默认true


title_background
color
reference


title_textcolor
color
标题字体颜色


title_textsize
dimension
标题字体大小


title_height
dimension
标题栏高度


indicator_width
dimension
指示器圆形按钮的宽度


indicator_height
dimension
指示器圆形按钮的高度


indicator_margin
dimension
指示器之间的间距


indicator_drawable_selected
reference
指示器选中效果


indicator_drawable_unselected
reference
指示器未选中效果


image_scale_type
enum
和imageview的ScaleType作用一样


banner_default_image
reference
当banner数据为空是显示的默认图片


banner_layout
reference
自定义banner布局文件，但是必须保证id的名称一样（你可以将banner的布局文件复制出来进行修改）





Banner2.0github地址:https://github.com/youth5201314/banner
在gradle文件中引入注意，使用了阿里云maven，所以下面引入的banner是在阿里云maven中的地址implementation &#x27;io.github.youth5201314:banner:2.2.2&#x27;//Banner
使用Banner2插入Banner控件在布局中插入Banner控件&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;    android:gravity=&quot;center_horizontal&quot;    android:orientation=&quot;vertical&quot;    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;    &lt;com.youth.banner.Banner        android:id=&quot;@+id/banner&quot;        android:layout_margin=&quot;10dp&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;160dp&quot;/&gt;&lt;/LinearLayout&gt;
创建适配器创建MyBannerAdapter类继承BannerAdapter，BannerAdapter定义了一个泛型类，并强制进行ViewHolder优化，泛型类的类型决定了适配器的构造器中参数的类型import android.view.View;import android.view.ViewGroup;import androidx.annotation.NonNull;import androidx.recyclerview.widget.RecyclerView;import com.youth.banner.adapter.BannerAdapter;import java.util.List;//MyBannerAdapter定义了一个泛型类，并强制进行ViewHolder优化，泛型类的类型决定了适配器的构造器中参数的类型public class MyBannerAdapter extends BannerAdapter&lt;String,MyBannerAdapter.MyViewHolder&gt; &#123;//    集合List的类型由泛型类中的类型决定，集合List的长度决定了轮播图的个数    public MyBannerAdapter(List&lt;String&gt; datas) &#123;        super(datas);    &#125;//    创建ViewHolder    @Override    public MyBannerAdapter.MyViewHolder onCreateHolder(ViewGroup parent, int viewType) &#123;        return null;    &#125;//    绑定图片源，设置要显示的图片    @Override    public void onBindView(MyBannerAdapter.MyViewHolder holder, String data, int position, int size) &#123;            &#125;//    在ViewHolder中初始化Banner中的轮播图    public class MyViewHolder extends RecyclerView.ViewHolder &#123;        public MyViewHolder(@NonNull View itemView) &#123;            super(itemView);        &#125;    &#125;&#125;
配置适配器使用了Glide动态设置图片import android.content.Context;import android.view.View;import android.view.ViewGroup;import android.widget.ImageView;import androidx.annotation.NonNull;import androidx.recyclerview.widget.RecyclerView;import com.bumptech.glide.Glide;import com.youth.banner.adapter.BannerAdapter;import java.util.List;//MyBannerAdapter定义了一个泛型类，并强制进行ViewHolder优化，泛型类的类型决定了适配器的构造器中参数的类型public class MyBannerAdapter extends BannerAdapter&lt;String,MyBannerAdapter.MyViewHolder&gt; &#123;    private Context context;    private List&lt;String&gt; datas;//    集合List的类型由泛型类中的类型决定，集合List的长度决定了轮播图的个数    public MyBannerAdapter(List&lt;String&gt; datas, Context context) &#123;        super(datas);        this.context = context;        this.datas = datas;    &#125;//    创建ViewHolder    @Override    public MyBannerAdapter.MyViewHolder onCreateHolder(ViewGroup parent, int viewType) &#123;        ImageView imageView = new ImageView(parent.getContext());//创建图片控件//        设置图片宽高属性        imageView.setLayoutParams(new ViewGroup.LayoutParams(                ViewGroup.LayoutParams.MATCH_PARENT,                ViewGroup.LayoutParams.MATCH_PARENT        ));        imageView.setScaleType(ImageView.ScaleType.FIT_XY);//设置图片显示方式，此处强制铺满控件        return new MyViewHolder(imageView);    &#125;//    绑定图片源，设置要显示的图片    @Override    public void onBindView(MyBannerAdapter.MyViewHolder holder, String data, int position, int size) &#123;//        使用Glide动态加载图片        Glide.with(context).load(datas.get(position)).into(holder.imageView);    &#125;//    在ViewHolder中初始化Banner中的轮播图    public class MyViewHolder extends RecyclerView.ViewHolder &#123;        ImageView imageView;        public MyViewHolder(@NonNull View itemView) &#123;            super(itemView);            this.imageView = (ImageView) itemView;        &#125;    &#125;&#125;
调用适配器具体调用请看setBanner()方法import androidx.appcompat.app.AppCompatActivity;import android.os.Bundle;import android.widget.Toast;import com.youth.banner.Banner;import com.youth.banner.indicator.CircleIndicator;import com.youth.banner.listener.OnBannerListener;import java.util.ArrayList;import java.util.List;public class BannerActivity extends AppCompatActivity &#123;    private Banner banner;    private List&lt;String&gt; datas;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_banner);        init();        setBanner();    &#125;    private void setBanner() &#123;//        实例化banner适配器        MyBannerAdapter myBannerAdapter = new MyBannerAdapter(datas, this);        banner.setAdapter(myBannerAdapter) //添加适配器                .addBannerLifecycleObserver(this) //添加生命周期观察者                .setIndicator(new CircleIndicator(this)) //添加指示器(小圆点)                .isAutoLoop(true) //是否允许自动轮播                .setLoopTime(1500); //自动轮播切换时间//        设置点击事件，下标从0开始        banner.setOnBannerListener(new OnBannerListener() &#123;            @Override            public void OnBannerClick(Object data, int position) &#123;                Toast.makeText(BannerActivity.this,&quot;点击了&quot; + position, Toast.LENGTH_SHORT).show();            &#125;        &#125;);    &#125;    private void init() &#123;        banner = findViewById(R.id.banner);//初始化banner//        设置数据源        datas = new ArrayList&lt;&gt;();        datas.add(&quot;https://pics2.baidu.com/feed/a8014c086e061d95bae4a9350d7a45d763d9cab6.png?token=a817a8157f425a71e0730e89fba08644&amp;s=EC3807D166031CF67E2D059B0300E012&quot;);        datas.add(&quot;https://img1.baidu.com/it/u=2837730020,691715572&amp;fm=26&amp;fmt=auto&quot;);        datas.add(&quot;https://img0.baidu.com/it/u=1768887447,1227450589&amp;fm=26&amp;fmt=auto&quot;);    &#125;&#125;
默认Banner适配器如果仅想实现简单的图片轮播，就使用默认的Banner适配器，具体改动请看setBanner()方法import androidx.appcompat.app.AppCompatActivity;import android.os.Bundle;import android.widget.Toast;import com.bumptech.glide.Glide;import com.youth.banner.Banner;import com.youth.banner.adapter.BannerImageAdapter;import com.youth.banner.holder.BannerImageHolder;import com.youth.banner.indicator.CircleIndicator;import com.youth.banner.listener.OnBannerListener;import java.util.ArrayList;import java.util.List;public class BannerActivity extends AppCompatActivity &#123;    private Banner banner;    private List&lt;String&gt; datas;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_banner);        init();        setBanner();    &#125;//    如果仅仅想实现图片轮播，那就是用默认的Banner适配器BannerImageAdapter    private void setBanner() &#123;//        使用默认适配器        banner.setAdapter(new BannerImageAdapter&lt;String&gt;(datas) &#123;            @Override            public void onBindView(BannerImageHolder holder, String data, int position, int size) &#123;//                使用Glide动态加载图片                Glide.with(BannerActivity.this).load(datas.get(position)).into(holder.imageView);            &#125;        &#125;);        banner.addBannerLifecycleObserver(this) //添加生命周期观察者                .setIndicator(new CircleIndicator(this)) //添加指示器(小圆点)                .isAutoLoop(true) //是否允许自动轮播                .setLoopTime(1500); //自动轮播切换时间//        设置点击事件，下标从0开始        banner.setOnBannerListener(new OnBannerListener() &#123;            @Override            public void OnBannerClick(Object data, int position) &#123;                Toast.makeText(BannerActivity.this,&quot;点击了&quot; + position, Toast.LENGTH_SHORT).show();            &#125;        &#125;);    &#125;    private void init() &#123;        banner = findViewById(R.id.banner);//初始化banner//        设置数据源        datas = new ArrayList&lt;&gt;();        datas.add(&quot;https://pics2.baidu.com/feed/a8014c086e061d95bae4a9350d7a45d763d9cab6.png?token=a817a8157f425a71e0730e89fba08644&amp;s=EC3807D166031CF67E2D059B0300E012&quot;);        datas.add(&quot;https://img1.baidu.com/it/u=2837730020,691715572&amp;fm=26&amp;fmt=auto&quot;);        datas.add(&quot;https://img0.baidu.com/it/u=1768887447,1227450589&amp;fm=26&amp;fmt=auto&quot;);    &#125;&#125;
网络权限不要忘记在清单文件中添加网络权限&lt;!-- 网络权限 --&gt;&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;
效果展示
Banner2方法


方法名
返回类型
描述




getAdapter()
extends BannerAdapter
获取你设置的BannerAdapter


getViewPager2()
ViewPager2
获取ViewPager2


getIndicator()
Indicator
获取你设置的指示器（没有设置直接获取会抛异常哦）


getIndicatorConfig()
IndicatorConfig
获取你设置的指示器配置信息（没有设置直接获取会抛异常哦）


getRealCount()
int
返回banner真实总数


setUserInputEnabled(boolean)
this
禁止手动滑动Banner;true 允许，false 禁止


setDatas(List)
this
重新设置banner数据


isAutoLoop(boolean)
this
是否允许自动轮播


setLoopTime(long)
this
设置轮播间隔时间（默认3000毫秒）


setScrollTime(long)
this
设置轮播滑动的时间（默认800毫秒）


start()
this
开始轮播(主要配合生命周期使用)，或者你手动暂停再次启动


stop()
this
停止轮播(主要配合生命周期使用)，或者你需要手动暂停


setAdapter(T extends BannerAdapter)
this
设置banner的适配器


setAdapter(T extends BannerAdapter,boolean)
this
设置banner的适配器,是否支持无限循环


setOrientation(@Orientation)
this
设置banner轮播方向(垂直or水平)


setOnBannerListener(this)
this
设置点击事件，下标是从0开始


addOnPageChangeListener(this)
this
添加viewpager2的滑动监听


setPageTransformer(PageTransformer)
this
设置viewpager的切换效果


addPageTransformer(PageTransformer)
this
添加viewpager的切换效果（可以设置多个）


setIndicator(Indicator)
this
设置banner轮播指示器(提供有base和接口，可以自定义)


setIndicator(Indicator,boolean)
this
设置指示器（传false代表不将指示器添加到banner上，配合布局文件，可以自我发挥）


setIndicatorSelectedColor(@ColorInt)
this
设置指示器选中颜色


setIndicatorSelectedColorRes(@ColorRes)
this
设置指示器选中颜色


setIndicatorNormalColor(@ColorInt)
this
设置指示器默认颜色


setIndicatorNormalColorRes(@ColorRes)
this
设置指示器默认颜色


setIndicatorGravity(@IndicatorConfig.Direction)
this
设置指示器位置（左，中，右）


setIndicatorSpace(int)
this
设置指示器之间的间距


setIndicatorMargins(IndicatorConfig.Margins)
this
设置指示器的Margins


setIndicatorWidth(int,int)
this
设置指示器选中和未选中的宽度，直接影响绘制指示器的大小


setIndicatorNormalWidth(int)
this
设置指示器未选中的宽度


setIndicatorSelectedWidth(int)
this
设置指示器选中的宽度


setIndicatorRadius(int)
this
设置指示器圆角，不要圆角可以设置为0


setIndicatorHeight(int)
this
设置指示器高度


setBannerRound(float)
this
设置banner圆角（还有一种setBannerRound2方法，需要5.0以上）


setBannerGalleryEffect(int,int,float)
this
画廊效果


setBannerGalleryMZ(int,float)
this
魅族效果


setStartPosition(int)
this
设置开始的位置 (需要在setAdapter或者setDatas之前调用才有效哦)


setIndicatorPageChange()
this
设置指示器改变监听 (一般是为了配合数据操作使用，看情况自己发挥)


setCurrentItem()
this
设置当前位置，和原生使用效果一样


addBannerLifecycleObserver()
this
给banner添加生命周期观察者，内部自动管理banner的生命周期




Banner2属性


Attributes
format
describe




banner_loop_time
integer
轮播间隔时间，默认3000


banner_auto_loop
boolean
是否自动轮播，默认true


banner_infinite_loop
boolean
是否支持无限循环（即首尾直接过渡），默认true


banner_orientation
enum
轮播方向：horizontal（默认） or vertical


banner_radius
dimension
banner圆角半径，默认0（不绘制圆角）


banner_indicator_normal_width
dimension
指示器默认的宽度，默认5dp （对RoundLinesIndicator无效）


banner_indicator_selected_width
dimension
指示器选中的宽度，默认7dp


banner_indicator_normal_color
color
指示器默认颜色，默认0x88ffffff


banner_indicator_selected_color
color
指示器选中颜色，默认0x88000000


banner_indicator_space
dimension
指示器之间的间距，默认5dp （对RoundLinesIndicator无效）


banner_indicator_gravity
dimension
指示器位置，默认center


banner_indicator_margin
dimension
指示器的margin,默认5dp，不能和下面的同时使用


banner_indicator_marginLeft
dimension
指示器左边的margin


banner_indicator_marginTop
dimension
指示器上边的margin


banner_indicator_marginRight
dimension
指示器右边的margin


banner_indicator_marginBottom
dimension
指示器下边的margin


banner_indicator_height
dimension
指示器高度（对CircleIndicator无效）


banner_indicator_radius
dimension
指示器圆角（对CircleIndicator无效）


banner_round_top_left
boolean
设置要绘制的banner圆角方向（如果都不设置默认全部）


banner_round_top_right
boolean
设置要绘制的banner圆角方向（如果都不设置默认全部）


banner_round_bottom_left
boolean
设置要绘制的banner圆角方向（如果都不设置默认全部）


banner_round_bottom_right
boolean
设置要绘制的banner圆角方向（如果都不设置默认全部）









]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android插件</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-EditText</title>
    <url>/2021/09/09/Android-EditText/</url>
    <content><![CDATA[常用属性
android:hint: 编辑框为空时提示
android:textColorHint: 提示文字的颜色
android:inputType: 输入类型
android:drawableXxxx: 在输入框的指定方位添加图片
android:drawablePadding: 设置图片与输入内容的间距
android:paddingXxxx: 设置内容与边框的间距
android:background: 背景色

取消自动聚焦: 在根布局设置一下两个属性//  可以获得焦点    android:focusable=&quot;true&quot;//  通过触摸获得焦点    android:focusableInTouchMode=&quot;true&quot;
inputType的常用类型//文本类型，多为大写、小写和数字符号。    android:inputType=&quot;none&quot;    android:inputType=&quot;text&quot;    android:inputType=&quot;textCapCharacters&quot; 字母大写    android:inputType=&quot;textCapWords&quot; 首字母大写    android:inputType=&quot;textCapSentences&quot; 仅第一个字母大写    android:inputType=&quot;textAutoCorrect&quot; 自动完成    android:inputType=&quot;textAutoComplete&quot; 自动完成    android:inputType=&quot;textMultiLine&quot; 多行输入    android:inputType=&quot;textImeMultiLine&quot; 输入法多行（如果支持）    android:inputType=&quot;textNoSuggestions&quot; 不提示    android:inputType=&quot;textUri&quot; 网址    android:inputType=&quot;textEmailAddress&quot; 电子邮件地址    android:inputType=&quot;textEmailSubject&quot; 邮件主题    android:inputType=&quot;textShortMessage&quot; 短讯    android:inputType=&quot;textLongMessage&quot; 长信息    android:inputType=&quot;textPersonName&quot; 人名    android:inputType=&quot;textPostalAddress&quot; 地址    android:inputType=&quot;textPassword&quot; 密码    android:inputType=&quot;textVisiblePassword&quot; 可见密码    android:inputType=&quot;textWebEditText&quot; 作为网页表单的文本    android:inputType=&quot;textFilter&quot; 文本筛选过滤    android:inputType=&quot;textPhonetic&quot; 拼音输入//数值类型    android:inputType=&quot;number&quot; 数字    android:inputType=&quot;numberSigned&quot; 带符号数字格式    android:inputType=&quot;numberDecimal&quot; 带小数点的浮点格式    android:inputType=&quot;phone&quot; 拨号键盘    android:inputType=&quot;datetime&quot; 时间日期    android:inputType=&quot;date&quot; 日期键盘    android:inputType=&quot;time&quot; 时间键盘
常用监听方法编辑框内容改变监听  search_edit.addTextChangedListener(new TextWatcher() &#123;      @Override      public void beforeTextChanged(CharSequence charSequence, int i, int i1, int i2) &#123;//          内容改变前      &#125;      @Override      public void onTextChanged(CharSequence charSequence, int i, int i1, int i2) &#123;//          内容改变中      &#125;      @Override      public void afterTextChanged(Editable editable) &#123;//          内容改变后      &#125;  &#125;);
软键盘按键监听  search_edit.setOnKeyListener(new View.OnKeyListener() &#123;      @Override      public boolean onKey(View view, int i, KeyEvent keyEvent) &#123;//          KeyEvent.ACTION_DOWN; 按下按钮时//          KeyEvent.ACTION_UP; 松开按钮时          if (keyEvent.getAction() == KeyEvent.ACTION_UP)&#123;              Toast.makeText(getContext(),&quot;松开按钮&quot;,Toast.LENGTH_SHORT).show();          &#125;          return false;      &#125;  &#125;);
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-Button</title>
    <url>/2021/09/08/Android-Button/</url>
    <content><![CDATA[StateListDrawable&ensp;&ensp;StateListDrawable：StateListDrawable就是对应于selector标签，也是表示一个Drawable集合，每个Drawable都对应View的一种状态&ensp;&ensp;StateListDrawable用途：设置可单击的View的背景，常和ShapeDrawable一起使用
StateListDrawable常用属性
drawable: 引用的drawable位图
state_focused: 是否获得焦点
state_pressed: 控件是否被按下
state_enaabled: 控件是否可用
state_selected: 控件时是否被选择，针对有滚轮的情况
state_checked: 控件是否被勾选
state_checkable: 控件可否被勾选

Button使用drawable文件设置背景Button继承自TextView，基本属性大致相同
Button背景选择器1.在app/src/main/res/drawable目录下创建一个drawable资源文件
2.导入几张drawable图片
3.在资源文件中写入对应的item标签
&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;&lt;!--    被按下时--&gt;    &lt;item android:drawable=&quot;@drawable/ic_baseline_accessible_24&quot; android:state_pressed=&quot;false&quot;/&gt;&lt;!--    没有按下时--&gt;    &lt;item android:drawable=&quot;@drawable/ic_baseline_accessible_forward_24&quot; android:state_pressed=&quot;true&quot;/&gt;&lt;/selector&gt;
4.将按钮的背景设置为drawable文件&lt;Button        android:layout_width=&quot;80dp&quot;        android:layout_height=&quot;80dp&quot;        android:id=&quot;@+id/btn1&quot;        android:background=&quot;@drawable/button1&quot;        android:text=&quot;按钮&quot;/&gt;
5.当按钮按下时，背景为ic_baseline_accessible_forward_24，松开时为ic_baseline_accessible_24
Button事件处理单击事件btn1 = findViewById(R.id.btn1);btn1.setOnClickListener(new View.OnClickListener()&#123;    @Override    public void onClick(View view) &#123;        tv_one.setText(&quot;大丈夫生居天地间，岂能郁郁久居人下&quot;);    &#125;&#125;);
单击事件还可以在xml中对某控件添加&lt;Button        android:layout_width=&quot;80dp&quot;        android:layout_height=&quot;80dp&quot;        android:id=&quot;@+id/btn1&quot;&lt;!--        需要有对应的TestClick()方法--&gt;        android:onClick=&quot;TestClick&quot;        android:background=&quot;@drawable/button1&quot;        android:text=&quot;按钮&quot;/&gt;
长按事件btn1 = findViewById(R.id.btn1);btn1.setOnLongClickListener(new View.OnLongClickListener() &#123;    @Override    public boolean onLongClick(View view) &#123;        tv_one.setText(&quot;须知少时凌云志，曾许人间第一流&quot;);//        返回true时，不再执行OnClick事件(若存在)        return true;    &#125;&#125;);
触摸事件触摸事件分为三种

ACTION_UP = 1(离开)
ACTION_DOWM = 0(按下)
ACTION_MOVE = 2(移动)

btn1.setOnTouchListener(new View.OnTouchListener() &#123;    @Override    public boolean onTouch(View view, MotionEvent motionEvent) &#123;        tv_one.setText(&quot;他日若遂凌云志，敢笑黄巢不丈夫&quot;);//        返回true时，不再相应OnClick和OnLongClick事件(若存在)        return false;    &#125;&#125;);
RadioButton和RadioGroup
RadioButton是安卓中用来实现单选功能的组件
RadioGroup是一个可以容纳多个RadioButton的容器

注意：在没有RadioGroup的情况下，RadioButton可以全部选中，RadioGroup中的RadioButton只能选中一个
常用方法//1.获取按钮组中选中按钮的id  RadioGroup.getCheckedRadioButtonId();  //2.清除选中状态  RadioGroup.clearCheck();  //3.设置指定单选按钮为选中状态，如果传递-1则等同于clearCheck  RadioGroup.check();  //4.RadioGroup的单选按钮选中状态事件监听器  RadioGroup.setOnCheckedChangeListener();
操作方式布局文件&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout android:layout_height=&quot;match_parent&quot;    android:layout_width=&quot;match_parent&quot;    android:orientation=&quot;vertical&quot;    android:gravity=&quot;center&quot;    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;    &lt;RadioGroup        android:id=&quot;@+id/group1&quot;        android:background=&quot;@color/lightyellow&quot;        android:layout_width=&quot;match_parent&quot;        android:gravity=&quot;center&quot;        android:layout_height=&quot;200dp&quot;&gt;&lt;!--        添加android:checked=&quot;true&quot;可设置默认选中--&gt;        &lt;RadioButton            android:id=&quot;@+id/btn1&quot;            android:text=&quot;炎龙铠甲&quot;            android:layout_width=&quot;wrap_content&quot;            android:layout_height=&quot;wrap_content&quot;/&gt;        &lt;RadioButton            android:id=&quot;@+id/btn2&quot;            android:text=&quot;风鹰铠甲&quot;            android:layout_width=&quot;wrap_content&quot;            android:layout_height=&quot;wrap_content&quot;/&gt;        &lt;RadioButton            android:id=&quot;@+id/btn3&quot;            android:text=&quot;黑犀铠甲&quot;            android:layout_width=&quot;wrap_content&quot;            android:layout_height=&quot;wrap_content&quot;/&gt;        &lt;RadioButton            android:id=&quot;@+id/btn4&quot;            android:text=&quot;地虎铠甲&quot;            android:layout_width=&quot;wrap_content&quot;            android:layout_height=&quot;wrap_content&quot;/&gt;        &lt;RadioButton            android:id=&quot;@+id/btn5&quot;            android:text=&quot;雪獒铠甲&quot;            android:layout_width=&quot;wrap_content&quot;            android:layout_height=&quot;wrap_content&quot;/&gt;    &lt;/RadioGroup&gt;&lt;/LinearLayout&gt;
java代码import androidx.appcompat.app.AppCompatActivity;import android.os.Bundle;import android.widget.RadioButton;import android.widget.RadioGroup;import android.widget.Toast;public class MainActivity extends AppCompatActivity &#123;    private RadioGroup group;    private RadioButton btn;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        group = findViewById(R.id.group1);//        选中R.id.btn1        group.check(R.id.btn1);//        多选按钮组选中事件        group.setOnCheckedChangeListener(new RadioGroup.OnCheckedChangeListener() &#123;            @Override            public void onCheckedChanged(RadioGroup group, int checkedId) &#123;//                得到选中的按钮                btn = findViewById(checkedId);                Toast.makeText(MainActivity.this,btn.getText(),Toast.LENGTH_SHORT).show();            &#125;        &#125;);    &#125;&#125;
checkBox(多选按钮)为其设置check=”true”属性则选中
常用方法//判断checkBox是否为选中状态  check.isChecked();  //选中状态事件监听  check.setOnCheckedChangeListener();
实例提示选中的复选框的文本内容，当没有复选框被选中时，按钮不可点击
布局文件&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout android:layout_height=&quot;match_parent&quot;    android:id=&quot;@+id/linear1&quot;    android:layout_width=&quot;match_parent&quot;    android:orientation=&quot;vertical&quot;    android:gravity=&quot;center&quot;    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;    &lt;CheckBox        android:id=&quot;@+id/checkBox1&quot;        android:text=&quot;炎龙铠甲&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;/&gt;    &lt;CheckBox        android:id=&quot;@+id/checkBox2&quot;        android:text=&quot;风鹰铠甲&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;/&gt;    &lt;CheckBox        android:id=&quot;@+id/checkBox3&quot;        android:text=&quot;黑犀铠甲&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;/&gt;    &lt;CheckBox        android:id=&quot;@+id/checkBox4&quot;        android:text=&quot;地虎铠甲&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;/&gt;    &lt;CheckBox        android:id=&quot;@+id/checkBox5&quot;        android:text=&quot;雪獒铠甲&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;/&gt;&lt;!--    初始状态设置为不可点击--&gt;    &lt;Button        android:id=&quot;@+id/btn1&quot;        android:text=&quot;选中状态&quot;        android:enabled=&quot;false&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;/&gt;&lt;/LinearLayout&gt;
java代码import androidx.appcompat.app.AppCompatActivity;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.CheckBox;import android.widget.CompoundButton;import android.widget.LinearLayout;import android.widget.Toast;import java.util.ArrayList;import java.util.List;public class MainActivity extends AppCompatActivity implements CompoundButton.OnCheckedChangeListener &#123;    private CheckBox[] checkBoxes = new CheckBox[5];    private Button btn1;    private LinearLayout linear1;    private int count;    private List&lt;String&gt; list = new ArrayList&lt;&gt;();    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        linear1 = findViewById(R.id.linear1);//        linear1.getChildCount()获取linear1子控件的个数        for (int i = 0;i &lt; linear1.getChildCount();i++)&#123;//            获取第i个子控件            View view = linear1.getChildAt(i);//            判断是否为CheckBox类型            if (view instanceof CheckBox)&#123;//                将View型强转为CheckBox型                checkBoxes[i] = (CheckBox) view;                checkBoxes[i].setOnCheckedChangeListener(this);            &#125;        &#125;//        给底部按钮添加click        btn1 = findViewById(R.id.btn1);        btn1.setOnClickListener(new View.OnClickListener() &#123;            @Override            public void onClick(View v) &#123;                String str = &quot;&quot;;                for (int i = 0;i &lt; list.size();i++)&#123;                    str += list.get(i) + &quot;;&quot;;                &#125;                Toast.makeText(MainActivity.this,str,Toast.LENGTH_SHORT).show();            &#125;        &#125;);    &#125;    @Override    public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) &#123;//        判断点击后的checkBox是否为选中状态        if (isChecked)&#123;            count++;            list.add(buttonView.getText().toString());//            如果按钮不可点击则设置为可点击            if (!btn1.isEnabled())&#123;                btn1.setEnabled(true);            &#125;        &#125;        else &#123;            count--;            list.remove(buttonView.getText().toString());//            全部未选中时设置按钮为不可点击            if (count == 0)&#123;                btn1.setEnabled(false);            &#125;        &#125;    &#125;&#125;
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-Fragment(上)</title>
    <url>/2021/09/13/Android-Fragment(%E4%B8%8A)/</url>
    <content><![CDATA[&ensp;&ensp;Fragment必须嵌入在Activity中使用，因此，虽然Fragment有自己的生命周期，但会受它所在的Activity的生命周期的控制

在MainActivity中使用Fragment①创建fragment创建一个普通的fragment
创建完毕后会自动生成对应的xml布局
②修改BlankFragment.java删掉其中无用的代码
删除完毕后import android.os.Bundle;import androidx.fragment.app.Fragment;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;public class BlankFragment extends Fragment &#123;    @Override    public void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);    &#125;    @Override    public View onCreateView(LayoutInflater inflater, ViewGroup container,                             Bundle savedInstanceState) &#123;        return inflater.inflate(R.layout.fragment_blank, container, false);    &#125;&#125;
优化onCreateView//    优化返回值写法，使其不会一直创建    private View root;    @Override    public View onCreateView(LayoutInflater inflater, ViewGroup container,                             Bundle savedInstanceState) &#123;        if (root == null)&#123;            root = inflater.inflate(R.layout.fragment_blank,container,false);        &#125;        return root;    &#125;
③修改两个Fragment的布局BlankFragment1&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout android:layout_height=&quot;match_parent&quot;    android:layout_width=&quot;match_parent&quot;    android:orientation=&quot;vertical&quot;    android:gravity=&quot;center_horizontal&quot;    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;    &lt;TextView        android:text=&quot;BlankFragment1&quot;        android:textSize=&quot;20sp&quot;        android:textColor=&quot;@color/black&quot;        android:textStyle=&quot;bold&quot;        android:id=&quot;@+id/blankFragmentText&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;/&gt;    &lt;Button        android:text=&quot;按钮&quot;        android:id=&quot;@+id/blankFragmentButton&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;/&gt;&lt;/LinearLayout&gt;
BlankFragment2&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout android:layout_height=&quot;match_parent&quot;    android:layout_width=&quot;match_parent&quot;    android:orientation=&quot;vertical&quot;    android:gravity=&quot;center_horizontal&quot;    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;    &lt;TextView        android:text=&quot;BlankFragment2&quot;        android:textSize=&quot;20sp&quot;        android:textColor=&quot;#ff0033&quot;        android:textStyle=&quot;bold&quot;        android:id=&quot;@+id/blankFragmentText2&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;/&gt;    &lt;Button        android:text=&quot;按钮&quot;        android:id=&quot;@+id/blankFragmentButton2&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;/&gt;&lt;/LinearLayout&gt;
④添加至MainActivity布局&ensp;&ensp;打开MainActivity的布局资源文件activity_main.xml，在其中插入fragment
&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;RelativeLayout android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;    android:orientation=&quot;vertical&quot;    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;    &lt;Button        android:text=&quot;replaceFragment1&quot;        android:textAllCaps=&quot;false&quot;        android:id=&quot;@+id/replaceFragment1&quot;        android:layout_alignParentBottom=&quot;true&quot;        android:layout_marginBottom=&quot;60dp&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_marginLeft=&quot;20dp&quot;        android:layout_height=&quot;wrap_content&quot;/&gt;    &lt;Button        android:text=&quot;replaceFragment2&quot;        android:textAllCaps=&quot;false&quot;        android:id=&quot;@+id/replaceFragment2&quot;        android:layout_marginRight=&quot;20dp&quot;        android:layout_marginBottom=&quot;60dp&quot;        android:layout_alignParentRight=&quot;true&quot;        android:layout_alignParentBottom=&quot;true&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;/&gt;    &lt;FrameLayout        android:background=&quot;#ccffcc&quot;        android:id=&quot;@+id/frameLayout1&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;match_parent&quot;&gt;        &lt;LinearLayout            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;match_parent&quot;            android:id=&quot;@+id/linearLayout1&quot;            android:orientation=&quot;vertical&quot;&gt;&lt;!--            插入的两个fragment布局--&gt;            &lt;fragment                android:id=&quot;@+id/mainActivityFragment1&quot;                android:name=&quot;com.a.fragment.BlankFragment1&quot;                android:layout_width=&quot;match_parent&quot;                android:layout_weight=&quot;1&quot;                android:layout_height=&quot;match_parent&quot;/&gt;            &lt;fragment                android:id=&quot;@+id/mainActivityFragment2&quot;                android:name=&quot;com.a.fragment.BlankFragment2&quot;                android:layout_width=&quot;match_parent&quot;                android:layout_weight=&quot;1&quot;                android:layout_height=&quot;match_parent&quot;/&gt;        &lt;/LinearLayout&gt;    &lt;/FrameLayout&gt;&lt;/RelativeLayout&gt;
注意&ensp;&ensp; 1. 插入在activity_main.xml中的fragment一定要有id&ensp;&ensp; 2. 插入在activity_main.xml中的fragment一定要有name(BlankFragment的完整类名)属性

给fragment添加事件fragment首次绘制界面时调用onCreateView，所以可以在onCreateView下写代码
给BlankFragment的按钮写事件(两个fragment一样的)import android.os.Bundle;import androidx.fragment.app.Fragment;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import android.widget.Button;import android.widget.TextView;public class BlankFragment1 extends Fragment implements View.OnClickListener&#123;    private View root;    private TextView blankFragmentText;    private Button blankFragmentButton;    @Override    public void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);    &#125;    @Override    public View onCreateView(LayoutInflater inflater, ViewGroup container,                             Bundle savedInstanceState) &#123;        if (root == null)&#123;            root = inflater.inflate(R.layout.fragment_blank1,container,false);        &#125;        blankFragmentButton = root.findViewById(R.id.blankFragmentButton);        blankFragmentText = root.findViewById(R.id.blankFragmentText);//        给按钮添加OnClick        blankFragmentButton.setOnClickListener(this);        return root;    &#125;    @Override    public void onClick(View v) &#123;        blankFragmentText.setText(&quot;Welcome BlankFragment1&quot;);    &#125;&#125;
③效果MainActivity页显示两个Fragment互不影响(两个Fragment甚至可以来自同一个BlankFragment.java，即name属性都为com.a.fragment.BlankFragment1)

动态添加fragment&ensp;&ensp;在动态添加fragment前一定要搞懂FragmentManager类
①两种fragment&ensp;&ensp;fragment分为app包内的fragment和v4包内的fragment
二者在使用上的区别：

app包中的fragment兼容自3.0起以后的版本，v4包中的fragment可以兼容到1.6的版本
app.fragment使用标签时继承Activity。v4.fragment使用标签时，当这个Activity的布局中有标签，必须继承FragmentActivity，如果不继成FragmentActivity的话 编译系统会把认为是app包中的Fragment来处理。但是此时我们导入的是v4包中的Fragment，所以会报错
getSupportFragmentManager()对应的是v4包，getFragmentManager()对应的是app包

&ensp;&ensp;注意：在3.0版本之前使用fragment需借助V4包的getSupportFragmentManager()方法来间接获取FragmentManager()对象，3.0版本之后，可以通过Fragment的api直接使用getFragmentManager()方法获取FragmentManager()对象
&ensp;&ensp;问：为什么我的MainActivity布局中使用v4的fragment，却继承AppCompatActivity而不是FragmentActivity？&ensp;&ensp;答：因为AppCompatActivity继承FragmentActivity，这样的话，MainActivity -继承-&gt; AppCompatActivity -继承-&gt; FragmentActivity
&ensp;&ensp;问：Android studio创建MainActivity自动extends AppCompatActivity，为什么不extends Activity&ensp;&ensp;答：AppCompatActivity继承v4包的FragmentAvtivity，并且加入了很多新特性，可以更好的兼容旧系统
②FragmentManager(Fragment的管理)
顾名思义FragmentManager是Fragment的管理类
getSupportFragmentManager()获取所在fragment 的父容器的管理器(getFragmentManager()同理)
getSupportFragmentManager()或者getFragmentManager()获得FragmentManager对象, 可以认为Activity是FragmentManager的宿主环境类

//通过getSupportFragmentManager()可以获取一个v4包的fragment管理类FragmentManager fragmentManager = getSupportFragmentManager();//通过getSupportFragmentManager()拿到fragmentManager的触发器FragmentTransactionFragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();//将fragment替换到R.id.frameLayoutfragmentTransaction.replace(R.id.frameLayout, fragment);//这里的fragment参数一个Fragment类创建的对象的变量//执行fragmentTransaction.commit();
③动态添加1、创建至MainActivity//        获取v4包的Fragment的管理类        FragmentManager fragmentManager = getSupportFragmentManager();//        获取Transaction管理        FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();//        将新fragment替换至指定id的控件内        fragmentTransaction.replace(R.id.frameLayout1,fragment);//        开始        fragmentTransaction.commit();
2、fragment入栈&ensp;&ensp;在FragmentManager.transaction.addToBackStack();向栈中添加Fragment,从而实现添加Fragment后,可以实现按返回键依次返回上个Fragment//入栈fragmentTransaction.addToBackStack(null);
3、完整代码import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.FrameLayout;import android.widget.LinearLayout;public class MainActivity extends AppCompatActivity implements View.OnClickListener&#123;    private Button replaceFragment1,replaceFragment2;    private FrameLayout frameLayout1;    private LinearLayout linearLayout1;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        replaceFragment1 = findViewById(R.id.replaceFragment1);        replaceFragment2 = findViewById(R.id.replaceFragment2);        frameLayout1 = findViewById(R.id.frameLayout1);        linearLayout1 = findViewById(R.id.linearLayout1);        replaceFragment1.setOnClickListener(this);        replaceFragment2.setOnClickListener(this);    &#125;    @Override//    两个按钮的事件    public void onClick(View v) &#123;//        隐藏FrameLayout里的LinearLayout        linearLayout1.setVisibility(View.GONE);        switch (v.getId())&#123;//            按钮一            case R.id.replaceFragment1://                创建BlankFragment1                BlankFragment1 blankFragment1 = new BlankFragment1();                setReplaceFragment(blankFragment1);                break;//            按钮二            case R.id.replaceFragment2://                创建BlankFragment2                BlankFragment2 blankFragment2 = new BlankFragment2();                setReplaceFragment(blankFragment2);                break;        &#125;    &#125;    private void setReplaceFragment (Fragment fragment)&#123;//        获取v4包的Fragment的管理类        FragmentManager fragmentManager = getSupportFragmentManager();//        获取Transaction管理        FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();//        将新fragment替换至指定id的控件内        fragmentTransaction.replace(R.id.frameLayout1,fragment);//        入栈        fragmentTransaction.addToBackStack(null);//        开始        fragmentTransaction.commit();    &#125;&#125;
Fragment入栈后在回退时可以一个一个的返回
fragment的数据传递fragment数据传递分三种模式，即

Activity向Fragment传递数据(Activity发送，Fragment接收)
Fragment向Activity传递数据(Fragment发送，Activity接收)
Fragment向Fragment传递数据

①原生Bundle传递数据&ensp;&ensp;Bundle传递的数据，是以key-value(键值对)的形式存在的；传递的数据可以是boolean、byte、int、long、float、double、string等基本类型或它们对应的数组，也可以是对象或对象数组；当Bundle传递的是对象或对象数组时，必须实现Serializable 或Parcelable接口
传递基本类型
在MainActivity中发送//  创建数据传递对象  Bundle bundle = new Bundle();//  写入键值对  bundle.putString(&quot;message1&quot;,&quot;Bundle方式传递的数据&quot;);//  创建Fragment对象  BlankFragment1 blankFragment1 = new BlankFragment1();//  设置需要传递的Fragment参数  blankFragment1.setArguments(bundle);//  在setReplaceFragment方法将Fragment实例化  setReplaceFragment(blankFragment1);
在Fragment中接收//  创建Bundle对象  Bundle bundle = this.getArguments();//  获取对应key的键值对  String msg = bundle.getString(&quot;message&quot;);//  输出  Toast.makeText(getActivity(),msg,Toast.LENGTH_SHORT).show();
写入MainActivity和Fragment先去删掉activity_main中FrameLayout的LinearLayout
MainActivityimport androidx.appcompat.app.AppCompatActivity;import androidx.fragment.app.Fragment;import androidx.fragment.app.FragmentManager;import androidx.fragment.app.FragmentTransaction;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.FrameLayout;public class MainActivity extends AppCompatActivity implements View.OnClickListener&#123;    private Button replaceFragment1,replaceFragment2;    private FrameLayout frameLayout1;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        replaceFragment1 = findViewById(R.id.replaceFragment1);        replaceFragment2 = findViewById(R.id.replaceFragment2);        frameLayout1 = findViewById(R.id.frameLayout1);        replaceFragment1.setOnClickListener(this);        replaceFragment2.setOnClickListener(this);    &#125;    @Override//    两个按钮的事件    public void onClick(View v) &#123;//        创建数据传递对象        Bundle bundle = new Bundle();        switch (v.getId())&#123;//            按钮一            case R.id.replaceFragment1:                BlankFragment1 blankFragment1 = new BlankFragment1();//                设置需要传递的Fragment参数                blankFragment1.setArguments(bundle);//                写入键值对                bundle.putString(&quot;message1&quot;,&quot;Bundle方式向BlankFragment1传递的数据&quot;);                setReplaceFragment(blankFragment1);                break;//            按钮二            case R.id.replaceFragment2:                BlankFragment2 blankFragment2 = new BlankFragment2();//                设置需要传递的Fragment参数                blankFragment2.setArguments(bundle);//                写入键值对                bundle.putString(&quot;message1&quot;,&quot;Bundle方式向BlankFragment2传递的数据&quot;);                setReplaceFragment(blankFragment2);                break;        &#125;    &#125;    private void setReplaceFragment (Fragment fragment)&#123;        FragmentManager fragmentManager = getSupportFragmentManager();        FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();        fragmentTransaction.replace(R.id.frameLayout1,fragment);        fragmentTransaction.addToBackStack(null);        fragmentTransaction.commit();    &#125;&#125;
两个BlankFragment类似import android.os.Bundle;import androidx.fragment.app.Fragment;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import android.widget.Button;import android.widget.TextView;import android.widget.Toast;public class BlankFragment1 extends Fragment implements View.OnClickListener&#123;    private View root;    private TextView blankFragmentText;    private Button blankFragmentButton;    private String msg;    @Override    public void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);//        创建Bundle对象        Bundle bundle = this.getArguments();//        获取对应的键值对        msg = bundle.getString(&quot;message1&quot;);        Toast.makeText(getActivity(),msg,Toast.LENGTH_SHORT).show();    &#125;    @Override    public View onCreateView(LayoutInflater inflater, ViewGroup container,                             Bundle savedInstanceState) &#123;        if (root == null)&#123;            root = inflater.inflate(R.layout.fragment_blank1,container,false);        &#125;        blankFragmentButton = root.findViewById(R.id.blankFragmentButton);        blankFragmentText = root.findViewById(R.id.blankFragmentText);        blankFragmentButton.setOnClickListener(this);        return root;    &#125;    @Override    public void onClick(View v) &#123;        blankFragmentText.setText(&quot;Welcome BlankFragment1&quot;);    &#125;&#125;
②使用接口传递数据创建接口public interface CallBack &#123;    String getMessage();    void sendMessage(String msg);&#125;
BlankFragment中1、让BlankFragment再继承一个OnLongClickListener，使单击时从MianActivity获取，长按时向MainActivity发送
2、用接口定义变量，并创建setCallBack方法供MainActivity调用//    用接口定义的变量    private CallBack callBack;//    在MianActivity中调用    public void setCallBack(CallBack callBack)&#123;        this.callBack = callBack;    &#125;
3、按钮单击时获取String str = callBack.getMessage();Toast.makeText(getActivity(),&quot;BlankFragment1:&quot; + str,Toast.LENGTH_SHORT).show();
4、按钮长按时发送callBack.sendMessage(&quot;BlankFragment1发送的数据&quot;);return true;
BlankFragment1.javaimport android.os.Bundle;import androidx.fragment.app.Fragment;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import android.widget.Button;import android.widget.TextView;import android.widget.Toast;public class BlankFragment1 extends Fragment implements View.OnClickListener,View.OnLongClickListener&#123;    private View root;    private TextView blankFragmentText;    private Button blankFragmentButton;    private String msg;    @Override    public void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);//        创建Bundle对象        Bundle bundle = this.getArguments();//        获取对应的键值对        msg = bundle.getString(&quot;message1&quot;);        Toast.makeText(getActivity(),msg,Toast.LENGTH_SHORT).show();    &#125;    @Override    public View onCreateView(LayoutInflater inflater, ViewGroup container,                             Bundle savedInstanceState) &#123;        if (root == null)&#123;            root = inflater.inflate(R.layout.fragment_blank1,container,false);        &#125;        blankFragmentButton = root.findViewById(R.id.blankFragmentButton);        blankFragmentText = root.findViewById(R.id.blankFragmentText);//        按钮事件        blankFragmentButton.setOnClickListener(this);        blankFragmentButton.setOnLongClickListener(this);        return root;    &#125;//    用接口定义的变量    private CallBack callBack;//    在MianActivity中调用    public void setCallBack(CallBack callBack)&#123;        this.callBack = callBack;    &#125;    @Override    public void onClick(View v) &#123;        blankFragmentText.setText(&quot;Welcome BlankFragment1&quot;);        String str = callBack.getMessage();        Toast.makeText(getActivity(),&quot;BlankFragment1:&quot; + str,Toast.LENGTH_SHORT).show();    &#125;    @Override    public boolean onLongClick(View v) &#123;        callBack.sendMessage(&quot;BlankFragment1发送的数据&quot;);        return true;    &#125;&#125;
MainActivity中1、调用setCallBack方法
在按钮单击事件下通过已经创建好的blankFragment对象调用
blankFragment1.setCallBack(new CallBack() &#123;    @Override    public String getMessage() &#123;        return &quot;MainActivity获取的数据&quot;;    &#125;    @Override    public void sendMessage(String msg) &#123;        Toast.makeText(MainActivity.this,&quot;MainActivity:&quot; + msg,Toast.LENGTH_SHORT).show();    &#125;&#125;);
2、按钮二blankFragment2.setCallBack(new CallBack() &#123;    @Override    public String getMessage() &#123;        return &quot;MainActivity获取的数据&quot;;    &#125;    @Override    public void sendMessage(String msg) &#123;        Toast.makeText(MainActivity.this,&quot;MainActivity:&quot; + msg,Toast.LENGTH_SHORT).show();    &#125;&#125;);
MainActivity.javaimport androidx.appcompat.app.AppCompatActivity;import androidx.fragment.app.Fragment;import androidx.fragment.app.FragmentManager;import androidx.fragment.app.FragmentTransaction;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.FrameLayout;import android.widget.Toast;public class MainActivity extends AppCompatActivity implements View.OnClickListener&#123;    private Button replaceFragment1,replaceFragment2;    private FrameLayout frameLayout1;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        replaceFragment1 = findViewById(R.id.replaceFragment1);        replaceFragment2 = findViewById(R.id.replaceFragment2);        frameLayout1 = findViewById(R.id.frameLayout1);        replaceFragment1.setOnClickListener(this);        replaceFragment2.setOnClickListener(this);    &#125;    @Override//    两个按钮的事件    public void onClick(View v) &#123;//        创建数据传递对象        Bundle bundle = new Bundle();        switch (v.getId())&#123;//            按钮一            case R.id.replaceFragment1:                BlankFragment1 blankFragment1 = new BlankFragment1();//                设置需要传递的Fragment参数                blankFragment1.setArguments(bundle);//                写入键值对                bundle.putString(&quot;message1&quot;,&quot;Bundle方式向BlankFragment1传递的数据&quot;);//                在setReplaceFragment方法将Fragment实例化                setReplaceFragment(blankFragment1);                blankFragment1.setCallBack(new CallBack() &#123;                    @Override                    public String getMessage() &#123;                        return &quot;MainActivity获取的数据&quot;;                    &#125;                    @Override                    public void sendMessage(String msg) &#123;                        Toast.makeText(MainActivity.this,&quot;MainActivity:&quot; + msg,Toast.LENGTH_SHORT).show();                    &#125;                &#125;);                break;//            按钮二            case R.id.replaceFragment2:                BlankFragment2 blankFragment2 = new BlankFragment2();//                设置需要传递的Fragment参数                blankFragment2.setArguments(bundle);//                写入键值对                bundle.putString(&quot;message1&quot;,&quot;Bundle方式向BlankFragment2传递的数据&quot;);//                在setReplaceFragment方法将Fragment实例化                setReplaceFragment(blankFragment2);                blankFragment2.setCallBack(new CallBack() &#123;                    @Override                    public String getMessage() &#123;                        return &quot;MainActivity获取的数据&quot;;                    &#125;                    @Override                    public void sendMessage(String msg) &#123;                        Toast.makeText(MainActivity.this,&quot;MainActivity:&quot; + msg,Toast.LENGTH_SHORT).show();                    &#125;                &#125;);                break;        &#125;    &#125;    private void setReplaceFragment (Fragment fragment)&#123;//        获取v4包的Fragment的管理类        FragmentManager fragmentManager = getSupportFragmentManager();//        获取Transaction管理        FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();//        将新fragment替换至指定id的控件内        fragmentTransaction.replace(R.id.frameLayout1,fragment);//        入栈        fragmentTransaction.addToBackStack(null);//        开始        fragmentTransaction.commit();    &#125;&#125;
效果图
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-Fragment(下)</title>
    <url>/2021/09/13/Android-Fragment(%E4%B8%8B)/</url>
    <content><![CDATA[Fragment与Activity

Fragment可以调用getActivity()方法获取他所在的Activity，Activity可调用FragmentManager的findFragmentById()或findFragmentByTag()来获取Fragment
在Activity运行过程中，可调用FragmentManager的add()、remove()、replace()等方法动态的添加、删除或替换Fragment
一个Activity可以组合多个Fragment，一个Fragment也可被多个Activity复用


通常，创建Fragment需要实现下面三个方法

onCreate(): 系统创建Fragment对象后回调该方法
onCreateView(): Fragment绘制界面组件时回调该方法
onPause(): 用户离开该Fragment时将会回调该方法

Fragment的生命周期
onAttach(): 当该Fragment添加到它所在的Context时被回调。该方法只会被调用一次
onCreate(): 创建Fragment时被回调。该方法只会被调用一次
onCreateView(): 每次创建、绘制该Fragment的View组件时回调该方法，Fragment将会显示该方法返回的View组件
onActivityCreated(): 当Fragment所在的Activity被启动完成后回调该方法
onStart(): 启动Fragment时回调
onResume(): 恢复Fragment时回调，在onStart()方法后一定会回调onResume()方法
onPause(): 暂停Fragment时被回调
onStop(): 停止Fragment时被回调
onDestoryView(): 销毁该Fragment所包含的View组件时调用
onDestory(): 销毁Fragment时被回调。该方法只会被调用一次
onDetach(): 将该Fragment从它所在的Context中删除、替换完成时回调该方法，在onDestory()方法后一定会回调onDetach()方法。该方法只会被调用一次

]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-GLSurfaceView预览摄像头</title>
    <url>/2023/04/20/Android-GLSurfaceView%E9%A2%84%E8%A7%88%E6%91%84%E5%83%8F%E5%A4%B4/</url>
    <content><![CDATA[权限申请&ensp;&ensp;清单文件中添加权限&lt;uses-permission android:name=&quot;android.permission.CAMERA&quot;/&gt;&ensp;&ensp;申请摄像头权限ActivityCompat.requestPermissions(this, new String[] &#123;        Manifest.permission.CAMERA&#125;, 10001);
自定义View&ensp;&ensp;在项目中，为追求代码简洁，在自定义View中实现GLSurfaceView显示摄像头画面
&ensp;&ensp;创建一个SuperSurfaceView类，使该类继承GLSurfaceView，并重写两个构造方法public class SuperSurfaceView extends GLSurfaceView &#123;    public SuperSurfaceView(Context context) &#123;        super(context);    &#125;    public SuperSurfaceView(Context context, AttributeSet attrs) &#123;        super(context, attrs);    &#125;&#125;
&ensp;&ensp;添加一个设置摄像头类型的方法private int cameraType = 0; // 摄像头类型，一般情况下，0为后置摄像头，1为前置摄像头public SuperSurfaceView setCameraType(int _cameraType) &#123;    this.cameraType = _cameraType;    return this;&#125;
&ensp;&ensp;添加一个开启摄像头预览的方法，后面写完GLSurfaceView渲染器之后再补其中的代码public void launch() &#123;&#125;
渲染器&ensp;&ensp;创建SuperRenderer类，在构造器中接收SuperSurfaceView实例和摄像头的类型，并为摄像头的类型创建一个set方法&ensp;&ensp;实现GLSurfaceView.Renderer和SurfaceTexture.OnFrameAvailableListener接口，重写如下的四个方法
public class SuperRenderer implements GLSurfaceView.Renderer, SurfaceTexture.OnFrameAvailableListener &#123;    private int cameraType;           // 摄像头类型，0为后置摄像头，1为前置摄像头    private final SuperSurfaceView superSurfaceView;    public SuperRenderer(SuperSurfaceView superSurfaceView, int cameraType) &#123;        this.superSurfaceView = superSurfaceView;        this.cameraType = cameraType;    &#125;    public void setCameraType(int cameraType) &#123;        this.cameraType = cameraType;    &#125;    @Override    public void onSurfaceCreated(GL10 gl10, EGLConfig eglConfig) &#123;        // GLSurfaceView创建时调用    &#125;    @Override    public void onSurfaceChanged(GL10 gl10, int width, int height) &#123;        // GLSurfaceView大小发生变化时调用    &#125;    @Override    public void onDrawFrame(GL10 gl10) &#123;        // 绘制画面    &#125;    @Override    public void onFrameAvailable(SurfaceTexture surfaceTexture) &#123;        superSurfaceView.requestRender();    &#125;&#125;
初始化工作&ensp;&ensp;着色器代码// 顶点着色器private final String vertexShaderCode = &quot;uniform mat4 textureTransform;\n&quot; +        &quot;attribute vec4 position;\n&quot; +        &quot;attribute vec2 inputTextureCoordinate;\n&quot; +        &quot;varying vec2 textureCoordinate;\n&quot; +        &quot;\n&quot; +        &quot;void main() &#123;\n&quot; +        &quot;    gl_Position = position;\n&quot; +        &quot;    textureCoordinate = inputTextureCoordinate;\n&quot; +        &quot;&#125;&quot;;// 片段着色器private final String fragmentShaderCode = &quot;#extension GL_OES_EGL_image_external : require\n&quot; +        &quot;precision mediump float;\n&quot; +        &quot;uniform samplerExternalOES videoTex;\n&quot; +        &quot;varying vec2 textureCoordinate;\n&quot; +        &quot;\n&quot; +        &quot;void main() &#123;\n&quot; +        &quot;    gl_FragColor = texture2D(videoTex, textureCoordinate);\n&quot; +        &quot;&#125;&quot;;
&ensp;&ensp;加载着色器private int loadShader(int shaderType, String shaderSource) &#123;    int shaderHandle = GLES20.glCreateShader(shaderType);    GLES20.glShaderSource(shaderHandle, shaderSource);    GLES20.glCompileShader(shaderHandle);    return shaderHandle;&#125;
&ensp;&ensp;加载着色器，创建OpenGL ES程序程序private int programId;private void createProgram() &#123;    int vertexShader = loadShader(GLES20.GL_VERTEX_SHADER, vertexShaderCode);    int fragmentShader = loadShader(GLES20.GL_FRAGMENT_SHADER, fragmentShaderCode);    // 创建空的OpenGL ES程序    programId = GLES20.glCreateProgram();    // 添加顶点着色器到程序中    GLES20.glAttachShader(programId, vertexShader);    // 添加片段着色器到程序中    GLES20.glAttachShader(programId, fragmentShader);    // 创建OpenGL ES程序可执行文件    GLES20.glLinkProgram(programId);    // 释放shader资源    GLES20.glDeleteShader(vertexShader);    GLES20.glDeleteShader(fragmentShader);&#125;
&ensp;&ensp;float数组转换为FloatBufferprivate FloatBuffer floatArr2FloatBuffer(float[] buffer) &#123;    FloatBuffer fb = ByteBuffer.allocateDirect(buffer.length * 4)            .order(ByteOrder.nativeOrder())            .asFloatBuffer();    fb.put(buffer);    fb.position(0);    return fb;&#125;
&ensp;&ensp;添加程序到ES环境中private int positionHandle;private int textureHandle;private int textureTransformHandle;// 绘制范围矩阵private final float[] rangeMatrix = &#123;-1, -1, -1, 1, 1, -1, 1, 1&#125;;// 前置摄像头绘制矩阵private final float[] frontCameraMatrix = &#123;0, 1, 1, 1, 0, 0, 1, 0&#125;;// 后置摄像头绘制矩阵private final float[] rearCameraMatrix = &#123;1, 1, 0, 1, 1, 0, 0, 0&#125;;/** * 添加程序到ES环境中 */private void activeProgram() &#123;    // 将程序添加到OpenGL ES环境    GLES20.glUseProgram(programId);    // 获取顶点着色器的position句柄    int positionHandle = GLES20.glGetAttribLocation(programId, &quot;position&quot;);    // 获取顶点着色器的inputTextureCoordinate句柄    int textureHandle = GLES20.glGetAttribLocation(programId, &quot;inputTextureCoordinate&quot;);    textureTransformHandle = GLES20.glGetUniformLocation(programId, &quot;textureTransform&quot;);    // 绘制范围矩阵转换后的buffer    FloatBuffer rangeMatrixBuffer = floatArr2FloatBuffer(rangeMatrix);    // 摄像头映像矩阵转换后的buffer    FloatBuffer cameraMatrixBuffer;    if(cameraType == 0)&#123;        cameraMatrixBuffer = floatArr2FloatBuffer(rearCameraMatrix);    &#125; else&#123;        cameraMatrixBuffer = floatArr2FloatBuffer(frontCameraMatrix);    &#125;    // 准备positionHandle坐标数据    GLES20.glVertexAttribPointer(positionHandle, 2, GLES20.GL_FLOAT, false, 8, rangeMatrixBuffer);    // 准备textureHandle坐标数据    GLES20.glVertexAttribPointer(textureHandle, 2, GLES20.GL_FLOAT, false, 8, cameraMatrixBuffer);    // 启用positionHandle的句柄    GLES20.glEnableVertexAttribArray(positionHandle);    // 启用textureHandle的句柄    GLES20.glEnableVertexAttribArray(textureHandle);&#125;
&ensp;&ensp;在onSurfaceCreated()中调用@Overridepublic void onSurfaceCreated(GL10 gl10, EGLConfig eglConfig) &#123;    // 设置背景颜色    GLES20.glClearColor(0.0f, 0.0f, 0.0f, 0.0f);    // 加载着色器，创建OpenGL ES程序程序    createProgram();    // 添加程序到ES环境中    activeProgram();&#125;
窗口大小改变时private final float[] orthoMatrix = new float[16];  // 接收正交投影的变换矩阵private final float[] cameraMatrix = new float[16]; // 接收相机变换矩阵private final float[] scaleMatrix = new float[16];  // 接收缩放变换矩阵@Overridepublic void onSurfaceChanged(GL10 gl10, int width, int height) &#123;    // 设置视窗大小和位置    GLES20.glViewport(0, 0, width, height);    // x y z 代表缩放到比例    Matrix.scaleM(scaleMatrix,0, 1f,1f,1f);    float ratio = (float) width / height;    Matrix.orthoM(orthoMatrix, 0,            -1, 1,            -ratio, ratio,            1, 7);    // 设置观察视角 eye相机坐标 center 目标坐标 up 相机正上方 向量vuv(相机头部指向)    Matrix.setLookAtM(cameraMatrix, 0,            0, 0, 1,            0, 0, 0,            0, 1, 0);    Matrix.multiplyMM(scaleMatrix, 0, orthoMatrix, 0, cameraMatrix, 0);&#125;
绘制画面private SurfaceTexture surfaceTexture;  // 用于建立摄像头和GLSurfaceView之间的连接public boolean isBound = false;@Overridepublic void onDrawFrame(GL10 gl10) &#123;    if (isBound) &#123;        activeProgram();        isBound = false;    &#125;    if (surfaceTexture != null) &#123;        // 清除屏幕缓存和深度缓存        GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT | GLES20.GL_DEPTH_BUFFER_BIT);        GLES20.glUniformMatrix4fv(textureTransformHandle, 1, false, scaleMatrix, 0);        // 根据顶点数据绘制平面图形        GLES20.glDrawArrays(GLES20.GL_TRIANGLE_STRIP, 0, rangeMatrix.length / 2);        surfaceTexture.updateTexImage();    &#125;&#125;
操作摄像头&ensp;&ensp;打开摄像头，关闭摄像头private Camera camera;public void openCamera() throws Exception &#123;    if (surfaceTexture == null) &#123;        surfaceTexture = new SurfaceTexture(createTextureId());        surfaceTexture.setOnFrameAvailableListener(this);    &#125;    camera = Camera.open(cameraType);    camera.setPreviewTexture(surfaceTexture);    camera.startPreview();&#125;public void closeCamera() throws Exception &#123;    if (camera != null) &#123;        camera.setPreviewTexture(null);        camera.stopPreview();        camera.release();        camera = null;    &#125;&#125;
调用方式&ensp;&ensp;在之前没写完的launch()方法中添加private SuperRenderer superRenderer;public void launch() throws Exception &#123;    if (superRenderer == null) &#123;        // 创建渲染器对象        superRenderer = new SuperRenderer(this, cameraType);        // 设置OpenGL ES版本        this.setEGLContextClientVersion(2);        // 设置渲染器        this.setRenderer(superRenderer);        //将模式设置为RENDERMODE_WHEN_DIRTY,这样可以减少渲染次数,也就可以减少电量的使用以及更少的使用系统的GPU和CPU资源.        this.setRenderMode(RENDERMODE_WHEN_DIRTY);    &#125; else &#123;        // 关闭摄像头        superRenderer.closeCamera();        // 设置摄像头类型        superRenderer.setCameraType(cameraType);        superRenderer.isBound = true;    &#125;    // 打开摄像头    superRenderer.openCamera();&#125;
&ensp;&ensp;并且在SuperSurfaceView中添加close()方法供关闭public void close() throws Exception &#123;    if (superRenderer != null) &#123;        superRenderer.closeCamera();    &#125;&#125;
&ensp;&ensp;在Activity中调用时private void initCamera() &#123;    SuperSurfaceView superFaceView = findViewById(R.id.superFaceView);    try &#123;        superFaceView.setCameraType(cameraType).launch();    &#125; catch (Exception e) &#123;        e.printStackTrace();    &#125;&#125;
&ensp;&ensp;Activity销毁时@Overrideprotected void onDestroy() &#123;    super.onDestroy();    try &#123;        superFaceView.close();    &#125; catch (Exception e) &#123;        e.printStackTrace();    &#125;&#125;
&ensp;&ensp;点击按钮切换前后摄像头时Button switch_camera = findViewById(R.id.switch_camera);// 切换前后摄像头switch_camera.setOnClickListener(view -&gt; &#123;    cameraType = (cameraType == 0) ? 1 : 0;    initCamera();&#125;);
获取当前帧&ensp;&ensp;获取当前帧的bitmap，通过接口的方式传输bitmap数据，在SuperSurfaceView类中添加如下/** * 获取bitmap的接口 */public interface BitmapCallback&#123;    void onResponse(Bitmap bitmap);&#125;/** * 获取bitmap */public void getBitmap(BitmapCallback bitmapCallback) &#123;    queueEvent(new Runnable() &#123;        @Override        public void run() &#123;            // 获取GLSurfaceView的宽度和高度            int width = SuperSurfaceView.this.getWidth();            int height = SuperSurfaceView.this.getHeight();            // 创建一个Bitmap对象            Bitmap bitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);            // 创建一个IntBuffer对象            IntBuffer pixelBuffer = IntBuffer.allocate(width * height);            // 读取GLSurfaceView的像素数据            GLES20.glReadPixels(0, 0, width, height, GLES20.GL_RGBA, GLES20.GL_UNSIGNED_BYTE, pixelBuffer);            // 将IntBuffer中的像素数据复制到Bitmap对象中            pixelBuffer.position(0);            bitmap.copyPixelsFromBuffer(pixelBuffer);            Matrix matrix = new Matrix();            matrix.postScale(1, -1); // 翻转垂直方向            bitmap = Bitmap.createBitmap(bitmap, 0, 0, width, height, matrix, false);            if (bitmapCallback != null) &#123;                bitmapCallback.onResponse(bitmap);            &#125;        &#125;    &#125;);&#125;
&ensp;&ensp;在Activity中的调用superFaceView.getBitmap(new SuperSurfaceView.BitmapCallback() &#123;    @Override    public void onResponse(Bitmap bitmap) &#123;        // 如果要显示bitmap图像。需在UI线程中        runOnUiThread(new Runnable() &#123;            @Override            public void run() &#123;                // 在UI线程中更新                ImageView imageView = new ImageView(MainActivity.this);                imageView.setImageBitmap(bitmap);            &#125;        &#125;);    &#125;&#125;);
页面布局&ensp;&ensp;在布局文件中添加&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;    android:gravity=&quot;center&quot;    android:orientation=&quot;vertical&quot;    tools:context=&quot;.MainActivity&quot;&gt;    &lt;com.wanzheng.supersurfaceview.SuperSurfaceView        android:id=&quot;@+id/superFaceView&quot;        android:layout_width=&quot;300dp&quot;        android:layout_height=&quot;530dp&quot;/&gt;    &lt;Button        android:text=&quot;切换摄像头&quot;        android:id=&quot;@+id/switch_camera&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;/&gt;&lt;/LinearLayout&gt;
&ensp;&ensp;预览



附，开源地址：https://github.com/xxinPro/SuperSurfaceView
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android开发手记</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-GSON</title>
    <url>/2021/09/27/Android-GSON/</url>
    <content><![CDATA[gson的github开源地址: https://github.com/google/gson
Gradle引入dependencies &#123;    implementation &#x27;com.google.code.gson:gson:2.8.6&#x27;&#125;
对象的序列化与反序列化创建Girlfriend类，并设置get方法对外开放获取变量值public class Girlfriend &#123;    private String name;    private int age;    private double height;    private double weight;    public Girlfriend(String name,int age,double height,double weight)&#123;        this.name = name;        this.age = age;        this.height = height;        this.weight = weight;    &#125;    public String getName() &#123;        return name;    &#125;    public int getAge() &#123;        return age;    &#125;    public double getHeight() &#123;        return height;    &#125;    public double getWeight() &#123;        return weight;    &#125;&#125;
序列化将Girlfriend类的所有属性用json数据记录//  创建Girlfriend对象  Girlfriend girlfriend1 = new Girlfriend(&quot;test&quot;,18,175.0,110.0);//  Gson对象  Gson gson1 = new Gson();//  序列化，用json数据记录girlfriend对象中的所有属性  json = gson1.toJson(girlfriend1);//json是一个String类型的全局变量  code.setText(json);
反序列化将json数据根据Girlfriend类型反序列化，得到一个Girlfriend类型对象//  创建Gson对象  Gson gson2 = new Gson();//  将json数据根据Girlfriend类型反序列化  Girlfriend girlfriend2 = gson2.fromJson(json,Girlfriend.class);//json是一个String类型的全局变量//  从反序列化的对象中取数据  String name = girlfriend2.getName();  int age = girlfriend2.getAge();  double height = girlfriend2.getHeight();  double weight = girlfriend2.getWeight();  code.setText(&quot;名字:&quot; + name + &quot;\n年龄:&quot; + age + &quot;\n身高:&quot; + height + &quot;\n体重:&quot; + weight);
创建Job类，并对外开放get方法获取job类下name和salary的值public class Job &#123;    private String name;    private int salary;    public Job(String name,int salary)&#123;        this.name = name;        this.salary = salary;    &#125;    public String getName() &#123;        return name;    &#125;    public int getSalary() &#123;        return salary;    &#125;&#125;
在Girlfriend类中用Job定义一个变量，并设置setJob方法开放修改job值，getJob获取job值public class Girlfriend &#123;    private String name;    private int age;    private double height;    private double weight;    private Job job;//自定义类创建的变量    public Girlfriend(String name,int age,double height,double weight)&#123;        this.name = name;        this.age = age;        this.height = height;        this.weight = weight;    &#125;//    给job赋值    public void setJob(Job job) &#123;        this.job = job;    &#125;//    获取job变量    public Job getJob() &#123;        return job;    &#125;    public String getName() &#123;        return name;    &#125;    public int getAge() &#123;        return age;    &#125;    public double getHeight() &#123;        return height;    &#125;    public double getWeight() &#123;        return weight;    &#125;&#125;
带自定义类变量的序列化创建自定义类的对象，并用类对象的变量通过通过girlfriend1的setJob给job变量赋值//  创建Girlfriend对象  Girlfriend girlfriend1 = new Girlfriend(&quot;test&quot;,18,175.0,110.0);//  创建Job对象  Job job = new Job(&quot;某公司老板&quot;,100000);//  通过girlfriend1下的setJob方法给job赋值  girlfriend1.setJob(job);//  Gson对象  Gson gson1 = new Gson();//  序列化，用json数据记录girlfriend对象中的所有属性  json = gson1.toJson(girlfriend1);  code.setText(json);//json是一个String类型的全局变量
带自定义类变量反序列化多了一层get而已//  创建Gson对象  Gson gson2 = new Gson();//  将json数据根据Girlfriend类型反序列化  Girlfriend girlfriend2 = gson2.fromJson(json,Girlfriend.class);//json是一个String类型的全局变量//  从反序列化的对象中取数据  String name = girlfriend2.getName();//名字  int age = girlfriend2.getAge();//年龄  double height = girlfriend2.getHeight();//身高  double weight = girlfriend2.getWeight();//体重  String jobName = girlfriend2.getJob().getName();//工作名  int salary = girlfriend2.getJob().getSalary();//收入  code.setText(&quot;名字:&quot; + name + &quot;\n年龄:&quot; + age + &quot;\n身高:&quot; + height + &quot;\n体重:&quot; + weight + &quot;\n工作:&quot; + jobName + &quot;\n收入:&quot; + salary);
数组的序列化与反序列化创建一个数组private String[] strArr = new String[]&#123;&quot;value1&quot;,&quot;value2&quot;,&quot;value3&quot;&#125;;private String json;//序列化值
序列化//  创建GSON对象  Gson gson3 = new Gson();//  对数组序列化  json = gson3.toJson(strArr);  code.setText(json);
反序列化//  创建GSON对象  Gson gson4 = new Gson();//  把json数组字符串反序列化  String[] arr = gson4.fromJson(json,String[].class);//  字符串叠加  String str = &quot;&quot;;  for (int i = 0;i &lt; arr.length;i++)&#123;      str += arr[i] + &quot;\n&quot;;  &#125;  code.setText(str);
自定义类型数组序列化与反序列化创建自定义类型数组private Girlfriend[] girlfriends = new Girlfriend[3];在方法中给数组赋值girlfriends[0] = new Girlfriend(&quot;test1&quot;,19,175.5,110.5);girlfriends[1] = new Girlfriend(&quot;test2&quot;,20,175.0,120.0);girlfriends[2] = new Girlfriend(&quot;test3&quot;,20,165.0,100.0);
序列化//  创建Gson对象  Gson gson3 = new Gson();//  序列化  json = gson3.toJson(girlfriends);  code.setText(json);
反序列化//  创建Gson对象  Gson gson4 = new Gson();//  反序列化得到Girlfriend类型数组，数组中的每个值都是一个Girlfriend对象  Girlfriend[] girlfriends2 = gson4.fromJson(json,Girlfriend[].class);//  调用它的getName  code.setText(girlfriend3.getName());
List集合的序列化与反序列化序列化//  创建Gson对象  Gson gson5 = new Gson();//  把集合序列化为json  json = gson5.toJson(girlfriendList);  code.setText(json);
反序列化  Gson gson6 = new Gson();//  gson提供的数据类型转换器  Type type = new TypeToken&lt;List&lt;Girlfriend&gt;&gt;()&#123;&#125;.getType();//  反序列化，把Json格式的数据转换成List&lt;AppVersion&gt; 类型  List&lt;Girlfriend&gt; girlfriendList2 = gson6.fromJson(json,type);  code.setText(girlfriendList2.get(0).getName());
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android插件</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-Glide</title>
    <url>/2021/09/23/Android-Glide/</url>
    <content><![CDATA[Glide是一个快速高效的Android图片加载库，可以自动加载网络、本地文件，app资源文件中的图片，注重于平滑的滚动
开源地址：https://github.com/bumptech/glide中文文档：https://muyangmin.github.io/glide-docs-cn/

①引入glide在gradle文件中的dependencies添加依赖implementation &#x27;com.github.bumptech.glide:glide:4.11.0&#x27;annotationProcessor &#x27;com.github.bumptech.glide:compiler:4.11.0&#x27;
②使用相应权限在清单文件中加入相应权限//    访问网络    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt;//    本地储存    &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;/&gt;
简单的使用import android.os.Bundle;import android.widget.ImageView;import android.widget.TextView;import com.bumptech.glide.Glide;public class MainActivity extends AppCompatActivity &#123;    private ImageView img;    private TextView text1;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        text1 = findViewById(R.id.text1);        img = findViewById(R.id.img1);        Glide.with(this)//                参数支持：url地址、file文件、文件对象、等等类型//                .load(R.mipmap.shuai)                .load(&quot;https://img0.baidu.com/it/u=1548103423,3809755433&amp;fm=26&amp;fmt=auto&quot;)//                ImageView对象传入                .into(img);    &#125;&#125;
不做缓存使加载的图片不写入本地缓存Glide.with(context)    .load(imgFile)    .skipMemoryCache(true) //不做内存缓存    .diskCacheStrategy(DiskCacheStrategy.NONE) //不做磁盘缓存    .into(imageView);
设置圆角自定义圆角角度//    设置圆角角度    RoundedCorners roundedCorners= new RoundedCorners(10);    RequestOptions options = RequestOptions.            bitmapTransform(roundedCorners).            override(300, 300); //设置采样率,压缩图片,降低内存消耗    Glide.with(context)            .load(imgFile)            .apply(options)            .into(imageView);
圆形图片RequestOptions options = RequestOptions.circleCropTransform()Glide.with(context)        .load(imgFile)        .apply(options)        .into(imageView);
Glide占位符Glide4中共有三种占位图

placeholder: 正在请求图片时展示的图片
error: 如果请求失败时展示的图片(如果没有设置，则展示placeholder)
fallback: 请求的url/model为null时展示的图片(如果没有设置，则展示placeholder)

创建RequestOptions对象  RequestOptions requestOptions = new RequestOptions()//          正在请求中          .placeholder(R.mipmap.shuai)//          请求失败时          .error(R.mipmap.shuai)//          请求地址为null时          .fallback(R.mipmap.shuai)//          图片大小，若未指定则以80x80加载          .override(100,100);
应用RequestOptions对象  Glide.with(this)          .load(&quot;https://img0.baidu.com/it/u=1548103423,3809755433&amp;fm=26&amp;fmt=auto&quot;)//          调用RequestOptions对象          .apply(requestOptions)          .into(img);
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android插件</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-HTTP content-type 对照表</title>
    <url>/2021/09/24/Android-HTTP-content-type-%E5%AF%B9%E7%85%A7%E8%A1%A8/</url>
    <content><![CDATA[ 
  
    
      文件扩展名
       Content-Type(Mime-Type)
       文件扩展名
       Content-Type(Mime-Type)
     
   
     
        
            .*（ 二进制流，不知道下载文件类型）
            application/octet-stream
            .tif
            image/tiff 
        
      
       .001
       application/x-001 
       .301
       application/x-301
       
      
       .323
       text/h323 

       .906
       application/x-906
       
      
       .907
       drawing/907 

       .a11
       application/x-a11
       
      
       .acp
       audio/x-mei-aac 

       .ai
       application/postscript
       
      
       .aif
       audio/aiff 

       .aifc
       audio/aiff
       
      
       .aiff
       audio/aiff 

       .anv
       application/x-anv
       
      
       .asa
       text/asa 

       .asf
       video/x-ms-asf
       
      
       .asp
       text/asp 

       .asx
       video/x-ms-asf
       
      
       .au
       audio/basic 

       .avi
       video/avi
       
      
       .awf
       application/vnd.adobe.workflow 

       .biz
       text/xml
       
      
       .bmp
       application/x-bmp 

       .bot
       application/x-bot
       
      
       .c4t
       application/x-c4t 

       .c90
       application/x-c90
       
      
       .cal
       application/x-cals 

       .cat
       application/vnd.ms-pki.seccat
       
      
       .cdf
       application/x-netcdf 

       .cdr
       application/x-cdr
       
      
       .cel
       application/x-cel 

       .cer
       application/x-x509-ca-cert
       
      
       .cg4
       application/x-g4 

       .cgm
       application/x-cgm
       
      
       .cit
       application/x-cit 

       .class
       java/*
       
      
       .cml
       text/xml 

       .cmp
       application/x-cmp
       
      
       .cmx
       application/x-cmx 

       .cot
       application/x-cot
       
      
       .crl
       application/pkix-crl 

       .crt
       application/x-x509-ca-cert
       
      
       .csi
       application/x-csi 

       .css
       text/css
       
      
       .cut
       application/x-cut 

       .dbf
       application/x-dbf
       
      
       .dbm
       application/x-dbm 

       .dbx
       application/x-dbx
       
      
       .dcd
       text/xml 

       .dcx
       application/x-dcx
       
      
       .der
       application/x-x509-ca-cert 

       .dgn
       application/x-dgn
       
      
       .dib
       application/x-dib 

       .dll
       application/x-msdownload
       
      
       .doc
       application/msword 

       .dot
       application/msword
       
      
       .drw
       application/x-drw 

       .dtd
       text/xml
       
      
       .dwf
       Model/vnd.dwf 

       .dwf
       application/x-dwf
       
      
       .dwg
       application/x-dwg 

       .dxb
       application/x-dxb
       
      
       .dxf
       application/x-dxf 

       .edn
       application/vnd.adobe.edn
       
      
       .emf
       application/x-emf 

       .eml
       message/rfc822
       
      
       .ent
       text/xml 

       .epi
       application/x-epi
       
      
       .eps
       application/x-ps 

       .eps
       application/postscript
       
      
       .etd
       application/x-ebx 

       .exe
       application/x-msdownload
       
      
       .fax
       image/fax 

       .fdf
       application/vnd.fdf
       
      
       .fif
       application/fractals 

       .fo
       text/xml
       
      
       .frm
       application/x-frm 

       .g4
       application/x-g4
       
      
       .gbr
       application/x-gbr 

       .
       application/x-
       
      
       .gif
       image/gif 

       .gl2
       application/x-gl2
       
      
       .gp4
       application/x-gp4 

       .hgl
       application/x-hgl
       
      
       .hmr
       application/x-hmr 

       .hpg
       application/x-hpgl
       
      
       .hpl
       application/x-hpl 

       .hqx
       application/mac-binhex40
       
      
       .hrf
       application/x-hrf 

       .hta
       application/hta
       
      
       .htc
       text/x-component 

       .htm
       text/html
       
      
       .html
       text/html 

       .htt
       text/webviewhtml
       
      
       .htx
       text/html 

       .icb
       application/x-icb
       
      
       .ico
       image/x-icon 

       .ico
       application/x-ico
       
      
       .iff
       application/x-iff 

       .ig4
       application/x-g4
       
      
       .igs
       application/x-igs 

       .iii
       application/x-iphone
       
      
       .img
       application/x-img 

       .ins
       application/x-internet-signup
       
      
       .isp
       application/x-internet-signup 

       .IVF
       video/x-ivf
       
      
       .java
       java/* 

       .jfif
       image/jpeg
       
      
       .jpe
       image/jpeg 

       .jpe
       application/x-jpe
       
      
       .jpeg
       image/jpeg 

       .jpg
       image/jpeg
       
      
       .jpg
       application/x-jpg 

       .js
       application/x-javascript
       
      
       .jsp
       text/html 

       .la1
       audio/x-liquid-file
       
      
       .lar
       application/x-laplayer-reg 

       .latex
       application/x-latex
       
      
       .lavs
       audio/x-liquid-secure 

       .lbm
       application/x-lbm
       
      
       .lmsff
       audio/x-la-lms 

       .ls
       application/x-javascript
       
      
       .ltr
       application/x-ltr 

       .m1v
       video/x-mpeg
       
      
       .m2v
       video/x-mpeg 

       .m3u
       audio/mpegurl
       
      
       .m4e
       video/mpeg4 

       .mac
       application/x-mac
       
      
       .man
       application/x-troff-man 

       .math
       text/xml
       
      
       .mdb
       application/msaccess 

       .mdb
       application/x-mdb
       
      
       .mfp
       application/x-shockwave-flash 

       .mht
       message/rfc822
       
      
       .mhtml
       message/rfc822 

       .mi
       application/x-mi
       
      
       .mid
       audio/mid 

       .midi
       audio/mid
       
      
       .mil
       application/x-mil 

       .mml
       text/xml
       
      
       .mnd
       audio/x-musicnet-download 

       .mns
       audio/x-musicnet-stream
       
      
       .mocha
       application/x-javascript 

       .movie
       video/x-sgi-movie
       
      
       .mp1
       audio/mp1 

       .mp2
       audio/mp2
       
      
       .mp2v
       video/mpeg 

       .mp3
       audio/mp3
       
      
       .mp4
       video/mpeg4 

       .mpa
       video/x-mpg
       
      
       .mpd
       application/vnd.ms-project 

       .mpe
       video/x-mpeg
       
      
       .mpeg
       video/mpg 

       .mpg
       video/mpg
       
      
       .mpga
       audio/rn-mpeg 

       .mpp
       application/vnd.ms-project
       
      
       .mps
       video/x-mpeg 

       .mpt
       application/vnd.ms-project
       
      
       .mpv
       video/mpg 

       .mpv2
       video/mpeg
       
      
       .mpw
       application/vnd.ms-project 

       .mpx
       application/vnd.ms-project
       
      
       .mtx
       text/xml 

       .mxp
       application/x-mmxp
       
      
       .net
       image/pnetvue 

       .nrf
       application/x-nrf
       
      
       .nws
       message/rfc822 

       .odc
       text/x-ms-odc
       
      
       .out
       application/x-out 

       .p10
       application/pkcs10
       
      
       .p12
       application/x-pkcs12 

       .p7b
       application/x-pkcs7-certificates
       
      
       .p7c
       application/pkcs7-mime 

       .p7m
       application/pkcs7-mime
       
      
       .p7r
       application/x-pkcs7-certreqresp 

       .p7s
       application/pkcs7-signature
       
      
       .pc5
       application/x-pc5 

       .pci
       application/x-pci
       
      
       .pcl
       application/x-pcl 

       .pcx
       application/x-pcx
       
      
       .pdf
       application/pdf 

       .pdf
       application/pdf
       
      
       .pdx
       application/vnd.adobe.pdx 

       .pfx
       application/x-pkcs12
       
      
       .pgl
       application/x-pgl 

       .pic
       application/x-pic
       
      
       .pko
       application/vnd.ms-pki.pko 

       .pl
       application/x-perl
       
      
       .plg
       text/html 
       .pls
       audio/scpls
       
      
       .plt
       application/x-plt 
       .png
       image/png
       
      
       .png
       application/x-png 
       .pot
       application/vnd.ms-powerpoint
       
      
       .ppa
       application/vnd.ms-powerpoint 
       .ppm
       application/x-ppm
       
      
       .pps
       application/vnd.ms-powerpoint 
       .ppt
       application/vnd.ms-powerpoint
       
      
       .ppt
       application/x-ppt 
       .pr
       application/x-pr
       
      
       .prf
       application/pics-rules 
       .prn
       application/x-prn
       
      
       .prt
       application/x-prt 
       .ps
       application/x-ps
       
      
       .ps
       application/postscript 
       .ptn
       application/x-ptn
       
      
       .pwz
       application/vnd.ms-powerpoint 
       .r3t
       text/vnd.rn-realtext3d
       
      
       .ra
       audio/vnd.rn-realaudio 
       .ram
       audio/x-pn-realaudio
       
      
       .ras
       application/x-ras 
       .rat
       application/rat-file
       
      
       .rdf
       text/xml 
       .rec
       application/vnd.rn-recording
       
      
       .red
       application/x-red 
       .rgb
       application/x-rgb
       
      
       .rjs
       application/vnd.rn-realsystem-rjs 
       .rjt
       application/vnd.rn-realsystem-rjt
       
      
       .rlc
       application/x-rlc 
       .rle
       application/x-rle
       
      
       .rm
       application/vnd.rn-realmedia 
       .rmf
       application/vnd.adobe.rmf
       
      
       .rmi
       audio/mid 
       .rmj
       application/vnd.rn-realsystem-rmj
       
      
       .rmm
       audio/x-pn-realaudio 
       .rmp
       application/vnd.rn-rn_music_package
       
      
       .rms
       application/vnd.rn-realmedia-secure 
       .rmvb
       application/vnd.rn-realmedia-vbr
       
      
       .rmx
       application/vnd.rn-realsystem-rmx 
       .rnx
       application/vnd.rn-realplayer
       
      
       .rp
       image/vnd.rn-realpix 
       .rpm
       audio/x-pn-realaudio-plugin
       
      
       .rsml
       application/vnd.rn-rsml 
       .rt
       text/vnd.rn-realtext
       
      
       .rtf
       application/msword 
       .rtf
       application/x-rtf
       
      
       .rv
       video/vnd.rn-realvideo 
       .sam
       application/x-sam
       
      
       .sat
       application/x-sat 
       .sdp
       application/sdp
       
      
       .sdw
       application/x-sdw 
       .sit
       application/x-stuffit
       
      
       .slb
       application/x-slb 
       .sld
       application/x-sld
       
      
       .slk
       drawing/x-slk 
       .smi
       application/smil
       
      
       .smil
       application/smil 
       .smk
       application/x-smk
       
      
       .snd
       audio/basic 
       .sol
       text/plain
       
      
       .sor
       text/plain 
       .spc
       application/x-pkcs7-certificates
       
      
       .spl
       application/futuresplash 
       .spp
       text/xml
       
      
       .ssm
       application/streamingmedia 
       .sst
       application/vnd.ms-pki.certstore
       
      
       .stl
       application/vnd.ms-pki.stl 
       .stm
       text/html
       
      
       .sty
       application/x-sty 
       .svg
       text/xml
       
      
       .swf
       application/x-shockwave-flash 
       .tdf
       application/x-tdf
       
      
       .tg4
       application/x-tg4 
       .tga
       application/x-tga
       
      
       .tif
       image/tiff 
       .tif
       application/x-tif
       
      
       .tiff
       image/tiff 
       .tld
       text/xml
       
      
       .top
       drawing/x-top 
       .torrent
       application/x-bittorrent
       
      
       .tsd
       text/xml 
       .txt
       text/plain
       
      
       .uin
       application/x-icq 
       .uls
       text/iuls
       
      
       .vcf
       text/x-vcard 
       .vda
       application/x-vda
       
      
       .vdx
       application/vnd.visio 
       .vml
       text/xml
       
      
       .vpg
       application/x-vpeg005 
       .vsd
       application/vnd.visio
       
      
       .vsd
       application/x-vsd 
       .vss
       application/vnd.visio
       
      
       .vst
       application/vnd.visio 
       .vst
       application/x-vst
       
      
       .vsw
       application/vnd.visio 
       .vsx
       application/vnd.visio
       
      
       .vtx
       application/vnd.visio 
       .vxml
       text/xml
       
      
       .wav
       audio/wav 
       .wax
       audio/x-ms-wax
       
      
       .wb1
       application/x-wb1 
       .wb2
       application/x-wb2
       
      
       .wb3
       application/x-wb3 
       .wbmp
       image/vnd.wap.wbmp
       
      
       .wiz
       application/msword 
       .wk3
       application/x-wk3
       
      
       .wk4
       application/x-wk4 
       .wkq
       application/x-wkq
       
      
       .wks
       application/x-wks 
       .wm
       video/x-ms-wm
       
      
       .wma
       audio/x-ms-wma 
       .wmd
       application/x-ms-wmd
       
      
       .wmf
       application/x-wmf 
       .wml
       text/vnd.wap.wml
       
      
       .wmv
       video/x-ms-wmv 
       .wmx
       video/x-ms-wmx
       
      
       .wmz
       application/x-ms-wmz 
       .wp6
       application/x-wp6
       
      
       .wpd
       application/x-wpd 
       .wpg
       application/x-wpg
       
      
       .wpl
       application/vnd.ms-wpl 
       .wq1
       application/x-wq1
       
      
       .wr1
       application/x-wr1 
       .wri
       application/x-wri
       
      
       .wrk
       application/x-wrk 
       .ws
       application/x-ws
       
      
       .ws2
       application/x-ws 
       .wsc
       text/scriptlet
       
      
       .wsdl
       text/xml 
       .wvx
       video/x-ms-wvx
       
      
       .xdp
       application/vnd.adobe.xdp 
       .xdr
       text/xml
       
      
       .xfd
       application/vnd.adobe.xfd 
       .xfdf
       application/vnd.adobe.xfdf
       
      
       .xhtml
       text/html 
       .xls
       application/vnd.ms-excel
       
      
       .xls
       application/x-xls 
       .xlw
       application/x-xlw
       
      
       .xml
       text/xml 
       .xpl
       audio/scpls
       
      
       .xq
       text/xml 
       .xql
       text/xml
       
      
       .xquery
       text/xml 
       .xsd
       text/xml
       
      
       .xsl
       text/xml 
       .xslt
       text/xml
       
      
       .xwd
       application/x-xwd 
       .x_b
       application/x-x_b
      
      
       .sis
       application/vnd.symbian.install
       .sisx
       application/vnd.symbian.install
      
      
       .x_t
       application/x-x_t
       .ipa
       application/vnd.iphone
       
      
       .apk
       application/vnd.android.package-archive
       .xap
       application/x-silverlight-app
      
    
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>频繁查阅</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-Handler</title>
    <url>/2021/10/09/Android-Handler/</url>
    <content><![CDATA[主要方法
post(Runnable)
postAtTime(Runnable,long)
postDelayed(Runnable,long)
sendEmptyMessage(int)
sendMessage(Message)
sendMessageAtTime(Message,long)
sendMessageDelayed(Message,long)

页面布局添加一个进度条和按钮模拟文件下载&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout android:layout_height=&quot;match_parent&quot;    android:id=&quot;@+id/linear1&quot;    android:layout_width=&quot;match_parent&quot;    android:orientation=&quot;vertical&quot;    android:gravity=&quot;center_horizontal&quot;    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;    &lt;ProgressBar        android:id=&quot;@+id/progress&quot;        style=&quot;@style/Widget.AppCompat.ProgressBar.Horizontal&quot;        android:progress=&quot;0&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;wrap_content&quot;/&gt;    &lt;Button        android:text=&quot;下载&quot;        android:id=&quot;@+id/btn&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;/&gt;&lt;/LinearLayout&gt;
程序设计创建Handler对象，并重写它的handleMessage方法//  创建Handler线程并重写handleMessage方法  Handler handler = new Handler()&#123;      @Override      public void handleMessage(@NonNull Message msg) &#123;          super.handleMessage(msg);//          接收msg中的参数并设置进度条的进度          progress.setProgress(msg.arg1);      &#125;  &#125;;
在方法中//  子线程  new Thread(new Runnable() &#123;      @Override      public void run() &#123;          for (int i = 0; i &lt; 100;i++)&#123;//              创建Message对象              Message message = new Message();//              设置message的第一个参数              message.arg1 = i+1;//              向Handler发送消息              handler.sendMessage(message);              try &#123;//                  暂停1秒。模拟下载                  Thread.sleep(100);              &#125; catch (InterruptedException e) &#123;                  e.printStackTrace();              &#125;          &#125;      &#125;  &#125;).start();
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-ImageView</title>
    <url>/2021/09/09/Android-ImageView/</url>
    <content><![CDATA[常用属性
android:src: 设置图片资源
android:scaleType: 设置图片缩放类型
android:maxHeight: 最大高度
android:maxWidth: 最大宽度
android:adjustViewBounds: 调整view界限

scaleType缩放类型//共同点：缩小图片fitStart: 保持宽高比缩放图片，直到较长的边与image的边长相等，缩放后将图片放在ImageView的左上角fitCenter: 默认值，保持宽高比缩放图片，直到较长的边与image的边长相等，缩放后放于中间fitEnd: 保持宽高比缩放图片，直到较长的边与image的边长相等，缩放后放于右下角fitXY: 对图像的纵横方向进行独立缩放使得图片完全适应ImageView，但是图片的宽高比可能会发生改变//共同点：居中显示center: 保持原图的宽高比和大小，图片中心点与ImageView中心点重叠，当原图宽高大于ImageView时，超出部分将被剪裁centerCrop: 保持宽高比缩放图片，直到完全覆盖ImageView，可能会出现图片的显示不完全centerInside: 保持宽高比缩放图片，直到ImageView能够完全地将图片显示出，如果图片宽高小于ImageView，将直接居中显示matrix: 保持原图的宽高比和大小,从ImageView的左上角开始绘制原图，超出部分将被剪裁
ViewFlipper其实ViewFlipper不该写在这里，因为它继承自ViewAnimator(提供不同View的动画切换效果)，而ViewAnimator又是FrameLayout的子类…
相关方法:

isFlipping: 判断view切换是否正在进行
setFlippInterval: 设置view之间切换的时间间隔
startFlipping: 使用上面切换的时间间隔开始切换所有的View，切换会循环进行
stopFlipping: 停止View切换

ViewAnimator通常不直接使用ViewAnimator，而是使用它的两个子类ViewFlipper和ViewSwitcher
相关方法:

setInAnimator: 设置View进入屏幕时使用的动画
setOutAnimator: 设置View退出屏幕时使用的动画
showNext: 显示下一个视图
showPrevious: 显示上一个视图

ViewFlipper画面切换ViewFlipper画面切换需要给其添加ImageView，原理跟播放幻灯片差不多，下面动态给ViewFlipper添加图片控件//  创建ImageView  ImageView imageView1  = new ImageView(this);  ImageView imageView2  = new ImageView(this);  ImageView imageView3  = new ImageView(this);  ImageView imageView4  = new ImageView(this);//  设置图片  imageView1.setImageResource(img[0]);  imageView2.setImageResource(img[1]);  imageView3.setImageResource(img[2]);  imageView4.setImageResource(img[3]);//  添加到ViewFlipper  home2_viewFlipper1.addView(imageView1);  home2_viewFlipper1.addView(imageView2);  home2_viewFlipper1.addView(imageView3);  home2_viewFlipper1.addView(imageView4);
切换下一张图片显示  home2_viewFlipper1.showNext();//切换上一张//home2_viewFlipper1.showPrevious();
ViewFlipper循环切换// 如果处于切换状态  if (home2_viewFlipper1.isFlipping())&#123;//      停止切换      home2_viewFlipper1.stopFlipping();      home2_btn2.setText(&quot;循环切换&quot;);  &#125;  else&#123;//      设置循环切换时间间隔      home2_viewFlipper1.setFlipInterval(1500);//      开始循环切换      home2_viewFlipper1.startFlipping();      home2_btn2.setText(&quot;停止切换&quot;);  &#125;
添加动画效果进入动画，inview.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;&lt;!--    因为左进右出两张图片，所以这里的duration是java代码中ViewFlipper切换时间间隔的一半才恰好--&gt;    &lt;translate        android:duration=&quot;500&quot;        android:fromXDelta=&quot;-100%p&quot;        android:toXDelta=&quot;0&quot;/&gt;&lt;/set&gt;
退出动画，outview.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;&lt;!--    因为左进右出两张图片，所以这里的duration是java代码中ViewFlipper切换时间间隔的一半才恰好--&gt;    &lt;translate        android:duration=&quot;500&quot;        android:fromXDelta=&quot;0&quot;        android:toXDelta=&quot;100%p&quot;/&gt;&lt;/set&gt;
在代码中添加动画//  装载从左淡入动画  Animation animation = AnimationUtils.loadAnimation(HomeActivity2.this,           R.anim.inview);//  绑定进入动画  home2_viewFlipper1.setInAnimation(animation);//  装载从右淡出效果  Animation animation1 = AnimationUtils.loadAnimation(HomeActivity2.this,          R.anim.outview);//  绑定退出动画  home2_viewFlipper1.setOutAnimation(animation1);//  如果处于切换状态  if (home2_viewFlipper1.isFlipping())&#123;//      停止切换      home2_viewFlipper1.stopFlipping();      home2_btn2.setText(&quot;循环切换&quot;);  &#125;  else&#123;//      设置循环切换时间间隔      home2_viewFlipper1.setFlipInterval(1000);//      开始循环切换      home2_viewFlipper1.startFlipping();      home2_btn2.setText(&quot;停止切换&quot;);  &#125;
效果图
扩展: 创建anim动画1.创建anim文件夹
2.在anim文件夹中创建动画资源文件
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-ListView</title>
    <url>/2021/09/10/Android-ListView/</url>
    <content><![CDATA[常用属性
listSelector: 当条目被点击后，改变条目的背景颜色
divider: 设置分割线的颜色
dividerHeight: 设置分割线的高度
srcollbars: 是否显示滚动条
fadingEdge: 去掉上下黑色阴影

简单的ListView资源文件下载
创建布局(activity_main.xml)&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout android:layout_height=&quot;match_parent&quot;    android:layout_width=&quot;match_parent&quot;    android:orientation=&quot;vertical&quot;    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;    &lt;LinearLayout        android:layout_width=&quot;match_parent&quot;        android:orientation=&quot;horizontal&quot;        android:background=&quot;#336633&quot;        android:gravity=&quot;center_vertical&quot;        android:layout_height=&quot;80dp&quot;&gt;        &lt;TextView            android:layout_width=&quot;wrap_content&quot;            android:layout_height=&quot;wrap_content&quot;            android:textSize=&quot;20sp&quot;            android:id=&quot;@+id/listTitle&quot;            android:layout_marginLeft=&quot;20dp&quot;            android:textColor=&quot;@color/white&quot;            android:textStyle=&quot;bold&quot;            android:text=&quot;TITLE&quot;/&gt;    &lt;/LinearLayout&gt;    &lt;ListView        android:layout_width=&quot;match_parent&quot;        android:id=&quot;@+id/listView&quot;        android:layout_height=&quot;match_parent&quot;/&gt;&lt;/LinearLayout&gt;
创建列表项布局(item.xml)&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout android:layout_height=&quot;100dp&quot;    android:layout_width=&quot;match_parent&quot;    android:orientation=&quot;horizontal&quot;    android:gravity=&quot;center_vertical&quot;    android:background=&quot;#339933&quot;    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;&lt;!--    任意一张图片做默认图片即可--&gt;    &lt;ImageView        android:layout_width=&quot;80dp&quot;        android:layout_marginLeft=&quot;10dp&quot;        android:src=&quot;@mipmap/moren&quot;        android:id=&quot;@+id/foodIcon&quot;        android:layout_height=&quot;80dp&quot;/&gt;    &lt;TextView        android:text=&quot;foodName&quot;        android:layout_marginLeft=&quot;20dp&quot;        android:textColor=&quot;@color/white&quot;        android:textSize=&quot;20sp&quot;        android:textStyle=&quot;bold&quot;        android:id=&quot;@+id/foodName&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;/&gt;&lt;/LinearLayout&gt;
创建MyListTest类，该类继承自BaseAdapter，ListView的适配器
import android.content.Context;import android.view.View;import android.view.ViewGroup;import android.widget.BaseAdapter;import android.widget.ImageView;import android.widget.TextView;public class MyAdapter extends BaseAdapter &#123;    private String[] foodName;    private int[] foodIcon;    private Context context;    public MyAdapter(String[] foodName,int[] foodIcon,Context context)&#123;        this.context = context;        this.foodIcon = foodIcon;        this.foodName = foodName;    &#125;    @Override//    返回列表的总列数    public int getCount() &#123;        return foodIcon.length;    &#125;    @Override//    返回Item的数据对象    public Object getItem(int position) &#123;        return null;    &#125;    @Override//    //返回item的id    public long getItemId(int position) &#123;        return position;    &#125;    @Override    public View getView(int position, View convertView, ViewGroup parent) &#123;//        如果没有拿到过ite资源文件        if (convertView == null)&#123;            convertView = View.inflate(context,R.layout.item,null);        &#125;//        从item中找到要设置的子控件        TextView textView = convertView.findViewById(R.id.foodName);        ImageView imageView = convertView.findViewById(R.id.foodIcon);//        设置        textView.setText(foodName[position]);        imageView.setImageResource(foodIcon[position]);        return convertView;    &#125;&#125;
在MainActivity中对ListView进行应用
import androidx.appcompat.app.AppCompatActivity;import android.os.Bundle;import android.widget.ListView;import android.widget.TextView;public class MainActivity extends AppCompatActivity &#123;    private int[] foodIcon = new int[]&#123;            R.mipmap.dangao,R.mipmap.cha,R.mipmap.hanbao,R.mipmap.jitui,R.mipmap.kafei,R.mipmap.kaixinguo,R.mipmap.lanmei,            R.mipmap.ningmeng,R.mipmap.niupai,R.mipmap.pijiu,R.mipmap.pisa,R.mipmap.qiyiguo,R.mipmap.regou,R.mipmap.sanmingzhi,            R.mipmap.shengnvguo,R.mipmap.shutiao,R.mipmap.tusi,R.mipmap.yimian,R.mipmap.yingtao,R.mipmap.zhangyuxiaowanzi    &#125;;    private String[] foodName = new String[]&#123;            &quot;蛋糕&quot;,&quot;茶&quot;,&quot;汉堡&quot;,&quot;鸡腿&quot;,&quot;咖啡&quot;,&quot;开心果&quot;,&quot;蓝莓&quot;,&quot;柠檬&quot;,&quot;牛排&quot;,&quot;啤酒&quot;,&quot;披萨&quot;,&quot;奇异果&quot;,&quot;热狗&quot;,&quot;三明治&quot;,&quot;圣女果&quot;,&quot;薯条&quot;,&quot;吐司&quot;,&quot;意面&quot;,&quot;樱桃&quot;,&quot;章鱼小丸子&quot;    &#125;;    private ListView listView;    private TextView listTitle;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        listView = findViewById(R.id.listView);		listTitle = findViewById(R.id.listTitle);        MyAdapter myAdapter = new MyAdapter(foodName,foodIcon,this);        listView.setAdapter(myAdapter);    &#125;&#125;
ListView的item添加点击事件在MainActivity中插入
//        给item添加事件        listView.setOnItemClickListener(new AdapterView.OnItemClickListener() &#123;            @Override            public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) &#123;                listTitle.setText(foodName[position]);            &#125;        &#125;);
ListView的优化优化原因：当滑动列表时，划出屏幕的item就会被摧毁掉，新出现的item就会创建一个新的view对象，并且findViewById也十分耗时
新知识点：setTag()是设置标签，getTag()是获取标签,经常用来存储一些view的数据(大概相当于js中setAttribute给标签添加属性)
在MyAdapter类中创建一个内部类final class ViewHolder&#123;//    将item下需要调用的子控件全部填入    TextView textView;    ImageView imageView;&#125;
在MyListTest类的getView方法中使用ViewHolder类创建对象
    @Override    public View getView(int position, View convertView, ViewGroup parent) &#123;//        声明viewHolder变量        ViewHolder viewHolder;        if (convertView == null)&#123;//            创建ViewHolder对象            viewHolder = new ViewHolder();            convertView = View.inflate(context,R.layout.item,null);//            将获取到的view赋值给viewHolder类的变量            viewHolder.textView = convertView.findViewById(R.id.text1);            viewHolder.imageView = convertView.findViewById(R.id.img1);//            将viewHolder附加给convertView            convertView.setTag(viewHolder);        &#125;        else&#123;//            从convertView中取出viewHolder            viewHolder = (ViewHolder) convertView.getTag();        &#125;//        得到ViewHolder类变量的值        viewHolder.textView.setText(iconName[position]);        viewHolder.imageView.setImageResource(iconId[position]);        return convertView;    &#125;


  真&ensp;
  他&ensp;
  🐎&ensp;
  难&ensp;
  搞








]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Android MPAndroidChart绘制统计图</title>
    <url>/2021/12/03/Android-MPAndroidChart%E7%BB%98%E5%88%B6%E7%BB%9F%E8%AE%A1%E5%9B%BE/</url>
    <content><![CDATA[引入MPAndroidChartallprojects &#123;    repositories &#123;        maven &#123; url &quot;https://jitpack.io&quot; &#125;    &#125;&#125;
dependencies &#123;    implementation &#x27;com.github.PhilJay:MPAndroidChart:v3.0.3&#x27;&#125;
线型图最简单的线型图&ensp;&ensp;&ensp;&ensp;在布局文件中添加&lt;com.github.mikephil.charting.charts.LineChart/&gt;标签&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout android:layout_height=&quot;match_parent&quot;    android:layout_width=&quot;match_parent&quot;    android:orientation=&quot;vertical&quot;    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;    &lt;com.github.mikephil.charting.charts.LineChart        android:id=&quot;@+id/lineChart&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;match_parent&quot;/&gt;&lt;/LinearLayout&gt;
&ensp;&ensp;&ensp;&ensp;获取View，设置数据，一个简单的线型图就成了public class LineActivity extends AppCompatActivity &#123;    private LineChart lineChart;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_line);        init();//初始化    &#125;    private void init() &#123;        lineChart = findViewById(R.id.lineChart);//获取到线型图的View        lineChart.setData(setData());//设置显示数据    &#125;    private LineData setData() &#123;//        创建一个Entry类型的集合，并添加数据        List&lt;Entry&gt; entries = new ArrayList&lt;&gt;();        for (int i = 0; i &lt; 10; i++) &#123;//            添加Entry对象，传入纵轴的索引和纵轴的值            entries.add(new Entry(i,new Random().nextInt(100)));        &#125;//        实例化LineDataSet类，并将Entry集合中的数据和这组数据名(或者说这个图形名)，通过这个类可以对线段进行设置        LineDataSet lineDataSet = new LineDataSet(entries,&quot;线型图测试&quot;);//        这个就是线型图所需的数据了        LineData lineData = new LineData(lineDataSet);        return lineData;    &#125;&#125;
&ensp;&ensp;&ensp;&ensp;但是现在不好看
设置属性&ensp;&ensp;&ensp;&ensp;主要用于演示public class LineActivity extends AppCompatActivity &#123;    private LineChart lineChart;    private final String[] strings = new String[]&#123;&quot;测试1&quot;,&quot;测试2&quot;,&quot;测试3&quot;,&quot;测试4&quot;,&quot;测试5&quot;,&quot;测试6&quot;,&quot;测试7&quot;,&quot;测试8&quot;,&quot;测试9&quot;,&quot;测试10&quot;&#125;;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_line);        init();//初始化    &#125;    private void init() &#123;        lineChart = findViewById(R.id.lineChart);//获取到线型图的View        lineChart.setData(setData());//设置显示数据        lineChart.invalidate();//刷新数据        lineChart.setDescription(null);//设置右下角说明性文字不显示//        图形边框的设置        lineChart.setDrawBorders(true);//设置四周的边框显示        lineChart.setBorderWidth(1);//设置边框宽度        lineChart.setBorderColor(Color.RED);//设置边框颜色为红色//        设置触控的操作        lineChart.setTouchEnabled(true);//设置为false时将不响应任何触控        lineChart.setScaleEnabled(true);//设置允许缩放        lineChart.setPinchZoom(true);//设置允许x和y轴同时缩放(默认禁止x轴y轴同时进行缩放)        lineChart.setDragEnabled(true);//设置图形内部可拖动(类似QQ图片放大后向上划或者向下划)//        设置x轴        XAxis xAxis = lineChart.getXAxis();//获取到x轴对象        xAxis.setPosition(XAxis.XAxisPosition.BOTTOM);//设置x轴的位置，图形上方或下方        xAxis.setDrawGridLines(false);//设置纵轴的背景表格线不显示        xAxis.setDrawAxisLine(true);//设置x轴的轴线显示        xAxis.setAxisLineWidth(1);//设置x轴轴线的宽度        xAxis.setAxisMinimum(0);//设置x轴的最小刻度        xAxis.setDrawLabels(true);//显示轴上的刻度        xAxis.setLabelCount(strings.length);//强制设置x轴刻度个数        xAxis.setGranularity(1);//缩放的时候有用，比如放大的时候，我不想把横轴再细分        xAxis.setEnabled(true);//显示x轴//        设置每个纵轴的名字        xAxis.setValueFormatter(new ValueFormatter() &#123;            @Override            public String getFormattedValue(float value) &#123;                return strings[(int) (value % strings.length)];            &#125;        &#125;);//        设置右边y轴        YAxis yAxisRight = lineChart.getAxisRight();//获取到右边的y轴的对象        yAxisRight.setAxisMinimum(0);//设置y轴的最小刻度        yAxisRight.setDrawGridLines(false);//设置横轴的背景表格线不显示，左右两边需要同时设置        yAxisRight.setDrawAxisLine(true);//设置右边y轴的轴线显示        yAxisRight.setAxisLineWidth(1);//设置右边y轴轴线的宽度        yAxisRight.setEnabled(false);//设置右边的轴线不显示//        设置左边y轴        YAxis yAxisLeft = lineChart.getAxisLeft();//获取到左边的y轴的对象        yAxisLeft.setAxisMinimum(0);//设置y轴的最小刻度        yAxisLeft.setDrawGridLines(false);//设置横轴的背景表格线不显示，左右两边需要同时设置        yAxisLeft.setDrawAxisLine(true);//设置左边y轴的轴线显示        yAxisLeft.setAxisLineWidth(1);//设置左边y轴轴线的宽度        yAxisLeft.setEnabled(true);//设置左边的轴线显示    &#125;    private LineData setData() &#123;//        创建一个Entry类型的集合，并添加数据        List&lt;Entry&gt; entries = new ArrayList&lt;&gt;();        for (int i = 0; i &lt; 10; i++) &#123;//            添加Entry对象，传入纵轴的索引和纵轴的值            entries.add(new Entry(i,new Random().nextInt(100)));        &#125;//        实例化LineDataSet类，并将Entry集合中的数据和这组数据名(或者说这个图形名)，通过这个类可以对线段进行设置        LineDataSet lineDataSet = new LineDataSet(entries,&quot;线型图测试&quot;);        lineDataSet.setCircleColor(Color.RED);//设置折折线点的颜色        lineDataSet.setColor(Color.BLUE);//设置折线的颜色//        lineDataSet.setAxisDependency(YAxis.AxisDependency.RIGHT);//如果使用了y轴右轴，必须设置这个//        得到设置完毕的线型图数据        LineData lineData = new LineData(lineDataSet);//        lineData.notifyDataChanged();//刷新数据//        lineData.addDataSet();//添加一组线型图        return lineData;    &#125;&#125;
&ensp;&ensp;&ensp;&ensp;现在的效果
常规配置&ensp;&ensp;&ensp;&ensp;再来看一下常规配置的效果和代码(布局不变)public class LineActivity extends AppCompatActivity &#123;    private LineChart lineChart;    private final String[] strings = new String[]&#123;&quot;测试1&quot;,&quot;测试2&quot;,&quot;测试3&quot;,&quot;测试4&quot;,&quot;测试5&quot;,&quot;测试6&quot;,&quot;测试7&quot;,&quot;测试8&quot;,&quot;测试9&quot;,&quot;测试10&quot;&#125;;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_line);        lineChart = findViewById(R.id.lineChart);        lineChart.setTouchEnabled(false);        lineChart.setDescription(null);        lineChart.setData(new LineData());//添加一个空数据        addData(&quot;数据1&quot;,Color.BLACK);//向空数据中添加数据        addData(&quot;数据2&quot;,Color.BLUE);//向空数据中添加数据        setAxis();    &#125;    private void setAxis() &#123;        XAxis xAxis = lineChart.getXAxis();//x轴        xAxis.setDrawGridLines(false);//取消背景表格        xAxis.setPosition(XAxis.XAxisPosition.BOTTOM);//位于底部        xAxis.setDrawAxisLine(true);//显示轴线        xAxis.setAxisMinimum(0);//最小刻度        xAxis.setLabelCount(strings.length);//强制刻度的个数        xAxis.setGranularity(1);//设置缩放时纵轴之间的最小值差        xAxis.setAxisLineWidth(1);//设置轴线的宽度        xAxis.setValueFormatter(new ValueFormatter() &#123;            @Override            public String getFormattedValue(float value) &#123;                return strings[(int) (value % strings.length)];            &#125;        &#125;);//x轴的每个数据的数据名        xAxis.setEnabled(true);//显示x轴        YAxis yAxisRight = lineChart.getAxisRight();//右边的y轴        yAxisRight.setAxisMinimum(0);//最小刻度        yAxisRight.setDrawGridLines(false);//不显示背景表格线        yAxisRight.setAxisLineWidth(1);//轴线宽度        yAxisRight.setDrawAxisLine(true);        yAxisRight.setEnabled(false);        YAxis yAxisLeft = lineChart.getAxisLeft();//左边的y轴        yAxisLeft.setDrawGridLines(false);//不显示背景表格线        yAxisLeft.setAxisMinimum(0);//最小刻度        yAxisLeft.setAxisLineWidth(1);//轴线宽度        yAxisLeft.setDrawAxisLine(true);        yAxisLeft.setEnabled(true);    &#125;    private void addData(String dataName,int color) &#123;        LineData lineData = lineChart.getData();        List&lt;Entry&gt; entries = new ArrayList&lt;&gt;();        for (int i = 0; i &lt; strings.length; i++) &#123;            entries.add(new Entry(i,new Random().nextInt(100)));//添加一个0-100的随机数给纵轴        &#125;        LineDataSet lineDataSet = new LineDataSet(entries,dataName);        lineDataSet.setColor(color);//设置线段的颜色        lineDataSet.setCircleColor(Color.RED);//设置圆点的颜色        lineDataSet.setValueTextColor(Color.RED);        lineData.addDataSet(lineDataSet);//添加数据        lineChart.notifyDataSetChanged();//刷新数据        lineChart.invalidate();//刷新数据    &#125;&#125;
柱状图最简单的柱状图&ensp;&ensp;&ensp;&ensp;在布局文件中添加&lt;com.github.mikephil.charting.charts.BarChart/&gt;标签&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout android:layout_height=&quot;match_parent&quot;    android:layout_width=&quot;match_parent&quot;    android:orientation=&quot;vertical&quot;    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;    &lt;com.github.mikephil.charting.charts.BarChart        android:id=&quot;@+id/barChart&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;match_parent&quot;/&gt;&lt;/LinearLayout&gt;
&ensp;&ensp;&ensp;&ensp;获取View，设置数据public class BarActivity extends AppCompatActivity &#123;    private BarChart barChart;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_bar);        barChart = findViewById(R.id.barChart);        barChart.setData(setData());    &#125;    private BarData setData() &#123;        List&lt;BarEntry&gt; barEntries = new ArrayList&lt;&gt;();        for (int i = 0; i &lt; strings.length; i++) &#123;            barEntries.add(new BarEntry(i,new Random().nextInt(100)));        &#125;        BarDataSet barDataSet = new BarDataSet(barEntries,&quot;测试数据&quot;);        BarData barData = new BarData(barDataSet);        return barData;    &#125;&#125;
&ensp;&ensp;&ensp;&ensp;基础效果
设置属性&ensp;&ensp;&ensp;&ensp;其实属性都差不多，只要英语学的好，记得很快public class BarActivity extends AppCompatActivity &#123;    private BarChart barChart;    private final String[] strings = new String[]&#123;&quot;测试1&quot;,&quot;测试2&quot;,&quot;测试3&quot;,&quot;测试4&quot;,&quot;测试5&quot;,&quot;测试6&quot;,&quot;测试7&quot;,&quot;测试8&quot;,&quot;测试9&quot;,&quot;测试10&quot;&#125;;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_bar);        barChart = findViewById(R.id.barChart);        barChart.setData(new BarData());        setData(&quot;数据1&quot;,Color.BLACK);    &#125;    private void setData(String dataName,int color) &#123;        BarData barData = barChart.getData();//获取到它的数据        barChart.setDescription(null);        barChart.setScaleEnabled(false);//禁止缩放        barChart.setDrawBarShadow(false);//不显示阴影        XAxis xAxis = barChart.getXAxis();//x轴        xAxis.setPosition(XAxis.XAxisPosition.BOTTOM);//设置x轴位于图形的底部        xAxis.setDrawGridLines(false);//隐藏纵轴的背景线        xAxis.setAxisLineWidth(1);//设置x轴轴线的宽度        xAxis.setAxisLineColor(Color.BLACK);//设置轴线的颜色        xAxis.setDrawAxisLine(true);//绘制轴线        xAxis.setAxisMinimum(0);//最小刻度        xAxis.setGranularity(1);//放大时坐标之间的差值        xAxis.setLabelCount(strings.length);//强制设置数轴个数        xAxis.setValueFormatter(new ValueFormatter() &#123;            @Override            public String getFormattedValue(float value) &#123;                return strings[(int) (value % strings.length)];            &#125;        &#125;);        xAxis.setEnabled(true);        YAxis yAxisRight = barChart.getAxisRight();//右边的y轴        yAxisRight.setAxisLineWidth(1);        yAxisRight.setDrawGridLines(false);        yAxisRight.setAxisMinimum(0);        yAxisRight.setDrawAxisLine(true);        yAxisRight.setLabelCount(strings.length);        yAxisRight.setEnabled(false);        YAxis yAxisLeft = barChart.getAxisLeft();        yAxisLeft.setDrawAxisLine(true);        yAxisLeft.setAxisLineWidth(1);        yAxisLeft.setAxisMinimum(0);        yAxisLeft.setDrawGridLines(false);        yAxisLeft.setLabelCount(strings.length);        yAxisLeft.setEnabled(true);        List&lt;BarEntry&gt; barEntries = new ArrayList&lt;&gt;();        for (int i = 0; i &lt; strings.length; i++) &#123;            barEntries.add(new BarEntry(i,new Random().nextInt(100)));        &#125;        BarDataSet barDataSet = new BarDataSet(barEntries,dataName);        barDataSet.setValueTextColor(Color.RED);        barDataSet.setColor(color);//柱子的颜色        barData.addDataSet(barDataSet);//添加一组数据        barChart.notifyDataSetChanged();//刷新数据        barChart.invalidate();    &#125;&#125;
&ensp;&ensp;&ensp;&ensp;分组显示柱子，设置多柱图&ensp;&ensp;&ensp;&ensp;注意: 设置多柱图一定要给X轴轴线设置最小值并根据x轴的个数比例设置最大值，否则柱子将会失去宽度比例public class BarActivity extends AppCompatActivity &#123;    private BarChart barChart;    private final String[] strings = new String[]&#123;&quot;测试1&quot;,&quot;测试2&quot;,&quot;测试3&quot;,&quot;测试4&quot;,&quot;测试5&quot;,&quot;测试6&quot;,&quot;测试7&quot;,&quot;测试8&quot;,&quot;测试9&quot;,&quot;测试10&quot;&#125;;    private float groupSpace = 0.04f,barSpace = 0.03f,barWidth = 0.45f;//组间隔、组内柱子间隔、柱子宽度    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_bar);        barChart = findViewById(R.id.barChart);        barChart.setData(new BarData());        setData(&quot;数据1&quot;,Color.BLACK);        setData(&quot;数据2&quot;,Color.BLUE);        barChart.getBarData().setBarWidth(barWidth);//设置柱子的宽度        barChart.groupBars(0, groupSpace, barSpace);//设置柱子分组    &#125;    private void setData(String dataName,int color) &#123;        BarData barData = barChart.getData();//获取到它的数据        barChart.setDescription(null);        barChart.setScaleEnabled(false);//禁止缩放        barChart.setDrawBarShadow(false);//不显示阴影        XAxis xAxis = barChart.getXAxis();//x轴        xAxis.setPosition(XAxis.XAxisPosition.BOTTOM);//设置x轴位于图形的底部        xAxis.setDrawGridLines(false);//隐藏纵轴的背景线        xAxis.setAxisLineWidth(1);//设置x轴轴线的宽度        xAxis.setAxisLineColor(Color.BLACK);//设置轴线的颜色        xAxis.setDrawAxisLine(true);//绘制轴线        xAxis.setAxisMinimum(0);//最小刻度        xAxis.setAxisMaximum(10);//最大刻度        xAxis.setGranularity(1);//放大时坐标之间的差值        xAxis.setLabelCount(strings.length);//强制设置数轴个数        xAxis.setValueFormatter(new ValueFormatter() &#123;            @Override            public String getFormattedValue(float value) &#123;                if ((int)value == -1)&#123;//                    他妈的开了标签居中显示后，这个值时不时的会等于-1，关键是这个-1一点也用不到                    value = 1;                &#125;                return strings[(int) value % strings.length];            &#125;        &#125;);        xAxis.setCenterAxisLabels(true);//标签居中显示        xAxis.setEnabled(true);        YAxis yAxisRight = barChart.getAxisRight();//右边的y轴        yAxisRight.setAxisLineWidth(1);//y轴的轴线宽度        yAxisRight.setDrawGridLines(false);//不显示横轴的背景线        yAxisRight.setAxisMinimum(0);//最小刻度        yAxisRight.setDrawAxisLine(true);//绘制轴线        yAxisRight.setEnabled(false);//是否显示        YAxis yAxisLeft = barChart.getAxisLeft();        yAxisLeft.setDrawAxisLine(true);        yAxisLeft.setAxisLineWidth(1);        yAxisLeft.setAxisMinimum(0);        yAxisLeft.setDrawGridLines(false);        yAxisLeft.setEnabled(true);        List&lt;BarEntry&gt; barEntries = new ArrayList&lt;&gt;();        for (int i = 0; i &lt; strings.length; i++) &#123;            barEntries.add(new BarEntry(i,new Random().nextInt(100)));        &#125;        BarDataSet barDataSet = new BarDataSet(barEntries,dataName);        barDataSet.setValueTextColor(Color.RED);//值的颜色        barDataSet.setColor(color);//柱子的颜色        barData.addDataSet(barDataSet);//添加一组数据        barChart.notifyDataSetChanged();//刷新数据        barChart.invalidate();//刷新数据    &#125;&#125;&ensp;&ensp;&ensp;&ensp;效果
饼状图基础饼状图&ensp;&ensp;&ensp;&ensp;在布局文件中添加&lt;com.github.mikephil.charting.charts.PieChart/&gt;标签
&ensp;&ensp;&ensp;&ensp;随随便便加个数据public class PieActivity extends AppCompatActivity &#123;    private PieChart pieChart;    private final String[] strings = new String[]&#123;&quot;测试1&quot;,&quot;测试2&quot;,&quot;测试3&quot;,&quot;测试4&quot;,&quot;测试5&quot;,&quot;测试6&quot;,&quot;测试7&quot;,&quot;测试8&quot;,&quot;测试9&quot;,&quot;测试10&quot;&#125;;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_pie);        pieChart = findViewById(R.id.pieChart);        pieChart.setData(setData());        pieChart.notifyDataSetChanged();        pieChart.invalidate();    &#125;    private PieData setData() &#123;        List&lt;PieEntry&gt; pieEntries = new ArrayList&lt;&gt;();        for (int i = 0; i &lt; strings.length; i++) &#123;            pieEntries.add(new PieEntry(i,new Random().nextInt(100)));        &#125;        PieDataSet pieDataSet = new PieDataSet(pieEntries,&quot;测试&quot;);        PieData pieData = new PieData(pieDataSet);        return pieData;    &#125;&#125;
&ensp;&ensp;&ensp;&ensp;效果不好看
常规属性配置&ensp;&ensp;&ensp;&ensp;没研究的配置还有很多，参考https://blog.csdn.net/shineflowers/article/details/44701645public class PieActivity extends AppCompatActivity &#123;    private PieChart pieChart;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_pie);        pieChart = findViewById(R.id.pieChart);        pieChart.setDescription(null);//设置右下角说明性文字不显示        pieChart.setHoleRadius(0);//设置中间空心的圆半径为0        pieChart.setTransparentCircleRadius(0);//设置中间半透明的圆半径为0        pieChart.setTransparentCircleAlpha(0);//或者可以把它改成透明        pieChart.setUsePercentValues(true);//设置使用百分比(不知道为什么不显示百分号，妈的)        pieChart.setRotationEnabled(true);//设置是否可以旋转        pieChart.setExtraOffsets(20, 15, 20, 15);//左上右下四个方向的边距        pieChart.setCenterText(&quot;年度支出&quot;);//设置圆环中央的文字，前提是setHoleRadius不为0        pieChart.setRotationAngle(120);//设置旋转角度        pieChart.animateX(1000, Easing.EaseInOutQuad);//数据显示动画        addData();//添加数据显示        pieChart.invalidate();//刷新数据    &#125;    private void addData() &#123;//        添加数据        List&lt;PieEntry&gt; pieEntries = new ArrayList&lt;&gt;();//        每添加一个PieEntry就相当于添加了一个扇区        pieEntries.add(new PieEntry(new Random().nextInt(100),&quot;第一季度&quot;));        pieEntries.add(new PieEntry(new Random().nextInt(100),&quot;第二季度&quot;));        pieEntries.add(new PieEntry(new Random().nextInt(100),&quot;第三季度&quot;));        pieEntries.add(new PieEntry(new Random().nextInt(100),&quot;第四季度&quot;));        PieDataSet pieDataSet = new PieDataSet(pieEntries,&quot;年支出比&quot;);        pieDataSet.setValueTextColor(Color.BLACK);//设置字体颜色        pieDataSet.setValueTextSize(15);//设置字体大小        pieDataSet.setSliceSpace(1);//设置扇区间的间隔        pieDataSet.setSelectionShift(5);//设置扇区被选中时向外偏移的距离//        数据连接线        pieDataSet.setValueLinePart1OffsetPercentage(50f);//数据连接线起始点距扇形中心的距离，为百分数        pieDataSet.setValueLinePart1Length(0.5f);//第1端连接线长度        pieDataSet.setValueLinePart2Length(1.3f);//第2段连接线长度        pieDataSet.setValueLineColor(Color.BLACK);//设置数据连接线颜色        pieDataSet.setYValuePosition(PieDataSet.ValuePosition.OUTSIDE_SLICE);//连接线所在的位置        setColor(pieDataSet);//设置扇区的颜色//        设置数据        PieData pieData = new PieData(pieDataSet);        pieData.setValueFormatter(new PercentFormatter(pieChart));//给百分比显示添加百分号        pieChart.setData(pieData);    &#125;    private void setColor(PieDataSet pieDataSet) &#123;//        设置每个扇区不同颜色，因为共4条数据，所以这里只设置了4种颜色        List&lt;Integer&gt; colors = new ArrayList&lt;&gt;();        colors.add(Color.BLUE);        colors.add(Color.DKGRAY);        colors.add(Color.GRAY);        colors.add(Color.RED);        pieDataSet.setColors(colors);//设置扇区颜色    &#125;&#125;
&ensp;&ensp;&ensp;&ensp;效果展示
雷达图雷达图以后再说，妈的累死了
参考地址: https://blog.csdn.net/wjk343977868/article/details/53316981
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android插件</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-MQTT通信</title>
    <url>/2023/02/24/Android-MQTT%E9%80%9A%E4%BF%A1/</url>
    <content><![CDATA[添加依赖implementation &#x27;org.eclipse.paho:org.eclipse.paho.client.mqttv3:1.2.5&#x27;implementation &#x27;org.eclipse.paho:org.eclipse.paho.android.service:1.1.1&#x27;
添加权限&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;&lt;application   ...   &lt;service android:name=&quot;org.eclipse.paho.android.service.MqttService&quot; /&gt;&lt;/application&gt;
创建MQTT管理器&ensp;&ensp;创建一个MQTTManager类，并添加一个方法使用单例模式获取实例public class MQTTManager &#123;    private static MQTTManager mqttManager;    /**     * 通过单例模式获取对象     */    public synchronized static MQTTManager getInstance() &#123;        if (mqttManager == null) &#123;            mqttManager = new MQTTManager();        &#125;        return mqttManager;    &#125;&#125;
初始化MQTT客户端// MQTT地址 = host + port + pathprivate final String serverUri = &quot;ws://127.0.0.1:8080/mqtt&quot;;private final String userName = &quot;admin&quot;;      // 用户名private final String password = &quot;admin&quot;;      // 密码private MqttAndroidClient mqttAndroidClient;  // 是对MqttClient进行的再封装拓展类private MqttConnectOptions mqttConnectOptions;// MQTT连接配置/** * 初始化 * @param context 上下文 */public void init(Context context) &#123;    // 客户端ID，这里是一个自定义方法，获取手机的IMEI码    String clientId = PhoneInfoUtils.getImei(context);    // MQTT连接配置    mqttConnectOptions = new MqttConnectOptions();    // 清除缓存    mqttConnectOptions.setCleanSession(true);    // 超时时间    mqttConnectOptions.setConnectionTimeout(5);    // 心跳包发送间隔    mqttConnectOptions.setKeepAliveInterval(5);    // 连接丢失后是否自动连接    mqttConnectOptions.setAutomaticReconnect(true);    // 用户名    mqttConnectOptions.setUserName(userName);    // 密码    mqttConnectOptions.setPassword(password.toCharArray());    // 设置遗言    String willContent = &quot;&#123; \&quot;data\&quot;: &#123;  \&quot;Carname\&quot;:\&quot;\&quot;,  \&quot;pic\&quot;:\&quot;\&quot;,  \&quot;type\&quot;:\&quot;1\&quot; &#125;, \&quot;msg\&quot;:\&quot;网络不佳，设备掉线\&quot;&#125;&quot;;    mqttConnectOptions.setWill(topic_send, willContent.getBytes(), 2, true);    // MQTT客户端    mqttAndroidClient = new MqttAndroidClient(context, serverUri, clientId);    // 设置MQTT连接回调    mqttAndroidClient.setCallback(new MyMqttCallback());&#125;/** * MQTT连接回调 */private static class MyMqttCallback implements MqttCallback &#123;    @Override    public void connectionLost(Throwable cause) &#123;        cause.printStackTrace();        LogUtils.d(getClass(), &quot;连接断开 = &quot; + cause);        // 连接断开后重新建立连接        // 这里可以添加一些条件，比如检查网络是否稳定        MQTTManager.getInstance().connect();    &#125;    @Override    public void messageArrived(String topic, MqttMessage message) &#123;        LogUtils.d(getClass(), &quot;主题 = &quot; + topic);        LogUtils.d(getClass(), &quot;收到消息 = &quot; + new String(message.getPayload()));    &#125;    @Override    public void deliveryComplete(IMqttDeliveryToken token) &#123;        LogUtils.d(getClass(), &quot;消息已到达&quot;);    &#125;&#125;
连接与断开连接MQTT&ensp;&ensp;订阅所使用的方法在下面会写public static final String topic_read = &quot;/photograph&quot;;// 预设的主题，用于接收public static final String topic_send = &quot;/photo&quot;;     // 预设的主题，用于发送/** * 连接mqtt */public void connect() &#123;    try &#123;        mqttAndroidClient.connect(mqttConnectOptions, null, new IMqttActionListener() &#123;            @Override            public void onSuccess(IMqttToken asyncActionToken) &#123;                LogUtils.d(getClass(), &quot;MQTT连接成功&quot;);                // 连接成功后可以订阅一个主题，以接收该主题中的消息                subscribe(topic_read, 2);            &#125;            @Override            public void onFailure(IMqttToken asyncActionToken, Throwable exception) &#123;                exception.printStackTrace();                LogUtils.d(getClass(), &quot;MQTT连接失败 = &quot; + exception);            &#125;        &#125;);    &#125; catch (MqttException e) &#123;        e.printStackTrace();    &#125;&#125;/** * 断开连接 */public void disconnect() &#123;    try &#123;        mqttAndroidClient.disconnect(null, new IMqttActionListener() &#123;            @Override            public void onSuccess(IMqttToken asyncActionToken) &#123;                LogUtils.d(getClass(), &quot;断开连接成功&quot;);            &#125;            @Override            public void onFailure(IMqttToken asyncActionToken, Throwable exception) &#123;                exception.printStackTrace();                LogUtils.d(getClass(), &quot;断开连接失败 = &quot; + exception);            &#125;        &#125;);    &#125; catch (MqttException e) &#123;        e.printStackTrace();    &#125;&#125;
订阅与取消订阅/** * 订阅主题 * @param topic 要订阅的目标主题名 * @param qos   0 – 最多发一次; 1 – 最少发一次; 2 – 保证收一次 */public void subscribe(String topic, int qos) &#123;    try &#123;        mqttAndroidClient.subscribe(topic, qos, null, new IMqttActionListener() &#123;            @Override            public void onSuccess(IMqttToken asyncActionToken) &#123;                LogUtils.d(getClass(), &quot;MQTT订阅成功&quot;);            &#125;            @Override            public void onFailure(IMqttToken asyncActionToken, Throwable exception) &#123;                LogUtils.d(getClass(), &quot;MQTT订阅失败&quot;);            &#125;        &#125;);    &#125; catch (MqttException e) &#123;        e.printStackTrace();    &#125;&#125;/** * 取消订阅主题 * @param topic 取消订阅的目标主题名 */public void unsubscribe(String topic) &#123;    try &#123;        mqttAndroidClient.unsubscribe(topic, null, new IMqttActionListener() &#123;            @Override            public void onSuccess(IMqttToken asyncActionToken) &#123;                LogUtils.d(getClass(), &quot;MQTT取消订阅成功&quot;);            &#125;            @Override            public void onFailure(IMqttToken asyncActionToken, Throwable exception) &#123;                exception.printStackTrace();                LogUtils.d(getClass(), &quot;MQTT取消订阅失败 = &quot; + exception);            &#125;        &#125;);    &#125; catch (MqttException e) &#123;        e.printStackTrace();    &#125;&#125;
发布主题/** * 在主题中发布消息 * @param topic 目标主题 * @param msg   内容消息 * @param qos   0 – 最多发一次; 1 – 最少发一次; 2 – 保证收一次 * @param retained 设置保留 */public void publish (String topic, String msg, int qos, boolean retained) &#123;    try &#123;        MqttMessage message = new MqttMessage();        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123;            message.setPayload(msg.getBytes(StandardCharsets.UTF_8));        &#125; else &#123;            message.setPayload(msg.getBytes());        &#125;        message.setQos(qos);        message.setRetained(retained);        // 推送消息        mqttAndroidClient.publish(topic, message, null, new IMqttActionListener() &#123;            @Override            public void onSuccess(IMqttToken asyncActionToken) &#123;                LogUtils.d(getClass(), &quot;发送消息成功&quot;);            &#125;            @Override            public void onFailure(IMqttToken asyncActionToken, Throwable exception) &#123;                exception.printStackTrace();                LogUtils.d(getClass(), &quot;发送消息失败 = &quot; + exception);            &#125;        &#125;);    &#125; catch (MqttException e) &#123;        e.printStackTrace();    &#125;&#125;
使用&ensp;&ensp;创建一个服务，服务绑定时先初始化MQTT管理器，然后通过connect()方法连接MQTT服务器，连接成功后会自动接收预设的订阅主题的消息@Overridepublic void onCreate() &#123;    super.onCreate();    MQTTManager.getInstance().init(this);    MQTTManager.getInstance().connect();&#125;
&ensp;&ensp;服务销毁时时随即断开MQTT连接@Overridepublic void onDestroy() &#123;    super.onDestroy();    // 销毁服务时断开MQTT连接    MQTTManager.getInstance().disconnect();&#125;
&ensp;&ensp;发布消息MQTTManager.getInstance().publish(MQTTManager.topic_send, &quot;测试消息&quot;, 2, true);
参考：https://www.emqx.com/zh/blog/android-connects-mqtt-using-kotlinhttps://blog.csdn.net/u014084081/article/details/121165147
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android开发手记</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-MediaPlayer</title>
    <url>/2021/10/09/Android-MediaPlayer/</url>
    <content><![CDATA[MediaPlayer播放音频①页面布局&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout android:layout_height=&quot;match_parent&quot;    android:layout_width=&quot;match_parent&quot;    android:orientation=&quot;vertical&quot;    android:gravity=&quot;center&quot;    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;    &lt;Button        android:text=&quot;播放&quot;        android:id=&quot;@+id/main2_btn1&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;/&gt;    &lt;Button        android:text=&quot;暂停&quot;        android:id=&quot;@+id/main2_btn2&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;/&gt;    &lt;Button        android:text=&quot;结束&quot;        android:id=&quot;@+id/main2_btn3&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;/&gt;&lt;/LinearLayout&gt;
②程序设计1.实例化MediaPlayer//  创建MediaPlayer对象  mediaPlayer = new MediaPlayer();
2.设置它要播放的音频并准备音频//  创建一个文件对象  File file = new File(getExternalFilesDir(&quot;&quot;),&quot;lbw.aac&quot;);  try &#123;//      设置MediaPlayer的文件路径      mediaPlayer.setDataSource(file.getAbsolutePath());//      准备音频      mediaPlayer.prepare();  &#125; catch (IOException e) &#123;      e.printStackTrace();  &#125;
3.在按钮的单击事件中播放、暂停或停止  public void onClick(View v) &#123;      switch (v.getId())&#123;          case R.id.main2_btn1://              播放              mediaPlayer.start();              break;//              暂停          case R.id.main2_btn2:              mediaPlayer.pause();              break;//              结束          case R.id.main2_btn3:              mediaPlayer.stop();              break;      &#125;  &#125;
4.当页面销毁时，释放MediaPlayer的缓存  protected void onDestroy() &#123;      super.onDestroy();//      停止播放      mediaPlayer.stop();//      释放缓存      mediaPlayer.release();  &#125;
5.整体预览import androidx.appcompat.app.AppCompatActivity;import android.media.MediaPlayer;import android.os.Bundle;import android.view.View;import android.widget.Button;import java.io.File;import java.io.IOException;public class MainActivity2 extends AppCompatActivity implements View.OnClickListener &#123;    private Button main2_btn1,main2_btn2,main2_btn3;    private MediaPlayer mediaPlayer;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main2);        main2_btn1 = findViewById(R.id.main2_btn1);        main2_btn2 = findViewById(R.id.main2_btn2);        main2_btn3 = findViewById(R.id.main2_btn3);        main2_btn1.setOnClickListener(this);        main2_btn2.setOnClickListener(this);        main2_btn3.setOnClickListener(this);//        创建MediaPlayer对象        mediaPlayer = new MediaPlayer();//        创建一个文件对象        File file = new File(getExternalFilesDir(&quot;&quot;),&quot;lbw.aac&quot;);        try &#123;//            设置MediaPlayer的文件路径            mediaPlayer.setDataSource(file.getAbsolutePath());//            准备音频            mediaPlayer.prepare();        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;    @Override    protected void onDestroy() &#123;        super.onDestroy();//        停止播放        mediaPlayer.stop();//        释放缓存        mediaPlayer.release();    &#125;    @Override    public void onClick(View v) &#123;        switch (v.getId())&#123;            case R.id.main2_btn1://                播放                mediaPlayer.start();                break;//                暂停            case R.id.main2_btn2:                mediaPlayer.pause();                break;//                结束            case R.id.main2_btn3:                mediaPlayer.stop();                break;        &#125;    &#125;&#125;
播放视频①页面布局&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;    android:orientation=&quot;vertical&quot;    android:gravity=&quot;center&quot;&gt;    &lt;TextureView        android:layout_weight=&quot;1&quot;        android:id=&quot;@+id/player_textureView&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;match_parent&quot;/&gt;    &lt;Button        android:text=&quot;开始播放&quot;        android:id=&quot;@+id/player_btn1&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;/&gt;&lt;/LinearLayout&gt;
②程序设计1.创建MediaPlayer对象//  创建mediaPlayer的对象  mediaPlayer = new MediaPlayer(); //mediaPlayer已经事先声明实例变量
2.指定视频源地址，调用prepare()方法使MediaPlayer对象进入准备完成状态
注意：prepare()不适用于较大的视频或网络视频，因为prepare()会在准备完成进入“准备完成”状态后才会继续向下执行、播放，延迟较大  try &#123;//      指定视频源地址，可以是本地资源、内部Uri、外部网址      mediaPlayer.setDataSource(new File(getExternalFilesDir(&quot;&quot;),&quot;test.mp4&quot;).getAbsolutePath());//      prepare()准备声音//      mediaPlayer.prepare();  &#125; catch (IOException e) &#123;      e.printStackTrace();  &#125;
当视频较大或播放网络视频时，通常不使用prepare()，而是在异常捕获外使用prepareAsync()进行异步准备//  如果视频比较大或者是网络视频，建议使用prepareAsync进行异步准备  mediaPlayer.prepareAsync();
3.设置TextureView控件显示视频，得到控件的Surface并设置显示//  创建Surface对象，得到TextureView的Surface  Surface surface = new Surface(player_textureView.getSurfaceTexture()); //player_textureView是TextureView的findViewById后的变量//  设置mediaPlayer播放在surface  mediaPlayer.setSurface(surface);
4.对prepare()或prepareAsync()进行监听，当视频准备完毕时调用，视频准备完毕就开始播放//  设置“视频准备”监听，当视频准备完毕时调用  mediaPlayer.setOnPreparedListener(new MediaPlayer.OnPreparedListener() &#123;      @Override      public void onPrepared(MediaPlayer mp) &#123;//          开始播放          mediaPlayer.start();      &#125;  &#125;);
5.视频播放完毕，结束MediaPlayer播放和释放缓存//  视频播放完毕时调用  mediaPlayer.setOnCompletionListener(new MediaPlayer.OnCompletionListener() &#123;      @Override      public void onCompletion(MediaPlayer mp) &#123;          player_btn1.setText(&quot;开始播放&quot;);          mediaPlayer.stop();          mediaPlayer.release();      &#125;  &#125;);
6.另外有//  开始播放  mediaPlayer.start();//  暂停播放  mediaPlayer.pause();//  结束播放  mediaPlayer.stop();//  释放缓存  mediaPlayer.release();
7.完整代码import androidx.appcompat.app.AppCompatActivity;import android.media.MediaPlayer;import android.os.Bundle;import android.view.Surface;import android.view.TextureView;import android.view.View;import android.widget.Button;import java.io.File;import java.io.IOException;public class MyMediaPlayer extends AppCompatActivity &#123;    private Button player_btn1;    private TextureView player_textureView;    private MediaPlayer mediaPlayer;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_media_player);        player_btn1 = findViewById(R.id.player_btn1);        player_textureView = findViewById(R.id.player_textureView);        player_btn1.setOnClickListener(new View.OnClickListener() &#123;            @Override            public void onClick(View v) &#123;                String str = player_btn1.getText().toString();                if (str.equals(&quot;开始播放&quot;))&#123;                    player_btn1.setText(&quot;停止播放&quot;);//                    创建mediaPlayer的对象                    mediaPlayer = new MediaPlayer();                    try &#123;//                        指定视频源地址，可以是本地地址、apk内的文件、网络地址                        mediaPlayer.setDataSource(new File(getExternalFilesDir(&quot;&quot;),&quot;test.mp4&quot;).getAbsolutePath());//                        进入准备完成阶段，也可以在线程外调用prepareAsync进入“准备中”状态//                        mediaPlayer.prepare();                    &#125; catch (IOException e) &#123;                        e.printStackTrace();                    &#125;//                    如果视频比较大或者是网络视频，建议使用prepareAsync进行异步准备                    mediaPlayer.prepareAsync();//                    设置视频显示的控件                    Surface surface = new Surface(player_textureView.getSurfaceTexture());                    mediaPlayer.setSurface(surface);//                    设置“视频准备”监听，当视频准备完毕时调用                    mediaPlayer.setOnPreparedListener(new MediaPlayer.OnPreparedListener() &#123;                        @Override                        public void onPrepared(MediaPlayer mp) &#123;//                            开始播放                            mediaPlayer.start();                        &#125;                    &#125;);//                    视频播放完毕时调用                    mediaPlayer.setOnCompletionListener(new MediaPlayer.OnCompletionListener() &#123;                        @Override                        public void onCompletion(MediaPlayer mp) &#123;                            player_btn1.setText(&quot;开始播放&quot;);                            mediaPlayer.stop();                            mediaPlayer.release();                        &#125;                    &#125;);                &#125;                else &#123;                    player_btn1.setText(&quot;开始播放&quot;);//                    结束播放                    mediaPlayer.stop();//                    释放                    mediaPlayer.release();                &#125;            &#125;        &#125;);    &#125;&#125;
8.补充&ensp;&ensp;&ensp;&ensp;TextureView与SurfaceView不同，它不会在WMS中单独创建窗口，而是作为View hierachy中的一个普通View，因此可以和其它普通View一样进行移动，旋转，缩放，动画等变化。&ensp;&ensp;&ensp;&ensp;TextureView必须在硬件加速的窗口中。它显示的内容流数据可以来自App进程或是远端进程。TextureView继承自View，它与其它的View一样在View hierachy中管理与绘制。
VideoView播放视频VideoView是官方帮我们封装的TextureView，实现一些简单的操作，自定义程度较低
①页面布局&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;    android:orientation=&quot;vertical&quot;    android:gravity=&quot;center&quot;&gt;    &lt;VideoView        android:id=&quot;@+id/videoView&quot;        android:layout_weight=&quot;1&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;match_parent&quot;/&gt;    &lt;Button        android:text=&quot;开始播放&quot;        android:id=&quot;@+id/video_btn1&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;/&gt;&lt;/LinearLayout&gt;
②程序设计1.findViewById找到VideoView后直接对它操作就好了videoView = findViewById(R.id.videoView);
2.设置本地播放路径//  设置本地路径  videoView.setVideoPath(new File(getExternalFilesDir(&quot;&quot;),&quot;test.mp4&quot;).getAbsolutePath());
3.VideoView有官方封装的控制器//  创建VideoView的控制器  MediaController mediaController = new MediaController(MyVideoView.this);//  给控制器设置上一个下一个视频  mediaController.setPrevNextListeners(          new View.OnClickListener() &#123;              @Override              public void onClick(View v) &#123;                  Toast.makeText(MyVideoView.this,&quot;上一个视频&quot;,Toast.LENGTH_SHORT).show();              &#125;          &#125;,          new View.OnClickListener() &#123;              @Override              public void onClick(View v) &#123;                  Toast.makeText(MyVideoView.this,&quot;下一个视频&quot;,Toast.LENGTH_SHORT).show();              &#125;          &#125;);//  添加控制器到VideoView  videoView.setMediaController(mediaController);
4.播放就好了…videoView.start();
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-MediaRecorder录制视频</title>
    <url>/2021/10/09/Android-MediaRecorder%E5%BD%95%E5%88%B6%E8%A7%86%E9%A2%91/</url>
    <content><![CDATA[使用MediaRecorder能够通过麦克风和相机捕获音视频并保存
相关权限&lt;!--    写入外部储存--&gt;    &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;/&gt;&lt;!--    读取外部储存--&gt;    &lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot;/&gt;&lt;!--    所有文件管理权限--&gt;    &lt;uses-permission android:name=&quot;android.permission.MANAGE_EXTERNAL_STORAGE&quot;/&gt;&lt;!--    麦克风--&gt;    &lt;uses-permission android:name=&quot;android.permission.RECORD_AUDIO&quot;/&gt;&lt;!--    摄像头--&gt;    &lt;uses-permission android:name=&quot;android.permission.CAMERA&quot;/&gt;
动态申请就不放了，太长
调用摄像头录制布局&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;    android:orientation=&quot;vertical&quot;    android:gravity=&quot;center&quot;&gt;&lt;!--    TextureView展示摄像头的预览图--&gt;    &lt;TextureView        android:layout_weight=&quot;1&quot;        android:id=&quot;@+id/media_textureView&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;match_parent&quot;/&gt;    &lt;Button        android:text=&quot;开始录制&quot;        android:id=&quot;@+id/media_btn1&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;/&gt;&lt;/LinearLayout&gt;
在按钮的点击事件中设置  media_btn1.setOnClickListener(new View.OnClickListener() &#123;      @Override      public void onClick(View v) &#123;          String btnText = media_btn1.getText().toString();          if (btnText.equals(&quot;开始录制&quot;))&#123;              media_btn1.setText(&quot;结束录制&quot;);//              得到摄像头对象              camera = Camera.open();//              摄像头画面预览旋转90°              camera.setDisplayOrientation(90);              camera.unlock();//              创建录制音频和视频的类              mediaRecorder = new MediaRecorder();//              把设置的camera给mediaRecorder              mediaRecorder.setCamera(camera);//              设置音频源，MIC是麦克风              mediaRecorder.setAudioSource(MediaRecorder.AudioSource.MIC);//              设置视频源，CAMERA是相机              mediaRecorder.setVideoSource(MediaRecorder.VideoSource.CAMERA);//              指定输出视频最终的格式，MPEG_4是mp4格式              mediaRecorder.setOutputFormat(MediaRecorder.OutputFormat.MPEG_4);//              指定音频的编码格式              mediaRecorder.setAudioEncoder(MediaRecorder.AudioEncoder.AAC);//              指定视频的编码格式              mediaRecorder.setVideoEncoder(MediaRecorder.VideoEncoder.H264);//              视频旋转90°，否则视频默认横屏播放              mediaRecorder.setOrientationHint(90);//              设置输出文件，储存至外部储存私有目录下的test.mp4，并转换为相对路径              mediaRecorder.setOutputFile(new File(getExternalFilesDir(&quot;&quot;),&quot;test.mp4&quot;).getAbsolutePath());//              设置视频长和宽尺寸              mediaRecorder.setVideoSize(1280,720);//              设置视频帧率              mediaRecorder.setVideoFrameRate(60);//              设置摄像头预览图像              mediaRecorder.setPreviewDisplay(new Surface(media_textureView.getSurfaceTexture()));              try &#123;//                  进入准备阶段                  mediaRecorder.prepare();              &#125; catch (IOException e) &#123;                  e.printStackTrace();              &#125;//              开始录制              mediaRecorder.start();          &#125;          else &#123;              media_btn1.setText(&quot;开始录制&quot;);//              停止录制              mediaRecorder.stop();//              释放mediaRecorder              mediaRecorder.release();//              释放摄像头对象              camera.stopPreview();              camera.release();          &#125;      &#125;  &#125;);
效果图

]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Android NFC开发</title>
    <url>/2022/08/22/Android-NFC%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[&nbsp;&nbsp;要开发NFC，首先确定设备需要支持NFC功能
申请权限&nbsp;&nbsp;在清单文件中声明所需要的权限，该权限并不需要动态申请&lt;!-- NFC权限 --&gt;&lt;uses-permission android:name=&quot;android.permission.NFC&quot;/&gt;&lt;!-- 声明需要android.hardware.nfc硬件模块的支持 --&gt;&lt;uses-feature android:name=&quot;android.hardware.nfc&quot; android:required=&quot;true&quot;/&gt;
配置NFC&nbsp;&nbsp;给对应的Activity添加NFC配置，该配置有三种类型:NDEF、TECH、TAG，从左到右过滤优先级依次降低，对应的Intent过滤规则如下&lt;activity    android:name=&quot;.activity.TeacherLogin&quot;    android:exported=&quot;false&quot;    android:screenOrientation=&quot;landscape&quot;&gt;    &lt;!-- NDEF --&gt;    &lt;intent-filter&gt;        &lt;action android:name=&quot;android.nfc.action.NDEF_DISCOVERED&quot;/&gt;    &lt;/intent-filter&gt;    &lt;!-- TECH (注意这里的mita标签中引用了一个xml配置文件) --&gt;    &lt;intent-filter&gt;        &lt;action android:name=&quot;android.nfc.action.TECH_DISCOVERED&quot; /&gt;    &lt;/intent-filter&gt;    &lt;meta-data        android:name=&quot;android.nfc.action.TECH_DISCOVERED&quot;        android:resource=&quot;@xml/nfc_tech_filter&quot; /&gt;    &lt;!-- TAG --&gt;    &lt;intent-filter&gt;        &lt;action android:name=&quot;android.nfc.action.TAG_DISCOVERED&quot; /&gt;        &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;    &lt;/intent-filter&gt;&lt;/activity&gt;
&nbsp;&nbsp;注意activity的meta-data中引用了一个xml配置文件，这个配置文件用于指定程序支持的nfc卡的类型&lt;resources&gt;    &lt;!-- 可以处理所有Android支持的NFC类型 --&gt;    &lt;tech-list&gt;        &lt;tech&gt;android.nfc.tech.NfcA&lt;/tech&gt;        &lt;tech&gt;android.nfc.tech.NfcB&lt;/tech&gt;        &lt;tech&gt;android.nfc.tech.NfcF&lt;/tech&gt;        &lt;tech&gt;android.nfc.tech.NfcV&lt;/tech&gt;        &lt;tech&gt;android.nfc.tech.IsoDep&lt;/tech&gt;        &lt;tech&gt;android.nfc.tech.Ndef&lt;/tech&gt;        &lt;tech&gt;android.nfc.tech.NdefFormatable&lt;/tech&gt;        &lt;tech&gt;android.nfc.tech.MifareClassic&lt;/tech&gt;        &lt;tech&gt;android.nfc.tech.MifareUltralight&lt;/tech&gt;    &lt;/tech-list&gt;&lt;/resources&gt;
&nbsp;&nbsp;不同NFC使用场景




NFC数据格式名称
ISO标准名称
实际应用场合




NfcA
ISO 14443-3A
门禁卡


NfcB
ISO 14443-3B
二代身份证


NfcF
JIS 6319-4
香港八达通


NfcV
ISO 15693
深圳图书馆读者证


IsoDep
ISO 14443-4
北京一卡通、深圳通、西安长安通、武汉通、广州羊城通




NFC读取数据初始化NFC适配器&nbsp;&nbsp;首先声明一个NFC适配器，和一个延迟意图private NfcAdapter nfcadapter; // 适配器private PendingIntent pendingIntent; // 延迟意图
&nbsp;&nbsp;获取到nfc适配器实例private void initNFC() &#123;    nfcAdapter = NfcAdapter.getDefaultAdapter(this);    if (nfcAdapter == null)&#123;        ToastUtils.show(&quot;设备不支持NFC&quot;, this);    &#125;    else if (!nfcAdapter.isEnabled())&#123;        ToastUtils.show(&quot;请先打开NFC功能&quot;, this);    &#125;    else &#123;        ToastUtils.show(&quot;NFC功能正常&quot;, this);        // 初始化延迟意图        Intent intent = new Intent(this, getClass());        intent.addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP);        pendingIntent = PendingIntent.getActivity(this, 0, intent, PendingIntent.FLAG_UPDATE_CURRENT);    &#125;&#125;
检测NFC读取&nbsp;&nbsp;在页面的onResume中读取数据@Overrideprotected void onResume()&#123;    super.onResume();    if (nfcAdapter == null || !nfcAdapter.isEnabled())&#123;        return;    &#125;    // 确定要过滤的类型    IntentFilter filter1 = new IntentFilter(NfcAdapter.ACTION_NDEF_DISCOVERED); // NDEF    IntentFilter filter2 = new IntentFilter(NfcAdapter.ACTION_TECH_DISCOVERED); // TECH    IntentFilter filter3 = new IntentFilter(NfcAdapter.ACTION_TAG_DISCOVERED);  // TAG    try &#123;        filter1.addDataType(&quot;*/*&quot;);    &#125; catch (IntentFilter.MalformedMimeTypeException e) &#123;        e.printStackTrace();    &#125;    // 意图过滤器    IntentFilter[] intentFilters = &#123;filter1, filter2, filter3&#125;;    // 确定要读的卡类型    String[][] techList = new String[][]&#123;            new String[]&#123;NfcA.class.getName()&#125;,            new String[]&#123;IsoDep.class.getName()&#125;    &#125;;    // 如果不过滤任何意图，将intentFilters替换为null即可    // 如果不限制卡的类型，将techList替换为null即可    nfcAdapter.enableForegroundDispatch(this, pendingIntent, intentFilters, techList);&#125;
读取NFC数据&nbsp;&nbsp;onResume()收到被调用后，将会调用newIntent()读取NFC收到的数据@Overrideprotected void onNewIntent(Intent intent) &#123;    super.onNewIntent(intent);    String action = intent.getAction();    Log.d(TAG, &quot;onNewIntent: action = &quot; + action);    // 判断意图是否符合要求    if (action.equals(NfcAdapter.ACTION_NDEF_DISCOVERED)        // NDEF            || action.equals(NfcAdapter.ACTION_TECH_DISCOVERED) // TECH            || action.equals(NfcAdapter.ACTION_TAG_DISCOVERED)  // TAG    ) &#123;        Tag tag = intent.getParcelableExtra(NfcAdapter.EXTRA_TAG);        byte[] tagId = tag.getId();        // 把读取到的数据转换为16进制的字符串        String hexString = byteArrayToHexString(tagId);        Log.d(TAG, &quot;onNewIntent: 读取数据 = &quot; + hexString);    &#125;&#125;/** * 字节流转换为16进制字符串 * @param bytes 字节流数据 * @return 转换后的16进制字符串 */public static String byteArrayToHexString(byte[] bytes) &#123;    StringBuilder stringBuilder = new StringBuilder();    if (bytes == null || bytes.length &lt;= 0) &#123;        return null;    &#125;    for (byte b : bytes) &#123;        String hv = Integer.toHexString(b &amp; 0xFF);        if (hv.length() &lt; 2) &#123;            stringBuilder.append(0);        &#125;        stringBuilder.append(hv);    &#125;    return stringBuilder.toString();&#125;
&nbsp;&nbsp;如此，整个过程完成，hexString就是NFC读取的数据了
禁止读取NFC数据&nbsp;&nbsp;由于当前页面接管了NFC数据读取，当应用进入后台后，我希望它不再读取数据，所以在onPause()方法中添加禁止读取@Overridepublic void onPause()&#123;    super.onPause();    if (nfcAdapter == null || !nfcAdapter.isEnabled())&#123;        return;    &#125;    nfcAdapter.disableForegroundDispatch(this);&#125;
其他扩展关于uses-feature&nbsp;&nbsp;用于指定Android是否需要某个硬件功能或者软件功能的支持
&nbsp;&nbsp;格式&lt;uses-feature    android:name=&quot;string&quot;    android:required=[&quot;true&quot; | &quot;false&quot;]    android:glEsVersion=&quot;integer&quot; /&gt;
&nbsp;&nbsp;释义




属性
释义




android:name
以描述符字符串的形式指定应用使用的单个硬件或软件功能，硬件功能和软件功能部分已列出有效的属性值参考下方uses-feature的name


android:required
表示应用是否需要 android:name 中所指定功能，为true时即是规定当设备不具有该指定功能时，应用无法正常工作，或设计为无法正常工作；为false则意味着如果设备具有该功能，应用会在必要时优先使用该功能，但应用设计为不使用该指定功能也可正常工作


android:glEsVersion
应用需要的 OpenGL ES 版本。高 16 位表示主版本号，低 16 位表示次版本号




uses-feature的name



name
释义




android.hardware.audio.low_latency
应用使用设备的低延迟时间音频管道，该管道可以减少处理声音输入或输出时的滞后和延迟。


android.hardware.audio.output
应用使用设备的扬声器、音频耳机插孔、蓝牙流式传输能力或类似机制传输声音。


android.hardware.audio.pro
应用使用设备的高端音频功能和性能能力。


android.hardware.microphone
应用使用设备的麦克风记录音频。


android.hardware.bluetooth
应用使用设备的蓝牙功能，通常用于与其他支持蓝牙的设备进行通信。


android.hardware.bluetooth_le
应用使用设备的低功耗蓝牙无线电功能。




&nbsp;&nbsp;更多参考: https://developer.android.google.cn/guide/topics/manifest/uses-feature-element
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android开发手记</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-NTP时间</title>
    <url>/2022/09/24/Android-NTP%E6%97%B6%E9%97%B4/</url>
    <content><![CDATA[&ensp;&ensp;其实如果用别人造好的轮子的话，也没有那么麻烦。。。
&ensp;&ensp;在工程级build.gradle中引入jetpack仓库，注意，可能需要科学上网repositories &#123;    maven &#123; url &quot;https://jitpack.io&quot; &#125;&#125;
&ensp;&ensp;在app级build.gradle中添加对truetime的依赖dependencies &#123;    // or if you want the vanilla version of Truetime:    implementation &#x27;com.github.instacart.truetime-android:library:3.5&#x27;&#125;
&ensp;&ensp;初始化new Thread(new Runnable() &#123;    @Override    public void run() &#123;        try &#123;            TrueTime.build()                    .withConnectionTimeout(3000) // NTP服务器响应超时时间                    .withNtpHost(&quot;ntp1.aliyun.com&quot;) // NTP服务器地址                    .initialize(); // 初始化        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;).start();
&ensp;&ensp;调用NTP服务器给的时间Date date = TrueTime.now();
&ensp;&ensp;如果无法科学上网或者不想添加jetpack依赖，也可以直接将这个插件包引入TrueTime.arr;
&ensp;&ensp;参考：https://github.com/instacart/truetime-android
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android开发手记</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-Notification</title>
    <url>/2021/09/09/Android-Notification/</url>
    <content><![CDATA[获取通知管理器NotificationManager notificationManager = (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);
&ensp;&ensp;Android 8.0+，需要为通知管理器添加一个通知渠道，并传入三个参数：渠道ID、渠道名、重要级别

渠道ID：需要和后面创建Notification所使用的channelId一致，创建后尽量避免修改
渠道名：显示给用户，传达通知的来源和内容
重要级别：有以下五种级别
IMPORTANCE_DEFAULT（默认）：通知的重要性属于中等级别，不会打断用户，但会显示在通知栏中。
IMPORTANCE_HIGH（高）：通知的重要性属于高级别，会以声音和震动的方式提醒用户，并在锁屏上显示。
IMPORTANCE_LOW（低）：通知的重要性属于低级别，不会打扰用户，而且不会在锁屏上显示。
IMPORTANCE_MIN（最低）：通知的重要性属于最低级别，不会打断用户，不会发出声音，也不会在锁屏上显示。
IMPORTANCE_NONE（无）：通知的重要性为零，将完全隐藏通知。



String channelId = &quot;notification&quot;;  // 通知渠道IDString name = &quot;channel_name&quot;;       // 通知渠道名// Android 8.0+ 需要创建通知渠道if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;    // 创建一个新的通知渠道，并指定渠道ID、名称和重要级别。    NotificationChannel notificationChannel = new NotificationChannel(channelId, name, NotificationManager.IMPORTANCE_DEFAULT);    // 将通知渠道与通知管理器绑定    notificationManager.createNotificationChannel(notificationChannel);&#125;
&ensp;&ensp;另外通知渠道有以下公共方法




方法名
作用




setDescription(CharSequence description)
设置通知渠道的描述


setSound(Uri sound, AudioAttributes audioAttributes)
设置通知渠道的声音和音频属性


setVibrationPattern(long[] vibrationPattern)
设置通知渠道的振动模式


enableLights(boolean lights)
启用或禁用通知渠道的LED灯光


enableVibration(boolean vibration)
启用或禁用通知渠道的振动


setLockscreenVisibility(int visibility)
设置通知渠道在锁屏时的可见性


setGroup(String groupId)
将通知渠道分组到指定的组


getImportance()
获取通知渠道的重要性级别




创建意图// 创建一个启动Activity的延迟意图PendingIntent pendingIntent;Intent intent = new Intent(context, TeacherLoginActivity.class);if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.S) &#123;    // Android 12+ 必须指定为PendingIntent.FLAG_IMMUTABLE或PendingIntent.FLAG_MUTABLE之一    pendingIntent = PendingIntent.getActivity(context, 10001, intent, PendingIntent.FLAG_IMMUTABLE);&#125; else &#123;    pendingIntent = PendingIntent.getActivity(context, 10001, intent, PendingIntent.FLAG_UPDATE_CURRENT);&#125;
发送通知&ensp;&ensp;构建通知时所需要的channelId与之前创建NotificationChannel所使用的channelId一致&ensp;&ensp;每个通知都需要一个唯一的通知ID，用于标识通知。如果使用相同的通知ID多次调用notify()方法，将会覆盖之前的通知
// 构建通知Notification notification = new NotificationCompat.Builder(context, channelId)        .setAutoCancel(true)            // 点击通知后自动清除        .setContentTitle(&quot;消息标题&quot;)     // 通知标题        .setContentText(&quot;消息内容&quot;)      // 通知内容        .setWhen(System.currentTimeMillis())    // 通知时间        .setSmallIcon(R.drawable.ic_launcher)   // 设置通知显示在系统状态栏的小图标        .setLargeIcon(BitmapFactory.decodeResource(context.getResources(), R.drawable.ic_launcher)) // 设置下拉状态栏后通知的图标        .setContentIntent(pendingIntent)    // 点击通知后跳转        .build();// 发送通知，确保每个通知使用唯一的通知IDint id = 1;notificationManager.notify(channelId, id, notification);
&ensp;&ensp;Notification类中常用的公共方法




方法名
作用




setContentTitle(CharSequence title)
设置通知的标题文本


setContentText(CharSequence text)
设置通知的内容文本


setSmallIcon(int icon)
设置通知的小图标


setLargeIcon(Bitmap icon)
设置通知的大图标


setContentIntent(PendingIntent intent)
设置点击通知时要执行的操作


setAutoCancel(boolean autoCancel)
设置通知是否在用户点击后自动取消


setDefaults(int defaults)
设置通知的默认行为，如声音、震动等


setPriority(int priority)
设置通知的优先级


setVisibility(int visibility)
设置通知在锁屏时的可见性


addAction(int icon, CharSequence title, PendingIntent intent)
添加操作按钮到通知中


setStyle(Notification.Style style)
设置通知的样式，如大文本样式、大图样式等


setGroup(String groupKey)
将通知分组到指定的组


setGroupSummary(boolean isGroupSummary)
设置是否为组的摘要通知


setGroupAlertBehavior(int groupAlertBehavior)
设置组通知的提醒行为


setOngoing(boolean ongoing)
设置通知是否为持久通知


setSound(Uri sound)
设置通知的声音


setVibrate(long[] pattern)
设置通知的震动模式。例如，long[] pattern = {0, 1000, 500, 1000, 500, 1000}; 表示在通知到达时先静止，然后以1秒振动、0.5秒静止、1秒振动、0.5秒静止、1秒振动的模式进行震动。


setColor(int argb)
设置通知的颜色


setCategory(String category)
设置通知类别


setFullScreenIntent(PendingIntent intent, boolean b)
设置全屏意图。全屏意图在特定条件下可以使通知以全屏方式显示




&ensp;&ensp;setCategory(String category)设置通知类别时填入如下10种类别

Notification.CATEGORY_ALARM：表示通知是一个闹钟或定时器相关的通知。
Notification.CATEGORY_CALL：表示通知与电话通话相关。
Notification.CATEGORY_EMAIL：表示通知与电子邮件相关。
Notification.CATEGORY_ERROR：表示通知是一个错误或异常相关的通知。
Notification.CATEGORY_EVENT：表示通知与日历事件或日程安排相关。
Notification.CATEGORY_MESSA：表示通知是一条消息或聊天相关的通知。
Notification.CATEGORY_PROGRESS：表示通知与长时间运行的操作或进度相关。
Notification.CATEGORY_PROMO：表示通知是营销或促销相关的通知。
Notification.CATEGORY_RECOMMENDATIO：表示通知是一个推荐或建议相关的通知。
Notification.CATEGORY_SERVICE：表示通知与后台服务或系统状态相关。

发送通知例子&ensp;&ensp;这是一个简单的通知例子，调用该方法并传入Activity后，将向系统发送一个通知
public void sendNotify(Context context) &#123;    // 通知管理器    NotificationManager notificationManager = (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);    String channelId = &quot;notification&quot;;  // 通知渠道ID    String name = &quot;channel_name&quot;;       // 通知渠道名    // Android 8.0+ 需要创建通知渠道    if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;        // 创建一个新的通知渠道，并指定渠道ID、名称和重要性级别。        NotificationChannel notificationChannel = new NotificationChannel(channelId, name, NotificationManager.IMPORTANCE_DEFAULT);        // 将通知渠道与通知管理器绑定        notificationManager.createNotificationChannel(notificationChannel);    &#125;    // 创建一个启动Activity的延迟意图    PendingIntent pendingIntent;    Intent intent = new Intent(context, TeacherLoginActivity.class);    if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.S) &#123;        // Android 12+ 必须指定为PendingIntent.FLAG_IMMUTABLE或PendingIntent.FLAG_MUTABLE之一        pendingIntent = PendingIntent.getActivity(context, 10001, intent, PendingIntent.FLAG_IMMUTABLE);    &#125; else &#123;        pendingIntent = PendingIntent.getActivity(context, 10001, intent, PendingIntent.FLAG_UPDATE_CURRENT);    &#125;    // 创建通知    Notification notification = new NotificationCompat.Builder(context, channelId)            .setAutoCancel(true)            // 点击通知后自动清除            .setContentTitle(&quot;消息标题&quot;)     // 通知标题            .setContentText(&quot;消息内容&quot;)      // 通知内容            .setWhen(System.currentTimeMillis())    // 通知时间            .setSmallIcon(R.drawable.ic_launcher)   // 设置通知显示在系统状态栏的小图标            .setLargeIcon(BitmapFactory.decodeResource(context.getResources(), R.drawable.ic_launcher)) // 设置下拉状态栏后通知的图标            .setContentIntent(pendingIntent)    // 点击通知后跳转            .setPriority(NotificationCompat.PRIORITY_MAX)  // 设置重要级别            .build();    // 发送通知    int id = 1; // 确保每个通知使用唯一的通知ID    notificationManager.notify(channelId, id, notification);&#125;
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-OBD开发</title>
    <url>/2023/01/10/Android-OBD%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[OBD设备&ensp;&ensp;在此之前，从未接触OBD这个东西，蓝牙也少有接触，谨以此篇来记录一下与OBD设备通信的开发过程
申请权限&ensp;&ensp;首先在清单文件中添加蓝牙权限&lt;!-- 使用蓝牙 --&gt;&lt;uses-permission android:name=&quot;android.permission.BLUETOOTH&quot; /&gt;&lt;!-- 蓝牙管理 --&gt;&lt;uses-permission android:name=&quot;android.permission.BLUETOOTH_ADMIN&quot; /&gt;
打开蓝牙&ensp;&ensp;创建一个OBDManager类，添加一个getInstance()方法，使用单例模式获取当前类的实例public class OBDManager &#123;    private static OBDManager obdManager;    /**     * 禁止创建对象     */    private OBDManager() &#123;&#125;    /**     * 通过单例模式获取该类的实例     */    public static OBDManager getInstance() &#123;        if (obdManager == null) &#123;            obdManager = new OBDManager();        &#125;        return obdManager;    &#125;&#125;
&ensp;&ensp;添加一个init()方法，为该类提供简单的初始化private BluetoothAdapter bluetoothAdapter;  // 蓝牙适配器/** * 初始化 */public void init() &#123;    // 初始化蓝牙适配器    bluetoothAdapter = BluetoothAdapter.getDefaultAdapter();    // 还有另外一种获取蓝牙适配器的方法，不过比较麻烦    //BluetoothManager bluetoothManager = (BluetoothManager) context.getSystemService(Context.BLUETOOTH_SERVICE);    //bluetoothAdapter = bluetoothManager.getAdapter();&#125;
&ensp;&ensp;判断设备是否拥有蓝牙功能，Android模拟器是提供不了蓝牙功能的/** * 判断设备是否拥有蓝牙功能 */public boolean isHasBluetooth(Context context) &#123;    return (bluetoothAdapter != null &amp;&amp; context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_BLUETOOTH));&#125;
&ensp;&ensp;判断当前是否已经打开蓝牙，打开\关闭蓝牙/** * 判断当前是否已经打开蓝牙 */public boolean isEnableBluetooth() &#123;    return bluetoothAdapter.isEnabled();&#125;/** * 打开蓝牙，不需要手动操作 */public boolean enableBluetooth() &#123;    return bluetoothAdapter.enable();&#125;/** * 打开蓝牙，需要手动确定 */public void enableBluetooth(Activity activity) &#123;    Intent intent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE);    activity.startActivityForResult(intent, 1);&#125;/** * 关闭蓝牙，不需要手动操作 */public boolean disableBluetooth() &#123;    return bluetoothAdapter.disable();&#125;
扫描蓝牙&ensp;&ensp;在真正开始搜索蓝牙设备之前，需要先注册一个广播，在广播中接收系统搜索到的蓝牙设备，并统一添加到一个集合中，然后添加一个回调事件，用以再扫描到设备时调用/** * 注册接收蓝牙搜索结果的广播 */public void register(Context context) &#123;    IntentFilter intentFilter = new IntentFilter();    intentFilter.addAction(BluetoothDevice.ACTION_FOUND);               // 接受搜索到蓝牙设备的广播    intentFilter.addAction(BluetoothDevice.ACTION_BOND_STATE_CHANGED);  // 接受配对状态改变时的广播    context.registerReceiver(bluetoothReceiver, intentFilter);&#125;/** * 注销接收蓝牙搜索结果的广播 */public void unregister(Context context) &#123;    context.unregisterReceiver(bluetoothReceiver);&#125;// 储存搜索到的附近的蓝牙设备private final List&lt;BluetoothDevice&gt; bluetoothDeviceList = new ArrayList&lt;&gt;();/** * 获取搜索到的蓝牙设备 */public List&lt;BluetoothDevice&gt; getBluetoothDeviceList() &#123;    return bluetoothDeviceList;&#125;/** * 清空已经搜索到的所有蓝牙设备 */public void clearBluetoothDeviceList() &#123;    bluetoothDeviceList.clear();&#125;/** * 接收蓝牙搜索结果的广播，配对结果的广播 */private final BroadcastReceiver bluetoothReceiver = new BroadcastReceiver() &#123;    @Override    public void onReceive(Context context, Intent intent) &#123;        String action = intent.getAction();        if (action != null) &#123;            if (action.equals(BluetoothDevice.ACTION_FOUND)) &#123;                BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);                // 如果搜索到的设备不存在于集合中，那么添加到集合，屏蔽没有名称或者地址的蓝牙设备                if (device.getName() != null &amp;&amp; device.getAddress() != null &amp;&amp; !isExistDevice(device)) &#123;                    bluetoothDeviceList.add(device);                    // 扫描到设备时的回调                    if (onScanBluetoothDeviceListener != null) &#123;                        onScanBluetoothDeviceListener.OnScan(device);                    &#125;                &#125;            &#125; else if (action.equals(BluetoothDevice.ACTION_BOND_STATE_CHANGED)) &#123;                // 当前配对状态                int state = intent.getIntExtra(BluetoothDevice.EXTRA_BOND_STATE,BluetoothDevice.ERROR);                // 上个配对状态                int prevState = intent.getIntExtra(BluetoothDevice.EXTRA_PREVIOUS_BOND_STATE,BluetoothDeviceERROR);                // 刚刚正在配对，现在配对成功，说明配对成功                if (state == BluetoothDevice.BOND_BONDED &amp;&amp; prevState == BluetoothDevice.BOND_BONDING) &#123;                    // 配对成功                &#125;                // 刚刚没有配对，现在正在配对，说明开始配对                else if (state == BluetoothDevice.BOND_BONDING &amp;&amp; prevState == BluetoothDevice.BOND_NONE) &#123;                    // 开始配对                &#125;                // 这个直接就说明配对失败                else if (state == BluetoothDevice.BOND_NONE) &#123;                    // 配对失败                &#125;            &#125;        &#125;    &#125;    /**     * 如果集合中是否存在这个目标设备     * @param newDevice 目标设备     * @return 是否存在     */    private boolean isExistDevice(BluetoothDevice newDevice) &#123;        for (BluetoothDevice bluetoothDevice : bluetoothDeviceList) &#123;            if (bluetoothDevice.getAddress().equals(newDevice.getAddress())) &#123;                return true;            &#125;        &#125;        return false;    &#125;&#125;;// 扫描到设备时的回调private OnScanBluetoothDeviceListener onScanBluetoothDeviceListener;// 扫描到设备时的回调public interface OnScanBluetoothDeviceListener&#123;    void OnScan(BluetoothDevice bluetoothDevice);&#125;
&ensp;&ensp;开始搜索蓝牙设备，停止搜索蓝牙设备，在开始搜索蓝牙设备的方法中传入回调方法，用以在搜索到蓝牙设备时调用/** * 开始搜索附近蓝牙设备 */public synchronized void startScanBluetoothDevices(OnScanBluetoothDeviceListener onScanBluetoothDeviceListener) &#123;    // 如果蓝牙没启用，则启用蓝牙    if (!isEnableBluetooth()) &#123;        enableBluetooth();    &#125;    this.onScanBluetoothDeviceListener = onScanBluetoothDeviceListener;    // 开始搜索附近设备    bluetoothAdapter.startDiscovery();&#125;/** * 停止搜索附近蓝牙设备 */public void cancelScanBluetoothDevices() &#123;    // 如果蓝牙没有启动，就不用继续向下执行了    if (!isEnableBluetooth()) &#123;        return;    &#125;        bluetoothAdapter.cancelDiscovery();&#125;
配对蓝牙&ensp;&ensp;调用setPin()方法使系统自动输入配对码，免去用户手动输入的繁琐，调用setPairingConfirmation()方法设置是否确认当前的配对，免去用户手动点击确认配对，调用createBond()即开始进行蓝牙配对/** * 发送配对请求，进行蓝牙配对 * @param bluetoothDevice 目标设备 * @return 配对请求发送结果 */public boolean createBond(BluetoothDevice bluetoothDevice) &#123;    if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123;        return bluetoothDevice.createBond();    &#125; else &#123;        try &#123;            Method method = bluetoothDevice.getClass().getMethod(&quot;createBond&quot;);            return (boolean) method.invoke(bluetoothDevice);        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;    return false;&#125;/** * 设置为确认配对状态，可以不经过用户操作自动配对蓝牙设备，这个权限无法授权给三方应用 * @param bluetoothDevice 目标设备 * @param confirm 是否为确认状态 */public boolean setPairingConfirmation(BluetoothDevice bluetoothDevice, boolean confirm) &#123;    if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123;        return bluetoothDevice.setPairingConfirmation(confirm);    &#125; else &#123;        try &#123;            Method method = bluetoothDevice.getClass().getMethod(&quot;setPairingConfirmation&quot;, boolean.class);            return (boolean) method.invoke(bluetoothDevice, confirm);        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;    return false;&#125;/* * 设置配对码 * @param bluetoothDevice 目标设备 * @param pin 配对码 */public boolean setPin(BluetoothDevice bluetoothDevice, byte[] pin) &#123;    if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123;        return bluetoothDevice.setPin(pin);    &#125; else &#123;        try &#123;            Method method = bluetoothDevice.getClass().getMethod(&quot;setPin&quot;, byte[].class);            return (boolean)method.invoke(bluetoothDevice, new Object[]&#123;pin&#125;);        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;    return false;&#125;
&ensp;&ensp;然后写一个bondDevice()方法来调用这三个方法，注意调用顺序：setPin()、setPairingConfirmation()、createBond()，这里需要注意的是，我所开发的软件是一个拥有所有权限的系统软件，所以可以不经过用户操作自动配对蓝牙设备，正常的三方软件开发过程中，setPairingConfirmation()会发生异常，在删除该方法的调用后，系统会显示一个允许配对的对话框/** * 配对蓝牙设备 * @param bluetoothDevice 目标蓝牙设备 * @param pinCode 配对所使用的pin码 */public void bondDevice(BluetoothDevice bluetoothDevice, String pinCode) &#123;    // 配对码不为空时设置配对码    if (!TextUtils.isEmpty(pinCode)) &#123;        setPin(bluetoothDevice, pinCode.getBytes());// 设置pin码    &#125;    setPairingConfirmation(bluetoothDevice, true);  // 设置为确认配对状态    boolean bond = createBond(bluetoothDevice);     // 进行配对    if (bond) &#123;        // 配对请求发送成功    &#125; else &#123;        // 配对请求发送失败    &#125;&#125;/** * 目标蓝牙设备是否已经配对 * @param bluetoothDevice 目标设备 */public boolean isBondDevice(BluetoothDevice bluetoothDevice) &#123;    return bluetoothDevice.getBondState() == BluetoothDevice.BOND_BONDED;&#125;
连接蓝牙&ensp;&ensp;经典蓝牙的连接相当于在两个设备之间建立了socket连接，是个耗时操作，所以需要在子线程中执行/** * 经典蓝牙的连接相当于socket连接，是个耗时操作 */private class ConnectThread extends Thread &#123;    private final BluetoothSocket bluetoothSocket;    public ConnectThread(BluetoothSocket socket) &#123;        bluetoothSocket = socket;    &#125;    @Override    public void run() &#123;        super.run();        // 进行蓝牙socket连接时先取消搜索蓝牙设备        cancelScanBluetoothDevices();        try &#123;            // 建立蓝牙socket连接            bluetoothSocket.connect();        &#125; catch (IOException e) &#123;            e.printStackTrace();            // 连接失败，关闭socket连接            closeConnect();        &#125;    &#125;    /**     * 关闭socket连接     */    public void closeConnect() &#123;        if (bluetoothSocket != null) &#123;            try &#123;                bluetoothSocket.close();            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;&#125;
&ensp;&ensp;使用一个connectToDevice()方法连接设备，传入的bluetoothDevice所代表的设备一定要已经成功配对，注意这里用到的UUID，它是一个预定的建立与OBD之间的连接所需的UUID，另外注意我们要使用createRfcommSocketToServiceRecord将本机作为一个客户端建立与OBD之间的连接，因为OBD是一种蓝牙设备，是一个服务器
// OBD通常默认会使用这个UUIDprivate final UUID uuid_obd = UUID.fromString(&quot;00001101-0000-1000-8000-00805F9B34FB&quot;);private ConnectThread connectThread;    // 建立Socket连接的进程/** * 连接到蓝牙设备 * @param bluetoothDevice 目标设备 */public synchronized void connectToDevice(BluetoothDevice bluetoothDevice) &#123;    try &#123;        // 创建与蓝牙设备之间通信的socket通道        BluetoothSocket socket = bluetoothDevice.createRfcommSocketToServiceRecord(uuid_obd);        // 关闭上个连接进程        if (connectThread != null) &#123;            connectThread.closeConnect();            connectThread = null;        &#125;        // 开启一个socket连接进程，建立与蓝牙设备之间的socket连接        connectThread = new ConnectThread(socket);        connectThread.start();    &#125; catch (IOException e) &#123;        e.printStackTrace();    &#125;&#125;
蓝牙通信&ensp;&ensp;创建一个MessageThread类，在这个类中完成两个蓝牙设备之间的通信private MessageThread messageThread;    // 接收\发送消息的进程private String message;                 // 蓝牙设备发送来的消息/** * 该线程负责两个蓝牙设备之间的通信 */private class MessageThread extends Thread &#123;    private final InputStream inputStream;      // 接收消息    private final OutputStream outputStream;    // 发送消息    private boolean isReceiveMsg = false;       // 是否持续接收消息    public MessageThread (BluetoothSocket socket) &#123;        InputStream _input = null;        OutputStream _output = null;        try &#123;            _input = socket.getInputStream();            _output = socket.getOutputStream();        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;        inputStream = _input;        outputStream = _output;    &#125;    @Override    public void run() &#123;        super.run();        byte[] buffer = new byte[1024]; // 用于缓存数据的缓冲区        int numBytes;                   // 缓冲区中的字节数        isReceiveMsg = true;            // 开始接收消息        // 循环读取数据        while (isReceiveMsg) &#123;            try &#123;                numBytes = inputStream.read(buffer);                if (numBytes &gt; 0) &#123;                    message = new String(buffer, 0, numBytes);                &#125;            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;    /**     * 关闭消息通道     */    public void closeMessage() &#123;        // 不再接收消息        isReceiveMsg = false;        // 中断该线程        this.interrupt();        if (inputStream != null) &#123;            try &#123;                inputStream.close();            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;        &#125;        if (outputStream != null) &#123;            try &#123;                outputStream.flush();                outputStream.close();            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;    /**     * 发送消息给蓝牙设备     * @param bytes 消息字节流     */    public void write(byte[] bytes) &#123;        try &#123;            outputStream.write(bytes);        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;
&ensp;&ensp;在添加直接写入和读取消息的方法，方便外部调用/** * 获取蓝牙设备发送的消息 */public String getMessage() &#123;    String _message = message;    message = null;    return _message;&#125;/** * 向蓝牙设备发送消息 */public void sendMessage(String msg) &#123;    sendMessage(msg.getBytes());&#125;/** * 向蓝牙设备发送消息 */public void sendMessage(byte[] bytes) &#123;    if (messageThread != null) &#123;        messageThread.write(bytes);    &#125;&#125;
&ensp;&ensp;这样的话，在上面的建立蓝牙连接之后，就可以通过创建MessageThread对象来开启发送和接收消息，如下/** * 经典蓝牙的连接相当于socket连接，是个耗时操作 */private class ConnectThread extends Thread &#123;    private final BluetoothSocket bluetoothSocket;    public ConnectThread(BluetoothSocket socket) &#123;        bluetoothSocket = socket;    &#125;    @Override    public void run() &#123;        super.run();        // 连接前先取消搜索蓝牙设备        cancelScanBluetoothDevices();        try &#123;            // 建立连接            bluetoothSocket.connect();            // 建立通信连接            messageThread = new MessageThread(bluetoothSocket);            messageThread.start();        &#125; catch (IOException e) &#123;            e.printStackTrace();            // 连接失败，关闭连接            closeConnect();        &#125;    &#125;    /**     * 关闭socket连接     */    public void closeConnect() &#123;        if (bluetoothSocket != null) &#123;            try &#123;                bluetoothSocket.close();            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;        &#125;        if (messageThread != null) &#123;            messageThread.closeMessage();            messageThread = null;        &#125;    &#125;&#125;
其他方法&ensp;&ensp;其他经常用到的方法
/** * 获取所有已经配对的蓝牙设备的列表 */public List&lt;BluetoothDevice&gt; getBluetoothBondList() &#123;    Set&lt;BluetoothDevice&gt; bondedDevices = bluetoothAdapter.getBondedDevices();    return new ArrayList&lt;&gt;(bondedDevices);&#125;/** * 通过MAC地址获取一个蓝牙设备 * @param address MAC地址 * @return 蓝牙设备 */public BluetoothDevice getDeviceByAddress(String address) &#123;    return bluetoothAdapter.getRemoteDevice(address);&#125;
&ensp;&ensp;添加一个over()方法，用来结束一切/** * 结束所有 */public void over(Context context) &#123;    // 停止扫描设备    cancelScanBluetoothDevices();    // 注销通知    unregister(context);    // 清除已经扫描到的所有设备    clearBluetoothDeviceList();    // 清除扫描回调方法    if (onScanBluetoothDeviceListener != null) &#123;        onScanBluetoothDeviceListener = null;    &#125;    // 结束socket连接和通信    if (connectThread != null) &#123;        connectThread.closeConnect();        connectThread = null;    &#125;&#125;
使用方式&ensp;&ensp;在onCreate()方法中，先注册接收蓝牙的通知
OBDManager.getInstance().register(this);
&ensp;&ensp;在onResume()方法中，使用initBlue()方法初始化蓝牙
/** * 初始化蓝牙 */private void initBlue() &#123;    OBDManager obdManager = OBDManager.getInstance();    // 判断设备是否支持蓝牙功能    boolean hasBluetooth = obdManager.isHasBluetooth(this);    if (hasBluetooth) &#123;        // 判断蓝牙是否启用        boolean isEnableBluetooth = obdManager.isEnableBluetooth();        if (isEnableBluetooth) &#123;            // 蓝牙已启用，初始化蓝牙列表            initList();            // 开始搜索蓝牙设备            obdManager.startScanBluetoothDevices(bluetoothDevice -&gt; &#123;                // 搜索到蓝牙设备之后的回调                initList();            &#125;);        &#125; else &#123;    // 如果蓝牙未启用，则在此启用蓝牙，并使用handle在启用一秒后递归            // 正在启用蓝牙            boolean enableBluetooth = obdManager.enableBluetooth();            // 启用成功后等待一秒递归            if (enableBluetooth) &#123;                // 此处是lambda表达式                handler.postDelayed(this::initBlue, 1000);            &#125; else &#123;                // 蓝牙启用失败            &#125;        &#125;    &#125; else &#123;        // 设备不支持蓝牙功能    &#125;&#125;
&ensp;&ensp;initBlue()中调用了initList()使搜索到的附近蓝牙设备在列表中显示，点击列表item时判断这个item所代表的蓝牙设备是否配对，如果已经配对则建立通信连接，如果没有配对则显示一个输入配对码的弹窗，输入配对码后点击确定进行配对，这里注意一下，OBD设备的配对码一般是“1234”或者“0000”
private RecyclerView blue_list = findViewById(R.id.blue_list); // 蓝牙列表private BlueAdapter blueAdapter;    // RecyclerView适配器private DialogX dialogX;            // 弹窗工具/** * 初始化蓝牙列表 */private void initList() &#123;    OBDManager obdManager = OBDManager.getInstance();    if (blueAdapter != null) &#123;        blueAdapter.setData(obdManager.getBluetoothDeviceList());    &#125; else &#123;        blueAdapter = new BlueAdapter(this, obdManager.getBluetoothDeviceList());        LinearLayoutManager layoutManager = new LinearLayoutManager(this, RecyclerView.VERTICAL, false);        blue_list.setAdapter(blueAdapter);        blue_list.setLayoutManager(layoutManager);        // 这里是自建的RecyclerView的itemClick        blueAdapter.setOnRecyclerItemClick((position, bluetoothDevice) -&gt; &#123;            // 如果已经配对            if (obdManager.isBondDevice(bluetoothDevice)) &#123;                // 连接蓝牙设备                obdManager.connectToDevice(bluetoothDevice);            &#125; else &#123;                // 显示一个带有编辑框和两个按钮的输入框                dialogX = DialogXUtil.showEditTwoButtonDialog(this, &quot;请输入配对码&quot;, &quot;&quot;,                        &quot;配对码&quot;, &quot;确定&quot;, &quot;取消&quot;, InputType.TYPE_CLASS_TEXT, true,                        new DialogXUtil.OnEditDialogOnSureButtonClick() &#123;   // 点击确定按钮的事件                            @Override                            public void ClickListener(EditText dialog_edit) &#123;                                dialogX.dismiss();                                String string = dialog_edit.getText().toString();                                // 配对设备                                obdManager.bondDevice(bluetoothDevice, string);                            &#125;                        &#125;, new DialogXUtil.OnEditDialogOnCancelButtonClick() &#123;  // 点击取消按钮的事件                            @Override                            public void ClickListener(EditText dialog_edit) &#123;                                dialogX.dismiss();                            &#125;                        &#125;);            &#125;        &#125;);    &#125;&#125;
&ensp;&ensp;再添加几个按钮，调用其他方法// 打开蓝牙open_blue.setOnClickListener(view -&gt; &#123;    boolean enableBluetooth = OBDManager.getInstance().enableBluetooth();    if (enableBluetooth) &#123;        TickApplication.getInstance().speak(&quot;蓝牙启用成功&quot;);    &#125; else &#123;        TickApplication.getInstance().speak(&quot;蓝牙启用失败&quot;);    &#125;&#125;);// 关闭蓝牙close_blue.setOnClickListener(view -&gt; &#123;    boolean disableBluetooth = OBDManager.getInstance().disableBluetooth();    if (disableBluetooth) &#123;        TickApplication.getInstance().speak(&quot;蓝牙关闭成功&quot;);    &#125; else &#123;        TickApplication.getInstance().speak(&quot;蓝牙关闭失败&quot;);    &#125;&#125;);// 刷新蓝牙列表notify_blue.setOnClickListener(view -&gt; &#123;    OBDManager obdManager = OBDManager.getInstance();    // 结束    obdManager.over(this);    // 注册通知    obdManager.register(this);    // 重新初始化    initBlue();&#125;);
&ensp;&ensp;最后，在onDestory()方法中调用OBDManager类下的over()方法结束一切OBDManager.getInstance().over(this);
效果预览&ensp;&ensp;列表中第三个那一堆东西是我在验证某个蓝牙设备已经匹配之后，显示它的所有UUID，打开设置是跳转到系统设置，缺点是没有在界面中添加通信功能，代码里都有
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android开发手记</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-OkHttp</title>
    <url>/2021/09/23/Android-OkHttp/</url>
    <content><![CDATA[&ensp;&ensp;从Android4.4开始HttpURLConnection的底层实现采用OkHttp
&ensp;&ensp;同步请求：发送方发出数据后，等接收方发回响应以后才发下一个数据包的通讯方式。同步通信方式要求通信双方以相同的时钟频率进行，而且准确协调，通过共享一个单个时钟或定时脉冲源保证发送方和接收方的准确同步，效率较高。
&ensp;&ensp;异步请求：发送方发出数据后，不等接收方发回响应，接着发送下个数据包的通讯方式。异步通信方式不要求双方同步，收发方可采用各自的时钟源，双方遵循异步的通信协议，以字符为数据传输单位，发送方传送字符的时间间隔不确定，发送效率比同步传送效率低。
&ensp;&ensp;测试URL: https://www.httpbin.org/
添加依赖implementation(&quot;com.squareup.okhttp3:okhttp:4.9.0&quot;)
相关权限&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt;&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;/&gt;
同步请求get请求创建一个OkHttpClient对象作为请求器OkHttpClient okHttpClient = new OkHttpClient();
创建http请求对象、设置请求地址、得到Request的实例对象、把request实例对象交给请求器、调用call的execute方法实现同步请求//连缀方式一行带过//Request request = new Request.Builder().url(&quot;https://www.httpbin.org/get&quot;).build();//  http请求的建造器  Request.Builder builder = new Request.Builder();//  通过建造器的url方法设置请求地址，并通过build方法返回一个Request请求对象  Request request = builder.url(&quot;https://www.httpbin.org/get&quot;).build();//  把request请求对象交给请求工具okHttpClient  Call call = okHttpClient.newCall(request);//  同步请求就调用call的execute方法，execute返回一个Response对象  Response response = call.execute();
Response报错，需要进行异常捕获处理  try &#123;//      同步请求就调用call的execute方法，execute返回一个Response对象      Response response = call.execute();  &#125; catch (IOException e) &#123;      e.printStackTrace();  &#125;
执行如下代码，会闪退并报错，因为安卓中完成网络请求必须请求一个子线程//  http请求的建造器  Request.Builder builder = new Request.Builder();//  通过建造器的url方法设置请求地址，并通过build方法返回一个Request请求对象  Request request = builder.url(&quot;https://www.httpbin.org/get&quot;).build();//  把request请求对象交给请求工具okHttpClient  Call call = okHttpClient.newCall(request);  try &#123;//      同步请求就调用call的execute方法，execute返回一个Response对象//      完成请求后得到的响应封装在Response对象中      Response response = call.execute();//      得到response的请求体，并得到其中的字符串数据      String str = response.body().string();//      设置显示      code.setText(str);  &#125; catch (IOException e) &#123;      e.printStackTrace();  &#125;
创建一个子线程//  创建一个新线程  new Thread()&#123;      @Override      public void run() &#123;          super.run();      &#125;  &#125;.start();
在线程中完成get请求//  创建一个新线程  new Thread()&#123;      @Override//      继承run方法，填入线程中执行的事件      public void run() &#123;//          http请求的建造器          Request.Builder builder = new Request.Builder();//          通过建造器的url方法设置请求地址，并通过build方法返回一个Request请求对象          Request request = builder.url(&quot;https://www.httpbin.org/get&quot;).build();//          把request请求对象交给请求工具okHttpClient          Call call = okHttpClient.newCall(request);          try &#123;//              同步请求就调用call的execute方法，execute返回一个Response对象//              完成请求后得到的响应封装在Response对象中              Response response = call.execute();//              得到response的请求体，并得到其中的字符串数据              String str = response.body().string();//              子线程中更新UI              runOnUiThread(new Runnable() &#123;                  @Override                  public void run() &#123;//                      设置请求的数据显示在text                      code.setText(str);                  &#125;              &#125;);          &#125; catch (IOException e) &#123;              e.printStackTrace();          &#125;      &#125;  &#125;.start();
post请求同步post请求与同步get请求几乎一样，多了post数据而已//  创建FormBody表单提交对象  FormBody formBody = new FormBody.Builder().add(&quot;a&quot;,&quot;1&quot;).add(&quot;b&quot;,&quot;2&quot;).build();//  创建post方式的请求对象,并把表单对象提交  Request request1 = new Request.Builder().url(&quot;https://www.lxx6.com&quot;).post(formBody).build();
完整代码  new Thread()&#123;      @Override      public void run() &#123;//          创建FormBody表单提交对象          FormBody formBody = new FormBody.Builder().add(&quot;a&quot;,&quot;1&quot;).add(&quot;b&quot;,&quot;2&quot;).build();//          创建post方式的请求对象,并把表单对象提交          Request request1 = new Request.Builder().url(&quot;https://www.lxx6.com&quot;).post(formBody).build();//          其余同get请求          Call call1 = okHttpClient.newCall(request1);          try &#123;              Response response = call1.execute();              String str = response.body().string();              runOnUiThread(new Runnable() &#123;                  @Override                  public void run() &#123;                      code.setText(str);                  &#125;              &#125;);          &#125; catch (IOException e) &#123;              e.printStackTrace();          &#125;      &#125;  &#125;.start();
异步请求get请求创建一个OkHttpClient对象作为请求器OkHttpClient okHttpClient = new OkHttpClient();
创建请求对象//  创建请求对象  Request request = new Request.Builder().url(&quot;https://blog.xxin.xyz&quot;).build();//  把请求对象提交给请求器发送请求  Call call = okHttpClient.newCall(request);
这里call调用enqueue()方法,不再是execute()//  这里call调用enqueue()方法,不再是execute()//  enqueue方法需要传入一个CallBack回调函数  call.enqueue(new Callback() &#123;      @Override//      当请求失败时调用onFailure      public void onFailure(@NotNull Call call, @NotNull IOException e) &#123;//          创建一个ui修改线程          runOnUiThread(new Runnable() &#123;              @Override              public void run() &#123;                  code.setText(&quot;请求失败&quot;);              &#125;          &#125;);      &#125;      @Override//      当请求结束时调用onResponse,请求结束并不代表请求成功,完成请求后得到的响应封装在Response对象中      public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException &#123;//          调用Response类的isSuccessful()方法判断是否请求成功//          打开isSuccessful()源码可知当请求码在200-299之间时请求成功          if (response.isSuccessful())&#123;//              得到response的请求体，并得到其中的字符串数据              String str = response.body().string();//              创建一个ui修改线程              runOnUiThread(new Runnable() &#123;                  @Override                  public void run() &#123;                      code.setText(str);                  &#125;              &#125;);          &#125;      &#125;  &#125;);
注意： 

异步请求不会阻塞后续代码的执行。
异步请求不需要创建新线程，创建enqueue时已经创建了新的线程

post请求异步post与异步get几乎相同，唯多了post数据而已//  创建FormBody表单提交对象  FormBody formBody = new FormBody.Builder().add(&quot;a&quot;,&quot;1&quot;).add(&quot;b&quot;,&quot;2&quot;).build();//  创建post方式的请求对象,并把表单对象提交  Request request1 = new Request.Builder().url(&quot;https://www.amyxiaoxin.top&quot;).post(formBody).build();
这里call调用enqueue()方法  Call call1 = okHttpClient.newCall(request1);  call1.enqueue(new Callback() &#123;      @Override//      请求失败时      public void onFailure(@NotNull Call call, @NotNull IOException e) &#123;          runOnUiThread(new Runnable() &#123;              @Override              public void run() &#123;                  code.setText(&quot;请求失败&quot;);              &#125;          &#125;);      &#125;      @Override//      请求结束时      public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException &#123;          if (response.isSuccessful())&#123;              String str = response.body().string();              runOnUiThread(new Runnable() &#123;                  @Override                  public void run() &#123;                      code.setText(str);                  &#125;              &#125;);          &#125;      &#125;  &#125;);
post上传文件协议规定POST提交的数据必须放在请求体中，但协议并没有规定数据必须使用什么编码方式
常用的编码方式有

Content-Type: application/x-www-form-urlencoded;数据被编码为“名称/键值对”，默认类型(FormBody就是这种类型)
Content-Type: multipart/from-date;数据编码为一条消息，一般用于文件上传
Content-Type: application/octet-stream;提交二进制数据，如果用于文件上传，只能上传一个文件
Content-Type: application/json;提交json数据

&ensp;&ensp;数据编码方式对照表
多文件上传用multipart/from-date编码方式实现多文件上传  new Thread()&#123;      @Override      public void run() &#123;//          设置文件路径          String File1Path = &quot;/storage/emulated/0/MT2/apks/temp/file1.txt&quot;;          String File2Path = &quot;/storage/emulated/0/MT2/apks/temp/file2.txt&quot;;//          获取路径下文件的对象          File file1 = new File(File1Path);          File file2 = new File(File2Path);//          创建请求体          RequestBody requestBody1 = RequestBody.create(file1, MediaType.parse(&quot;text/plain&quot;));//文件，文件类型,文件对象          RequestBody requestBody2 = RequestBody.create(file2, MediaType.parse(&quot;text/plain&quot;));//文件，文件类型,文件对象//          通过multipart方式进行多文件上传,所以创建MultipartBody          MultipartBody multipartBody = new MultipartBody.Builder()                  .addFormDataPart(&quot;file1&quot;,file1.getName(),requestBody1)//文件key值,文件名                  .addFormDataPart(&quot;file2&quot;,file2.getName(),requestBody2)//文件key值,文件名                  .build();//          创建请求对象          Request request = new Request.Builder().url(&quot;https://www.httpbin.org/post&quot;).post(multipartBody).build();//          用请求器发起请求          Call call = okHttpClient.newCall(request);          try &#123;              Response execute = call.execute();              String str = execute.body().string();              runOnUiThread(new Runnable() &#123;                  @Override                  public void run() &#123;                      code.setText(str);                  &#125;              &#125;);          &#125; catch (IOException e) &#123;              e.printStackTrace();          &#125;      &#125;  &#125;.start();
二进制流上传文件不知道文件类型，使用application/octet-stream二进制流上传文件  new Thread()&#123;      @Override      public void run() &#123;//         设置文件路径          String FilePath = &quot;/storage/emulated/0/MT2/apks/temp/img.png&quot;;//         得到文件对象          File file = new File(FilePath);//          创建请求体          RequestBody requestBody = RequestBody.create(file,MediaType.parse(&quot;application/x-png&quot;));//          创建请求对象          Request request = new Request.Builder().url(&quot;https://www.httpbin.org/post&quot;).post(requestBody).build();          Call call = okHttpClient.newCall(request);          try &#123;              Response execute = call.execute();              String str = execute.body().string();              runOnUiThread(new Runnable() &#123;                  @Override                  public void run() &#123;                      code.setText(str);                  &#125;              &#125;);          &#125; catch (IOException e) &#123;              e.printStackTrace();          &#125;      &#125;  &#125;.start();
提交json数据  new Thread()&#123;      @Override      public void run() &#123;//          创建json数据          String json = &quot;&#123;\&quot;a\&quot;:2,\&quot;b\&quot;:2&#125;&quot;;//          创建请求体          RequestBody requestBody = RequestBody.create(json,MediaType.parse(&quot;application/json&quot;));//          创建请求对象          Request request = new Request.Builder().url(&quot;https://www.httpbin.org/post&quot;).post(requestBody).build();//          用请求器发起请求          Call call = okHttpClient.newCall(request);          try &#123;              Response execute = call.execute();              String str = execute.body().string();              runOnUiThread(new Runnable() &#123;                  @Override                  public void run() &#123;                      code.setText(str);                  &#125;              &#125;);          &#125; catch (IOException e) &#123;              e.printStackTrace();          &#125;      &#125;  &#125;.start();
get下载文件OkHttp简单的文件下载  Request request = new Request.Builder().url(&quot;https://www.httpbin.org/image/png&quot;).build();  okHttpClient.newCall(request).enqueue(new Callback() &#123;      @Override      public void onFailure(@NotNull Call call, @NotNull IOException e) &#123;          runOnUiThread(new Runnable() &#123;              @Override              public void run() &#123;                  code.setText(&quot;下载失败&quot;);              &#125;          &#125;);      &#125;      @Override      public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException &#123;          if (response.isSuccessful()) &#123;//              用输入流接收response中的字节流并解码              InputStream inputStream = response.body().byteStream();//              用输出流，把接收的数据写入本地文件              FileOutputStream fileOutputStream = null;//              文件储存地址              String filePath = &quot;/storage/emulated/0/MT2/apks/temp/download.png&quot;;              File file = new File(filePath);//创建文件对象//              写入到本地              fileOutputStream = new FileOutputStream(file);              byte[] bytes = new byte[1024];//字节长度              int len = 0;//              获取下载文件大小              long fileSize = response.body().contentLength();              long sum = 0;//计算下载进度值              while ((len = inputStream.read(bytes)) != -1) &#123;                  fileOutputStream.write(bytes,0,len);//                  得到进度值                  sum += len;                  Log.d(TAG, &quot;进度: &quot; + (int) ((sum * 1.0f / fileSize) * 100) + &quot;%&quot;);              &#125;          &#125;      &#125;  &#125;);
拦截器addInterceptor（应用拦截器，先执行）:

不需要担心中间过程的响应,如重定向和重试
总是只调用一次,即使HTTP响应是从缓存中获取
观察应用程序的初衷. 不关心OkHttp注入的头信息如: If-None-Match
允许短路而不调用 Chain.proceed(),即中止调用
允许重试,使 Chain.proceed()调用多

addNetworkInterceptor（网络拦截器，后执行）:

能够操作中间过程的响应,如重定向和重试
当网络短路而返回缓存响应时不被调用
只观察在网络上传输的数据
携带请求来访问连接

addInterceptor（应用拦截器）可以添加很多个，执行顺序与添加顺序相同（但总会比addNetworkInterceptor先执行）
&ensp;&ensp;在请求器发送请求前会执行一次Interceptor拦截器的intercept方法，intercept方法内可以通过chain请求对象request，对请求对象进行发送请求前置操作，例如添加响应头等，然后通过chain.proceed(request)获得到处理之后的最终的响应信息并返回出去，这样就省下了在拦截器外重复添加响应头的繁琐  OkHttpClient okHttpClient = new OkHttpClient.Builder()          .addInterceptor(new Interceptor() &#123;      @NotNull      @Override//      在请求器发送请求前会执行一次Interceptor拦截器的intercept方法      public Response intercept(@NotNull Chain chain) throws IOException &#123;//          通过chain可以得到请求对象request          Request request = chain.request();//          对请求对象处理          Request request1 = request.newBuilder()                  .addHeader(&quot;os&quot;,&quot;andrroid&quot;)//添加响应头                  .addHeader(&quot;version&quot;,&quot;1.0&quot;)//添加响应头                  .build();//          获得到处理之后的最终的响应信息并返回出去          Response response = chain.proceed(request1);          return response;      &#125;  &#125;)//添加addInterceptor拦截器          .build();//  创建请求对象发起请求  new Thread()&#123;      @Override      public void run() &#123;          Request request = new Request.Builder().url(&quot;https://www.httpbin.org/get&quot;).build();          Call call = okHttpClient.newCall(request);          try &#123;              Response response = call.execute();              String str = response.body().string();              Log.d(TAG, &quot;addInterceptor: &quot; + str);              runOnUiThread(new Runnable() &#123;                  @Override                  public void run() &#123;                      code.setText(str);                  &#125;              &#125;);          &#125; catch (IOException e) &#123;              e.printStackTrace();          &#125;      &#125;  &#125;.start();
可见应用拦截器添加的响应头
addNetworkInterceptor（网络拦截器）addNetworkInterceptor总会比addInterceptor后执行，所以它可以读取addNetworkInterceptor中添加的信息  OkHttpClient okHttpClient = new OkHttpClient.Builder()          .addNetworkInterceptor(new Interceptor() &#123;              @NotNull              @Override              public Response intercept(@NotNull Chain chain) throws IOException &#123;//                  通过chain可以得到请求对象request                  Request request = chain.request();//                  对请求对象处理                  Request request1 = request.newBuilder()                          .addHeader(&quot;os&quot;,&quot;android&quot;)//添加响应头                          .addHeader(&quot;version&quot;,&quot;1.0&quot;)//添加响应头                          .build();                  Response response = chain.proceed(request1);                  return response;              &#125;          &#125;)//添加addNetwork拦截器          .build();//  创建请求对象发起请求  new Thread()&#123;      @Override      public void run() &#123;          Request request = new Request.Builder().url(&quot;https://www.httpbin.org/get&quot;).build();          Call call = okHttpClient.newCall(request);          try &#123;              Response response = call.execute();              String str = response.body().string();              Log.d(TAG, &quot;addInterceptor: &quot; + str);              runOnUiThread(new Runnable() &#123;                  @Override                  public void run() &#123;                      code.setText(str);                  &#125;              &#125;);          &#125; catch (IOException e) &#123;              e.printStackTrace();          &#125;      &#125;  &#125;.start();
OkHttp的缓存添加缓存后okHttpClient会自动判断是否可以使用缓存并且自动保存缓存  OkHttpClient okHttpClient = new OkHttpClient.Builder()//          添加请求缓存，参数：缓存保存路径，缓存文件最大占用(超过大小新缓存会自动替换旧缓存)          .cache(new Cache(new File(&quot;/storage/emulated/0/MT2/apks/temp/temp&quot;),1024*1024))          .build();//  创建请求对象发起请求  new Thread()&#123;      @Override      public void run() &#123;          Request request = new Request.Builder().url(&quot;https://www.httpbin.org/get&quot;).build();          Call call = okHttpClient.newCall(request);          try &#123;              Response response = call.execute();              String str = response.body().string();              Log.d(TAG, &quot;addInterceptor: &quot; + str);              runOnUiThread(new Runnable() &#123;                  @Override                  public void run() &#123;                      code.setText(str);                  &#125;              &#125;);          &#125; catch (IOException e) &#123;              e.printStackTrace();          &#125;      &#125;  &#125;.start();
拓展：try/catch异常抛出与捕获try &#123;//    可能出现异常的代码&#125; catch（异常类名A e）&#123;//    如果出现了异常类A类型的异常，那么执行该代码&#125;//...（catch可以有多个）finally &#123;//    最终肯定必须要执行的代码（例如释放资源的代码）&#125;
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android插件</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-ProgressBar</title>
    <url>/2021/09/09/Android-ProgressBar/</url>
    <content><![CDATA[圆环进度条&ensp;&ensp;如果不给ProgressBar添加style，其创建之初就是一个环形的进度条&lt;ProgressBar    android:layout_width=&quot;wrap_content&quot;    android:layout_height=&quot;wrap_content&quot;/&gt;
横向进度条&ensp;&ensp;添加一个style属性&lt;ProgressBar    android:max=&quot;100&quot;    android:progress=&quot;10&quot;    style=&quot;@style/Widget.AppCompat.ProgressBar.Horizontal&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;wrap_content&quot;/&gt;
&ensp;&ensp;常用属性

max: 进度条的最大值
progress: 进度条已完成进度值
indeterminate: 如果设置成true，则进度条不精确显示进度

&ensp;&ensp;在程序中，可以通过设置其progress值来改变进度条进度// 目标进度int progressValue = 100;    // 绑定idProgressBar progressBar = findViewById(R.id.progress);// 设置进度条Handler handler = new Handler(Looper.myLooper()) &#123;    @Override    public void handleMessage(@NonNull Message msg) &#123;        super.handleMessage(msg);        if (msg.what == 0) &#123;            progressBar.setProgress(msg.arg1);        &#125;    &#125;&#125;;// 每隔0.1秒发送一次消息new Thread(new Runnable() &#123;    @Override    public void run() &#123;        for (int i = 1; i &lt;= progressValue; i++) &#123;            Message message = Message.obtain();            message.what = 0;            message.arg1 = i;            handler.sendMessage(message);            try &#123;                Thread.sleep(100);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;&#125;).start();
&ensp;&ensp;效果如下
进度不明确的横向进度条&ensp;&ensp;在横向进度条的基础上添加一个indeterminate属性，并设为true&lt;ProgressBar    android:indeterminate=&quot;true&quot;    style=&quot;@style/Widget.AppCompat.ProgressBar.Horizontal&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;wrap_content&quot;/&gt;

]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-Receiver</title>
    <url>/2021/09/23/Android-Receiver/</url>
    <content><![CDATA[静态注册广播①静态注册广播接收者创建一个MyReceiver类作为广播接收者public class MyReceiver&#123;    &#125;
该类继承自BroadcastReceiver，并重写了onReceive方法import android.content.BroadcastReceiver;import android.content.Context;import android.content.Intent;import android.widget.Toast;//广播接收者public class MyReceiver extends BroadcastReceiver &#123;    @Override//    MyReceiver接收广播后，会调用onReceive方法    public void onReceive(Context context, Intent intent) &#123;//        接收intent中的消息        String msg = intent.getStringExtra(&quot;message&quot;);        Toast.makeText(context,msg,Toast.LENGTH_SHORT).show();    &#125;&#125;
在清单文件的application中注册广播接收类&lt;!--    注册广播接收类--&gt;    &lt;receiver android:name=&quot;.MyReceiver&quot;/&gt;
清单文件中注册后，需要给它一个标记，通过这个标记找到广播接收类&lt;!--    注册广播接收类--&gt;    &lt;receiver android:name=&quot;.MyReceiver&quot;&gt;        &lt;intent-filter&gt;&lt;!--            标记可以任意填写--&gt;            &lt;action android:name=&quot;com.test.myReceiver&quot;/&gt;        &lt;/intent-filter&gt;    &lt;/receiver&gt;
②发送广播给接收者在事件中//  创建意图  Intent intent = new Intent();//  传入的action要和注册的广播接收类中的action保持一致  intent.setAction(&quot;com.test.myReceiver&quot;);//  发送消息  intent.putExtra(&quot;message&quot;,&quot;MainActivity发送的消息&quot;);//  在Android8.0以上，需要设置setComponent()传入ComponentName对象，ComponentName对象需要设置广播接收者所在的包名和广播接收者的完整类名  intent.setComponent(new ComponentName(getPackageName(),getPackageName().toString()+&quot;.MyReceiver&quot;));//  发送广播  sendBroadcast(intent);
注意：在Android8.0以上，静态广播必须设置广播接收者所在的包名和广播接收者的完整类名//  创建ComponentName对象，传入广播接收者所在的包名、广播接收者的完整类名  ComponentName componentName = new ComponentName(getPackageName(),getPackageName()+&quot;.MyReceiver&quot;);//  设置Component  intent.setComponent(componentName);
动态注册广播①动态注册广播接收者创建一个MyReceiver类作为广播接收者public class MyReceiver&#123;    &#125;
该类继承自BroadcastReceiver，并重写了onReceive方法import android.content.BroadcastReceiver;import android.content.Context;import android.content.Intent;import android.widget.Toast;//广播接收者public class MyReceiver extends BroadcastReceiver &#123;    @Override//    MyReceiver接收广播后，会调用onReceive方法    public void onReceive(Context context, Intent intent) &#123;//        接收intent中的消息        String msg = intent.getStringExtra(&quot;message&quot;);        Toast.makeText(context,msg,Toast.LENGTH_SHORT).show();    &#125;&#125;
动态注册广播接收类//  使用广播接收类创建对象  MyReceiver myReceiver = new MyReceiver();//  创建intentFilter  IntentFilter intentFilter = new IntentFilter();//  给intentFilter添加Action  intentFilter.addAction(&quot;com.test.myReceiver&quot;);//  注册Receiver  registerReceiver(myReceiver,intentFilter);
②发送广播给接收者在事件中//  创建意图  Intent intent = new Intent();//  发送消息  intent.putExtra(&quot;message&quot;,&quot;MainActivity发送的消息&quot;);//  设置Action  intent.setAction(&quot;com.test.myReceiver&quot;);//  发送广播  sendBroadcast(intent);
注意：动态注册广播一定不要设置setComponent()
发送广播的方式①sendBroadcast所有满足条件的广播接收者都会执行其onReceive()方法来处理响应，当有多个满足条件的广播接收者时，不能保证它们onReceive()的执行顺序
②sendStickyBroadcastintent在发送后一直存在，并且在以后调用registerReceiver注册相匹配的Receive时会把这个intent直接返回给新注册的Receive
通俗讲：先动态注册再发送广播，或者先发送广播再动态注册，intent都可以被接收器接收到并执行其onReceive方法。
不过需要在manifest.xml文件中配置此类型广播权限&lt;uses-permissionandroid:name=&quot;android.permission.BROADCAST_STICKY&quot;/&gt;
③sendOrderBroadcast通过sendOrderBroadcast发送广播，当有多个满足条件的广播接收者，会根据广播接收者注册时intentFilter设置的优先级顺序来执行onReceive()方法，对于相同优先级的广播接收者则不能保证onReceive()的执行顺序
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-RecyclerView</title>
    <url>/2021/09/11/Android-RecyclerView/</url>
    <content><![CDATA[资源文件下载
添加依赖首先在build.gradle的dependencies中添加依赖，然后sync now一下//    添加Recyclerview依赖包    implementation &#x27;androidx.recyclerview:recyclerview:1.1.0&#x27;
RecyclerView构建1.创建RecyclerView布局(activity_main.xml)&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout android:layout_height=&quot;match_parent&quot;    android:layout_width=&quot;match_parent&quot;    android:orientation=&quot;vertical&quot;    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;    &lt;LinearLayout        android:layout_width=&quot;match_parent&quot;        android:orientation=&quot;horizontal&quot;        android:gravity=&quot;center_vertical&quot;        android:background=&quot;#336666&quot;        android:layout_height=&quot;80dp&quot;&gt;        &lt;TextView            android:layout_width=&quot;wrap_content&quot;            android:layout_height=&quot;wrap_content&quot;            android:text=&quot;TITLE&quot;            android:textColor=&quot;@color/white&quot;            android:layout_marginLeft=&quot;20dp&quot;            android:id=&quot;@+id/listTitle&quot;            android:textStyle=&quot;bold&quot;            android:textSize=&quot;20sp&quot;/&gt;    &lt;/LinearLayout&gt;    &lt;androidx.recyclerview.widget.RecyclerView        android:layout_width=&quot;match_parent&quot;        android:id=&quot;@+id/recycler&quot;        android:layout_height=&quot;match_parent&quot;/&gt;&lt;/LinearLayout&gt;
2.创建列表项的布局(item.xml)&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout android:layout_height=&quot;match_parent&quot;    android:layout_width=&quot;match_parent&quot;    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;    &lt;LinearLayout        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;100dp&quot;        android:gravity=&quot;center_vertical&quot;        android:orientation=&quot;horizontal&quot;        android:background=&quot;#009966&quot;&gt;&lt;!--        这里添加了一张默认图--&gt;        &lt;ImageView            android:layout_width=&quot;80dp&quot;            android:layout_height=&quot;80dp&quot;            android:id=&quot;@+id/foodIcon&quot;            android:src=&quot;@mipmap/moren&quot;            android:layout_marginLeft=&quot;10dp&quot;/&gt;        &lt;TextView            android:layout_width=&quot;wrap_content&quot;            android:layout_height=&quot;wrap_content&quot;            android:layout_marginLeft=&quot;20dp&quot;            android:text=&quot;NAME&quot;            android:textStyle=&quot;bold&quot;            android:id=&quot;@+id/foodName&quot;            android:textColor=&quot;@color/white&quot;            android:textSize=&quot;20sp&quot;/&gt;    &lt;/LinearLayout&gt;&lt;/LinearLayout&gt;
3.创建RecycleView的适配器(MyAdapter)import android.content.Context;import android.view.View;import android.view.ViewGroup;import android.widget.ImageView;import android.widget.TextView;import androidx.annotation.NonNull;import androidx.recyclerview.widget.RecyclerView;//MyAdapter继承自RecyclerView.Adapter并强制创建ViewHolder类进行优化public class MyAdapter extends RecyclerView.Adapter&lt;MyAdapter.MyViewHolder&gt; &#123;    private String[] foodName;    private int[] foodIcon;    private Context context;//    手动创建一个构造器，用于被外部调用时接收参数    public MyAdapter(String[] foodName,int[] foodIcon,Context context)&#123;        this.foodName = foodName;        this.foodIcon = foodIcon;        this.context = context;    &#125;    @NonNull    @Override//    创建ViewHolder    public MyViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) &#123;//        获取到布局文件，并通过MyViewHolder的构造器传递至MyViewHolder中        View view = View.inflate(context,R.layout.item,null);        MyViewHolder myViewHolder = new MyViewHolder(view);        return myViewHolder;    &#125;    @Override//    事件绑定    public void onBindViewHolder(@NonNull MyViewHolder holder, int position) &#123;        holder.foodName.setText(foodName[position]);        holder.foodIcon.setImageResource(foodIcon[position]);    &#125;//    定义item列表的总数    @Override    public int getItemCount() &#123;        return foodIcon.length;    &#125;//    MyViewHolder继承自RecyclerView的ViewHolder//    对RecyclerView.ViewHolder进行封装//    使MyAdapter使用ViewHolder优化    public class MyViewHolder extends RecyclerView.ViewHolder &#123;//        将item.xml布局文件中用到的控件定义在这里先        private TextView foodName;        private ImageView foodIcon;//        这里的itemView即为onCreateViewHolder传入的布局文件item.xml        public MyViewHolder(@NonNull View itemView) &#123;            super(itemView);//            获取到item.xml中的组件            foodIcon = itemView.findViewById(R.id.foodIcon);            foodName = itemView.findViewById(R.id.foodName);        &#125;    &#125;&#125;
4.在MainActivity中对ListView进行应用import androidx.appcompat.app.AppCompatActivity;import androidx.recyclerview.widget.GridLayoutManager;import androidx.recyclerview.widget.RecyclerView;import android.os.Bundle;public class MainActivity extends AppCompatActivity &#123;    private int[] foodIcon = new int[]&#123;            R.mipmap.dangao,R.mipmap.cha,R.mipmap.hanbao,R.mipmap.jitui,R.mipmap.kafei,R.mipmap.kaixinguo,R.mipmap.lanmei,            R.mipmap.ningmeng,R.mipmap.niupai,R.mipmap.pijiu,R.mipmap.pisa,R.mipmap.qiyiguo,R.mipmap.regou,R.mipmap.sanmingzhi,            R.mipmap.shengnvguo,R.mipmap.shutiao,R.mipmap.tusi,R.mipmap.yimian,R.mipmap.yingtao,R.mipmap.zhangyuxiaowanzi    &#125;;    private String[] foodName = new String[]&#123;            &quot;蛋糕&quot;,&quot;茶&quot;,&quot;汉堡&quot;,&quot;鸡腿&quot;,&quot;咖啡&quot;,&quot;开心果&quot;,&quot;蓝莓&quot;,&quot;柠檬&quot;,&quot;牛排&quot;,&quot;啤酒&quot;,&quot;披萨&quot;,&quot;奇异果&quot;,&quot;热狗&quot;,&quot;三明治&quot;,&quot;圣女果&quot;,&quot;薯条&quot;,&quot;吐司&quot;,&quot;意面&quot;,&quot;樱桃&quot;,&quot;章鱼小丸子&quot;    &#125;;    private RecyclerView recycler;	private TextView listTitle;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        recycler = findViewById(R.id.recycler);        listTitle = findViewById(R.id.listTitle);//        定义RecyclerView的item的布局//        两个参数：上下文、列数        GridLayoutManager gridLayoutManager = new GridLayoutManager(this,2);//        三个参数：上下文、布局方向、是否倒排序        LinearLayoutManager layoutManager = new LinearLayoutManager(this,RecyclerView.VERTICAL,false);//        瀑布流；两个参数：列数、布局方向        StaggeredGridLayoutManager staggeredGridLayoutManager = new StaggeredGridLayoutManager(2,StaggeredGridLayoutManager.VERTICAL);//        设置布局        recycler.setLayoutManager(staggeredGridLayoutManager);//        在MyAdapter中对列表进行配置        MyAdapter myAdapter = new MyAdapter(foodName,foodIcon,this);//        将列表设置到recycler        recycler.setAdapter(myAdapter);    &#125;&#125;
自定义itemOnClickRecyclerView没有像ListView一样提供监听事件所以要自己创建一个setOnRecyclerItemClickListener比较繁琐，他🐎的
1.在MyAdapter类中创建一个setOnRecyclerItemClickListener方法供外部调用//    首先创建一个setOnRecyclerItemClickListener供外部调用//    他需要传入一个重写后的OnRecyclerItemListener对象    public void setOnRecyclerItemClickListener(OnRecyclerItemListener onRecyclerItemClickListener)&#123;//        把传入的OnRecyclerItemListener对象赋值给实例变量中的OnRecyclerItemListener,以此供其他方法调用        this.onRecyclerItemListener = onRecyclerItemClickListener;    &#125;
2.定义一个接口供setOnRecyclerItemClickListener定义形参使当外部调用setOnRecyclerItemClickListener时必须使用该接口创建对象
//    定义一个接口供setOnRecyclerItemClickListener定义形参,//    使当外部调用setOnRecyclerItemClickListener时必须使用该接口创建对象//    item执行的事件就在重写后的OnRecyclerItemClick方法中写入    public interface OnRecyclerItemListener&#123;        void OnRecyclerItemClick(int position);    &#125;
3.使用接口定义一个实例变量用于将重写后的OnRecyclerItemListener对象储存于此,供其他方法调用//    使用接口定义一实例变量,用于将重写后的OnRecyclerItemListener对象储存于此,供其他方法调用    private OnRecyclerItemListener onRecyclerItemListener;
4.在MyAdapter内部类MyViewHolder类的构造器中通过itemView设置监听//    给item.xml布局文件添加OnCLick    itemView.setOnClickListener(new View.OnClickListener() &#123;        @Override        public void onClick(View v) &#123;//            实例变量OnRecyclerItemListener不为空说明setOnRecyclerItemClickListener被调用            if (onRecyclerItemListener != null)&#123;//                那么执行OnRecyclerItemListener被重写后的OnRecyclerItemClick方法//                并把点击item.xml的position值传入，使其可以定位点击的item.xml在RecyclerView中的位置                onRecyclerItemListener.OnRecyclerItemClick(getAdapterPosition());            &#125;        &#125;    &#125;);
5.MyAdapter.java完成后import android.content.Context;import android.view.View;import android.view.ViewGroup;import android.widget.ImageView;import android.widget.TextView;import androidx.annotation.NonNull;import androidx.recyclerview.widget.RecyclerView;//MyAdapter继承自RecyclerView.Adapter并强制创建ViewHolder类进行优化public class MyAdapter extends RecyclerView.Adapter&lt;MyAdapter.MyViewHolder&gt; &#123;    private String[] foodName;    private int[] foodIcon;    private Context context;//    手动创建一个构造器，用于被外部调用时接收参数    public MyAdapter(String[] foodName,int[] foodIcon,Context context)&#123;        this.foodName = foodName;        this.foodIcon = foodIcon;        this.context = context;    &#125;    @NonNull    @Override//    创建ViewHolder    public MyViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) &#123;//        获取到布局文件，并通过MyViewHolder的构造器传递至MyViewHolder中        View view = View.inflate(context,R.layout.item,null);        MyViewHolder myViewHolder = new MyViewHolder(view);        return myViewHolder;    &#125;    @Override//    事件绑定    public void onBindViewHolder(@NonNull MyViewHolder holder, int position) &#123;        holder.foodName.setText(foodName[position]);        holder.foodIcon.setImageResource(foodIcon[position]);    &#125;//    item总数    @Override    public int getItemCount() &#123;        return foodIcon.length;    &#125;//    MyViewHolder继承自RecyclerView的ViewHolder，使MyAdapter强制使用ViewHolder优化    public class MyViewHolder extends RecyclerView.ViewHolder &#123;//        将item.xml布局文件中用到的控件定义在这里先        private TextView foodName;        private ImageView foodIcon;//        这里的itemView即为onCreateViewHolder传入的布局文件item.xml        public MyViewHolder(@NonNull View itemView) &#123;            super(itemView);//            获取到item.xml中的组件            foodIcon = itemView.findViewById(R.id.foodIcon);            foodName = itemView.findViewById(R.id.foodName);//            给item.xml布局文件添加OnCLick            itemView.setOnClickListener(new View.OnClickListener() &#123;                @Override                public void onClick(View v) &#123;//                    实例变量OnRecyclerItemListener不为空说明setOnRecyclerItemClickListener被调用                    if (onRecyclerItemListener != null)&#123;//                        那么执行OnRecyclerItemListener被重写后的OnRecyclerItemClick方法//                        并把点击item.xml的position值传入                        onRecyclerItemListener.OnRecyclerItemClick(getAdapterPosition());                    &#125;                &#125;            &#125;);        &#125;    &#125;//    首先创建一个setOnRecyclerItemClickListener供外部调用//    他需要传入一个重写后的OnRecyclerItemListener    public void setOnRecyclerItemClickListener(OnRecyclerItemListener onRecyclerItemClickListener)&#123;//        把传入的OnRecyclerItemListener对象赋值给实例变量中的OnRecyclerItemListener,以此供其他方法调用        this.onRecyclerItemListener = onRecyclerItemClickListener;    &#125;//    定义一个接口供setOnRecyclerItemClickListener定义形参,//    使当外部调用setOnRecyclerItemClickListener时必须实现接口//    item执行的事件就在重写后的OnRecyclerItemClick方法中写入    public interface OnRecyclerItemListener&#123;        void OnRecyclerItemClick(int position);    &#125;//    使用接口定义一个类变量,用于被重写后的OnRecyclerItemListener赋值,供其他方法调用    private OnRecyclerItemListener onRecyclerItemListener;&#125;
6.在MainActivity.java中调用//    setOnRecyclerItemClickListener需要一个OnRecyclerItemListener接口类型参数,实现这个接口需要重写它的方法    myAdapter.setOnRecyclerItemClickListener(new MyAdapter.OnRecyclerItemListener() &#123;        @Override//        重写了接口的所有方法,它只有一个OnRecyclerItemClick//        这里并不执行OnRecyclerItemClick,不过是重写它并把它作为参数给予setOnRecyclerItemClickListener        public void OnRecyclerItemClick(int position) &#123;//            设置item的事件            listTitle.setText(foodName[position]);        &#125;    &#125;);
源代码给item传入了AlertDialog对话框事件，源代码下载


写的什么🐓8玩意
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-Service</title>
    <url>/2021/09/21/Android-Service/</url>
    <content><![CDATA[Service是Android中实现程序后台运行的解决方案，适用于去执行那些不需要和用户交互而且还要求长期运行的任务
创建Service创建一个MyService类继承自Service，并重写onBind()方法
public class MyService2 extends Service &#123;    public MyService2() &#123;    &#125;    @Override    public IBinder onBind(Intent intent) &#123;        // TODO: Return the communication channel to the service.        throw new UnsupportedOperationException(&quot;Not yet implemented&quot;);    &#125;&#125;
在清单文件中注册Service类
android:exported; 是否允许其他应用隐式调用该组件android:enabled; 是否可以被系统实例化&lt;service    android:name=&quot;.MyService2&quot;    android:enabled=&quot;true&quot;    android:exported=&quot;true&quot;&gt;&lt;/service&gt;
Service生命周期//启动服务  startService()//关闭服务  stopService()//绑定服务  bindService()//解绑服务  unbindService()

import android.app.Service;import android.content.Intent;import android.os.IBinder;import android.util.Log;public class MyService2 extends Service &#123;    private final String TAG = &quot;xin&quot;;    @Override//    Service第一次被创建时调用    public void onCreate() &#123;        super.onCreate();        Log.d(TAG, &quot;onCreate()&quot;);    &#125;    @Override//    startService()启动时调用    public int onStartCommand(Intent intent, int flags, int startId) &#123;        Log.d(TAG, &quot;onStartCommand()&quot;);        return super.onStartCommand(intent, flags, startId);    &#125;    @Override//    Service不再使用时调用    public void onDestroy() &#123;        super.onDestroy();        Log.d(TAG, &quot;onDestroy()&quot;);    &#125;    @Override//    必须实现的方法，返回一个绑定的接口给Service    public IBinder onBind(Intent intent) &#123;        Log.d(TAG, &quot;onBind()&quot;);        return null;//        throw new UnsupportedOperationException(&quot;Not yet implemented&quot;);    &#125;    @Override//    解绑服务    public boolean onUnbind(Intent intent) &#123;        Log.d(TAG, &quot;onUnbind()&quot;);        return super.onUnbind(intent);    &#125;&#125;
启动Service通过startService()启动启动状态：&ensp;&ensp;&ensp;&ensp;当应用组件通过调用startService()启动服务时，服务即处于“启动”状态。一旦启动，服务即可在后台无期限运行，即使启动服务的组件已被销毁也不受影响，除非手动调用才能停止服务，已启动的服务通常是执行单一操作，而且不会将结果返回给调用方

启动时，依次调用onCreate -&gt; onStartCommand
如果Service已经被启动，再次启动时将不会执行onCreate，而是直接执行onStartCommand
stopService时直接进入onDestory
无论调用了几次startService，一次stopService就能结束该Service

  Intent intent = new Intent(MyService.this,MyService2.class);//  启动服务  startService(intent);//  停止服务  stopService(intent);
通过bindService()启动绑定状态：&ensp;&ensp;&ensp;&ensp;当应用组件通过调用bindService()启动服务时，服务即处于“绑定”状态。绑定服务提供了一个端口—服务器接口，允许组件与服务进行交互、发送请求、获取结果，甚至是利用进程间通信跨进程执行这些操作。仅当与另一个应用组件绑定时，绑定服务才会运行。多个组件可以同时绑定到该服务，但全部取消绑定时，该服务即会销毁

启动时只运行onCreate()
停止时，依次调用onUnbind -&gt; onDestory
当与之绑定的Activity被销毁时自动解绑Service

Activity与Service绑定需要实例化一个ServiceConnection坐桥梁//  通过一个桥梁给Activity和Service进行绑定  ServiceConnection serviceConnection = new ServiceConnection() &#123;      @Override//      传送在service的onBind()中返回的IBinder      public void onServiceConnected(ComponentName name, IBinder service) &#123;      &#125;      @Override//      Service被不正常kill时调用      public void onServiceDisconnected(ComponentName name) &#123;      &#125;  &#125;;
绑定Service//  绑定服务，传入 intent、ServiceConnection、绑定模式  bindService(intent, serviceConnection, Context.BIND_AUTO_CREATE);  //  解绑服务  unbindService(serviceConnection);
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-SharedPreferences</title>
    <url>/2021/10/11/Android-SharedPreferences/</url>
    <content><![CDATA[&ensp;&ensp;&ensp;&ensp;SharedPreferences用于储存轻量级数据在本地，可以保存的数据类型有：int、boolean、float、long、String、StringSet
访问模式SharedPreferences有三种访问模式

MODE_PRIVATE: 私有，仅创建SharedPreferences的程序有权限对其进行读写
MODE_WORLD_READABLE: 其他应用程序有读取权限，没有写入权限(Android 4.2中弃用)
MODE_WORLD_WRITEABLE: 其他应用程序有写入权限，没有读取权限(Android 4.2中弃用)

读写本地配置文件得到一个SharedPreferences实例//  getSharedPreferences返回一个SharedPreferences实例//  传入两个参数: 本地配置文件名、访问模式  SharedPreferences sharedPreferences = getSharedPreferences(&quot;文件名&quot;,MODE_PRIVATE);
从SharedPreferences中读取信息//  读取配置信息，当对应的key值找不到便会返回默认值//  传入两个参数: key、默认值  String str = sharedPreferences.getString(&quot;time&quot;,&quot;首次读取&quot;);
读取到默认值则写入配置文件  if (str.equals(&quot;首次读取&quot;))&#123;//      使用sharedPreferences的edit()方法写入本地配置      SharedPreferences.Editor editor = sharedPreferences.edit();//      写入值      editor.putString(&quot;time&quot;,&quot;配置文件信息&quot;);//      提交以写入      editor.commit();  &#125;  else &#123;      Toast.makeText(this,&quot;读取到的值&quot; + str,Toast.LENGTH_SHORT).show();  &#125;
完整代码import android.content.SharedPreferences;import android.os.Bundle;import android.widget.Toast;import androidx.annotation.Nullable;import androidx.appcompat.app.AppCompatActivity;public class MyCoffeeStore extends AppCompatActivity&#123;    @Override    protected void onCreate(@Nullable Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_coffee_store);//        getSharedPreferences返回一个SharedPreferences实例，配置文件名、访问模式        SharedPreferences sharedPreferences = getSharedPreferences(&quot;testName&quot;,MODE_PRIVATE);//        读取配置信息，当对应的key值找不到便会返回默认值；传入key、默认值        String str = sharedPreferences.getString(&quot;testName&quot;,&quot;首次读取&quot;);        if (str.equals(&quot;首次读取&quot;))&#123;//            使用sharedPreferences的edit()方法写入本地配置            SharedPreferences.Editor editor = sharedPreferences.edit();//            写入值            editor.putString(&quot;testName&quot;,&quot;配置文件信息&quot;);//            提交以写入            editor.commit();        &#125;        else &#123;            Toast.makeText(this,&quot;读取到的值&quot; + str,Toast.LENGTH_SHORT).show();        &#125;    &#125;&#125;
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-SoundPool播放音效</title>
    <url>/2021/10/09/Android-SoundPool%E6%92%AD%E6%94%BE%E9%9F%B3%E6%95%88/</url>
    <content><![CDATA[&ensp;&ensp;&ensp;&ensp;MediaPalyer虽然可以播放音频，但是资源占用量较高、延迟时间较长、不支持多个音频同时播放等缺点，SoundPool一般用来播放密集、急促、短暂的音效

导入音频文件Android工程的音频文件存放在raw文件夹

页面布局没啥好看的&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:orientation=&quot;vertical&quot;    android:gravity=&quot;center&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;&gt;    &lt;Button        android:text=&quot;播放音频&quot;        android:id=&quot;@+id/sound_btn1&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;/&gt;&lt;/LinearLayout&gt;
程序设计Android5.0是SoundPool的一个分水岭，在5.0版本SoundPool发生了大变化//SDK21是SoundPool的一个分水岭  if(Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLIPOP)&#123;        &#125;  else &#123;        &#125;
SDK_INT &gt;= 211.创建SoundPool的构建对象//  创建一个SoundPool的构建对象  SoundPool.Builder builder = new SoundPool.Builder();//  最大同时播放音频的数量  builder.setMaxStreams(1);
2.创建AudioAttributes的构建对象，它封装音频各种属性的方法，使用它设置音频流的合适的属性并加载到SoundPool的构建对象//  封装音频各种属性的方法  AudioAttributes.Builder audioAttriBuilder = new AudioAttributes.Builder();//  设置音频流的合适的属性  audioAttriBuilder.setLegacyStreamType(AudioManager.STREAM_MUSIC);//  加载一个AudioAttributes到builder  builder.setAudioAttributes(audioAttriBuilder.build());
3.通过build()方法得到SoundPool对象//  通过构建方法得到SoundPool对象，soundPool是实例变量  soundPool = builder.build();
SDK_INT &lt; 21//  最大同时播放音频的数量、AudioManager中描述的音频流类型、采样率转换器的质量  soundPool = new SoundPool(1, AudioManager.STREAM_MUSIC,0);
加载播放1.加载音频资源，load会返回一个int类型的id，该id用于控制这个音效，开始、卸载等//  加载音频资源，把load返回的id赋值给soundId，该id值用于控制该音效  soundId = soundPool.load(MySoundPool.this,R.raw.lbw,3);
2.音频资源加载完成后，播放音频//  音频资源加载完成后会调用setOnLoadCompleteListener  soundPool.setOnLoadCompleteListener(new SoundPool.OnLoadCompleteListener() &#123;      @Override//      三个参数：load()方法中的SoundPool对象，load()方法返回的soundId，加载音频资源 的状态(为0时成功)      public void onLoadComplete(SoundPool soundPool, int sampleId, int status) &#123;          if (status == 0)&#123;//              播放              soundPool.play(soundId, //soundLoadId                      1.0f, //左侧音量值（范围= 0.0到1.0）                      1.0f, //右侧音量值（范围= 0.0到1.0）                      1, //优先级(越大越高)                      0, //重复播放次数(0是1次，-1无限循环)                      1.0f); //播放的速率，范围0.5-2.0(0.5为一半速率，1.0为正常速率，2.0为两倍速率)          &#125;      &#125;  &#125;);
卸载并释放由于一个SoundPool对象可能播放很多个音效，所以在页面销毁时再对它进行释放  protected void onDestroy() &#123;      super.onDestroy();//      退出页面时卸载音效，如果播放了多个音效，则根据它们的id一一卸载      soundPool.unload(soundId);//      释放soundPool对象      soundPool.release();  &#125;
完整程序预览import androidx.appcompat.app.AppCompatActivity;import android.media.AudioAttributes;import android.media.AudioManager;import android.media.SoundPool;import android.os.Build;import android.os.Bundle;import android.view.View;import android.widget.Button;public class MySoundPool extends AppCompatActivity &#123;    private Button sound_btn1;    private SoundPool soundPool;    private int soundId;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_sound_pool);        sound_btn1 = findViewById(R.id.sound_btn1);        sound_btn1.setOnClickListener(new View.OnClickListener() &#123;            @Override            public void onClick(View v) &#123;//                sdk版本21是SoundPool的一个分水岭                if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP)&#123;//                    创建一个SoundPool的构建对象                    SoundPool.Builder builder = new SoundPool.Builder();//                    最大同时播放音频的数量                    builder.setMaxStreams(1);//                    封装音频各种属性的方法                    AudioAttributes.Builder audioAttriBuilder = new AudioAttributes.Builder();//                    设置音频流的合适的属性                    audioAttriBuilder.setLegacyStreamType(AudioManager.STREAM_MUSIC);//                    加载一个AudioAttributes                    builder.setAudioAttributes(audioAttriBuilder.build());//                    通过构建方法得到SoundPool对象                    soundPool = builder.build();                &#125;                else &#123;//                    对象的最大并发流数、AudioManager中描述的音频流类型、采样率转换器的质量                    soundPool = new SoundPool(1, AudioManager.STREAM_MUSIC,0);                &#125;//                加载音频资源，把load返回的id赋值给soundId，该id值用于控制该音效                soundId = soundPool.load(MySoundPool.this,R.raw.lbw,3);//                音频资源加载完成后会调用setOnLoadCompleteListener                soundPool.setOnLoadCompleteListener(new SoundPool.OnLoadCompleteListener() &#123;                    @Override//                    三个参数：load()方法中的SoundPool对象，load()方法返回的soundId，加载音频资源 的状态(为0时成功)                    public void onLoadComplete(SoundPool soundPool, int sampleId, int status) &#123;                        if (status == 0)&#123;//                            播放                            soundPool.play(soundId, //soundLoadId                                    1.0f, //左侧音量值（范围= 0.0到1.0）                                    1.0f, //右侧音量值（范围= 0.0到1.0）                                    1, //优先级(越大越高)                                    0, //重复播放次数(0是1次，-1无限循环)                                    1.0f); //播放的速率，范围0.5-2.0(0.5为一半速率，1.0为正常速率，2.0为两倍速率)                        &#125;                    &#125;                &#125;);            &#125;        &#125;);    &#125;        @Override    protected void onDestroy() &#123;        super.onDestroy();//        退出页面时卸载音效        soundPool.unload(soundId);//        释放soundPool        soundPool.release();    &#125;&#125;
扩展&ensp;&ensp;&ensp;&ensp;SoundPool一般用来播放密集、急促、短暂的音效，所以它对一个音频文件最大只播放6秒&ensp;&ensp;&ensp;&ensp;若要突破这个限制

将声音文件的采样率更改为16000Hz。
将音频通道改为单声道，而不是立体声。
将声音文件转换为ogg格式。
确保经过这些过程后文件小于1mb。

]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Android Studio layout文件夹分离</title>
    <url>/2022/10/26/Android-Studio-layout%E6%96%87%E4%BB%B6%E5%A4%B9%E5%88%86%E7%A6%BB/</url>
    <content><![CDATA[&ensp;&ensp;默认的，在Android Studio中开发，布局文件会统一存放在src\main\res\layout目录下，如此一来，当开发的项目庞大，布局文件过多时，layout文件夹下的布局文件会显得异常的臃肿，查找非常麻烦，所以要对其进行分离，方便管理


&ensp;&ensp;在layout文件夹下创建子文件夹，在每个子文件夹中创建layout文件夹
&ensp;&ensp;在app级的build.gradle文件中，android层级下，添加如下android &#123;    sourceSets &#123;        main &#123;            res.srcDirs = [                    &#x27;src/main/res/layout/activity&#x27;,                    &#x27;src/main/res/layout/dialog&#x27;,                    &#x27;src/main/res/layout&#x27;,                    &#x27;src/main/res&#x27;            ]        &#125;    &#125;&#125;
&ensp;&ensp;注意&#39;src/main/res&#39;和&#39;src/main/res/layout&#39;的位置不能变，修改之后同步一下项目，此时可以看到文件夹变成了这样，说明成功了，清理一下项目缓存即可，唯一的缺点是会有红色的错误提示一直亮
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android开发手记</tag>
      </tags>
  </entry>
  <entry>
    <title>Android Studio无线调试</title>
    <url>/2022/01/30/Android-Studio%E6%97%A0%E7%BA%BF%E8%B0%83%E8%AF%95/</url>
    <content><![CDATA[1.在手机开发者选项中打开USB调试，打开无线调试，并使用USB数据线链接电脑
2.在cmd窗口输入adb devices

如果设备环境正常，将会显示连接的设备
3.在cmd窗口输入adb tcpip 7218
如果端口被开启，将会显示
4.查看手机的内网ip，以”adb connect”+内网ip+端口号的格式输入adb connect 192.168.1.2:7218
连接成功将会显示
]]></content>
      <categories>
        <category>菜鸡手记</category>
      </categories>
      <tags>
        <tag>软件与工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Android Studio混淆</title>
    <url>/2023/07/01/Android-Studio%E6%B7%B7%E6%B7%86/</url>
    <content><![CDATA[使用Android Gradle插件3.4.0或更高版本构建项目时，不再使用ProGuard执行编译时代码优化，而是与R8编译器协同工作
开启混淆&ensp;&ensp;在gradle文件中启用混淆，在混淆配置文件中，getDefaultProguardFile(&#39;proguard-android-optimize.txt&#39;)代表sdk目录tools\proguard路径下的默认混淆配置文件，proguard-rules.txt代表项目根目录下的开发者自定义混淆配置文件
android &#123;    buildTypes &#123;        release &#123;            // 启用代码压缩、混淆和优化            minifyEnabled true            // 启用资源压缩            shrinkResources true            // 添加混淆配置文件            proguardFiles getDefaultProguardFile(&#x27;proguard-android-optimize.txt&#x27;), &#x27;proguard-rules.txt&#x27;        &#125;    &#125;&#125;
混淆命令



命令
作用




-keep
防止类和成员被移除和被重命名


-keepnames
防止类和成员被重命名


-keepclassmembers
防止成员被移除和被重命名


-keepclassmembernames
防止成员被重命名


-keepclasseswithmembers
防止拥有该成员的类和成员被移除或重命名


-keepclasseswithmembernames
防止拥有该成员的类和成员被重命名





-keep

类和类成员均不压缩和混淆。类和类成员在未使用的情况下不被删除，并保留原始名称-keep class com.test.packagename.Bean &#123;    *;&#125;

-keepnames

允许类和类成员压缩，不允许混淆。类和成员未使用时将会被删除，使用时保留原始名称-keepnames class com.test.packagename.Bean &#123;    *;&#125;

-keepclassmembers

允许类压缩和混淆，不允许类成员压缩和混淆。类未使用时将被删除，类使用时不保留原始名称，但类成员不会被删除且保留原始名称-keepclassmembers class com.test.packagename.Bean &#123;    *;&#125;

-keepclassmembernames

允许类压缩和混淆，类成员仅允许压缩不允许混淆。类未使用时将会被删除，类使用时不保留原始名称，类成员未使用是将被删除，类成员使用时保留原始名称-keepclassmembernames class com.test.packagename.Bean &#123;    *;&#125;

-keepclasseswithmembers

指定的类和类成员不压缩和混淆。被指定的类和类成员在未使用的情况下不被删除，并保留原始名称# 指定类及所有类成员不被压缩和混淆-keepclasseswithmembers class com.test.packagename.Bean &#123;    *;&#125;

-keepclasseswithmembernames

指定类和类成员仅允许压缩，不允许混淆。被指定的类和成员在未使用时将会被删除，使用时保留原始名称# 指定类及所有类成员允许压缩不允许混淆-keepclasseswithmembernames class com.test.packagename.Bean &#123;    *;&#125;
混淆规则[命令] [修饰符] [类|接口|枚举] [类名|接口名|枚举名] &#123;    [成员]&#125;
命令规则仅支持填入保持命令

-keep
-keepnames
-keepclassmembers
-keepclassmembernames
-keepclasseswithmembers
-keepclasseswithmembernames

类规则
类

保持类(接口、枚举也属于类的一种)com.test.packagename.Bean和类成员不压缩、不混淆-keep class com.test.packagename.Bean &#123;    [成员]&#125;保持包`com.test.packagename`下的所有类、接口、枚举及其成员不压缩、不混淆-keep class com.test.packagename.* &#123;    [成员]&#125;

接口

保持接口com.test.packagename.CallBack和成员不压缩、不混淆-keep interface com.test.packagename.CallBack &#123;    [成员]&#125;

枚举

保持枚举com.test.packagename.Param和成员不压缩、不混淆-keep enum com.test.packagename.Param &#123;    [成员]&#125;

支持逻辑非!

不保持com.test.packagename包下的接口，保持其余所有类、接口、枚举及其成员不压缩、不混淆-keep !interface com.test.packagename.* &#123;    [成员]&#125;
修饰符规则修饰符可以留空，留空则代表同时选中public和!public

public

仅保持com.test.packagename下的public类和类成员不压缩、不混淆-keep public class com.test.packagename.* &#123;    [成员]&#125;

!public

仅保持com.test.packagename包下的非public类和类成员不压缩、不混淆-keep !public class com.test.packagename.* &#123;    [成员]&#125;
类名规则
直接写入

保持类com.test.packagename.Bean和类成员不压缩、不混淆-keep class com.test.packagename.Bean&#123;    *;&#125;

通配符

保持com.test.packagename包下所有类和类成员不压缩、不混淆-keep class com.test.packagename.* &#123;    *;&#125;
保持com.test.packagename包及其子包下所有类和类成员不压缩、不混淆-keep class com.test.packagename.** &#123;    *;&#125;

继承类、实现接口

保持所有继承了android.app.Activity的类和类成员不压缩、不混淆-keep class com.test.packagename.** extends android.app.Activity &#123;    *;&#125;
保持所有实现了java.io.Serializable的类和类成员不压缩、不混淆-keep class com.test.packagename.** implements java.io.Serializable &#123;    *;&#125;

内部类

保持类com.test.packagename.Bean中的所有子类和子类成员不压缩、不混淆-keep class com.test.packagename.Bean$* &#123;    *;&#125;
成员规则构造器规则
空参构造器

保持com.test.packagename包下所有类和类的空参构造器不压缩、不混淆-keep class com.test.packagename.** &#123;    &lt;init&gt;();&#125;

任意构造器

保持com.test.packagename包下所有类和类中构造器不压缩、不混淆-keep class com.test.packagename.** &#123;    &lt;init&gt;(*);&#125;

指定参数构造器

保持com.test.packagename包下所有类和类中接收String参数的构造器不压缩、不混淆-keep class com.test.packagename.** &#123;    &lt;init&gt;(java.lang.String);&#125;

任意参数构造器

保持com.test.packagename包下所有类和类中接收任意参数的构造器不压缩、不混淆-keep class com.test.packagename.** &#123;    &lt;init&gt;(...);&#125;
方法规则
所有方法

保持com.test.packagename包下所有类和成员方法不压缩、不混淆-keep class com.test.packagename.** &#123;    &lt;methods&gt;;&#125;// # 另一种写法，二者等效// -keep class com.test.packagename.** &#123;//     *(*);// &#125;

指定方法

保持com.test.packagename包下所有类和类中main方法不压缩、不混淆-keep class com.test.packagename.** &#123;    main();&#125;

还有访问修饰符、通配符、返回值、接收参数，他妈的不写了

常用规则关闭压缩-dontshrink
关闭代码优化，默认Proguard规则文件已包含-dontoptimize
关闭混淆-dontobfuscate
指定代码优化级别，值在0-7之间，默认为5-optimizationpasses 5
混淆时不使用大小写混合类名，默认Proguard规则文件已包含-dontusemixedcaseclassnames
不忽略库中的非public的类，默认Proguard规则文件已包含-dontskipnonpubliclibraryclasses
不忽略库中的非public的类成员-dontskipnonpubliclibraryclassmembers
输出详细信息，默认Proguard规则文件已包含-verbose
不做预校验，预校验是作用在Java平台上的，Android平台上不需要这项功能，去掉之后还可以加快混淆速度，默认Proguard规则文件已包含-dontpreverify
保持指定包下的类名，不包括子包下的类名-keep class com.test.packagename*
保持指定包下的类名，包括子包下的类名-keep class com.test.packagename**
保持指定包下的类名及其所有成员、方法和字段的命名-keep class com.test.packagename.* &#123;*;&#125;
保持所有继承于指定类的类，如下保持所有继承Activity的类-keep public class * extends android.app.Activity

简书文章：https://www.jianshu.com/p/c19444e5d3aa简书文章：https://www.jianshu.com/p/fdadca8e2094Android 开发者文档：http://developer.android.google.cn/guide/developing/tools/proguard.htmlProGuard 官方文档：https://www.guardsquare.com/manual/home

]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android开发手记</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-TextView</title>
    <url>/2021/09/08/Android-TextView/</url>
    <content><![CDATA[TextView的基础属性
layout_width: 组件的宽度
layout_height: 组件的高度
id: 组件的id
text: 设置文本显示的内容
textColor: 设置字体颜色
textStyle: 设置字体风格，normal[无效果]、bold[加粗]、italic[倾斜]
textSize: 字体大小，单位一般用sp
background: 控件的背景颜色，可以是图片
gravity: 设置控件中内容的对齐方向

TextView阴影
shadowColor: 设置阴影的颜色，需要与shadowRadius一起使用
shadowRadius: 设置阴影的模糊程度，建议3.0
shadowDx: 设置阴影在水平方向的偏移
shadowDy: 设置阴影在垂直方向的偏移

跑马灯效果
android:singleLine: 内容单行显示
android:focusable: 是否可以获取焦点
android:focusableInTouchMode: 用于控制视图在触摸模式下是否可以聚焦
android:ellipsize: 在哪里省略文本
android:marqueeRepeatLimit: 字母动画重复的次数

设置上面5个属性后，此时跑马灯依然不能运行，有两种运行的解决方案
方法一、自定义TextView1.新建MyTextView类继承TextView类
2.继承3个MyTextView构造方法public class MyTextView extends TextView &#123;    public MyTextView(Context context) &#123;        super(context);    &#125;    public MyTextView(Context context, @Nullable AttributeSet attrs) &#123;        super(context, attrs);    &#125;    public MyTextView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123;        super(context, attrs, defStyleAttr);    &#125;		@Override    public boolean isFocused() &#123;        return true;    &#125;&#125;
3.重写isFocused方法，使其返回truepublic class MyTextView extends TextView &#123;    public MyTextView(Context context) &#123;        super(context);    &#125;    public MyTextView(Context context, @Nullable AttributeSet attrs) &#123;        super(context, attrs);    &#125;    public MyTextView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123;        super(context, attrs, defStyleAttr);    &#125;		@Override    public boolean isFocused() &#123;        return true;    &#125;&#125;
4.将xml布局文件中的TextView修改为com.a.Smartcity.MyTextView(全类名)
方法二、修改xml标签1.将TextView单标签修改为双标签
2.在TextView中添加&lt;requestFocus/&gt;单标签
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-ViewPager</title>
    <url>/2021/09/13/Android-ViewPager/</url>
    <content><![CDATA[创建ViewPager控件&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout android:layout_height=&quot;match_parent&quot;    android:layout_width=&quot;match_parent&quot;    android:orientation=&quot;vertical&quot;    android:id=&quot;@+id/linear&quot;    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;&lt;!--    ViewPager控件--&gt;    &lt;androidx.viewpager.widget.ViewPager        android:id=&quot;@+id/viewPager&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;match_parent&quot;/&gt;&lt;/LinearLayout&gt;
创建ViewPager的子view&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout android:layout_height=&quot;match_parent&quot;    android:layout_width=&quot;match_parent&quot;    android:orientation=&quot;vertical&quot;    android:background=&quot;#ff00ffff&quot;    android:gravity=&quot;center&quot;    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;    &lt;TextView        android:text=&quot;layout1&quot;        android:textSize=&quot;28sp&quot;        android:textColor=&quot;@color/black&quot;        android:textStyle=&quot;bold&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;/&gt;&lt;/LinearLayout&gt;
创建适配器ViewPager和RecyclerView、ListView一样需要适配器Adapter，它的适配器继承自PagerAdapterimport android.view.View;import android.view.ViewGroup;import androidx.annotation.NonNull;import androidx.viewpager.widget.PagerAdapter;import java.util.List;//继承自PagerAdapterpublic class MyAdapter extends PagerAdapter &#123;    private List&lt;View&gt; viewList;//    构造器    public MyAdapter(List&lt;View&gt; viewList)&#123;        this.viewList = viewList;    &#125;    @NonNull    @Override//    将view项实例化到ViewGroup中    public Object instantiateItem(@NonNull ViewGroup container, int position) &#123;        container.addView(viewList.get(position),0);//        返回一个Object(key)，通常直接返回view本身，可以自定义key，但是每个key和view有一一对应关系        return viewList.get(position);    &#125;    @Override//    返回viewPager中view的数量    public int getCount() &#123;        return viewList.size();    &#125;    @Override//    判断instantiateItem返回来的key与一个页面视图是否一一对应，通常直接写return view == object    public boolean isViewFromObject(@NonNull View view, @NonNull Object object) &#123;        return view == object;    &#125;    @Override//    对超出范围的资源进行销毁    public void destroyItem(@NonNull ViewGroup container, int position, @NonNull Object object) &#123;//        super.destroyItem(container, position, object);        container.removeView(viewList.get(position));    &#125;&#125;
调用适配器import androidx.appcompat.app.AppCompatActivity;import androidx.viewpager.widget.ViewPager;import android.os.Bundle;import android.view.View;import java.util.ArrayList;import java.util.List;public class MainActivity extends AppCompatActivity &#123;    private ViewPager viewPager;    private List&lt;View&gt; viewList;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);//        给集合中添加值        viewList = new ArrayList&lt;&gt;();        View view1 = View.inflate(this,R.layout.layout1,null);        View view2 = View.inflate(this,R.layout.layout2,null);        View view3 = View.inflate(this,R.layout.layout3,null);        viewList.add(view1);        viewList.add(view2);        viewList.add(view3);        viewPager = findViewById(R.id.viewPager);//        创建 适配器对象        MyAdapter myAdapter = new MyAdapter(viewList);//        设置适配器        viewPager.setAdapter(myAdapter);    &#125;&#125;
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-ViewPager2</title>
    <url>/2021/09/13/Android-ViewPager2/</url>
    <content><![CDATA[&ensp;&ensp;与Viewpager不同，ViewPager2是对RecycleView的封装&ensp;&ensp;由于采用ViewPager2实现，所以自带懒加载
添加依赖ViewPager2需要先添加依赖
implementation &#x27;androidx.viewpager2:viewpager2:1.0.0&#x27;
修改布局&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout android:layout_height=&quot;match_parent&quot;    android:layout_width=&quot;match_parent&quot;    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;&lt;!--    创建ViewPager2控件--&gt;    &lt;androidx.viewpager2.widget.ViewPager2        android:layout_width=&quot;match_parent&quot;        android:id=&quot;@+id/viewPager2&quot;        android:layout_height=&quot;match_parent&quot;/&gt;&lt;/LinearLayout&gt;
创建item.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout android:layout_height=&quot;match_parent&quot;    android:layout_width=&quot;match_parent&quot;    android:gravity=&quot;center&quot;    android:id=&quot;@+id/item_linearLayout&quot;    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;    &lt;TextView        android:text=&quot;文本&quot;        android:textSize=&quot;28sp&quot;        android:textColor=&quot;@color/black&quot;        android:textStyle=&quot;bold&quot;        android:id=&quot;@+id/item_text&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;/&gt;&lt;/LinearLayout&gt;
创建适配器ViewPager2的适配器与RecyclerView相同，继承自RecyclerView.Adapter，并重写Adapter中的三个方法public class MyAdapter extends RecyclerView.Adapter&#123;    @NonNull    @Override    public RecyclerView.ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) &#123;        return null;    &#125;    @Override    public void onBindViewHolder(@NonNull RecyclerView.ViewHolder holder, int position) &#123;    &#125;    @Override    public int getItemCount() &#123;        return 0;    &#125;&#125;
Adapter是泛型，需要给它一个继承自ViewHolder的类，然后把其他方法中的RecyclerView.ViewHolder修改为MyViewHolderpublic class MyAdapter extends RecyclerView.Adapter&lt;MyTestAdapter.MyViewHolder&gt;&#123;    @NonNull    @Override    public MyViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) &#123;        return null;    &#125;    @Override    public void onBindViewHolder(@NonNull MyViewHolder holder, int position) &#123;    &#125;    @Override    public int getItemCount() &#123;        return 0;    &#125;	//    创建一个内部类，该类对RecyclerView.ViewHolder进行封装    class MyViewHolder extends RecyclerView.ViewHolder &#123;        public MyViewHolder(@NonNull View itemView) &#123;            super(itemView);        &#125;    &#125;&#125;
定义变量、创建构造器、绑定事件（参考RecyclerView）import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import android.widget.LinearLayout;import android.widget.TextView;import androidx.annotation.NonNull;import androidx.recyclerview.widget.RecyclerView;import java.util.ArrayList;public class MyAdapter extends RecyclerView.Adapter&lt;MyAdapter.MyViewHolder&gt; &#123;    private ArrayList&lt;Integer&gt; integerArrayList;    private ArrayList&lt;String&gt; stringArrayList;    public MyAdapter(ArrayList&lt;String&gt; stringArrayList,ArrayList&lt;Integer&gt; integerArrayList)&#123;        this.stringArrayList = stringArrayList;        this.integerArrayList = integerArrayList;    &#125;    @NonNull    @Override//    创建布局    public MyViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) &#123;//        得到item布局文件        View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.item,parent,false);        MyViewHolder myViewHolder = new MyViewHolder(view);        return myViewHolder;    &#125;    @Override//    绑定事件    public void onBindViewHolder(@NonNull MyViewHolder holder, int position) &#123;//        设置每页的背景和文本内容        holder.item_text.setText(stringArrayList.get(position));        holder.item_linearLayout.setBackgroundResource(integerArrayList.get(position));    &#125;    @Override//    获取条数    public int getItemCount() &#123;        return stringArrayList.size();    &#125;//    MyViewHolder继承自RecyclerView的ViewHolder//    创建一个内部类，该类对RecyclerView.ViewHolder进行封装    public class MyViewHolder extends RecyclerView.ViewHolder &#123;        private LinearLayout item_linearLayout;        private TextView item_text;        public MyViewHolder(@NonNull View itemView) &#123;            super(itemView);            item_text = itemView.findViewById(R.id.item_text);            item_linearLayout = itemView.findViewById(R.id.item_linearLayout);        &#125;    &#125;&#125;
调用适配器import androidx.appcompat.app.AppCompatActivity;import androidx.viewpager2.widget.ViewPager2;import android.os.Bundle;import java.util.ArrayList;public class MainActivity extends AppCompatActivity&#123;    private ViewPager2 viewPager2;    private ArrayList&lt;Integer&gt; integerArrayList;    private ArrayList&lt;String&gt; stringArrayList;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        stringArrayList = new ArrayList&lt;&gt;();        integerArrayList = new ArrayList&lt;&gt;();        stringArrayList.add(&quot;页面1&quot;);        stringArrayList.add(&quot;页面2&quot;);        stringArrayList.add(&quot;页面3&quot;);        integerArrayList.add(R.color.antiquewhite);        integerArrayList.add(R.color.darkorange);        integerArrayList.add(R.color.lime);        viewPager2 = findViewById(R.id.viewPager2);        MyAdapter myAdapter = new MyAdapter(stringArrayList,integerArrayList);        viewPager2.setAdapter(myAdapter);    &#125;&#125;
效果
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Android View保存为本地图片</title>
    <url>/2021/11/22/Android-View%E4%BF%9D%E5%AD%98%E4%B8%BA%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87/</url>
    <content><![CDATA[ImageView的保存方式和其它View稍微有些不一样
ImageView&ensp;&ensp;&ensp;&ensp;大概思路：获取到ImageView的bitmap数据，将bitmap数据压缩为图片并输出，关闭输出流
//  设置保存路径，现在的路径就是&quot;/storage/emulated/0&quot;目录下的image1.png  File file = new File(Environment.getExternalStorageDirectory().getAbsolutePath(),&quot;image1.png&quot;);//  获取到ImageView的drawable，并强转为bitmapDrawable  BitmapDrawable bitmapDrawable = (BitmapDrawable) imageView.getDrawable();  Bitmap bitmap = bitmapDrawable.getBitmap();//bitmapDrawable转换为bitmap//  判断是不是获取到了bitmap  if (bitmap != null)&#123;//    输出流需要捕获异常      try &#123;//        输出流          FileOutputStream fileOutputStream = new FileOutputStream(file);          // CompressFormat: 压缩格式，png、jpg、webp等          // quality: 图片质量，0-100          // OutputStream: 输出流          bitmap.compress(Bitmap.CompressFormat.PNG,100,fileOutputStream);          fileOutputStream.flush(); //清空io      &#125; catch (IOException e) &#123;          e.printStackTrace();      &#125; finally &#123;          if (file.exists())&#123;              Toast.makeText(getContext(),&quot;保存成功&quot;,Toast.LENGTH_SHORT).show();          &#125;          else &#123;              Toast.makeText(getContext(),&quot;保存失败&quot;,Toast.LENGTH_SHORT).show();          &#125;      &#125;  &#125;  else &#123;      Toast.makeText(getContext(),&quot;保存失败&quot;,Toast.LENGTH_SHORT).show();  &#125;
其它View&ensp;&ensp;&ensp;&ensp;其它View无法像ImageView那样通过getDrawable获取drawable并强转为bitmapDrawable，然后再转换为bitmap并保存；必须给View创建一个bitmap，然后将画面绘制在bitmap中
//设置保存路径，现在的路径就是&quot;/storage/emulated/0&quot;目录下的image2.png  File file = new File(Environment.getExternalStorageDirectory().getAbsolutePath(),&quot;image2.png&quot;);//  获取它的宽高，用于定义创建的bitmap的宽高  int w = pagerView.getWidth();  int h = pagerView.getHeight();  // width: bitmap的宽  // height: bitmap的高  // Config: bitmap的画质，ARGB_8888代表32位ARGB位图，最高画质  Bitmap bitmap = Bitmap.createBitmap(w,h, Bitmap.Config.ARGB_8888);//  向bitmap中绘制View中的控件，否则保存为一片空白  Canvas canvas = new Canvas(bitmap);  canvas.drawColor(Color.WHITE);//设置canvas画布颜色，默认为透明  pagerView.layout(0,0,w,h);//剪裁View，左边开始位置、顶部开始位置、右边结束位置、底部结束位置  pagerView.draw(canvas);//将view画到canvas中  //  然后和正常流程一样了  try &#123;      FileOutputStream fileOutputStream = new FileOutputStream(file);      bitmap.compress(Bitmap.CompressFormat.PNG,100,fileOutputStream);      fileOutputStream.flush();  &#125; catch (IOException e) &#123;      e.printStackTrace();  &#125; finally &#123;      if (file.exists())&#123;          Toast.makeText(getContext(),&quot;保存成功&quot;,Toast.LENGTH_SHORT).show();      &#125;      else &#123;          Toast.makeText(getContext(),&quot;保存失败&quot;,Toast.LENGTH_SHORT).show();      &#125;  &#125;
&ensp;&ensp;&ensp;&ensp;不要忘记赋予储存读写权限
附，Android文件复制&ensp;&ensp;&ensp;&ensp;读取后直接写入，读多少，写多少，简单粗暴
//  源文件路径和目标文件路径  File file1 = new File(Environment.getExternalStorageDirectory().getAbsolutePath(),&quot;image2.png&quot;);  File file2 = new File(Environment.getExternalStorageDirectory().getAbsolutePath(),&quot;image3.png&quot;);  FileInputStream fileInputStream = null;  FileOutputStream fileOutputStream = null;  try &#123;      fileInputStream = new FileInputStream(file1);      fileOutputStream = new FileOutputStream(file2);//      字节流      byte[] bytes = new byte[1024];      int len;//剩余长度      while ((len = fileInputStream.read(bytes)) &gt; 0)&#123;          fileOutputStream.write(bytes,0,len);//直接写入      &#125;      fileOutputStream.flush();//清空io  &#125; catch (IOException e) &#123;      e.printStackTrace();  &#125; finally &#123;      if (file2.exists())&#123;          Toast.makeText(getContext(),&quot;复制成功&quot;,Toast.LENGTH_SHORT).show();      &#125;      else &#123;          Toast.makeText(getContext(),&quot;复制失败&quot;,Toast.LENGTH_SHORT).show();      &#125;      if (fileInputStream != null || fileOutputStream != null)&#123;          try &#123;              fileInputStream.close();              fileOutputStream.close();          &#125; catch (IOException e) &#123;              e.printStackTrace();          &#125;      &#125;  &#125;
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android开发手记</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-Volley框架</title>
    <url>/2022/05/15/Android-Volley%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[引入Volley&ensp;&ensp;记得在清单文件中添加网络请求权限compile &#x27;com.android.volley:volley:1.2.1&#x27;
get请求&ensp;&ensp;使用Volley发送一条get请求  private void sendGet() &#123;//      请求地址      String url = &quot;https://www.httpbin.org/get&quot;;//      请求器      RequestQueue requestQueue = Volley.newRequestQueue(this);//      请求对象      StringRequest stringRequest = new StringRequest(url,              new Response.Listener&lt;String&gt;() &#123;//                  请求成功时                  @Override                  public void onResponse(String response) &#123;                      Log.d(TAG, &quot;onResponse: &quot; + response);                  &#125;              &#125;,              new Response.ErrorListener() &#123;//                  请求失败时                  @Override                  public void onErrorResponse(VolleyError error) &#123;                      Log.d(TAG, &quot;onErrorResponse: &quot; + error);                  &#125;              &#125;);//      把请求对象添加进请求器，当有多个请求对象时，完全可以添加进一个请求器      requestQueue.add(stringRequest);  &#125;
POST请求&ensp;&ensp;使用Volley发送一条post请求  private void sendPost() &#123;      String url = &quot;https://www.httpbin.org/post&quot;;//      请求器      RequestQueue requestQueue = Volley.newRequestQueue(this);//      请求对象，注意这里添加了Request.Method.Post参数      StringRequest stringRequest = new StringRequest(Request.Method.POST, url,              new Response.Listener&lt;String&gt;() &#123;//                  请求成功时                  @Override                  public void onResponse(String response) &#123;                      Log.d(TAG, &quot;onResponse: &quot; + response);                  &#125;              &#125;,              new Response.ErrorListener() &#123;//                  请求失败时                  @Override                  public void onErrorResponse(VolleyError error) &#123;                      Log.d(TAG, &quot;onErrorResponse: &quot; + error);                  &#125;              &#125;)&#123;//          重写getParams方法，以此获得POST参数          @Nullable          @Override          protected Map&lt;String, String&gt; getParams() throws AuthFailureError &#123;              Map&lt;String, String&gt; map = new HashMap&lt;&gt;();              map.put(&quot;value1&quot;,&quot;1111&quot;);              return map;          &#125;      &#125;;      requestQueue.add(stringRequest);  &#125;
JsonRequest请求Json格式的数据//  这样返回的直接就是一个Json对象  private void sendJson() &#123;      String url = &quot;https://www.httpbin.org/get&quot;;      RequestQueue requestQueue = Volley.newRequestQueue(this);      JsonObjectRequest jsonObjectRequest = new JsonObjectRequest(url,              new Response.Listener&lt;JSONObject&gt;() &#123;                  @Override                  public void onResponse(JSONObject response) &#123;                      try &#123;                          Log.d(TAG, &quot;onResponse: &quot; + response.getString(&quot;origin&quot;));                      &#125; catch (JSONException e) &#123;                          e.printStackTrace();                      &#125;                  &#125;              &#125;,              new Response.ErrorListener() &#123;                  @Override                  public void onErrorResponse(VolleyError error) &#123;                      Log.d(TAG, &quot;onErrorResponse: &quot; + error);                  &#125;              &#125;);      requestQueue.add(jsonObjectRequest);  &#125;
加载图片ImageRequest    private void loadImageView() &#123;        String url = &quot;https://www.httpbin.org/image/png&quot;;        RequestQueue requestQueue = Volley.newRequestQueue(this);        ImageRequest imageRequest = new ImageRequest(url,                new Response.Listener&lt;Bitmap&gt;() &#123;//                    请求成功时加载请求到的图片                    @Override                    public void onResponse(Bitmap response) &#123;                        imageView.setImageBitmap(response);                    &#125;                &#125;, 1000, 100, Bitmap.Config.ARGB_8888, //最大宽度，最大高度，图片画质                new Response.ErrorListener() &#123;//                    失败时加载的图片                    @Override                    public void onErrorResponse(VolleyError error) &#123;                        imageView.setImageResource(R.drawable.ic_launcher_background);                    &#125;                &#125;);        requestQueue.add(imageRequest);    &#125;
ImageLoader&ensp;&ensp;ImageLoader更牛逼的地方是它可以指定加载完毕前和加载失败后显示的图片，同时建立图片缓存    private void loadImageView() &#123;        String url = &quot;https://www.httpbin.org/image/png&quot;;        RequestQueue requestQueue = Volley.newRequestQueue(this);//        创建一个ImageLoader对象        ImageLoader imageLoader = new ImageLoader(requestQueue, new ImageLoader.ImageCache() &#123;            @Nullable            @Override            public Bitmap getBitmap(String url) &#123;                return null;            &#125;            @Override            public void putBitmap(String url, Bitmap bitmap) &#123;            &#125;        &#125;);//        图片监听器，指定网络图片加载成功之前显示的图片，和加载失败时显示的图片        ImageLoader.ImageListener imageListener = ImageLoader.getImageListener(imageView,                R.drawable.ic_launcher_foreground,R.drawable.ic_launcher_background);//        指定图片链接，指定监听器，指定最大宽高        imageLoader.get(url, imageListener, 1000, 1000);    &#125;
&ensp;&ensp;现在是一个空的ImageLoader，如果要实现缓存，需要重写它public class BitmapCache implements ImageLoader.ImageCache&#123;    private LruCache&lt;String, Bitmap&gt; lruCache;    public BitmapCache() &#123;        int maxSize = 10 * 1024 * 1024;        lruCache = new LruCache&lt;String, Bitmap&gt;(maxSize) &#123;            @Override            protected int sizeOf(String key, Bitmap bitmap) &#123;                return bitmap.getRowBytes() * bitmap.getHeight();            &#125;        &#125;;    &#125;    @Nullable    @Override    public Bitmap getBitmap(String url) &#123;        return lruCache.get(url);    &#125;    @Override    public void putBitmap(String url, Bitmap bitmap) &#123;        lruCache.put(url, bitmap);    &#125;&#125;
&ensp;&ensp;ImageLoader这样的话就是    private void loadImageView() &#123;        String url = &quot;https://www.httpbin.org/image/png&quot;;        RequestQueue requestQueue = Volley.newRequestQueue(this);//        创建一个ImageLoader对象        ImageLoader imageLoader = new ImageLoader(requestQueue, new BitmapCache());//        图片监听器，指定网络图片加载成功之前显示的图片，和加载失败时显示的图片        ImageLoader.ImageListener imageListener = ImageLoader.getImageListener(imageView,                R.drawable.ic_launcher_foreground,R.drawable.ic_launcher_background);//        指定图片链接，指定监听器，指定最大宽高        imageLoader.get(url, imageListener, 1000, 1000);    &#125;	    public class BitmapCache implements ImageLoader.ImageCache&#123;        private LruCache&lt;String, Bitmap&gt; lruCache;        public BitmapCache() &#123;            int maxSize = 10 * 1024 * 1024;            lruCache = new LruCache&lt;String, Bitmap&gt;(maxSize) &#123;                @Override                protected int sizeOf(String key, Bitmap bitmap) &#123;                    return bitmap.getRowBytes() * bitmap.getHeight();                &#125;            &#125;;        &#125;        @Nullable        @Override        public Bitmap getBitmap(String url) &#123;            return lruCache.get(url);        &#125;        @Override        public void putBitmap(String url, Bitmap bitmap) &#123;            lruCache.put(url, bitmap);        &#125;    &#125;
NetworkImageView&ensp;&ensp;首先需要在布局文件中添加NetworkImageView&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;    android:gravity=&quot;center&quot;    tools:context=&quot;.volley.VolleyActivity&quot;&gt;    &lt;com.android.volley.toolbox.NetworkImageView        android:id=&quot;@+id/networkImageView&quot;        android:layout_width=&quot;50dp&quot;        android:layout_height=&quot;50dp&quot;/&gt;&lt;/LinearLayout&gt;
&ensp;&ensp;加载图片    private void loadImageView() &#123;        String url = &quot;https://www.httpbin.org/image/png&quot;;        RequestQueue requestQueue = Volley.newRequestQueue(this);        ImageLoader imageLoader = new ImageLoader(requestQueue, new BitmapCache());//        加载完毕前显示的图片        networkImageView.setDefaultImageResId(R.drawable.ic_launcher_foreground);//        加载失败时显示的图片        networkImageView.setErrorImageResId(R.drawable.ic_launcher_background);//        加载图片        networkImageView.setImageUrl(url,imageLoader);    &#125;    public class BitmapCache implements ImageLoader.ImageCache&#123;        private LruCache&lt;String, Bitmap&gt; lruCache;        public BitmapCache() &#123;            int maxSize = 10 * 1024 * 1024;            lruCache = new LruCache&lt;String, Bitmap&gt;(maxSize) &#123;                @Override                protected int sizeOf(String key, Bitmap bitmap) &#123;                    return bitmap.getRowBytes() * bitmap.getHeight();                &#125;            &#125;;        &#125;        @Nullable        @Override        public Bitmap getBitmap(String url) &#123;            return lruCache.get(url);        &#125;        @Override        public void putBitmap(String url, Bitmap bitmap) &#123;            lruCache.put(url, bitmap);        &#125;    &#125;
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android插件</tag>
      </tags>
  </entry>
  <entry>
    <title>Android dp、px互转</title>
    <url>/2021/12/01/Android-dp%E3%80%81px%E4%BA%92%E8%BD%AC/</url>
    <content><![CDATA[什么是dp：&ensp;&ensp;&ensp;&ensp;Device Independent Pixels(设备独立像素)，Android开发中常用dp来适配手机。不同的设备有不同的显示效果，当1英寸屏幕上有160个像素点（px）时，此时1dp=1px=1dpi。一般为了支持WVGA、HVGA和QVGA推荐使用dp，不依赖像素。
什么是px：&ensp;&ensp;&ensp;&ensp;Pixels，即像素，1px代表屏幕上的一个物理像素点。

dp转pxcontext.getResources().getDisplayMetrics().density可以得到在一个dpi区域中px的密度
//  dp值 x 区域密度 + 精度丢失值 = px值    public int dpToPx(double dp,Context context)&#123;        int px = (int)(dp * context.getResources().getDisplayMetrics().density + 0.5f);        return px;    &#125;
px转dp//  px值 / 区域密度 + 精度丢失值 = dp值    public int pxToDp(double px,Context context)&#123;        int dp = (int)(px/context.getResources().getDisplayMetrics().density + 0.5f);        return dp;    &#125;
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android开发手记</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-spinner</title>
    <url>/2021/12/08/Android-spinner/</url>
    <content><![CDATA[添加spinner控件&ensp;&ensp;&ensp;&ensp;在布局文件中插入&lt;spinner/&gt;标签&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout android:layout_width=&quot;match_parent&quot;    android:orientation=&quot;vertical&quot;    android:layout_height=&quot;match_parent&quot;    android:id=&quot;@+id/linearLayout&quot;    android:gravity=&quot;center&quot;    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;    &lt;Spinner        android:id=&quot;@+id/spinner&quot;        android:background=&quot;#ededed&quot;        android:layout_width=&quot;160dp&quot;        android:layout_height=&quot;wrap_content&quot;/&gt;&lt;/LinearLayout&gt;
android:entries&ensp;&ensp;&ensp;&ensp;静态绑定数据，在value目录下创建arrays.xml，向其&lt;resource/&gt;中加入&lt;string-array name=&quot;spinner_list_content&quot;&gt;    &lt;item&gt;java&lt;/item&gt;    &lt;item&gt;python&lt;/item&gt;    &lt;item&gt;c++&lt;/item&gt;    &lt;item&gt;php&lt;/item&gt;&lt;/string-array&gt;

&ensp;&ensp;&ensp;&ensp;在spinner的布局中引用android:entries=&quot;@array/spinner_list_content&quot;
android:spinnerMode&ensp;&ensp;&ensp;&ensp;有两种显示方式，下拉菜单和弹出框，通过android:spinnerMode设置android:spinnerMode=&quot;dropdown&quot;
android:spinnerMode=&quot;dialog&quot;

android:prompt&ensp;&ensp;&ensp;&ensp;dialog选择列表时的提示，在xml中选择这个字符串时只能调用string.xml中的值，不能直接填字真是操蛋android:prompt=&quot;@string/spinner_prompt&quot;
spinner的方法动态添加spinner列表    private void init() &#123;        spinner = findViewById(R.id.spinner);//        这个数组完全可以用List&lt;String&gt;取代        String[] starArray = new String[]&#123;&quot;java&quot;,&quot;python&quot;,&quot;kotlin&quot;,&quot;php&quot;&#125;;//        创建adapter        ArrayAdapter&lt;String&gt; arrayAdapter = new ArrayAdapter&lt;String&gt;(this,R.layout.support_simple_spinner_dropdown_item,starArray);//        设置adapter        spinner.setAdapter(arrayAdapter);    &#125;
设置顶部提示&ensp;&ensp;&ensp;&ensp;doalog模式下顶部的提示spinner.setPrompt(&quot;请选择一个语言&quot;);
默认选择项&ensp;&ensp;&ensp;&ensp;如果有添加选择监听器，会响应一次选择监听spinner.setSelection(0);
选择监听器&ensp;&ensp;&ensp;&ensp;选择列表项时响应spinner.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() &#123;    @Override    public void onItemSelected(AdapterView&lt;?&gt; adapterView, View view, int i, long l) &#123;        Toast.makeText(MainActivity.this,&quot;选择了&quot; + starArray[i],Toast.LENGTH_SHORT).show();    &#125;    @Override    public void onNothingSelected(AdapterView&lt;?&gt; adapterView) &#123; &#125;&#125;);
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-动画</title>
    <url>/2021/09/13/Android-%E5%8A%A8%E7%94%BB/</url>
    <content><![CDATA[逐帧动画&ensp;&ensp;逐帧动画就是一张张图片连起来形成的帧动画资源下载
创建1.往drawable中导入图片
2.创建xml文件
3.xml文件中的控件和属性&ensp;&ensp;animation-list: 根节点，包含了item子节点&ensp;&ensp;item: animation-list的子节点，每个item存放一张图片
&ensp;&ensp;android:drawable: 定义图片&ensp;&ensp;android:duration: 定义每张图的时间(毫秒)
&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;animation-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;    &lt;item android:drawable=&quot;@drawable/practice_1&quot; android:duration=&quot;100&quot;&gt;&lt;/item&gt;    &lt;item android:drawable=&quot;@drawable/practice_2&quot; android:duration=&quot;100&quot;&gt;&lt;/item&gt;    &lt;item android:drawable=&quot;@drawable/practice_3&quot; android:duration=&quot;100&quot;&gt;&lt;/item&gt;    &lt;item android:drawable=&quot;@drawable/practice_4&quot; android:duration=&quot;100&quot;&gt;&lt;/item&gt;    &lt;item android:drawable=&quot;@drawable/practice_5&quot; android:duration=&quot;100&quot;&gt;&lt;/item&gt;    &lt;item android:drawable=&quot;@drawable/practice_6&quot; android:duration=&quot;100&quot;&gt;&lt;/item&gt;    &lt;item android:drawable=&quot;@drawable/practice_7&quot; android:duration=&quot;100&quot;&gt;&lt;/item&gt;&lt;/animation-list&gt;
应用直接应用于控件背景&lt;LinearLayout android:layout_height=&quot;match_parent&quot;    android:layout_width=&quot;match_parent&quot;    android:orientation=&quot;vertical&quot;    android:background=&quot;@drawable/frame&quot;    android:id=&quot;@+id/linear&quot;    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;&lt;/LinearLayout&gt;
在java文件中使其“动”起来
//        获取动画的drawable资源        AnimationDrawable animationDrawable = (AnimationDrawable) linearLayout.getBackground();//        启动动画        animationDrawable.start();//        停止动画//        animationDrawable.stop();
import android.graphics.drawable.AnimationDrawable;import android.os.Bundle;import android.widget.LinearLayout;public class MainActivity extends AppCompatActivity &#123;    private LinearLayout linearLayout;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        linearLayout = findViewById(R.id.linear);//        获取动画的drawable资源        AnimationDrawable animationDrawable = (AnimationDrawable) linearLayout.getBackground();//        启动动画        animationDrawable.start();//        停止动画//        animationDrawable.stop();    &#125;&#125;
补间动画
alpha: 透明度
rotate: 旋转
scale: 缩放
translate: 平移

属性动画太无聊了动画这个东西，以后有时间再写
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-多入口多进程</title>
    <url>/2023/03/21/Android-%E5%A4%9A%E5%85%A5%E5%8F%A3%E5%A4%9A%E8%BF%9B%E7%A8%8B/</url>
    <content><![CDATA[&ensp;&ensp;在清单文件中，给另一个Activity添加如下内容，设置为桌面启动入口&lt;intent-filter&gt;    &lt;action android:name=&quot;android.intent.action.MAIN&quot;/&gt;    &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;/&gt;&lt;/intent-filter&gt;
&ensp;&ensp;清单文件中如下所示，两个Activity都存在上面intent-filter以及其中的内容，安装后将会在桌面显示两个应用图标&ensp;&ensp;现在启动两个桌面图标会进入同一个Activity，先注册哪个Activity为启动入口，两个图标启动后都会进入这个Activity&lt;application    android:allowBackup=&quot;true&quot;    android:label=&quot;@string/app_name&quot;    android:icon=&quot;@drawable/app_icon&quot;    android:theme=&quot;@style/AppTheme&quot;&gt;    &lt;activity        android:name=&quot;.MainActivity&quot;        android:exported=&quot;true&quot; &gt;        &lt;intent-filter&gt;            &lt;action android:name=&quot;android.intent.action.MAIN&quot;/&gt;            &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;/&gt;        &lt;/intent-filter&gt;    &lt;/activity&gt;    &lt;!-- 如果不重新添加label和icon，将会使用application中对应的值 --&gt;    &lt;activity        android:label=&quot;@string/app_name2&quot;        android:icon=&quot;@drawable/app_icon2&quot;        android:name=&quot;.SplashActivity&quot;        android:exported=&quot;true&quot; &gt;        &lt;intent-filter&gt;            &lt;action android:name=&quot;android.intent.action.MAIN&quot;/&gt;            &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;/&gt;        &lt;/intent-filter&gt;    &lt;/activity&gt;&lt;/application&gt;
&ensp;&ensp;将其中一个Activity设置为默认启动页面，此时将无视Activity注册启动入口的先后顺序，两个图标启动后都会进入这个Activity&lt;intent-filter&gt;    &lt;!-- 加入这个标签的Activity，将会成为所有启动入口进入的页面 --&gt;    &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;    &lt;action android:name=&quot;android.intent.action.MAIN&quot;/&gt;    &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;/&gt;&lt;/intent-filter&gt;
&ensp;&ensp;如果给另一个Activity也设置为默认启动页面，那么又将以注册启动入口的先后顺序来决桌面图标启动进入的页面&lt;application    android:allowBackup=&quot;true&quot;    android:label=&quot;@string/app_name&quot;    android:icon=&quot;@drawable/app_icon&quot;    android:theme=&quot;@style/AppTheme&quot;&gt;    &lt;activity        android:name=&quot;.MainActivity&quot;        android:exported=&quot;true&quot; &gt;        &lt;intent-filter&gt;            &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;            &lt;action android:name=&quot;android.intent.action.MAIN&quot;/&gt;            &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;/&gt;        &lt;/intent-filter&gt;    &lt;/activity&gt;    &lt;!-- 如果不重新添加label和icon，将会使用application中定义的对应值 --&gt;    &lt;activity        android:label=&quot;@string/app_name2&quot;        android:icon=&quot;@drawable/app_icon2&quot;        android:name=&quot;.SplashActivity&quot;        android:exported=&quot;true&quot; &gt;        &lt;intent-filter&gt;            &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;            &lt;action android:name=&quot;android.intent.action.MAIN&quot;/&gt;            &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;/&gt;        &lt;/intent-filter&gt;    &lt;/activity&gt;&lt;/application&gt;
&ensp;&ensp;若要使两个启动图标打开不同的启动页面，需要给两个Activity定义不同的process属性，使两个Activity运行在不同的进程中&lt;application    android:allowBackup=&quot;true&quot;    android:label=&quot;@string/app_name&quot;    android:icon=&quot;@drawable/app_icon&quot;    android:theme=&quot;@style/AppTheme&quot;&gt;    &lt;!-- 该图标启动main进程 --&gt;    &lt;activity        android:name=&quot;.MainActivity&quot;        android:process=&quot;:process.main&quot;        android:exported=&quot;true&quot; &gt;        &lt;intent-filter&gt;            &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;            &lt;action android:name=&quot;android.intent.action.MAIN&quot;/&gt;            &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;/&gt;        &lt;/intent-filter&gt;    &lt;/activity&gt;    &lt;!-- 该图标启动splash进程 --&gt;    &lt;activity        android:label=&quot;@string/app_name2&quot;        android:icon=&quot;@drawable/app_icon2&quot;        android:name=&quot;.SplashActivity&quot;        android:process=&quot;:process.splash&quot;        android:exported=&quot;true&quot; &gt;        &lt;intent-filter&gt;            &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;            &lt;action android:name=&quot;android.intent.action.MAIN&quot;/&gt;            &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;/&gt;        &lt;/intent-filter&gt;    &lt;/activity&gt;&lt;/application&gt;
&ensp;&ensp;为Activity指定process属性后，还要为其指定单例运行模式，将launchMode设置为singleInstance&lt;application    android:allowBackup=&quot;true&quot;    android:label=&quot;@string/app_name&quot;    android:icon=&quot;@drawable/app_icon&quot;    android:theme=&quot;@style/AppTheme&quot;&gt;    &lt;!-- 该图标启动main进程 --&gt;    &lt;activity        android:name=&quot;.MainActivity&quot;        android:process=&quot;:process.main&quot;        android:launchMode=&quot;singleInstance&quot;        android:exported=&quot;true&quot; &gt;        &lt;intent-filter&gt;            &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;            &lt;action android:name=&quot;android.intent.action.MAIN&quot;/&gt;            &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;/&gt;        &lt;/intent-filter&gt;    &lt;/activity&gt;    &lt;!-- 该图标启动splash进程 --&gt;    &lt;activity        android:label=&quot;@string/app_name2&quot;        android:icon=&quot;@drawable/app_icon2&quot;        android:name=&quot;.SplashActivity&quot;        android:process=&quot;:process.splash&quot;        android:launchMode=&quot;singleInstance&quot;        android:exported=&quot;true&quot; &gt;        &lt;intent-filter&gt;            &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;            &lt;action android:name=&quot;android.intent.action.MAIN&quot;/&gt;            &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;/&gt;        &lt;/intent-filter&gt;    &lt;/activity&gt;&lt;/application&gt;
&ensp;&ensp;全部设置完毕后，此时该应用的两个图标将进入两个不同的Activity&ensp;&ensp;需要注意的是,多个进程会创建多个Application对象，执行多次OnCreate方法
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android开发手记</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-布局</title>
    <url>/2021/09/09/Android-%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[一、LinearLayout(线性布局)常用属性
orientation: 布局中组件的排列方式
gravity: 控制组件所包含的子元素的对齐方式
layout_gravity: 控制该组件在父容器里的对齐方式
background: 设置背景，可以是颜色
divider: 分割线
showDivider: 设置分割线位置，none(无),beginning(开始),end结束),middle(每两个组件之间)
dividerPadding: 设置分割线的padding
layout_weight: 权重，按比例划分空间

二、RelativeLayout(相对布局)常用属性根据父容器定位
layout_alignParentLeft: 与父容器左对齐
layout_alignParentRight: 与父容器右对齐
layout_alignParentTop: 与父容器顶部对齐
layout_alignParentBottom: 与父容器底部对齐
layout_centerHorizontal: 水平居中与父容器
layout_centerVertical: 垂直居中于父容器
layout_centerParent: 居中于父容器

根据兄弟组件定位
layout_toLeftOf: 放置于参考组件左侧
layout_tuRightOf: 放置于参考组件右侧
layout_above: 放置于参考组件上方
layout_below: 放置于参考组件下方
layout_alignTop: 对齐参考组件上边界
layout_alignBottom: 对齐参考组件下边界
layout_alignLeft: 对齐参考组件左边界
layout_alignRight: 对齐参考组件右边界
layout_alignBaseline: 该控件的baseline(基线)和指定控件的baseline对齐

三、FrameLayout(帧布局)常用属性
foreground: 设置前景
foregroundGravity: 设置前景位置

四、TableLayout(表格布局)一般和TableRow结合使用
常用属性
collapseColumns: 设置需要被隐藏的列的序号，从0开始
stretchColumns: 设置允许被拉伸的列的序号，从0开始
shrinkColumns: 设置允许被收缩的列的序号，从0开始

子控件设置属性
layout_column: 显示在第几列
layout_ span: 横向跨几列

五、GridLayout(网格布局)常用属性
android:columnCount: 最大列数
android:rowCount: 最大行数
android:orientation: 布局方向

子控件设置属性
layout_column: 组件显示在第几列
layout_columnSpan: 横向跨几列
layout_columnWeight: 组件垂直方向权重
layout_gravity: 组件的对齐方式
layout_row: 组件显示在第几行
layout_rowSpan: 横向跨几行
layout_rowWeight: 组件向权重

通过layout_rowSpan和layout_columnSpan设置跨越的列数和行数后，通过layout_gravity=”fill”即可将该组件填满所跨越的整行或整列
通过网格布局设置响应式工具栏通过对GridLayouy的columnCount和rowCount设置，达到响应式工具栏1.当手机屏幕时，设置columnCount为4，此时显示两行四列2.当平板电脑屏幕时，设置columnCount为6，此时显示一行六列
&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;GridLayout    android:background=&quot;#12fa21&quot;    android:columnCount=&quot;4&quot;    android:rowCount=&quot;2&quot;    android:id=&quot;@+id/grid&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;200dp&quot;&gt;    &lt;LinearLayout        android:layout_columnWeight=&quot;1&quot;        android:gravity=&quot;center&quot;        android:layout_rowWeight=&quot;1&quot;&gt;        &lt;ImageView            android:src=&quot;@mipmap/ic_launcher&quot;            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;match_parent&quot;/&gt;    &lt;/LinearLayout&gt;    &lt;LinearLayout        android:layout_columnWeight=&quot;1&quot;        android:gravity=&quot;center&quot;        android:layout_rowWeight=&quot;1&quot;&gt;        &lt;ImageView            android:src=&quot;@mipmap/ic_launcher&quot;            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;match_parent&quot;/&gt;    &lt;/LinearLayout&gt;    &lt;LinearLayout        android:layout_columnWeight=&quot;1&quot;        android:gravity=&quot;center&quot;        android:layout_rowWeight=&quot;1&quot;&gt;        &lt;ImageView            android:src=&quot;@mipmap/ic_launcher&quot;            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;match_parent&quot;/&gt;    &lt;/LinearLayout&gt;    &lt;LinearLayout        android:layout_columnWeight=&quot;1&quot;        android:gravity=&quot;center&quot;        android:layout_rowWeight=&quot;1&quot;&gt;        &lt;ImageView            android:src=&quot;@mipmap/ic_launcher&quot;            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;match_parent&quot;/&gt;    &lt;/LinearLayout&gt;    &lt;LinearLayout        android:layout_columnWeight=&quot;1&quot;        android:gravity=&quot;center&quot;        android:layout_rowWeight=&quot;1&quot;&gt;        &lt;ImageView            android:src=&quot;@mipmap/ic_launcher&quot;            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;match_parent&quot;/&gt;    &lt;/LinearLayout&gt;    &lt;LinearLayout        android:layout_columnWeight=&quot;1&quot;        android:gravity=&quot;center&quot;        android:layout_rowWeight=&quot;1&quot;&gt;        &lt;ImageView            android:src=&quot;@mipmap/ic_launcher&quot;            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;match_parent&quot;/&gt;    &lt;/LinearLayout&gt;    &lt;LinearLayout        android:layout_columnWeight=&quot;1&quot;        android:gravity=&quot;center&quot;        android:layout_rowWeight=&quot;1&quot;&gt;        &lt;ImageView            android:src=&quot;@mipmap/ic_launcher&quot;            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;match_parent&quot;/&gt;    &lt;/LinearLayout&gt;    &lt;LinearLayout        android:layout_columnWeight=&quot;1&quot;        android:gravity=&quot;center&quot;        android:layout_rowWeight=&quot;1&quot;&gt;        &lt;ImageView            android:src=&quot;@mipmap/ic_launcher&quot;            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;match_parent&quot;/&gt;    &lt;/LinearLayout&gt;&lt;/GridLayout&gt;
六、ConstraintLayout(约束布局)学尼玛，不学了
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-底部弹出的dialog</title>
    <url>/2021/12/08/Android-%E5%BA%95%E9%83%A8%E5%BC%B9%E5%87%BA%E7%9A%84dialog/</url>
    <content><![CDATA[比如，修改QQ头像时
弹窗的样式&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout android:layout_height=&quot;match_parent&quot;    android:layout_width=&quot;match_parent&quot;    android:orientation=&quot;vertical&quot;    android:background=&quot;#fff&quot;    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;    &lt;TextView        android:text=&quot;拍摄&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;48dp&quot;        android:textSize=&quot;18sp&quot;        android:textStyle=&quot;bold&quot;        android:textColor=&quot;#000000&quot;        android:gravity=&quot;center&quot;/&gt;    &lt;View        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;1dp&quot;        android:background=&quot;@android:color/darker_gray&quot;/&gt;    &lt;TextView        android:text=&quot;相册选择&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;48dp&quot;        android:textSize=&quot;18sp&quot;        android:textStyle=&quot;bold&quot;        android:textColor=&quot;#000000&quot;        android:gravity=&quot;center&quot;/&gt;    &lt;View        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;5dp&quot;        android:background=&quot;@android:color/darker_gray&quot;/&gt;    &lt;TextView        android:text=&quot;取消&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;48dp&quot;        android:textSize=&quot;18sp&quot;        android:textStyle=&quot;bold&quot;        android:textColor=&quot;#000000&quot;        android:gravity=&quot;center&quot;/&gt;&lt;/LinearLayout&gt;
进入动画和退出动画&ensp;&ensp;&ensp;&ensp;进入动画&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;    &lt;translate        android:duration=&quot;300&quot;        android:fromXDelta=&quot;0&quot;        android:fromYDelta=&quot;1000&quot;        android:toXDelta=&quot;0&quot;        android:toYDelta=&quot;0&quot;/&gt;&lt;/set&gt;
&ensp;&ensp;&ensp;&ensp;推出动画&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;    &lt;translate        android:duration=&quot;300&quot;        android:fromXDelta=&quot;0&quot;        android:fromYDelta=&quot;0&quot;        android:toYDelta=&quot;1000&quot;        android:toXDelta=&quot;0&quot;/&gt;&lt;/set&gt;
样式和动画&ensp;&ensp;&ensp;&ensp;在styles.xml中定义dialog的样式&lt;!--  dialog的样式，继承自@andorid:style/Theme.Dialog  --&gt;&lt;style name=&quot;DialogStyle&quot; parent=&quot;@android:style/Theme.Dialog&quot;&gt;    &lt;!--    半透明    --&gt;    &lt;item name=&quot;android:windowIsTranslucent&quot;&gt;true&lt;/item&gt;    &lt;!--    悬浮在Activity之上    --&gt;    &lt;item name=&quot;android:windowIsFloating&quot;&gt;true&lt;/item&gt;    &lt;!--    背景颜色    --&gt;    &lt;item name=&quot;android:windowBackground&quot;&gt;@android:color/transparent&lt;/item&gt;    &lt;!--    遮罩层    --&gt;    &lt;item name=&quot;android:backgroundDimAmount&quot;&gt;0.5&lt;/item&gt;    &lt;!--    模糊    --&gt;    &lt;item name=&quot;android:backgroundDimEnabled&quot;&gt;true&lt;/item&gt;    &lt;!--    无标题    --&gt;    &lt;item name=&quot;android:windowNoTitle&quot;&gt;true&lt;/item&gt;    &lt;!--    边框    --&gt;    &lt;item name=&quot;android:windowFrame&quot;&gt;@null&lt;/item&gt;&lt;/style&gt;
&ensp;&ensp;&ensp;&ensp;上边这是抄的别人的，其实我觉得没这么麻烦，可能是因为我的sdk版本不同吧，在我的@andorid:style/Theme.Dialog父样式中，有几个属性是自然存在的，所以不需要再次申明&ensp;&ensp;&ensp;&ensp;甚至只存在一个“背景颜色”，显示依然正常&lt;!--  dialog的样式，继承自@andorid:style/Theme.Dialog  --&gt;&lt;style name=&quot;DialogStyle&quot; parent=&quot;@android:style/Theme.Dialog&quot;&gt;    &lt;!--    半透明    --&gt;    &lt;item name=&quot;android:windowIsTranslucent&quot;&gt;true&lt;/item&gt;    &lt;!--    背景颜色    --&gt;    &lt;item name=&quot;android:windowBackground&quot;&gt;@android:color/transparent&lt;/item&gt;    &lt;!--    遮罩层    --&gt;    &lt;item name=&quot;android:backgroundDimAmount&quot;&gt;0.5&lt;/item&gt;&lt;/style&gt;
&ensp;&ensp;&ensp;&ensp;添加进入动画和退出动画&lt;!--  dialog的动画  --&gt;&lt;style name=&quot;dialog_anim&quot;&gt;    &lt;item name=&quot;android:windowEnterAnimation&quot;&gt;@anim/dialog_in&lt;/item&gt;    &lt;item name=&quot;android:windowExitAnimation&quot;&gt;@anim/dialog_out&lt;/item&gt;&lt;/style&gt;
调用弹窗显示    public void showDialog(View view) &#123;//        实例化dialog,传入content和弹窗样式        Dialog dialog = new Dialog(this,R.style.DialogStyle);//        获取到dialog的布局文件        View view1 = View.inflate(this,R.layout.dialog,null);        dialog.setContentView(view1);//设置布局        Window window = dialog.getWindow();//获取window        window.setGravity(Gravity.BOTTOM);//显示在底部        window.setWindowAnimations(R.style.dialog_anim);//设置动画//        设置宽高        window.setLayout(ViewGroup.LayoutParams.MATCH_PARENT,ViewGroup.LayoutParams.WRAP_CONTENT);        dialog.show();//显示弹窗//        dialog.dismiss();//关闭弹窗    &#125;
&ensp;&ensp;&ensp;&ensp;效果
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android开发手记</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-悬浮窗</title>
    <url>/2022/01/29/Android-%E6%82%AC%E6%B5%AE%E7%AA%97/</url>
    <content><![CDATA[在清单文件中添加&lt;uses-permission android:name=&quot;android.permission.SYSTEM_ALERT_WINDOW&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.SYSTEM_OVERLAY_WINDOW&quot; /&gt;
动态申请权限    /**     * 请求悬浮窗权限     * @param activity Activity     * @param requestCode 请求码     */    public static void requestWindowPermission(Activity activity, int requestCode)&#123;//        Android版本是否在6之后        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M)&#123;//            是否已经拥有悬浮窗权限            if (Settings.canDrawOverlays(activity))&#123;                MyUtils.showToast(activity,&quot;已获得悬浮窗权限&quot;);            &#125;            else &#123;                MyUtils.showToast(activity,&quot;请赋予悬浮窗权限&quot;);//                跳转到授权页面                Intent intent = new Intent(Settings.ACTION_MANAGE_OVERLAY_PERMISSION);                intent.setData(Uri.parse(&quot;package:&quot; + activity.getPackageName()));                Log.d(TAG, &quot;requestWindowPermission: &quot; + intent.getData());                activity.startActivityForResult(intent,requestCode);            &#125;        &#125;        else &#123;//            Android6之前版本,不需要动态申请        &#125;    &#125;
悬浮窗控制类&ensp;&ensp;&ensp;&ensp;1.一些变量public class ControlFloatWindow &#123;    private View windowView; //悬浮窗view    private WindowManager.LayoutParams layoutParams; //悬浮窗布局管理    private WindowManager windowManager; //悬浮窗管理器    private static ControlFloatWindow controlFloatWindow; //当前类对象    private static Activity activity; //调用该类传入的activity&#125;
&ensp;&ensp;&ensp;&ensp;2.单例模式获取弹窗控制类的实例public class ControlFloatWindow &#123;    private View windowView; //悬浮窗view    private WindowManager.LayoutParams layoutParams; //悬浮窗布局管理    private WindowManager windowManager; //悬浮窗管理器    private static ControlFloatWindow controlFloatWindow; //当前类对象    private static Activity activity; //调用该类传入的activity	//    获取弹窗控制类的实例    public static ControlFloatWindow getInstance(Activity activity, View windowView)&#123;        if (controlFloatWindow == null || activity.isFinishing())&#123;            ControlFloatWindow.activity = activity;            controlFloatWindow = new ControlFloatWindow(activity, windowView);        &#125;        return controlFloatWindow;    &#125;	//    构造器    public ControlFloatWindow(Activity activity, View windowViw)&#123;        this.windowView = windowViw;        ControlFloatWindow.activity = activity;        initWindow(); //初始化弹窗    &#125;&#125;
&ensp;&ensp;&ensp;&ensp;3.初始化悬浮窗//    初始化弹窗    private void initWindow() &#123;        windowView.setOnTouchListener(new FloatingOnTouchListener()); //设置触摸监听//        定义构成        layoutParams = new WindowManager.LayoutParams(WindowManager.LayoutParams.WRAP_CONTENT, //window的宽                WindowManager.LayoutParams.WRAP_CONTENT, //window的高                0, //窗口类型                0, //窗口行为                PixelFormat.TRANSPARENT);//        设置窗口行为        layoutParams.flags = WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL                | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE                | WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED;//        设置窗口类型        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;            layoutParams.type = WindowManager.LayoutParams.TYPE_APPLICATION_OVERLAY;        &#125; else &#123;            layoutParams.type = WindowManager.LayoutParams.TYPE_PHONE;        &#125;        layoutParams.format = PixelFormat.RGBA_8888; //位图格式        layoutParams.gravity = Gravity.LEFT | Gravity.TOP; //窗口左对齐，顶部对其        layoutParams.x = 0; //与其x轴对其方向的边距        layoutParams.y = 0; //与其y轴对其方向的边距        windowManager = (WindowManager) activity.getSystemService(Context.WINDOW_SERVICE);    &#125;
&ensp;&ensp;&ensp;&ensp;4.创建FloatingOnTouchListener子类，该类继承View.OnTouchListener类//    跟随手指移动    class FloatingOnTouchListener implements View.OnTouchListener &#123;        private int startX;        private int startY;        @SuppressLint(&quot;ClickableViewAccessibility&quot;)        @Override        public boolean onTouch(View view, MotionEvent event) &#123;            switch (event.getAction()) &#123;                case MotionEvent.ACTION_DOWN:                    startX = (int) event.getRawX();                    startY = (int) event.getRawY();                    break;                case MotionEvent.ACTION_MOVE:                    int nowX = (int) event.getRawX();                    int nowY = (int) event.getRawY();                    int movedX = nowX - startX;                    int movedY = nowY - startY;                    startX = nowX;                    startY = nowY;                    layoutParams.x = layoutParams.x + movedX;                    layoutParams.y = layoutParams.y + movedY;                    // 更新悬浮窗                    windowManager.updateViewLayout(view, layoutParams);                    break;                default:                    break;            &#125;            return false;        &#125;    &#125;至此，悬浮窗创建完毕
&ensp;&ensp;&ensp;&ensp;5.悬浮窗显示、删除、更新//    添加悬浮窗    public void addView()&#123;        windowManager.addView(windowView, layoutParams);    &#125;//    移除悬浮窗    public void removeView()&#123;        windowManager.removeView(windowView);    &#125;//    更新悬浮窗    public void updateView()&#123;        windowManager.updateViewLayout(windowView, layoutParams);    &#125;
&ensp;&ensp;&ensp;&ensp;6.整体/** * 百变语音悬浮窗控制类 */public class ControlFloatWindow &#123;    private View windowView; //悬浮窗view    private WindowManager.LayoutParams layoutParams; //悬浮窗布局管理    private WindowManager windowManager; //悬浮窗管理器    @SuppressLint(&quot;StaticFieldLeak&quot;)    private static ControlFloatWindow controlFloatWindow; //当前类对象    @SuppressLint(&quot;StaticFieldLeak&quot;)    private static Activity activity; //调用该类传入的activity//    获取弹窗实例    public static ControlFloatWindow getInstance(Activity activity, View windowView)&#123;        if (controlFloatWindow == null || activity.isFinishing())&#123;            ControlFloatWindow.activity = activity;            controlFloatWindow = new ControlFloatWindow(activity, windowView);        &#125;        return controlFloatWindow;    &#125;//    构造器    public ControlFloatWindow(Activity activity, View windowViw)&#123;        this.windowView = windowViw;        ControlFloatWindow.activity = activity;        initWindow();    &#125;//    添加悬浮窗    public void addView()&#123;        windowManager.addView(windowView, layoutParams);    &#125;//    移除悬浮窗    public void removeView()&#123;        windowManager.removeView(windowView);    &#125;//    更新悬浮窗    public void updateView()&#123;        windowManager.updateViewLayout(windowView, layoutParams);    &#125;//    初始化弹窗    @SuppressLint(&quot;RtlHardcoded&quot;)    private void initWindow() &#123;        windowView.setOnTouchListener(new FloatingOnTouchListener()); //设置触摸监听，随手指移动//        定义构成        layoutParams = new WindowManager.LayoutParams(WindowManager.LayoutParams.WRAP_CONTENT, //window的宽                WindowManager.LayoutParams.WRAP_CONTENT, //window的高                0, //窗口类型                0, //窗口行为                PixelFormat.TRANSPARENT);//        设置窗口行为        layoutParams.flags = WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL                | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE                | WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED;//        设置窗口类型        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;            layoutParams.type = WindowManager.LayoutParams.TYPE_APPLICATION_OVERLAY;        &#125; else &#123;            layoutParams.type = WindowManager.LayoutParams.TYPE_PHONE;        &#125;        layoutParams.format = PixelFormat.RGBA_8888; //位图格式        layoutParams.gravity = Gravity.LEFT | Gravity.TOP; //窗口左对齐，顶部对其        layoutParams.x = 0; //与其x轴对其方向的边距        layoutParams.y = 0; //与其y轴对其方向的边距        windowManager = (WindowManager) activity.getSystemService(Context.WINDOW_SERVICE);    &#125;//    跟随手指移动    class FloatingOnTouchListener implements View.OnTouchListener &#123;        private int startX;        private int startY;        @SuppressLint(&quot;ClickableViewAccessibility&quot;)        @Override        public boolean onTouch(View view, MotionEvent event) &#123;            switch (event.getAction()) &#123;                case MotionEvent.ACTION_DOWN:                    startX = (int) event.getRawX();                    startY = (int) event.getRawY();                    break;                case MotionEvent.ACTION_MOVE:                    int nowX = (int) event.getRawX();                    int nowY = (int) event.getRawY();                    int movedX = nowX - startX;                    int movedY = nowY - startY;                    startX = nowX;                    startY = nowY;                    layoutParams.x = layoutParams.x + movedX;                    layoutParams.y = layoutParams.y + movedY;                    // 更新悬浮窗                    windowManager.updateViewLayout(view, layoutParams);                    break;                default:                    break;            &#125;            return false;        &#125;    &#125;&#125;
&ensp;&ensp;&ensp;&ensp;7.调用//        悬浮窗的view        View windowView = LayoutInflater.from(this).inflate(R.layout.float_window, null);//        获取悬浮窗控制类实例        ControlFloatWindow windowInstance = ControlFloatWindow.getInstance(this, windowView);//        添加悬浮窗        windowInstance.addView();//        移除悬浮窗        windowInstance.removeView();//        更新悬浮窗        windowInstance.updatView();
WindowManager.LayoutParams详解&ensp;&ensp;&ensp;&ensp;该类继承自ViewGroup.LayoutParams。
窗口类型(type)的取值主要有三种类型1.Applicationwindows：&ensp;&ensp;&ensp;&ensp;取值在 FIRST_APPLICATION_WINDOW 和 LAST_APPLICATION_WINDOW 之间。&ensp;&ensp;&ensp;&ensp;是通常的、顶层的应用程序窗口。必须将 token 设置成 activity 的 token 。
2.Sub_windows：&ensp;&ensp;&ensp;&ensp;取值在 FIRST_SUB_WINDOW 和 LAST_SUB_WINDOW 之间。&ensp;&ensp;&ensp;&ensp;与顶层窗口相关联，token 必须设置为它所附着的宿主窗口的 token。
3.Systemwindows：&ensp;&ensp;&ensp;&ensp;取值在 FIRST_SYSTEM_WINDOW 和 LAST_SYSTEM_WINDOW 之间。&ensp;&ensp;&ensp;&ensp;用于特定的系统功能。它不能用于应用程序，使用时需要特殊权限。
type的取值&ensp;&ensp;&ensp;&ensp;应用程序窗口。public static final int FIRST_APPLICATION_WINDOW = 1;
&ensp;&ensp;&ensp;&ensp;所有程序窗口的“基地”窗口，其他应用程序窗口都显示在它上面。public static final int TYPE_BASE_APPLICATION =1;       
&ensp;&ensp;&ensp;&ensp;普通应用功能程序窗口。token必须设置为Activity的token，以指出该窗口属谁。public static final int TYPE_APPLICATION = 2;
&ensp;&ensp;&ensp;&ensp;用于应用程序启动时所显示的窗口。应用本身不要使用这种类型。&ensp;&ensp;&ensp;&ensp;它用于让系统显示些信息，直到应用程序可以开启自己的窗口。public static final int  TYPE_APPLICATION_STARTING = 3;
&ensp;&ensp;&ensp;&ensp;应用程序窗口结束。public static final int LAST_APPLICATION_WINDOW = 99;
&ensp;&ensp;&ensp;&ensp;子窗口。子窗口的Z序和坐标空间都依赖于他们的宿主窗口。public static final int FIRST_SUB_WINDOW = 1000;
&ensp;&ensp;&ensp;&ensp;面板窗口，显示于宿主窗口上层。public static final int TYPE_APPLICATION_PANEL = FIRST_SUB_WINDOW;
&ensp;&ensp;&ensp;&ensp;媒体窗口，例如视频。显示于宿主窗口下层。public static final int TYPE_APPLICATION_MEDIA = FIRST_SUB_WINDOW+1;
&ensp;&ensp;&ensp;&ensp;应用程序窗口的子面板。显示于所有面板窗口的上层。（GUI的一般规律，越“子”越靠上）public static final int TYPE_APPLICATION_SUB_PANEL = FIRST_SUB_WINDOW + 2;
&ensp;&ensp;&ensp;&ensp;对话框。类似于面板窗口，绘制类似于顶层窗口，而不是宿主的子窗口。public static final int TYPE_APPLICATION_ATTACHED_DIALOG = FIRST_SUB_WINDOW +3;
&ensp;&ensp;&ensp;&ensp;媒体信息。显示在媒体层和程序窗口之间，需要实现透明（半透明）效果。（例如显示字幕）public static final int TYPE_APPLICATION_MEDIA_OVERLAY = FIRST_SUB_WINDOW +4;
&ensp;&ensp;&ensp;&ensp;子窗口结束。（ End of types of sub-windows ）public static final int LAST_SUB_WINDOW = 1999;
&ensp;&ensp;&ensp;&ensp;系统窗口。非应用程序创建。public static final int FIRST_SYSTEM_WINDOW = 2000;
&ensp;&ensp;&ensp;&ensp;状态栏。只能有一个状态栏；它位于屏幕顶端，其他窗口都位于它下方。public static final int TYPE_STATUS_BAR =  FIRST_SYSTEM_WINDOW;
&ensp;&ensp;&ensp;&ensp;搜索栏。只能有一个搜索栏；它位于屏幕上方。public static final int TYPE_SEARCH_BAR = FIRST_SYSTEM_WINDOW + 1;
&ensp;&ensp;&ensp;&ensp;电话窗口。它用于电话交互（特别是呼入）。它置于所有应用程序之上，状态栏之下。public static final int TYPE_PHONE = FIRST_SYSTEM_WINDOW + 2;
&ensp;&ensp;&ensp;&ensp;系统提示。它总是出现在应用程序窗口之上。public static final int TYPE_SYSTEM_ALERT =  FIRST_SYSTEM_WINDOW + 3;
&ensp;&ensp;&ensp;&ensp;锁屏窗口。public static final int TYPE_KEYGUARD = FIRST_SYSTEM_WINDOW + 4;
&ensp;&ensp;&ensp;&ensp;信息窗口。用于显示toast。public static final int TYPE_TOAST = FIRST_SYSTEM_WINDOW + 5;
&ensp;&ensp;&ensp;&ensp;系统顶层窗口。显示在其他一切内容之上。此窗口不能获得输入焦点，否则影响锁屏。public static final int TYPE_SYSTEM_OVERLAY = FIRST_SYSTEM_WINDOW + 6;
&ensp;&ensp;&ensp;&ensp;电话优先，当锁屏时显示。此窗口不能获得输入焦点，否则影响锁屏。public static final int TYPE_PRIORITY_PHONE = FIRST_SYSTEM_WINDOW + 7;
&ensp;&ensp;&ensp;&ensp;系统对话框。（例如音量调节框）。public static final int TYPE_SYSTEM_DIALOG = FIRST_SYSTEM_WINDOW + 8;
&ensp;&ensp;&ensp;&ensp;锁屏时显示的对话框。public static final int TYPE_KEYGUARD_DIALOG = FIRST_SYSTEM_WINDOW + 9;
&ensp;&ensp;&ensp;&ensp;系统内部错误提示，显示于所有内容之上。public static final int TYPE_SYSTEM_ERROR = FIRST_SYSTEM_WINDOW + 10;
&ensp;&ensp;&ensp;&ensp;内部输入法窗口，显示于普通UI之上。应用程序可重新布局以免被此窗口覆盖。public static final int TYPE_INPUT_METHOD = FIRST_SYSTEM_WINDOW + 11;
&ensp;&ensp;&ensp;&ensp;内部输入法对话框，显示于当前输入法窗口之上。public static final int TYPE_INPUT_METHOD_DIALOG = FIRST_SYSTEM_WINDOW + 2;
&ensp;&ensp;&ensp;&ensp;墙纸窗口。public static final int TYPE_WALLPAPER = FIRST_SYSTEM_WINDOW + 13;
&ensp;&ensp;&ensp;&ensp;状态栏的滑动面板。public static final int TYPE_STATUS_BAR_PANEL = FIRST_SYSTEM_WINDOW + 14;
&ensp;&ensp;&ensp;&ensp;系统窗口结束。public static final int LAST_SYSTEM_WINDOW = 2999;
窗口行为(flags)取值&ensp;&ensp;&ensp;&ensp;窗口之后的内容变暗。public static final int FLAG_DIM_BEHIND = 0x00000002;
&ensp;&ensp;&ensp;&ensp;窗口之后的内容变模糊。public static final int FLAG_BLUR_BEHIND = 0x00000004;
&ensp;&ensp;&ensp;&ensp;不许获得焦点。&ensp;&ensp;&ensp;&ensp;不能获得按键输入焦点，所以不能向它发送按键或按钮事件。那些时间将发送给它后面的可以获得焦点的窗口。此选项还会设置 FLAG_NOT_TOUCH_MODAL选项。设置此选项，意味着窗口不能与软输入法进行交互，所以它的Z序独立于任何活动的输入法（换句话说，它可以 全屏显示，如果需要的话，可覆盖输入法窗口）。要修改这一行为，可参考FLAG_ALT_FOCUSALBE_IM选项。public static final int FLAG_NOT_FOCUSABLE = 0x00000008;
&ensp;&ensp;&ensp;&ensp;不接受触摸屏事件。public static final int FLAG_NOT_TOUCHABLE = 0x00000010;
&ensp;&ensp;&ensp;&ensp;当窗口可以获得焦点（没有设置 FLAG_NOT_FOCUSALBE 选项）时，仍然将窗口范围之外的点设备事件（鼠标、触摸屏）发送给后面的窗口处理。否则它将独占所有的点设备事件，而不管它们是不是发生在窗口范围内。public static final int FLAG_NOT_TOUCH_MODAL = 0x00000020;
&ensp;&ensp;&ensp;&ensp;如果设置了这个标志，当设备休眠时，点击触摸屏，设备将收到这个第一触摸事件。&ensp;&ensp;&ensp;&ensp;通常第一触摸事件被系统所消耗，用户不会看到他们点击屏幕有什么反应。public static final int FLAG_TOUCHABLE_WHEN_WAKING = 0x00000040;
&ensp;&ensp;&ensp;&ensp;当此窗口为用户可见时，保持设备常开，并保持亮度不变。public static final int FLAG_KEEP_SCREEN_ON = 0x00000080;
&ensp;&ensp;&ensp;&ensp;窗口占满整个屏幕，忽略周围的装饰边框（例如状态栏）。此窗口需考虑到装饰边框的内容。public static final int FLAG_LAYOUT_IN_SCREEN = 0x00000100;
&ensp;&ensp;&ensp;&ensp;允许窗口扩展到屏幕之外。public static final int FLAG_LAYOUT_NO_LIMITS = 0x00000200;
&ensp;&ensp;&ensp;&ensp;窗口显示时，隐藏所有的屏幕装饰（例如状态条）。使窗口占用整个显示区域。public static final int FLAG_FULLSCREEN = 0x00000400;
&ensp;&ensp;&ensp;&ensp;此选项将覆盖FLAG_FULLSCREEN选项，并强制屏幕装饰（如状态条）弹出。public static final int FLAG_FORCE_NOT_FULLSCREEN = 0x00000800;
&ensp;&ensp;&ensp;&ensp;抖动。指 对半透明的显示方法。又称“点透”。图形处理较差的设备往往用“点透”替代Alpha混合。public static final int FLAG_DITHER = 0x00001000;
&ensp;&ensp;&ensp;&ensp;不允许屏幕截图。public static final int FLAG_SECURE = 0x00002000;
&ensp;&ensp;&ensp;&ensp;一种特殊模式，布局参数用于指示显示比例。public static final int FLAG_SCALED = 0x00004000;
&ensp;&ensp;&ensp;&ensp;当屏幕有可能贴着脸时，这一选项可防止面颊对屏幕造成误操作。public static final int FLAG_IGNORE_CHEEK_PRESSES = 0x00008000;
&ensp;&ensp;&ensp;&ensp;当请求布局时，你的窗口可能出现在状态栏的上面或下面，从而造成遮挡。当设置这一选项后，窗口管理器将确保窗口内容不会被装饰条（状态栏）盖住。public static final int FLAG_LAYOUT_INSET_DECOR = 0x00010000;
&ensp;&ensp;&ensp;&ensp;反转FLAG_NOT_FOCUSABLE选项。&ensp;&ensp;&ensp;&ensp;如果同时设置了FLAG_NOT_FOCUSABLE选项和本选项，窗口将能够与输入法交互，允许输入法窗口覆盖；&ensp;&ensp;&ensp;&ensp;如果FLAG_NOT_FOCUSABLE没有设置而设置了本选项，窗口不能与输入法交互，可以覆盖输入法窗口。public static final int FLAG_ALT_FOCUSABLE_IM = 0x00020000;
&ensp;&ensp;&ensp;&ensp;如果你设置了FLAG_NOT_TOUCH_MODAL，那么当触屏事件发生在窗口之外事，可以通过设置此标志接收到一个 MotionEvent.ACTION_OUTSIDE事件。注意，你不会收到完整的down/move/up事件，只有第一次down事件时可以收到 ACTION_OUTSIDE。public static final int FLAG_WATCH_OUTSIDE_TOUCH = 0x00040000;
&ensp;&ensp;&ensp;&ensp;当屏幕锁定时，窗口可以被看到。这使得应用程序窗口优先于锁屏界面。可配合FLAG_KEEP_SCREEN_ON选项点亮屏幕并直接显示在锁屏界面之前。可使用FLAG_DISMISS_KEYGUARD选项直接解除非加锁的锁屏状态。此选项只用于最顶层的全屏幕窗口。public static final int FLAG_SHOW_WHEN_LOCKED = 0x00080000;
&ensp;&ensp;&ensp;&ensp;请求系统墙纸显示在你的窗口后面。窗口必须是半透明的。public static final int FLAG_SHOW_WALLPAPER = 0x00100000;
&ensp;&ensp;&ensp;&ensp;窗口一旦显示出来，系统将点亮屏幕，正如用户唤醒设备那样。public static final int FLAG_TURN_SCREEN_ON = 0x00200000;
&ensp;&ensp;&ensp;&ensp;解除锁屏。只有锁屏界面不是加密的才能解锁。如果锁屏界面是加密的，那么用户解锁之后才能看到此窗口，除非设置了FLAG_SHOW_WHEN_LOCKED选项。public static final int FLAG_DISMISS_KEYGUARD = 0x00400000;
&ensp;&ensp;&ensp;&ensp;锁屏界面淡出时，继续运行它的动画。public static final int FLAG_KEEP_SURFACE_WHILE_ANIMATING = 0x10000000;
&ensp;&ensp;&ensp;&ensp;以原始尺寸显示窗口。用于在兼容模式下运行程序。public static final int FLAG_COMPATIBLE_WINDOW = 0x20000000;
&ensp;&ensp;&ensp;&ensp;用于系统对话框。设置此选项的窗口将无条件获得焦点。public static final int FLAG_SYSTEM_ERROR = 0x40000000;
窗口使用的内存缓冲类型(memoryType)&ensp;&ensp;&ensp;&ensp;窗口缓冲位于主内存。public static final int MEMORY_TYPE_NORMAL = 0;
&ensp;&ensp;&ensp;&ensp;窗口缓冲位于可以被DMA访问，或者硬件加速的内存区域。public static final int MEMORY_TYPE_HARDWARE = 1;
&ensp;&ensp;&ensp;&ensp;窗口缓冲位于可被图形加速器访问的区域。public static final int MEMORY_TYPE_GPU = 2;
&ensp;&ensp;&ensp;&ensp;窗口缓冲不拥有自己的缓冲区，不能被锁定。缓冲区由本地方法提供。public static final int MEMORY_TYPE_PUSH_BUFFERS = 3;
窗口输入法模式(softInputMode)&ensp;&ensp;&ensp;&ensp;软输入区域是否可见。public static final int SOFT_INPUT_MASK_STATE = 0x0f;
&ensp;&ensp;&ensp;&ensp;未指定状态。public static final int SOFT_INPUT_STATE_UNSPECIFIED = 0;
&ensp;&ensp;&ensp;&ensp;不要修改软输入法区域的状态。public static final int SOFT_INPUT_STATE_UNCHANGED = 1;
&ensp;&ensp;&ensp;&ensp;隐藏输入法区域（当用户进入窗口时）。public static final int SOFT_INPUT_STATE_HIDDEN = 2;
&ensp;&ensp;&ensp;&ensp;当窗口获得焦点时，隐藏输入法区域。public static final int SOFT_INPUT_STATE_ALWAYS_HIDDEN = 3;
&ensp;&ensp;&ensp;&ensp;显示输入法区域（当用户进入窗口时）。public static final int SOFT_INPUT_STATE_VISIBLE = 4;
&ensp;&ensp;&ensp;&ensp;当窗口获得焦点时，显示输入法区域。public static final int SOFT_INPUT_STATE_ALWAYS_VISIBLE = 5;
&ensp;&ensp;&ensp;&ensp;窗口应当主动调整，以适应软输入窗口。public static final int SOFT_INPUT_MASK_ADJUST = 0xf0;
&ensp;&ensp;&ensp;&ensp;未指定状态，系统将根据窗口内容尝试选择一个输入法样式。public static final int SOFT_INPUT_ADJUST_UNSPECIFIED = 0x00;
&ensp;&ensp;&ensp;&ensp;当输入法显示时，允许窗口重新计算尺寸，使内容不被输入法所覆盖。&ensp;&ensp;&ensp;&ensp;不可与SOFT_INPUT_ADJUSP_PAN混合使用,如果两个都没有设置，系统将根据窗口内容自动设置一个选项。public static final int SOFT_INPUT_ADJUST_RESIZE = 0x10;
&ensp;&ensp;&ensp;&ensp;输入法显示时平移窗口。它不需要处理尺寸变化，框架能够移动窗口以确保输入焦点可见。不可与SOFT_INPUT_ADJUST_RESIZE混合使用;如果两个都没设置,系统将根据窗口内容自动设置一个选项。public static final int SOFT_INPUT_ADJUST_PAN = 0x20;
&ensp;&ensp;&ensp;&ensp;当用户转至此窗口时，由系统自动设置，所以你不要设置它。&ensp;&ensp;&ensp;&ensp;当窗口显示之后该标志自动清除。public static final int SOFT_INPUT_IS_FORWARD_NAVIGATION = 0x100;
gravity;&ensp;&ensp;&ensp;&ensp;窗口如何停靠。public int gravity = Gravity.LEFT | Gravity.TOP;
horizontalMargin;&ensp;&ensp;&ensp;&ensp;水平边距，容器与widget之间的距离，占容器宽度的百分率。public float horizontalMargin = 0.3f;
verticalMargin;&ensp;&ensp;&ensp;&ensp;垂直边距，容器与height之间的距离，占容器宽度的百分率。public float verticalMargin = 0.3f;
format;&ensp;&ensp;&ensp;&ensp;期望的位图格式。默认为不透明。参考android.graphics.PixelFormat。public int format = PixelFormat.RGBA_8888;
windowAnimations;&ensp;&ensp;&ensp;&ensp;窗口所使用的动画设置。它必须是一个系统资源而不是应用程序资源，因为窗口管理器不能访问应用程序。
alpha&ensp;&ensp;&ensp;&ensp;整个窗口的半透明值，1.0表示不透明，0.0表示全透明。public float alpha = 1.0f;
dimAmount&ensp;&ensp;&ensp;&ensp;当FLAG_DIM_BEHIND设置后生效。该变量指示后面的窗口变暗的程度。&ensp;&ensp;&ensp;&ensp;1.0表示完全不透明，0.0表示没有变暗。public float dimAmount = 1.0f
screenBrightness&ensp;&ensp;&ensp;&ensp;用来覆盖用户设置的屏幕亮度。表示应用用户设置的屏幕亮度。&ensp;&ensp;&ensp;&ensp;从0到1调整亮度从暗到最亮发生变化。public float screenBrightness = -1.0f;
token&ensp;&ensp;&ensp;&ensp;窗口的标示符。( Identifier for this window. This will usually be filled in for you. )public IBinder token = null;
packageName&ensp;&ensp;&ensp;&ensp;此窗口所在的包名。public String packageName = null;
screenOrientation&ensp;&ensp;&ensp;&ensp;屏幕方向，参见android.content.pm.ActivityInfo#screenOrientation。public int screenOrientation =ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED;
其它可参考文章：https://blog.csdn.net/dongzhong1990/article/details/80512706https://www.jianshu.com/p/1b51368ca8a0
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android开发手记</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-文件储存</title>
    <url>/2021/09/25/Android-%E6%96%87%E4%BB%B6%E5%82%A8%E5%AD%98/</url>
    <content><![CDATA[Android版本与API级别关系对应表 
储存权限安卓的权限大概分三种

普通权限：只需要在清单文件中注册即可(例如网络权限)
危险权限：需要在代码中动态申请，以弹系统Dialog的形式进行请求(例如储存权限)
特殊权限：需要在代码中动态申请，以跳系统Activity的形式进行请求(例如安卓11中的所有文件访问权限)

关于储存权限

anroid 6之前，它是普通权限，在清单文件中注册即可
anroid 6-10之间，它是危险权限，需要以系统Dialog的形式请求
android 11后，它是特殊权限，需要跳转至系统的“所有文件访问权限”进行授权

这不是拿老子当猴耍吗

android 6前的储存权限很简单，在清单文件中注册即可&lt;!--    读取--&gt;&lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot; /&gt;&lt;!--    写入--&gt;&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt;
android 7-9的储存权限清单权限+Dialog动态申请
清单文件&lt;!--    读取--&gt;&lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot; /&gt;&lt;!--    写入--&gt;&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt;
动态申请，使用时调用RequestPermissions()方法即可//  权限动态申请  private void RequestPermissions() &#123;//      判断android版本是否大于安卓6      if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M)&#123;//          判断是否已经有储存权限(PackageManager.PERMISSION_GRANTED:已授权;PackageManager.PERMISSION_DENIED:未授权)          if (ActivityCompat.checkSelfPermission(this,Manifest.permission.READ_EXTERNAL_STORAGE) == PackageManager.PERMISSION_GRANTED          &amp;&amp; ActivityCompat.checkSelfPermission(this,Manifest.permission.WRITE_EXTERNAL_STORAGE) == PackageManager.PERMISSION_GRANTED)&#123;              Toast.makeText(this,&quot;已经拥有读取和储存权限&quot;,Toast.LENGTH_SHORT).show();          &#125;          else&#123;              ActivityCompat.requestPermissions(this,new String[]&#123;                      Manifest.permission.READ_EXTERNAL_STORAGE,                      Manifest.permission.WRITE_EXTERNAL_STORAGE              &#125;,1);//最后一个参数是请求码          &#125;      &#125;  &#125;//  回调判断是否赋予了请求的权限  @Override  public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123;      super.onRequestPermissionsResult(requestCode, permissions, grantResults);//      1就是上边的请求码      if (requestCode == 1)&#123;          if (ActivityCompat.checkSelfPermission(this,Manifest.permission.READ_EXTERNAL_STORAGE) == PackageManager.PERMISSION_GRANTED          &amp;&amp; ActivityCompat.checkSelfPermission(this,Manifest.permission.WRITE_EXTERNAL_STORAGE) == PackageManager.PERMISSION_GRANTED)&#123;              Toast.makeText(this,&quot;权限请求成功&quot;,Toast.LENGTH_SHORT).show();          &#125;          else &#123;              Toast.makeText(this,&quot;权限请求失败&quot;,Toast.LENGTH_SHORT).show();          &#125;      &#125;  &#125;
android 10的储存权限清单权限+Dialog动态申请
清单文件，如果不加入android:requestLegacyExternalStorage=”true”，在安卓 10.0 的设备无法正常读写外部存储的文件&lt;!--    读取--&gt;&lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot; /&gt;&lt;!--    写入--&gt;&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt;&lt;!--    并在application中加入--&gt;&lt;application    ...    android:requestLegacyExternalStorage=&quot;true&quot;&gt;	...&lt;/application&gt;
动态申请//  跟android 7-9一样，不赘述
android 11后的储存权限清单文件+Dialog动态申请+Activity跳转申请
清单文件&lt;!--    读取外部储存--&gt;&lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot; /&gt;&lt;!--    写入外部储存--&gt;&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt;&lt;!--    管理外部储存--&gt;&lt;uses-permission android:name=&quot;android.permission.MANAGE_EXTERNAL_STORAGE&quot; /&gt;&lt;!--    并在application中加入，使其做到安卓10兼容--&gt;&lt;application    ...    android:requestLegacyExternalStorage=&quot;true&quot;&gt;	...&lt;/application&gt;
动态申请//  权限动态申请  private void RequestPermissions() &#123;//      判断是否为安卓11      if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.R)&#123;//          判断是否已经有储存管理权限          if (Environment.isExternalStorageManager())&#123;              Toast.makeText(this,&quot;已经拥有储存管理权限&quot;,Toast.LENGTH_SHORT).show();          &#125;          else &#123;              Intent intent = new Intent(Settings.ACTION_MANAGE_APP_ALL_FILES_ACCESS_PERMISSION);//              根据包名打开特定应用程序的权限申请              intent.setData(Uri.parse(&quot;package:&quot; + this.getPackageName()));//              startActivityForResult主要用来从FirstActivity跳转到SecondActivity//              然后返回FirstActivity并且获取从SecondActivity传回来的参数              startActivityForResult(intent,1);//1是请求码          &#125;      &#125;//      判断android版本是否大于安卓6      else if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M)&#123;//          判断是否已经有储存权限(PackageManager.PERMISSION_GRANTED:已授权;PackageManager.PERMISSION_DENIED:未授权)          if (ActivityCompat.checkSelfPermission(this,Manifest.permission.READ_EXTERNAL_STORAGE) == PackageManager.PERMISSION_GRANTED          &amp;&amp; ActivityCompat.checkSelfPermission(this,Manifest.permission.WRITE_EXTERNAL_STORAGE) == PackageManager.PERMISSION_GRANTED)&#123;              Toast.makeText(this,&quot;已经拥有读取和储存权限&quot;,Toast.LENGTH_SHORT).show();          &#125;          else&#123;              ActivityCompat.requestPermissions(this,new String[]&#123;                      Manifest.permission.READ_EXTERNAL_STORAGE,                      Manifest.permission.WRITE_EXTERNAL_STORAGE              &#125;,1);//最后一个参数是请求码          &#125;      &#125;      else&#123;          Toast.makeText(this,&quot;版本小于Android 6，无需申请&quot;,Toast.LENGTH_SHORT).show();      &#125;  &#125;  @Override//  回调权限申请结果方法，判断是否赋予了请求的权限  public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123;      super.onRequestPermissionsResult(requestCode, permissions, grantResults);//      1就是上边的请求码      if (requestCode == 1)&#123;          if (ActivityCompat.checkSelfPermission(this,Manifest.permission.READ_EXTERNAL_STORAGE) == PackageManager.PERMISSION_GRANTED          &amp;&amp; ActivityCompat.checkSelfPermission(this,Manifest.permission.WRITE_EXTERNAL_STORAGE) == PackageManager.PERMISSION_GRANTED)&#123;              Toast.makeText(this,&quot;权限请求成功&quot;,Toast.LENGTH_SHORT).show();          &#125;          else &#123;              Toast.makeText(this,&quot;权限请求失败&quot;,Toast.LENGTH_SHORT).show();          &#125;      &#125;  &#125;  @Override//  进入另一个Activity再返回HomeActivity时回调该方法  protected void onActivityResult(int requestCode, int resultCode, @Nullable Intent data) &#123;      super.onActivityResult(requestCode, resultCode, data);      if (requestCode == 1 &amp;&amp; Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.R)&#123;          if (Environment.isExternalStorageManager())&#123;              Toast.makeText(this,&quot;储存管理权限请求成功&quot;,Toast.LENGTH_SHORT).show();          &#125;          else &#123;              Toast.makeText(this,&quot;储存管理权限请求失败&quot;,Toast.LENGTH_SHORT).show();          &#125;      &#125;  &#125;
内部储存随应用卸载被删除
data/data/packageName/目录下

/data/data/packageName/shared_prefs
/data/data/packageName/databases
/data/data/packageName/files
/data/data/packageName/cache

//获取/data/data/packageName/cachecontext.getCacheDir();//获取/data/data/packageName/filescontext.getFilesDir();
FileOutputStream(储存数据)打开输出流//  打开输出流。传入文件名，文件保护类型  FileOutputStream fileOutputStream = openFileOutput(&quot;fileName.txt&quot;,MODE_PRIVATE);
此时会提示捕获异常，根据提示操作即可//  添加异常捕获  try &#123;//      打开输出流，传入文件名，文件保护类型      FileOutputStream fileOutputStream = openFileOutput(&quot;fileName.txt&quot;,MODE_PRIVATE);  &#125; catch (FileNotFoundException e) &#123;      e.printStackTrace();  &#125;
将字符串转为字节组并写入内部储存//  字符串  String str = &quot;内部储存&quot;;//  添加异常捕获  try &#123;//      打开输出流，传入文件名，文件保护类型      FileOutputStream fileOutputStream = openFileOutput(&quot;fileName.txt&quot;,MODE_PRIVATE);//      它需要添加捕获异常      fileOutputStream.write(str.getBytes());  &#125; catch (IOException e) &#123;      e.printStackTrace();  &#125;
添加finally，并在其中执行关闭输出流  FileOutputStream fileOutputStream = null;//  字符串  String str = &quot;内部储存&quot;;  try &#123;//      打开输出流，传入文件名，文件保护类型      fileOutputStream = openFileOutput(&quot;fileName.txt&quot;,MODE_PRIVATE);//      它需要添加捕获异常      fileOutputStream.write(str.getBytes());  &#125; catch (IOException e) &#123;      e.printStackTrace();  &#125; finally &#123;      if (fileOutputStream != null)&#123;          try &#123;//              关闭输出流              fileOutputStream.close();          &#125; catch (IOException e) &#123;              e.printStackTrace();          &#125;      &#125;  &#125;
FileInputStream(读取数据)打开输入流  FileInputStream fileInputStream = null;//  打开输入流。传入需要读取的文件名  fileInputStream = openFileInput(&quot;fileName.txt&quot;);
添加异常捕获  FileInputStream fileInputStream = null;//  打开输入流。传入需要读取的文件名  try &#123;      fileInputStream = openFileInput(&quot;fileName.txt&quot;);  &#125; catch (FileNotFoundException e) &#123;      e.printStackTrace();  &#125;
定义字节组，创建字符串拼接对象//  定义字节组，1024表示最大储存1024字节，每次读取最多读1024字节  byte[] bytes = new byte[1024];//  用于字符串拼接  StringBuilder stringBuilder = new StringBuilder();//  本次读取的文件流的长度  int len;
循环读取文件字节组，并转换为字符串  FileInputStream fileInputStream = null;//  打开输入流。传入需要读取的文件名  try &#123;      fileInputStream = openFileInput(&quot;fileName.txt&quot;);//      定义字节组，1024表示最大储存1024字节，每次读取最多读1024字节      byte[] bytes = new byte[1024];//      字符串拼接      StringBuilder stringBuilder = new StringBuilder();//      本次读取的文件流的长度      int len;//      为0说明读完了      while ((len = fileInputStream.read(bytes)) &gt; 0)&#123;//          将读取的字节转换为字符串并添加到stringBuilder          stringBuilder.append(new String(bytes,0,len));      &#125;      Toast.makeText(this,stringBuilder.toString(),Toast.LENGTH_SHORT).show();  &#125; catch (FileNotFoundException e) &#123;      e.printStackTrace();  &#125; catch (IOException e) &#123;      e.printStackTrace();  &#125; finally &#123;      if (fileInputStream != null)&#123;          try &#123;//              关闭输入流              fileInputStream.close();          &#125; catch (IOException e) &#123;              e.printStackTrace();          &#125;      &#125;  &#125;
外部储存File类中:

getAbsolutePath()获取绝对路径
getPath()获取相对路径
getName()获取文件名
list()获取指定路径下所有文件（夹）名称数组
listFiles()获取指定目录下所有文件（夹）File数组

公有目录/storage/emulated/0/下的目录
获取公有目录//公有目录根目录Environment.getExternalStorageDirectory();//通过填入参数，例如Environment.DIRECTORY_DOWNLOADS可以得到download目录Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS)
私有目录私有目录随应用卸载而删除
/storage/emulated/0/Android/data/packageName目录下

缓存目录: /storage/emulated/0/Android/data/packageName/cache
文件目录: /storage/emulated/0/Android/data/packageName/files

FileOutputStream(储存数据)Environment.getExternalStorageDirectory()外部储存根目录mkdir()只可以创建一个文件夹，mkdirs()可以创建folder1/folder2/folder3一连串的文件夹//  获取外部储存根目录/myFolder路径  File folder = new File(Environment.getExternalStorageDirectory(),&quot;myFolder&quot;);//  folder文件夹中的fileName.txt  File file = new File(folder,&quot;fileName.txt&quot;);//  如果不存在  if (!folder.exists())&#123;//      新建文件夹      folder.mkdirs();  &#125;//  如果不存在  if(!file.exists())&#123;      file.createNewFile();  &#125;
外部储存使用new FileOutputStream创建输出流，而非打开  String str = &quot;外部储存&quot;;//          创建输出流变量  FileOutputStream fileOutputStream = null;  try &#123;//      获取外部储存根目录/文件夹路径作为对象      File path = new File(Environment.getExternalStorageDirectory(),&quot;lxx/gqtx&quot;);//      path路径下的文件      File file = new File(path,&quot;test.txt&quot;);//      路径是否存在，不存在则创建路径文件夹      if (!path.exists())&#123;          path.mkdirs();      &#125;//      文件是否存在，不存在则创建文件      if (!file.exists())&#123;          file.createNewFile();      &#125;//      创建输出流对象，打开输出流      fileOutputStream = new FileOutputStream(file);//      写入字节      fileOutputStream.write(str.getBytes());  &#125;catch (IOException e) &#123;      e.printStackTrace();  &#125; finally &#123;//      关闭输出流      if (fileOutputStream != null)&#123;          try &#123;              fileOutputStream.close();          &#125; catch (IOException e) &#123;              e.printStackTrace();          &#125;      &#125;  &#125;
FileInputStream(读取数据)外部储存使用new FileInputStream创建输入流，而非打开getAbsolutePath()会将Environment.getExternalStorageDirectory()的File文件对象类型转换为String//  创建输入流变量  FileInputStream fileInputStream = null;//  获取外部储存根目录/文件夹路径作为对象  File file = new File(Environment.getExternalStorageDirectory().getAbsolutePath() + File.separator + &quot;lxx/gqtx&quot;,&quot;test.txt&quot;);  try &#123;//      创建输入流对象，打开输入流      fileInputStream = new FileInputStream(file);//      创建字节组      byte[] bytes = new byte[1024];//      字符串缓冲区      StringBuilder stringBuilder = new StringBuilder();//      长度      int len;//      循环读取字符串      while ((len = fileInputStream.read(bytes)) &gt; 0)&#123;//          进入缓冲区          stringBuilder.append(new String(bytes,0,len));      &#125;//      Toast提示      Toast.makeText(this,stringBuilder.toString(),Toast.LENGTH_SHORT).show();  &#125; catch (IOException e) &#123;      e.printStackTrace();  &#125;
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android开发手记</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 时间和时间戳</title>
    <url>/2021/12/06/Android-%E6%97%B6%E9%97%B4%E5%92%8C%E6%97%B6%E9%97%B4%E6%88%B3/</url>
    <content><![CDATA[什么是时间戳&ensp;&ensp;&ensp;&ensp;时间戳是指格林威治时间1970年01月01日00时00分00秒(北京时间1970年01月01日08时00分00秒)起至现在的总毫秒数。通俗的讲，时间戳是一份能够表示一份数据在一个特定时间点已经存在的完整的可验证的数据
什么是标准格式化时间&ensp;&ensp;&ensp;&ensp;比如现在的时间，北京时间2021年12月6号10点57分54秒，对应的标准格式化时间就是“Mon Dec 06 10:57:54 GMT+08:00 2021”//  calendar.getTime()获取到的就是这一刻的标准格式化时间  Calendar calendar = Calendar.getInstance();  Log.d(&quot;标准格式化时间: &quot;,calendar.getTime());
时间转换为时间戳&ensp;&ensp;&ensp;&ensp;注意下，Calendar的getTime（）得到的是标准格式化时间，而在这里date已经是标准格式化时间，Date的getTime()得到的是一个时间戳//    提交进来一个yyyy-MM-dd HH:mm:ss格式的参数    private String dateToStamp(String dateValue) throws ParseException &#123;        SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);//输入时间格式        Date date = simpleDateFormat.parse(dateValue);//将传入的时间字符串根据时间格式转换为标准格式化时间        long timeStampValue = date.getTime();//得到时间戳        return String.valueOf(timeStampValue);    &#125;
时间戳转换为时间//    提交进来一个时间戳    private String stampToDate(long stampValue)&#123;        SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);//输入时间格式        Date date = new Date(stampValue);//根据传入的时间戳得到标准格式化时间        String dateValue = simpleDateFormat.format(date);//从标准格式化时间中得到与时间格式对应的日期        return dateValue;    &#125;
当前时间信息&ensp;&ensp;&ensp;&ensp;兜兜转转，无非是围绕着一个标准格式化时间转来转去
    private void dateShow() &#123;        Calendar calendar = Calendar.getInstance();//日历类        SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);//时间格式                Date date = calendar.getTime();//当前的标准格式化时间        String dateValue = simpleDateFormat.format(date);//从当前标准格式化时间中得到与时间格式对应的时间        long dateStamp = date.getTime();//当前时间的时间戳//        Date类中的年月日时分秒获取方法已经废弃        int Year = calendar.get(Calendar.YEAR);//年        int Month = calendar.get(Calendar.MONTH);//月份(0-11)        int Day = calendar.get(Calendar.DAY_OF_MONTH);//日        int Hour = calendar.get(Calendar.HOUR_OF_DAY);//时(24小时格式)        int Minute = calendar.get(Calendar.MINUTE);//分        int Second = calendar.get(Calendar.SECOND);//秒        Log.d(TAG, &quot;dateShow: 标准格式化时间: &quot; + date);        Log.d(TAG, &quot;dateShow: 时间格式对应时间: &quot; + dateValue);        Log.d(TAG, &quot;dateShow: 时间戳: &quot; + dateStamp);        Log.d(TAG, &quot;dateShow: &quot; + Year + &quot;年&quot; + (Month + 1) + &quot;月&quot; + Day + &quot;日&quot; + Hour + &quot;时&quot; + Minute + &quot;分&quot; + Second + &quot;秒&quot;);    &#125;
&ensp;&ensp;&ensp;&ensp;输出D/MainActivity: dateShow: 标准格式化时间: Mon Dec 06 12:00:40 GMT+08:00 2021D/MainActivity: dateShow: 时间格式对应时间: 2021-12-06 12:00:40D/MainActivity: dateShow: 时间戳: 1638763240386D/MainActivity: dateShow: 2021年12月6日12时0分40秒
从时间戳中截取日期&ensp;&ensp;&ensp;&ensp;怎么简单的获取时间戳中的年月日，不能转换为时间格式然后再用substring截取吧。。。    private void stamp(long timeStamp) &#123;        Calendar calendar = Calendar.getInstance();//        long timeStamp = calendar.getTimeInMillis();//这个方法可以获取时间戳，比Date.getTime()效率更高        calendar.setTimeInMillis(timeStamp);//给Calendar类重设时间戳//        从设置的时间戳中获取年月日        int Year = calendar.get(Calendar.YEAR);        int Month = calendar.get(Calendar.MONTH);        int Day = calendar.get(Calendar.DAY_OF_MONTH);        Log.d(TAG, &quot;stamp: &quot; + Year + &quot;年&quot; + (Month + 1) + &quot;月&quot; + Day + &quot;日&quot;);    &#125;
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android开发手记</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-根据包名判断软件是否安装</title>
    <url>/2022/02/06/Android-%E6%A0%B9%E6%8D%AE%E5%8C%85%E5%90%8D%E5%88%A4%E6%96%AD%E8%BD%AF%E4%BB%B6%E6%98%AF%E5%90%A6%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[若要适配Android11，在清单文件中添加如下权限，不不需要动态申请&lt;uses-permission android:name=&quot;android.permission.QUERY_ALL_PACKAGES&quot;/&gt;

获取软件包名列表获取所有软件的包名的列表，然后循环判断/** * 从所有以安装软件的包名的列表中判断是否安装 * @param context 上下文 * @param appPackName 检测的包名 * @return true:已安装 false:未安装 */public static boolean appList(Context context, String appPackName)&#123;    PackageManager packageManager = context.getPackageManager();    List&lt;PackageInfo&gt; installedPackages = packageManager.getInstalledPackages(0);    for (int i = 0; i &lt; installedPackages.size(); i++) &#123;        if (appPackName.equals(installedPackages.get(i).packageName))&#123;            return true;        &#125;    &#125;    return false;&#125;
根据包名信息判断/** * 检测是否安装了某软件 * @param context 上下文 * @param appPackName 被检测的软件的包名 * @return true:已安装 false:未安装 */@SuppressLint(&quot;QueryPermissionsNeeded&quot;)public static boolean checkAppInstalled(Context context, String appPackName)&#123;    PackageInfo packageInfo = null;    try &#123;        packageInfo = context.getPackageManager().getPackageInfo(appPackName,0);    &#125; catch (PackageManager.NameNotFoundException e) &#123;        e.printStackTrace();    &#125;    return packageInfo != null;&#125;
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android开发手记</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 选择图片</title>
    <url>/2021/12/05/Android-%E9%80%89%E6%8B%A9%E5%9B%BE%E7%89%87/</url>
    <content><![CDATA[注意: 申请写入和读取储存的权限

相册选取&ensp;&ensp;&ensp;&ensp;在方法中写入下面的代码就可以了
//  世界上再也没有比这个还简单的相册选取  Intent intent = new Intent(Intent.ACTION_PICK,null);  intent.setDataAndType(MediaStore.Images.Media.EXTERNAL_CONTENT_URI,&quot;image/*&quot;);  startActivityForResult(intent,PICTURE);//  也可以这样使用，但是如果这个样子，将无法调用除系统外的第三方提供的相册接口，如QQ浏览器的文件管理//  Intent intent = new Intent(Intent.ACTION_PICK,MediaStore.Images.Media.EXTERNAL_CONTENT_URI);//  startActivityForResult(intent,PICTURE);
&ensp;&ensp;&ensp;&ensp;页面返回的回调判断    @Override    protected void onActivityResult(int requestCode, int resultCode, @Nullable Intent data) &#123;        super.onActivityResult(requestCode, resultCode, data);//        调用了相册选择(PICTURE请求码的值随意)        if (requestCode == PICTURE)&#123;//            如果onActivityResult中返回的data为空值，说明没有选择相册中的图片            if (data == null)&#123;                Toast.makeText(this,&quot;没有选择图片&quot;,Toast.LENGTH_SHORT).show();            &#125;            else &#123;                Uri uri = data.getData();//图片的uri地址                imageView.setImageURI(uri);//设置图片显示            &#125;        &#125;    &#125;
相机拍摄&ensp;&ensp;&ensp;&ensp;在方法中写入下面的代码就可以了//  在发布版中记得申请相机权限  Intent intent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);  startActivityForResult(intent,CAMERA);
&ensp;&ensp;&ensp;&ensp;页面返回的回调判断  @Override  protected void onActivityResult(int requestCode, int resultCode, @Nullable Intent data) &#123;      super.onActivityResult(requestCode, resultCode, data);//      相机      if (requestCode == CAMERA)&#123;          /*           * 这里有个坑,跳转到相机拍摄页面后,           * 如果点击系统提供的&quot;x&quot;号返回,那么data不为空值,可以用getExtra从data中取数据,但是取到的数据是空值           * 如果使用手机物理返回键返回,那data直接是空值,从空值data中get会直接报错           * 所以应该用短路按位与或短路按钮为·按位或,再不济用两个if分别来判断data和data.getExtras()           * data或data.getExtras为空值时,说明没有拍照           */          if (data == null || data.getExtras() == null)&#123;              Toast.makeText(this,&quot;没有拍摄照片&quot;,Toast.LENGTH_SHORT).show();          &#125;          else &#123;              Bitmap bitmap = (Bitmap) data.getExtras().get(&quot;data&quot;);              imageView.setImageBitmap(bitmap);          &#125;      &#125;  &#125;
整体预览布局&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout android:layout_width=&quot;match_parent&quot;    android:orientation=&quot;vertical&quot;    android:layout_height=&quot;match_parent&quot;    android:id=&quot;@+id/linearLayout&quot;    android:gravity=&quot;center&quot;    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;    &lt;ImageView        android:src=&quot;@mipmap/ic_launcher&quot;        android:id=&quot;@+id/imageView&quot;        android:layout_width=&quot;100dp&quot;        android:layout_height=&quot;100dp&quot;/&gt;    &lt;LinearLayout        android:layout_marginTop=&quot;50dp&quot;        android:orientation=&quot;horizontal&quot;        android:gravity=&quot;center&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;wrap_content&quot;&gt;        &lt;Button            android:text=&quot;相机拍摄&quot;            android:onClick=&quot;camera&quot;            android:layout_marginRight=&quot;10dp&quot;            android:layout_width=&quot;wrap_content&quot;            android:layout_height=&quot;wrap_content&quot;/&gt;        &lt;Button            android:text=&quot;相册选取&quot;            android:onClick=&quot;picture&quot;            android:layout_marginLeft=&quot;10dp&quot;            android:layout_width=&quot;wrap_content&quot;            android:layout_height=&quot;wrap_content&quot;/&gt;    &lt;/LinearLayout&gt;&lt;/LinearLayout&gt;
程序public class MainActivity extends AppCompatActivity&#123;    private ImageView imageView;    private final int CAMERA = 1;//调用相机回调判断码    private final int PICTURE = 2;//调用相册回调判断码    private final int REQUEST = 3;//申请外部储存读写权限的请求码    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        init();//初始化界面        requestPermission();//申请权限    &#125;    private void init() &#123;        imageView = findViewById(R.id.imageView);    &#125;    private void requestPermission() &#123;//        申请读写权限        if (ActivityCompat.checkSelfPermission(this, Manifest.permission.WRITE_EXTERNAL_STORAGE) == PackageManager.PERMISSION_DENIED         &amp;&amp; ActivityCompat.checkSelfPermission(this,Manifest.permission.READ_EXTERNAL_STORAGE) == PackageManager.PERMISSION_DENIED         &amp;&amp; ActivityCompat.checkSelfPermission(this,Manifest.permission.CAMERA) == PackageManager.PERMISSION_DENIED)&#123;            ActivityCompat.requestPermissions(this,new String[] &#123;                    Manifest.permission.WRITE_EXTERNAL_STORAGE,                    Manifest.permission.READ_EXTERNAL_STORAGE,                    Manifest.permission.CAMERA            &#125;,REQUEST);        &#125;    &#125;    public void camera(View view) &#123;//        记得申请相机权限        Intent intent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);        startActivityForResult(intent,CAMERA);    &#125;    public void picture(View view) &#123;//        世界上再也没有比这个还简单的相册选取        Intent intent = new Intent(Intent.ACTION_PICK,null);        intent.setDataAndType(MediaStore.Images.Media.EXTERNAL_CONTENT_URI,&quot;image/*&quot;);        startActivityForResult(intent,PICTURE);//        也可以这样使用，但是如果这个样子，将无法调用除系统外的第三方提供的相册接口，如QQ浏览器的文件管理//        Intent intent = new Intent(Intent.ACTION_PICK,MediaStore.Images.Media.EXTERNAL_CONTENT_URI);//        startActivityForResult(intent,PICTURE);    &#125;    @Override//    页面回调方法    protected void onActivityResult(int requestCode, int resultCode, @Nullable Intent data) &#123;        super.onActivityResult(requestCode, resultCode, data);        if (requestCode == CAMERA)&#123;//            相机            /*             * 这里有个坑,跳转到相机拍摄页面后,             * 如果点击系统提供的&quot;x&quot;号返回,那么data不为空值,可以用getExtra从data中取数据,但是取到的数据是空值             * 如果使用手机物理返回键返回,那data直接是空值,从空值data中get会直接报错             * 所以应该用短路按位与或短路按钮为·按位或,再不济用两个if分别来判断data和data.getExtras()             * data或data.getExtras为空值时,说明没有拍照             */            if (data == null || data.getExtras() == null)&#123;                Toast.makeText(this,&quot;没有拍摄照片&quot;,Toast.LENGTH_SHORT).show();            &#125;            else &#123;                Bitmap bitmap = (Bitmap) data.getExtras().get(&quot;data&quot;);                imageView.setImageBitmap(bitmap);            &#125;        &#125;//        调用了相册选择        else if (requestCode == PICTURE)&#123;//            如果onActivityResult中返回的data为空值，说明没有选择相册中的图片            if (data == null)&#123;                Toast.makeText(this,&quot;没有选择图片&quot;,Toast.LENGTH_SHORT).show();            &#125;            else &#123;                Uri uri = data.getData();//图片的uri地址                imageView.setImageURI(uri);//设置图片显示            &#125;        &#125;    &#125;    @Override//    权限申请回调方法    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123;        super.onRequestPermissionsResult(requestCode, permissions, grantResults);        if (requestCode == REQUEST)&#123;            if (ActivityCompat.checkSelfPermission(this, Manifest.permission.WRITE_EXTERNAL_STORAGE) == PackageManager.PERMISSION_DENIED                    &amp;&amp; ActivityCompat.checkSelfPermission(this,Manifest.permission.READ_EXTERNAL_STORAGE) == PackageManager.PERMISSION_DENIED)&#123;                Toast.makeText(this,&quot;外部储存读写权限申请失败&quot;,Toast.LENGTH_SHORT).show();            &#125;            else &#123;                Toast.makeText(this,&quot;外部储存读写权限申请成功&quot;,Toast.LENGTH_SHORT).show();            &#125;            if (ActivityCompat.checkSelfPermission(this,Manifest.permission.CAMERA) == PackageManager.PERMISSION_DENIED)&#123;                Toast.makeText(this,&quot;相机权限申请失败&quot;,Toast.LENGTH_SHORT).show();            &#125;            else &#123;                Toast.makeText(this,&quot;相机权限申请成功&quot;,Toast.LENGTH_SHORT).show();            &#125;        &#125;    &#125;&#125;
视图
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android开发手记</tag>
      </tags>
  </entry>
  <entry>
    <title>AndroidStudio导入jar包</title>
    <url>/2021/10/08/AndroidStudio%E5%AF%BC%E5%85%A5jar%E5%8C%85/</url>
    <content><![CDATA[方法一官方jar引入

点击Project Structure

点击Dependencies → app，点击“+”号

选择Library Dependencies

输入想要添加的依赖并搜索，搜索完毕后ok添加即可


方法二从github同步

查看项目的依赖添加方式

粘贴至gradle文件的dependencies


方法三本地引入

把下载好的jar包粘贴至lib目录

右键点击“Add As Library”


]]></content>
      <categories>
        <category>菜鸡手记</category>
      </categories>
      <tags>
        <tag>软件与工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Android判断当前设备</title>
    <url>/2021/11/17/Android%E5%88%A4%E6%96%AD%E5%BD%93%E5%89%8D%E8%AE%BE%E5%A4%87/</url>
    <content><![CDATA[Configuration类的常量与变量
屏幕大小判断&ensp;&ensp;&ensp;&ensp;Configuration类用于描述手机设备上的配置信息//  获得Configuration对象  Configuration configuration = getResources().getConfiguration();
&ensp;&ensp;&ensp;&ensp;通过Configuration对象就可以获取系统的配置信息，例如//  获取屏幕bit大小，是一个变量   int a = this.getResources().getConfiguration().screenLayout;  //  作为一个单位，可以对屏幕的bit大小进行位运算，位运算后得到一个“代表值”  int b = Configuration.SCREENLAYOUT_SIZE_MASK;  //  位运算方式  int c = a &amp; b;  //  获取一个“代表值”，表示屏幕至少约为480x640(dp单位)，常量  int d = Configuration.SCREENLAYOUT_SIZE_LARGE  //  获取一个“代表值”，表示屏幕至少约为320x470(dp单位)，常量  int d = Configuration.SCREENLAYOUT_SIZE_NORMAL  //  获取一个“代表值”，表示屏幕至少约为320x426(dp单位)，常量  int d = Configuration.SCREENLAYOUT_SIZE_SMALL  //  获取一个“代表值”，表示未设置大小，常量  int d = Configuration.SCREENLAYOUT_SIZE_UNDEFINED  //  获取一个“代表值”，表示屏幕至少约为720x960(dp单位)，常量  int d = Configuration.SCREENLAYOUT_SIZE_XLARGE  // 如果c大于d，说明当前屏幕大小至少为代表值d代表的大小  boolean e = c &gt; d;
判断是否为平板&ensp;&ensp;&ensp;&ensp;官方给的方法    private boolean isPad(Context context)&#123;//        获取屏幕总Bit数        int a = context.getResources().getConfiguration().screenLayout;//        作为一个单位，对屏幕的bit大小进行位运算的数        int b = Configuration.SCREENLAYOUT_SIZE_MASK;//        通过SCREENLAYOUT_SIZE_MASK计算得到一个结果，该结果是一个“代表值”        int c = a &amp; b;//        获取一个代表值，表示屏幕至少约为480x640(dp单位)        int d = Configuration.SCREENLAYOUT_SIZE_LARGE;//        如果代表值c大于代表值d，说明当前屏幕至少约为480x640(dp单位)        boolean e = c &gt; d;//        如果大于480x640(dp单位)说明是平板，返回布尔值        return e;    &#125;
&ensp;&ensp;&ensp;&ensp;简化合并一下private boolean isPad(Context context)&#123;    return (context.getResources().getConfiguration().screenLayout &amp; Configuration.SCREENLAYOUT_SIZE_MASK) &gt;= Configuration.SCREENLAYOUT_SIZE_LARGE;&#125;
&ensp;&ensp;&ensp;&ensp;总起来说，就是获取屏幕bit大小，然后通过SCREENLAYOUT_SIZE_MASK计算当前bit大小的代表值，通过代表值的对比，就可以得到当前屏幕至少应该有多大
&ensp;&ensp;&ensp;&ensp;但是这种方法在一定环境的刺激下就不灵了，比如华为的平板可以放大界面，所以有了一种优化方案：
&ensp;&ensp;&ensp;&ensp;获取屏幕的长度和宽度(单位像素)，通过勾股定理计算屏幕的对角线长度，用对角线像素值计算出英寸大小，目前市面上最小的平板是7.0英寸，如果我们计算的英寸值大于等于7.0，说明当前的设备是平板设备，反之则是手机设备    private boolean isPad(Context context)&#123;        WindowManager windowManager = (WindowManager) context.getSystemService(context.WINDOW_SERVICE);        Display display = windowManager.getDefaultDisplay();        DisplayMetrics displayMetrics = new DisplayMetrics();        display.getMetrics(displayMetrics);        double x = Math.pow(displayMetrics.widthPixels / displayMetrics.xdpi, 2);        double y = Math.pow(displayMetrics.heightPixels / displayMetrics.ydpi, 2);//        屏幕英寸        double inch = Math.sqrt(x + y);//        大于等于7.0就是平板，反之就是手机        return inch &gt;= 7.0;    &#125;
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android开发手记</tag>
      </tags>
  </entry>
  <entry>
    <title>Android多任务显示</title>
    <url>/2023/03/22/Android%E5%A4%9A%E4%BB%BB%E5%8A%A1%E6%98%BE%E7%A4%BA/</url>
    <content><![CDATA[第一种方式，添加Flag&ensp;&ensp;在目标清单文件中添加属性值&lt;Activity    ...    android:launchMode=&quot;standard&quot;    ...    /&gt;
&ensp;&ensp;在使用Intent跳转页面时，给Intent添加如下Flag，即启动后以新的任务窗口显示在后台中Intent intent = new Intent(this, VideoMainActivity.class);// 此标志用于将文档打开到一个 基于此意图的新任务中intent.addFlags(Intent.FLAG_ACTIVITY_NEW_DOCUMENT);// 此标志用于创建新任务并将活动导入其中intent.addFlags(Intent.FLAG_ACTIVITY_MULTIPLE_TASK);startActivity(intent);
第二种方式，配置清单文件documentLaunchMode(启动模式):

intoExisting: 如果之前已经打开过，则会打开之前的(类似于 Activity 的 singleTask)；
always: 不管之前有没有打开，都新创建一个(类似于 Activity 的 standard)；
none: 不会在任务列表创建新的窗口，依旧显示单个任务；
never: 不会在任务列表创建新的窗口，依旧显示单个任务，设置此值会替代 FLAG_ACTIVITY_NEW_DOCUMENT 和 FLAG_ACTIVITY_MULTIPLE_TASK 标志的行为（如果在 Intent 中设置了其中一个标志）。

注意：对于除 none 和 never 以外的值，必须使用 launchMode=&quot;standard&quot; 定义 Activity。如果未指定此属性，则使用 documentLaunchMode=&quot;none&quot;
excludeFromRecents(离开是否从任务列表移除):

false: 离开页面不会从任务列表移除该页面(默认值)
true: 离开页面后，将会从任务列表移除该页面

maxRecents(设置应用能够包括在概览屏幕中的最大任务数):&ensp;&ensp;整型值，默认为16，上限为50，达到最大任务数后，最近最少使用的任务将从概览屏幕中移除
&lt;activity    android:name=&quot;.MainActivity&quot;    android:documentLaunchMode=&quot;intoExisting&quot;    android:excludeFromRecents=&quot;false&quot;    android:maxRecents=&quot;3&quot;/&gt;
第三种方式，配置清单文件&ensp;&ensp;给Activity添加一个taskAffinity属性，这样的好处是，taskAffinity属性值相同的Activity之间相互跳转不会启用新的任务窗口&ensp;&ensp;如果使用该方式，launchMode属性的值不可为standard，否则将不会生效
&lt;activity    android:name=&quot;.MainActivity&quot;    android:exported=&quot;true&quot;    android:launchMode=&quot;standard&quot;    android:taskAffinity=&quot;com.example.test.main&quot; /&gt;
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android开发手记</tag>
      </tags>
  </entry>
  <entry>
    <title>Android实战-智慧城市(3)</title>
    <url>/2021/11/02/Android%E5%AE%9E%E6%88%98-%E6%99%BA%E6%85%A7%E5%9F%8E%E5%B8%82-3/</url>
    <content><![CDATA[上回说到，Android实战-智慧城市(2)
软件设计主页面&ensp;&ensp;&ensp;&ensp;主页面是个大工程，首先用ViewPager2+Fragment的方式实现了4页切换，与引导页不同的是每页有一个单独的Fragment页面，底部的四个按钮与四个页面相呼应
新闻内容页&ensp;&ensp;&ensp;&ensp;新闻内容页展示新闻内容，当点击了智慧城市页和新闻页的新闻后，即跳转到新闻内容页，展示对应的新闻和评论
修改HomeFragment0.java&ensp;&ensp;&ensp;&ensp;修改HomeFragment0.java中的startNewsActivity方法，使点击专题和新闻列表时发声页面跳转//    启动新闻内容显示页面    private void startNewsActivity(int id) &#123;//        获取到点击的专题或新闻列表中的新闻的id并将新闻的id值传递给新闻显示页        Intent intent = new Intent(getContext(), NewsHomeActivity.class);        intent.putExtra(&quot;newsId&quot;,id);        startActivity(intent);    &#125;
新闻详细内容的反序列化对象&ensp;&ensp;&ensp;&ensp;用于将请求到的新闻的详细内容的json反序列化&ensp;&ensp;&ensp;&ensp;NewsHomeBean.javapackage com.SmartCity.NewsHome;public class NewsHomeBean &#123;    private String msg;    private int code;    private DataBean data;    public String getMsg() &#123;        return msg;    &#125;    public void setMsg(String msg) &#123;        this.msg = msg;    &#125;    public int getCode() &#123;        return code;    &#125;    public void setCode(int code) &#123;        this.code = code;    &#125;    public DataBean getData() &#123;        return data;    &#125;    public void setData(DataBean data) &#123;        this.data = data;    &#125;    public static class DataBean &#123;        private Object searchValue;        private String createBy;        private String createTime;        private String updateBy;        private String updateTime;        private Object remark;        private ParamsBean params;        private int id;        private String appType;        private String cover;        private String title;        private Object subTitle;        private String content;        private String status;        private String publishDate;        private Object tags;        private int commentNum;        private int likeNum;        private int readNum;        private String type;        private String top;        private String hot;        public Object getSearchValue() &#123;            return searchValue;        &#125;        public void setSearchValue(Object searchValue) &#123;            this.searchValue = searchValue;        &#125;        public String getCreateBy() &#123;            return createBy;        &#125;        public void setCreateBy(String createBy) &#123;            this.createBy = createBy;        &#125;        public String getCreateTime() &#123;            return createTime;        &#125;        public void setCreateTime(String createTime) &#123;            this.createTime = createTime;        &#125;        public String getUpdateBy() &#123;            return updateBy;        &#125;        public void setUpdateBy(String updateBy) &#123;            this.updateBy = updateBy;        &#125;        public String getUpdateTime() &#123;            return updateTime;        &#125;        public void setUpdateTime(String updateTime) &#123;            this.updateTime = updateTime;        &#125;        public Object getRemark() &#123;            return remark;        &#125;        public void setRemark(Object remark) &#123;            this.remark = remark;        &#125;        public ParamsBean getParams() &#123;            return params;        &#125;        public void setParams(ParamsBean params) &#123;            this.params = params;        &#125;        public int getId() &#123;            return id;        &#125;        public void setId(int id) &#123;            this.id = id;        &#125;        public String getAppType() &#123;            return appType;        &#125;        public void setAppType(String appType) &#123;            this.appType = appType;        &#125;        public String getCover() &#123;            return cover;        &#125;        public void setCover(String cover) &#123;            this.cover = cover;        &#125;        public String getTitle() &#123;            return title;        &#125;        public void setTitle(String title) &#123;            this.title = title;        &#125;        public Object getSubTitle() &#123;            return subTitle;        &#125;        public void setSubTitle(Object subTitle) &#123;            this.subTitle = subTitle;        &#125;        public String getContent() &#123;            return content;        &#125;        public void setContent(String content) &#123;            this.content = content;        &#125;        public String getStatus() &#123;            return status;        &#125;        public void setStatus(String status) &#123;            this.status = status;        &#125;        public String getPublishDate() &#123;            return publishDate;        &#125;        public void setPublishDate(String publishDate) &#123;            this.publishDate = publishDate;        &#125;        public Object getTags() &#123;            return tags;        &#125;        public void setTags(Object tags) &#123;            this.tags = tags;        &#125;        public int getCommentNum() &#123;            return commentNum;        &#125;        public void setCommentNum(int commentNum) &#123;            this.commentNum = commentNum;        &#125;        public int getLikeNum() &#123;            return likeNum;        &#125;        public void setLikeNum(int likeNum) &#123;            this.likeNum = likeNum;        &#125;        public int getReadNum() &#123;            return readNum;        &#125;        public void setReadNum(int readNum) &#123;            this.readNum = readNum;        &#125;        public String getType() &#123;            return type;        &#125;        public void setType(String type) &#123;            this.type = type;        &#125;        public String getTop() &#123;            return top;        &#125;        public void setTop(String top) &#123;            this.top = top;        &#125;        public String getHot() &#123;            return hot;        &#125;        public void setHot(String hot) &#123;            this.hot = hot;        &#125;        public static class ParamsBean &#123;        &#125;    &#125;&#125;
新闻评论内容的反序列化对象&ensp;&ensp;&ensp;&ensp;用于将请求到的新闻的评论内容的json反序列化&ensp;&ensp;&ensp;&ensp;NewCommentBean.java(这里打错了一个字母News打成了New)package com.SmartCity.NewsHome;import java.io.Serializable;import java.util.List;public class NewCommentBean implements Serializable &#123;    private int total;    private List&lt;RowsBean&gt; rows;    private int code;    private String msg;    public int getTotal() &#123;        return total;    &#125;    public void setTotal(int total) &#123;        this.total = total;    &#125;    public List&lt;RowsBean&gt; getRows() &#123;        return rows;    &#125;    public void setRows(List&lt;RowsBean&gt; rows) &#123;        this.rows = rows;    &#125;    public int getCode() &#123;        return code;    &#125;    public void setCode(int code) &#123;        this.code = code;    &#125;    public String getMsg() &#123;        return msg;    &#125;    public void setMsg(String msg) &#123;        this.msg = msg;    &#125;    public static class RowsBean implements Serializable &#123;        private Object searchValue;        private Object createBy;        private Object createTime;        private Object updateBy;        private Object updateTime;        private Object remark;        private ParamsBean params;        private int id;        private String appType;        private int newsId;        private String content;        private String commentDate;        private int userId;        private int likeNum;        private String userName;        private String newsTitle;        public Object getSearchValue() &#123;            return searchValue;        &#125;        public void setSearchValue(Object searchValue) &#123;            this.searchValue = searchValue;        &#125;        public Object getCreateBy() &#123;            return createBy;        &#125;        public void setCreateBy(Object createBy) &#123;            this.createBy = createBy;        &#125;        public Object getCreateTime() &#123;            return createTime;        &#125;        public void setCreateTime(Object createTime) &#123;            this.createTime = createTime;        &#125;        public Object getUpdateBy() &#123;            return updateBy;        &#125;        public void setUpdateBy(Object updateBy) &#123;            this.updateBy = updateBy;        &#125;        public Object getUpdateTime() &#123;            return updateTime;        &#125;        public void setUpdateTime(Object updateTime) &#123;            this.updateTime = updateTime;        &#125;        public Object getRemark() &#123;            return remark;        &#125;        public void setRemark(Object remark) &#123;            this.remark = remark;        &#125;        public ParamsBean getParams() &#123;            return params;        &#125;        public void setParams(ParamsBean params) &#123;            this.params = params;        &#125;        public int getId() &#123;            return id;        &#125;        public void setId(int id) &#123;            this.id = id;        &#125;        public String getAppType() &#123;            return appType;        &#125;        public void setAppType(String appType) &#123;            this.appType = appType;        &#125;        public int getNewsId() &#123;            return newsId;        &#125;        public void setNewsId(int newsId) &#123;            this.newsId = newsId;        &#125;        public String getContent() &#123;            return content;        &#125;        public void setContent(String content) &#123;            this.content = content;        &#125;        public String getCommentDate() &#123;            return commentDate;        &#125;        public void setCommentDate(String commentDate) &#123;            this.commentDate = commentDate;        &#125;        public int getUserId() &#123;            return userId;        &#125;        public void setUserId(int userId) &#123;            this.userId = userId;        &#125;        public int getLikeNum() &#123;            return likeNum;        &#125;        public void setLikeNum(int likeNum) &#123;            this.likeNum = likeNum;        &#125;        public String getUserName() &#123;            return userName;        &#125;        public void setUserName(String userName) &#123;            this.userName = userName;        &#125;        public String getNewsTitle() &#123;            return newsTitle;        &#125;        public void setNewsTitle(String newsTitle) &#123;            this.newsTitle = newsTitle;        &#125;        public static class ParamsBean implements Serializable &#123;        &#125;    &#125;&#125;
显示html内容到Android页面&ensp;&ensp;&ensp;&ensp;通过截图中可以看出，请求到的新闻的内容是html格式，通过Html.fromHtml可以将html格式页面显示在TextView中，但是并不能显示图片，如果想使其动态显示图片，就需要重写ImageGetter类，具体实现可以看TextView实现图文混排

&ensp;&ensp;&ensp;&ensp;创建MyImageGetter类继承ImageGetter类，在该类中重写了getDrawable(String source)方法，当Html.fromHtml解析&lt;img&gt;标签时会回调该方法，方法中的source就是img标签src属性的属性值，当回调该方法时，将source中的图片加载出来并以Drawable格式返回给Html.fromHtml，即可做到图片加载&ensp;&ensp;&ensp;&ensp;MyImageGetter.javapackage com.SmartCity.NewsHome;import android.content.Context;import android.graphics.drawable.Drawable;import android.graphics.drawable.LevelListDrawable;import android.text.Html;import android.widget.TextView;import androidx.annotation.NonNull;import androidx.annotation.Nullable;import com.SmartCity.SoftData;import com.bumptech.glide.Glide;import com.bumptech.glide.request.target.CustomTarget;import com.bumptech.glide.request.transition.Transition;public class MyImageGetter implements Html.ImageGetter &#123;    private Context context;//上下文    private TextView textView;//内容加载的TextView对象    public MyImageGetter(Context context,TextView textView)&#123;        this.context = context;        this.textView = textView;    &#125;    @Override//    Html.fromHtml解析&lt;img&gt;时会回调getDrawable方法，所以getDrawable返回的Drawable图片就会被绘制//    参数中的source就是&lt;img&gt;标签中src属性的值    public Drawable getDrawable(String source) &#123;//        实例化LevelListDrawable类，可以通过改变level的值来切换相应的图片，也可以向LevelListDrawable中添加图片队列        LevelListDrawable levelListDrawable = new LevelListDrawable();//        通过new CustomTarget&lt;Drawable&gt;将图片以Drawable资源动态加载到自定义的位置，这里的加载位置在LevelListDrawable类中        Glide.with(context).asDrawable().load(&quot;http://&quot; + SoftData.ipPort + source).into(new CustomTarget&lt;Drawable&gt;() &#123;            @Override            public void onResourceReady(@NonNull Drawable resource, @Nullable Transition&lt;? super Drawable&gt; transition) &#123;                levelListDrawable.addLevel(1,1,resource);//把drawable资源加载到levelListDrawable中//                为其设置边界，没有设置的话TextView将不能显示该Drawable                levelListDrawable.setBounds(0,0,resource.getIntrinsicWidth(),resource.getMinimumHeight());                levelListDrawable.setLevel(1);//设置对象级别                textView.invalidate();//重新绘制textView界面                textView.setText(textView.getText());//叠加覆盖原内容            &#125;            @Override            public void onLoadCleared(@Nullable Drawable placeholder) &#123;//                The Methods is Nothing            &#125;        &#125;);//        返回加载的Drawable文件资源文件，该文件会被Html.fromHtml绘制        return levelListDrawable;    &#125;&#125;
评论列表的item布局&ensp;&ensp;&ensp;&ensp;activity_news_home_item.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout android:layout_height=&quot;wrap_content&quot;    android:layout_width=&quot;match_parent&quot;    android:orientation=&quot;horizontal&quot;    android:paddingTop=&quot;5dp&quot;    android:paddingBottom=&quot;5dp&quot;    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;    &lt;ImageView        android:layout_marginLeft=&quot;10dp&quot;        android:layout_marginRight=&quot;10dp&quot;        android:src=&quot;@mipmap/avatar&quot;        android:layout_width=&quot;48dp&quot;        android:layout_height=&quot;48dp&quot;/&gt;    &lt;LinearLayout        android:orientation=&quot;vertical&quot;        android:layout_marginRight=&quot;10dp&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;wrap_content&quot;&gt;        &lt;LinearLayout            android:orientation=&quot;horizontal&quot;            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;match_parent&quot;&gt;            &lt;TextView                android:text=&quot;nickName&quot;                android:id=&quot;@+id/nickName&quot;                android:layout_width=&quot;0dp&quot;                android:textColor=&quot;@color/black&quot;                android:textSize=&quot;14sp&quot;                android:layout_weight=&quot;1&quot;                android:layout_height=&quot;wrap_content&quot;/&gt;            &lt;TextView                android:text=&quot;times&quot;                android:id=&quot;@+id/times&quot;                android:textColor=&quot;@color/black&quot;                android:textSize=&quot;14sp&quot;                android:layout_width=&quot;0dp&quot;                android:layout_weight=&quot;1&quot;                android:layout_height=&quot;wrap_content&quot;/&gt;        &lt;/LinearLayout&gt;        &lt;TextView            android:id=&quot;@+id/comments&quot;            android:text=&quot;comments&quot;            android:gravity=&quot;left&quot;            android:textColor=&quot;@color/black&quot;            android:layout_marginRight=&quot;10dp&quot;            android:textStyle=&quot;bold&quot;            android:textSize=&quot;15sp&quot;            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;match_parent&quot;/&gt;    &lt;/LinearLayout&gt;&lt;/LinearLayout&gt;
评论列表的适配器&ensp;&ensp;&ensp;&ensp;一个普通适配器而已package com.SmartCity.NewsHome;import android.content.Context;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import android.widget.TextView;import androidx.annotation.NonNull;import androidx.recyclerview.widget.RecyclerView;import com.SmartCity.R;import java.util.List;public class NewsCommentAdapter extends RecyclerView.Adapter&lt;NewsCommentAdapter.MyViewHolder&gt; &#123;    private List&lt;String&gt; commentContents;//评论内容    private List&lt;String&gt; commentUserNames;//评论者昵称    private List&lt;String&gt; commentDates;//评论时间    private Context context;//上下文    public NewsCommentAdapter(List&lt;String&gt; commentContents, List&lt;String&gt; commentUserNames, List&lt;String&gt; commentDates, Context context) &#123;        this.commentContents = commentContents;        this.commentUserNames = commentUserNames;        this.commentDates = commentDates;        this.context = context;    &#125;    @NonNull    @Override    public MyViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) &#123;        View view = LayoutInflater.from(context).inflate(R.layout.activity_news_home_item,parent,false);        return new MyViewHolder(view);    &#125;    @Override    public void onBindViewHolder(@NonNull MyViewHolder holder, int position) &#123;        holder.comments.setText(commentContents.get(position));        holder.times.setText(commentDates.get(position));        holder.nickName.setText(commentUserNames.get(position));    &#125;    @Override    public int getItemCount() &#123;        return commentContents.size();    &#125;    public class MyViewHolder extends RecyclerView.ViewHolder &#123;        private TextView nickName,times,comments;        public MyViewHolder(@NonNull View itemView) &#123;            super(itemView);            nickName = itemView.findViewById(R.id.nickName);            times = itemView.findViewById(R.id.times);            comments = itemView.findViewById(R.id.comments);        &#125;    &#125;&#125;
使最新评论列表绝对禁止滑动&ensp;&ensp;&ensp;&ensp;创建MyLinearLayoutManager类继承自LinearLayoutManager，重写它的canScrollVertically()方法，使其永远返回false，调用该类创建的LayoutManager设置为列表的LayoutManager时，该列表将无法被滑动，不会像recyclerView.setNestedScrollingEnabled(false);一样，禁止滑动再滑动时会显示蓝色底边&ensp;&ensp;&ensp;&ensp;MyLinearLayoutManager.javapackage com.SmartCity.NewsHome;import android.content.Context;import android.util.AttributeSet;import androidx.recyclerview.widget.LinearLayoutManager;public class MyLinearLayoutManager extends LinearLayoutManager &#123;    public MyLinearLayoutManager(Context context) &#123;        super(context);    &#125;    public MyLinearLayoutManager(Context context, int orientation, boolean reverseLayout) &#123;        super(context, orientation, reverseLayout);    &#125;    public MyLinearLayoutManager(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) &#123;        super(context, attrs, defStyleAttr, defStyleRes);    &#125;    @Override    public boolean canScrollVertically() &#123;//        重写canScrollVertically使其达到滑动的绝对禁止        return false;    &#125;&#125;
新闻详情页面布局&ensp;&ensp;&ensp;&ensp;显示新闻详情&ensp;&ensp;&ensp;&ensp;activity_news_home.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout android:layout_height=&quot;match_parent&quot;    android:layout_width=&quot;match_parent&quot;    android:orientation=&quot;vertical&quot;    android:gravity=&quot;center_horizontal&quot;    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;    &lt;!--    Title--&gt;    &lt;LinearLayout        android:background=&quot;@color/blue&quot;        android:orientation=&quot;horizontal&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;58dp&quot;&gt;        &lt;LinearLayout            android:onClick=&quot;finishActivity&quot;            android:gravity=&quot;center&quot;            android:layout_width=&quot;58dp&quot;            android:layout_height=&quot;58dp&quot;&gt;            &lt;ImageView                android:src=&quot;@mipmap/back&quot;                android:layout_width=&quot;20dp&quot;                android:layout_height=&quot;20dp&quot;/&gt;        &lt;/LinearLayout&gt;        &lt;LinearLayout            android:gravity=&quot;center&quot;            android:layout_weight=&quot;1&quot;            android:layout_width=&quot;0dp&quot;            android:layout_height=&quot;match_parent&quot;&gt;            &lt;TextView                android:text=&quot;新闻详情&quot;                android:textStyle=&quot;bold&quot;                android:textSize=&quot;18sp&quot;                android:textColor=&quot;@color/white&quot;                android:layout_width=&quot;wrap_content&quot;                android:layout_height=&quot;wrap_content&quot;/&gt;        &lt;/LinearLayout&gt;        &lt;LinearLayout            android:gravity=&quot;center&quot;            android:layout_width=&quot;58dp&quot;            android:layout_height=&quot;58dp&quot;&gt;        &lt;/LinearLayout&gt;    &lt;/LinearLayout&gt;    &lt;!--    Content--&gt;    &lt;ScrollView        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;match_parent&quot;&gt;        &lt;LinearLayout            android:orientation=&quot;vertical&quot;            android:gravity=&quot;center_horizontal&quot;            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;wrap_content&quot;&gt;            &lt;TextView                android:gravity=&quot;center&quot;                android:text=&quot;title&quot;                android:id=&quot;@+id/title&quot;                android:layout_marginTop=&quot;10dp&quot;                android:layout_marginBottom=&quot;10dp&quot;                android:layout_marginRight=&quot;20dp&quot;                android:layout_marginLeft=&quot;20dp&quot;                android:textSize=&quot;20sp&quot;                android:textColor=&quot;@color/black&quot;                android:textStyle=&quot;bold&quot;                android:layout_width=&quot;wrap_content&quot;                android:layout_height=&quot;wrap_content&quot;/&gt;            &lt;View                android:layout_marginRight=&quot;10dp&quot;                android:layout_marginLeft=&quot;10dp&quot;                android:background=&quot;@color/darker_gray&quot;                android:layout_width=&quot;match_parent&quot;                android:layout_height=&quot;1dp&quot;/&gt;            &lt;TextView                android:id=&quot;@+id/content&quot;                android:textSize=&quot;18sp&quot;                android:textColor=&quot;@color/black&quot;                android:textStyle=&quot;bold&quot;                android:layout_margin=&quot;20dp&quot;                android:layout_width=&quot;match_parent&quot;                android:layout_height=&quot;wrap_content&quot;/&gt;            &lt;TextView                android:layout_marginRight=&quot;10dp&quot;                android:layout_marginLeft=&quot;10dp&quot;                android:textColor=&quot;@color/black&quot;                android:textSize=&quot;16sp&quot;                android:textStyle=&quot;bold&quot;                android:text=&quot;最新评论&quot;                android:gravity=&quot;left&quot;                android:layout_width=&quot;match_parent&quot;                android:layout_height=&quot;wrap_content&quot;/&gt;            &lt;androidx.recyclerview.widget.RecyclerView                android:layout_margin=&quot;10dp&quot;                android:id=&quot;@+id/recyclerView&quot;                android:layout_width=&quot;match_parent&quot;                android:layout_height=&quot;wrap_content&quot;/&gt;            &lt;TextView                android:text=&quot;没有评论\n快来成为第一个吧OvO&quot;                android:gravity=&quot;center&quot;                android:textColor=&quot;@color/black&quot;                android:textSize=&quot;25sp&quot;                android:textStyle=&quot;bold&quot;                android:id=&quot;@+id/noComment&quot;                android:visibility=&quot;gone&quot;                android:layout_margin=&quot;10dp&quot;                android:layout_width=&quot;match_parent&quot;                android:layout_height=&quot;wrap_content&quot;/&gt;            &lt;LinearLayout                android:orientation=&quot;horizontal&quot;                android:layout_marginBottom=&quot;20dp&quot;                android:layout_width=&quot;match_parent&quot;                android:layout_height=&quot;wrap_content&quot;&gt;                &lt;TextView                    android:text=&quot;写评论&quot;                    android:layout_marginRight=&quot;100dp&quot;                    android:layout_marginLeft=&quot;10dp&quot;                    android:onClick=&quot;onClick&quot;                    android:textColor=&quot;@color/blue&quot;                    android:layout_width=&quot;0dp&quot;                    android:layout_weight=&quot;1&quot;                    android:layout_height=&quot;wrap_content&quot;/&gt;                &lt;TextView                    android:gravity=&quot;right&quot;                    android:text=&quot;全部评论&quot;                    android:id=&quot;@+id/allCommentSum&quot;                    android:onClick=&quot;onClick&quot;                    android:layout_marginLeft=&quot;100dp&quot;                    android:layout_marginRight=&quot;10dp&quot;                    android:textColor=&quot;@color/blue&quot;                    android:layout_width=&quot;0dp&quot;                    android:layout_weight=&quot;1&quot;                    android:layout_height=&quot;wrap_content&quot;/&gt;            &lt;/LinearLayout&gt;        &lt;/LinearLayout&gt;    &lt;/ScrollView&gt;&lt;/LinearLayout&gt;
新闻详情程序设计&ensp;&ensp;&ensp;&ensp;两个难点：1.Html.fromHtml()加载图片；2.最新评论显示5条&ensp;&ensp;&ensp;&ensp;还有一个容易出错的地方：bundle传递对象&ensp;&ensp;&ensp;&ensp;NewsHomeActivity.javapackage com.SmartCity.NewsHome;import androidx.annotation.NonNull;import androidx.annotation.Nullable;import androidx.appcompat.app.AppCompatActivity;import androidx.recyclerview.widget.RecyclerView;import android.annotation.SuppressLint;import android.content.Intent;import android.os.Build;import android.os.Bundle;import android.os.Handler;import android.os.Looper;import android.os.Message;import android.text.Html;import android.view.View;import android.widget.TextView;import android.widget.Toast;import com.SmartCity.MyHttpRequest;import com.SmartCity.R;import java.util.ArrayList;import java.util.List;public class NewsHomeActivity extends AppCompatActivity &#123;    private int newsId;//新闻的id    private TextView title,content;//标题和内容    private MyHttpRequest myHttpRequest = new MyHttpRequest();//封装的服务器通信    private NewsHomeBean newsHomeBean;//新闻详细内容的反序列化对象    private Handler handler;//handler线程通信    private NewCommentBean newCommentBean;//新闻评论的反序列化对象    private List&lt;String&gt; commentContents;//评论的内容    private List&lt;String&gt; commentUserNames;//评论者昵称    private List&lt;String&gt; commentDates;//评论时间    private RecyclerView recyclerView;//新闻内容下的“最新评论”列表    private TextView allCommentSum;//全部评论数量    private TextView noComment;//没有评论时显示的view    private NewsCommentAdapter newsCommentAdapter;//评论列表的适配器    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_news_home);        myHandler();//线程通信        init();//初始化页面        getNewsData();//获取新闻的详细信息        getCommentData();//获取最新评论详细信息(最新评论最多5条)    &#125;//    线程通信    private void myHandler() &#123;        handler = new Handler(Looper.getMainLooper())&#123;            @Override            public void handleMessage(@NonNull Message msg) &#123;                super.handleMessage(msg);                if (msg.what == 1)&#123;                    setNewsData();//设置新闻内容显示                &#125;                else if (msg.what == 2)&#123;                    setComment();//设置最新评论显示                &#125;            &#125;        &#125;;    &#125;//    设置新闻内容显示    private void setNewsData() &#123;        if (newsHomeBean == null)&#123;            MyToast(&quot;新闻内容获取失败: 未知原因&quot;);        &#125;        else if (newsHomeBean.getCode() != 200)&#123;            MyToast(&quot;新闻内容获取失败: &quot; + newsHomeBean.getMsg());        &#125;        else &#123;            String newsTitle = newsHomeBean.getData().getTitle();//新闻标题            String newsContent = newsHomeBean.getData().getContent();//新闻内容            title.setText(newsTitle);//设置标题            /*             * 这里就比较麻烦了，因为新闻内容是html格式，甚至内容中一些图片也是html格式，在Android页面中不可能将这些东西一一动态的创建出来             * 那么就需要用到一个特殊的方法Html.fromHtml，但是他有一个巨大的缺点，不能绘制图片，所以我们需要重写它的一个方法来动态的加载图片             * 这个方法就是ImageGetter，在MyImageGetter中有绘制html图片的具体过程             *             * 在android7.0以后，Html.fromHtml不支持设置flags，所以这里添加了版本判断             * FROM_HTML_MODE_COMPACT：html块元素之间使用一个换行符分隔             * FROM_HTML_MODE_LEGACY：html块元素之间使用两个换行符分隔             *///            实例化重写的ImageGetter类，在重写的MyImageGetter中加载文章中的图片            MyImageGetter myImageGetter = new MyImageGetter(NewsHomeActivity.this,content);            if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N) &#123;                content.setText(Html.fromHtml(newsContent,Html.FROM_HTML_MODE_COMPACT,myImageGetter,null));//显示新闻内容            &#125;            else &#123;                content.setText(Html.fromHtml(newsContent,myImageGetter,null));//显示新闻内容            &#125;        &#125;    &#125;    @SuppressLint(&quot;SetTextI18n&quot;)    private void setComment() &#123;        if (newCommentBean == null)&#123;            MyToast(&quot;评论内容加载失败: 未知原因&quot;);        &#125;        else if (newCommentBean.getCode() != 200)&#123;            MyToast(&quot;评论内容加载失败: &quot; + newCommentBean.getMsg());        &#125;        else &#123;            allCommentSum.setText(&quot;全部评论(&quot; + Math.min(newCommentBean.getTotal(),99) + &quot;)&quot;);            if (newCommentBean.getTotal() != 0)&#123;//                评论不为空时                if (newsCommentAdapter == null)&#123;                    noComment.setVisibility(View.GONE);//隐藏没有评论的提示//                    使用重写的MyLinearLayoutManager使列表绝对禁止滑动                    MyLinearLayoutManager layoutManager = new MyLinearLayoutManager(this,RecyclerView.VERTICAL,false);//                    创建评论列表的适配器                    newsCommentAdapter = new NewsCommentAdapter(commentContents,commentUserNames,commentDates,this);//                    默认的分割线                    recyclerView.addItemDecoration(new DividerItemDecoration(NewsHomeActivity.this,DividerItemDecoration.VERTICAL));                    recyclerView.setAdapter(newsCommentAdapter);                    recyclerView.setLayoutManager(layoutManager);                &#125;                else &#123;//                    如果创建过评论列表的适配器则刷新数据                    newsCommentAdapter.notifyDataSetChanged();                &#125;            &#125;            else &#123;//                评论为空时显示没有评论                noComment.setVisibility(View.VISIBLE);            &#125;        &#125;    &#125;//    初始化界面    private void init() &#123;        newsId = getIntent().getExtras().getInt(&quot;newsId&quot;);        title = findViewById(R.id.title);        content = findViewById(R.id.content);        recyclerView = findViewById(R.id.recyclerView);        allCommentSum = findViewById(R.id.allCommentSum);        noComment = findViewById(R.id.noComment);    &#125;//    获取新闻详细信息    private void getNewsData() &#123;        new Thread()&#123;            @Override            public void run() &#123;                super.run();                newsHomeBean = (NewsHomeBean) myHttpRequest.myHttp(&quot;/prod-api/press/press/&quot; + newsId,null,NewsHomeBean.class,null,&quot;get&quot;);                Message message = Message.obtain();                message.what = 1;                handler.sendMessage(message);            &#125;        &#125;.start();    &#125;//    获取最新评论详细信息(最新评论最多5条)    private void getCommentData() &#123;        new Thread()&#123;            @Override            public void run() &#123;                super.run();                newCommentBean = (NewCommentBean) myHttpRequest.myHttp(&quot;/prod-api/press/comments/list?newsId=&quot; + newsId,null,NewCommentBean.class,null,&quot;get&quot;);                if (newCommentBean != null)&#123;                    int commentSum = Math.min(newCommentBean.getTotal(), 5);//commentSum不能大于五                    setList();//                    for循环中反向取值，得到最新的评论内容(最新评论最多5条)                    for (int i = 0,j = newCommentBean.getTotal()-1; i &lt; commentSum; i++,j--) &#123;                        commentContents.add(newCommentBean.getRows().get(j).getContent());                        commentUserNames.add(newCommentBean.getRows().get(j).getUserName());                        commentDates.add(newCommentBean.getRows().get(j).getCommentDate());                    &#125;                &#125;                Message message = Message.obtain();                message.what = 2;                handler.sendMessage(message);            &#125;        &#125;.start();    &#125;//    设置List清空或创建    private void setList() &#123;        if (commentContents != null &amp;&amp; commentUserNames != null &amp;&amp; commentDates != null)&#123;            commentContents.clear();            commentUserNames.clear();            commentDates.clear();        &#125;        else &#123;            commentContents = new ArrayList&lt;&gt;();            commentUserNames = new ArrayList&lt;&gt;();            commentDates = new ArrayList&lt;&gt;();        &#125;    &#125;//    点击写评论或全部评论时跳转到评论页面    public void onClick(View view) &#123;        // 这里有个坑，bundle+intent传递对象需要使用putSerializable        // 这样被传递的类和被传递的类中的每个内部类必须需实现Serializable接口        // 不然就报错，妈的        Intent intent = new Intent(NewsHomeActivity.this,CommentActivity.class);        Bundle bundle = new Bundle();        bundle.putInt(&quot;newsId&quot;,newsId);        bundle.putSerializable(&quot;newCommentBean&quot;, newCommentBean);        intent.putExtras(bundle);//使用bundle把新闻的id和评论内容传递到全部评论页面        startActivityForResult(intent,1);    &#125;//    回调判断    @Override    protected void onActivityResult(int requestCode, int resultCode, @Nullable Intent data) &#123;        super.onActivityResult(requestCode, resultCode, data);//        如果从评论页返回，刷新评论列表        if (requestCode == 1)&#123;            getCommentData();//刷新评论列表        &#125;    &#125;//    提示弹窗    private void MyToast(String message)&#123;        Toast.makeText(this,message,Toast.LENGTH_SHORT).show();    &#125;    //    结束页面    public void finishActivity(View view) &#123;  finish();  &#125;&#125;
全部评论页面布局&ensp;&ensp;&ensp;&ensp;当点击写评论或全部评论时就会跳转到这一页&ensp;&ensp;&ensp;&ensp;activity_comment.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout android:layout_height=&quot;match_parent&quot;    android:layout_width=&quot;match_parent&quot;    android:orientation=&quot;vertical&quot;    android:gravity=&quot;center_horizontal&quot;    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;    &lt;!--    Title--&gt;    &lt;LinearLayout        android:background=&quot;@color/blue&quot;        android:orientation=&quot;horizontal&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;58dp&quot;&gt;        &lt;LinearLayout            android:onClick=&quot;finishActivity&quot;            android:gravity=&quot;center&quot;            android:layout_width=&quot;58dp&quot;            android:layout_height=&quot;58dp&quot;&gt;            &lt;ImageView                android:src=&quot;@mipmap/back&quot;                android:layout_width=&quot;20dp&quot;                android:layout_height=&quot;20dp&quot;/&gt;        &lt;/LinearLayout&gt;        &lt;LinearLayout            android:gravity=&quot;center&quot;            android:layout_weight=&quot;1&quot;            android:layout_width=&quot;0dp&quot;            android:layout_height=&quot;match_parent&quot;&gt;            &lt;TextView                android:text=&quot;全部评论&quot;                android:textStyle=&quot;bold&quot;                android:textSize=&quot;18sp&quot;                android:textColor=&quot;@color/white&quot;                android:layout_width=&quot;wrap_content&quot;                android:layout_height=&quot;wrap_content&quot;/&gt;        &lt;/LinearLayout&gt;        &lt;LinearLayout            android:gravity=&quot;center&quot;            android:layout_width=&quot;58dp&quot;            android:layout_height=&quot;58dp&quot;&gt;        &lt;/LinearLayout&gt;    &lt;/LinearLayout&gt;    &lt;!--    Content--&gt;    &lt;LinearLayout        android:orientation=&quot;vertical&quot;        android:gravity=&quot;center_horizontal&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;match_parent&quot;&gt;        &lt;androidx.recyclerview.widget.RecyclerView            android:id=&quot;@+id/recyclerView&quot;            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;0dp&quot;            android:layout_marginLeft=&quot;10dp&quot;            android:layout_marginRight=&quot;10dp&quot;            android:layout_weight=&quot;1&quot; /&gt;        &lt;TextView            android:text=&quot;没有评论\n快来成为第一个吧OvO&quot;            android:gravity=&quot;center&quot;            android:textColor=&quot;@color/black&quot;            android:textSize=&quot;25sp&quot;            android:textStyle=&quot;bold&quot;            android:id=&quot;@+id/noComment&quot;            android:visibility=&quot;gone&quot;            android:layout_margin=&quot;10dp&quot;            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;match_parent&quot;/&gt;        &lt;LinearLayout            android:gravity=&quot;center_vertical&quot;            android:orientation=&quot;horizontal&quot;            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;48dp&quot;&gt;            &lt;EditText                android:hint=&quot;请输入评论内容&quot;                android:paddingLeft=&quot;10dp&quot;                android:paddingRight=&quot;10dp&quot;                android:textSize=&quot;16sp&quot;                android:id=&quot;@+id/edit_comment&quot;                android:background=&quot;@drawable/edit_text_style&quot;                android:layout_weight=&quot;1&quot;                android:layout_width=&quot;0dp&quot;                android:layout_marginLeft=&quot;10dp&quot;                android:layout_height=&quot;38dp&quot;/&gt;            &lt;Button                android:text=&quot;发送&quot;                android:textStyle=&quot;bold&quot;                android:textColor=&quot;@color/white&quot;                android:textSize=&quot;15sp&quot;                android:id=&quot;@+id/sendComment&quot;                android:background=&quot;@drawable/button_style2&quot;                android:layout_marginRight=&quot;10dp&quot;                android:layout_marginLeft=&quot;10dp&quot;                android:layout_width=&quot;58dp&quot;                android:layout_height=&quot;38dp&quot;/&gt;        &lt;/LinearLayout&gt;    &lt;/LinearLayout&gt;&lt;/LinearLayout&gt;
全部评论程序设计&ensp;&ensp;&ensp;&ensp;全部评论页面和新闻详情页面中的评论只有两个不同的地方：1.一个加载全部评论，一个加载部分评论；2.一个可以写评论，一个不可以写评论&ensp;&ensp;&ensp;&ensp;CommentActivity.javapackage com.SmartCity.NewsHome;import androidx.annotation.NonNull;import androidx.appcompat.app.AppCompatActivity;import androidx.recyclerview.widget.DividerItemDecoration;import androidx.recyclerview.widget.LinearLayoutManager;import androidx.recyclerview.widget.RecyclerView;import android.os.Bundle;import android.os.Handler;import android.os.Looper;import android.os.Message;import android.text.TextUtils;import android.view.View;import android.widget.Button;import android.widget.EditText;import android.widget.TextView;import android.widget.Toast;import com.SmartCity.Bean;import com.SmartCity.MyHttpRequest;import com.SmartCity.R;import com.SmartCity.SoftData;import java.util.ArrayList;import java.util.List;public class CommentActivity extends AppCompatActivity &#123;    private int newsId;//新闻的id    private NewCommentBean newCommentBean;//评论内容的反序列化对象    private Button sendComment;//发送按钮    private EditText edit_comment;//输入的评论内容    private RecyclerView recyclerView;//评论列表    private MyHttpRequest myHttpRequest = new MyHttpRequest();//封装的服务器通信模块    private Handler handler;//线程通信    private List&lt;String&gt; commentContents;//评论内容    private List&lt;String&gt; commentUserNames;//评论者昵称    private List&lt;String&gt; commentDates;//评论时间    private NewsCommentAdapter newsCommentAdapter;//评论列表的适配器    private TextView noComment;//没有评论时显示的view    private Bean bean;//通用的最简单的反序列化对象    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_comment);        myHandler();//线程通信        init();//初始化界面        submit();//设置监听        getData();//获取数据        setComment();//加载评论列表    &#125;//    线程通信    private void myHandler() &#123;        handler = new Handler(Looper.getMainLooper())&#123;            @Override            public void handleMessage(@NonNull Message msg) &#123;                super.handleMessage(msg);                if (msg.what == 1)&#123;                    setComment();                &#125;                else if (msg.what == 2)&#123;                    commentResult();//发送评论的结果                &#125;            &#125;        &#125;;    &#125;//    加载评论列表    private void setComment() &#123;        if (newCommentBean == null)&#123;            MyToast(&quot;评论内容加载失败: 未知原因&quot;);        &#125;        else if (newCommentBean.getCode() != 200)&#123;            MyToast(&quot;评论内容加载失败: &quot; + newCommentBean.getMsg());        &#125;        else &#123;//            评论内容为空时            if (newCommentBean.getTotal() != 0)&#123;//                是否实例化过评论列表适配器                if (newsCommentAdapter == null)&#123;                    noComment.setVisibility(View.GONE);//隐藏没有评论的提示                    recyclerView.setVisibility(View.VISIBLE);                    LinearLayoutManager layoutManager = new LinearLayoutManager(this,RecyclerView.VERTICAL,false);                    newsCommentAdapter = new NewsCommentAdapter(commentContents,commentUserNames,commentDates,this);//                    默认的分割线                    recyclerView.addItemDecoration(new DividerItemDecoration(CommentActivity.this,DividerItemDecoration.VERTICAL));                    recyclerView.setAdapter(newsCommentAdapter);                    recyclerView.setLayoutManager(layoutManager);                &#125;                else &#123;                    newsCommentAdapter.notifyDataSetChanged();                &#125;            &#125;            else &#123;//                显示没有评论的提示                noComment.setVisibility(View.VISIBLE);                recyclerView.setVisibility(View.GONE);            &#125;        &#125;    &#125;//    发送评论的结果    private void commentResult() &#123;        if (bean == null)&#123;            MyToast(&quot;评论失败: 未知原因&quot;);        &#125;        else if (bean.getCode() != 200)&#123;            MyToast(&quot;评论失败: &quot; + bean.getMsg());        &#125;        else &#123;            MyToast(&quot;评论发表成功&quot;);            getCommentData();            edit_comment.setText(&quot;&quot;);        &#125;    &#125;//    初始化页面    private void init() &#123;        sendComment = findViewById(R.id.sendComment);        edit_comment = findViewById(R.id.edit_comment);        recyclerView = findViewById(R.id.recyclerView);        newsId = getIntent().getExtras().getInt(&quot;newsId&quot;);        noComment = findViewById(R.id.noComment);        newCommentBean = (NewCommentBean) getIntent().getExtras().getSerializable(&quot;newCommentBean&quot;);    &#125;//    设置监听    private void submit() &#123;//        点击发送按钮时        sendComment.setOnClickListener(new View.OnClickListener() &#123;            @Override            public void onClick(View v) &#123;                String string = edit_comment.getText().toString();                if (TextUtils.isEmpty(string))&#123;                    MyToast(&quot;评论内容不可为空&quot;);                &#125;                else &#123;//                    发送评论内容                    sendCommentContent(string);                &#125;            &#125;        &#125;);    &#125;//    发送评论内容    private void sendCommentContent(String string) &#123;        new Thread()&#123;            @Override            public void run() &#123;                super.run();                String json = &quot;&#123;\n&quot; +                        &quot;\&quot;newsId\&quot;: &quot; + newsId + &quot;,\n&quot; +                        &quot;\&quot;content\&quot;: \&quot;&quot; + string + &quot;\&quot;\n&quot; +                        &quot;&#125;&quot;;                bean = (Bean) myHttpRequest.myHttp(&quot;/prod-api/press/pressComment&quot;,json,Bean.class, SoftData.token,&quot;post&quot;);                Message message = Message.obtain();                message.what = 2;                handler.sendMessage(message);            &#125;        &#125;.start();    &#125;    //    首次进入评论页面时加载    private void getData() &#123;        setList();//清空或创建集合        for (int i = 0,j = newCommentBean.getTotal()-1; i &lt; newCommentBean.getTotal(); i++,j--) &#123;//            反向取值，得到最新的评论内容            commentContents.add(newCommentBean.getRows().get(j).getContent());            commentUserNames.add(newCommentBean.getRows().get(j).getUserName());            commentDates.add(newCommentBean.getRows().get(j).getCommentDate());        &#125;    &#125;//    获取全部评论的详细内容    private void getCommentData() &#123;        new Thread()&#123;            @Override            public void run() &#123;                super.run();                newCommentBean = (NewCommentBean) myHttpRequest.myHttp(&quot;/prod-api/press/comments/list?newsId=&quot; + newsId,null,NewCommentBean.class,null,&quot;get&quot;);                if (newCommentBean != null)&#123;                    setList();                    for (int i = 0,j = newCommentBean.getTotal()-1; i &lt; newCommentBean.getTotal(); i++,j--) &#123;//                        反向取值，使最最新的评论在前                        commentContents.add(newCommentBean.getRows().get(j).getContent());                        commentUserNames.add(newCommentBean.getRows().get(j).getUserName());                        commentDates.add(newCommentBean.getRows().get(j).getCommentDate());                    &#125;                &#125;                Message message = Message.obtain();                message.what = 1;                handler.sendMessage(message);            &#125;        &#125;.start();    &#125;//    设置List清空或创建    private void setList() &#123;        if (commentContents != null &amp;&amp; commentUserNames != null &amp;&amp; commentDates != null)&#123;            commentContents.clear();            commentUserNames.clear();            commentDates.clear();        &#125;        else &#123;            commentContents = new ArrayList&lt;&gt;();            commentUserNames = new ArrayList&lt;&gt;();            commentDates = new ArrayList&lt;&gt;();        &#125;    &#125;//    弹窗提示    private void MyToast(String message)&#123;        Toast.makeText(this,message,Toast.LENGTH_SHORT).show();    &#125;//    关闭页面    public void finishActivity(View view) &#123;  finish();  &#125;&#125;
&ensp;&ensp;&ensp;&ensp;现在主页面已经全部搞定了，我这里“主页面”的设计范围是根据题目要求定的，下面这些功能都实现了，所以我说主页面全部搞定了
&ensp;&ensp;&ensp;&ensp;从下一篇开始就是“个人中心页”的开发。欲知后事如何，且听下回分解
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android开发手记</tag>
        <tag>智慧城市</tag>
      </tags>
  </entry>
  <entry>
    <title>Android实战-智慧城市(2)</title>
    <url>/2021/11/02/Android%E5%AE%9E%E6%88%98-%E6%99%BA%E6%85%A7%E5%9F%8E%E5%B8%82-2/</url>
    <content><![CDATA[续上回，Android实战-智慧城市
软件设计主页面&ensp;&ensp;&ensp;&ensp;主页面是个大工程，首先用ViewPager2+Fragment的方式实现了4页切换，与引导页不同的是每页有一个单独的Fragment页面，底部的四个按钮与四个页面相呼应
智慧城市页&ensp;&ensp;&ensp;&ensp;算是HomeActivity的4个Fragment中最复杂的一个，从题目要求中可以看出，该页需要加载 轮播图、推荐服务、专题、新闻分类四个模块，妈的，难搞
创建轮播图的适配器&ensp;&ensp;&ensp;&ensp;轮播图使用了Banner插件2.2.2版本，具体引入方式前面已经说过，简单使用方式可以看之前博客中写过的例子，Banner的GitHub地址&ensp;&ensp;&ensp;&ensp;创建轮播图的适配器MyBannerAdapter.java继承BannerAdapter，BannerAdapter是一个泛型类，如果只想实现一些简单的功能，也可以直接在HomeFragemnt0的代码中使用默认的适配器new BannerImageAdapter&lt;&gt;()package com.SmartCity.Home;import android.content.Context;import android.view.View;import android.view.ViewGroup;import android.widget.ImageView;import androidx.annotation.NonNull;import androidx.recyclerview.widget.RecyclerView;import com.bumptech.glide.Glide;import com.youth.banner.adapter.BannerAdapter;import java.util.List;public class MyBannerAdapter extends BannerAdapter&lt;String,MyBannerAdapter.MyViewHolder&gt; &#123;    private List&lt;String&gt; datas;//传入的图片url集合    private Context context;    public MyBannerAdapter(List&lt;String&gt; datas, Context context) &#123;        super(datas);        this.datas = datas;//它的长度直接决定了轮播图的item个数        this.context = context;    &#125;    @Override//    传入布局    public MyViewHolder onCreateHolder(ViewGroup parent, int viewType) &#123;//        创建ImageView并设置大小        ImageView imageView = new ImageView(context);        imageView.setLayoutParams(new ViewGroup.LayoutParams(                ViewGroup.LayoutParams.MATCH_PARENT,                ViewGroup.LayoutParams.MATCH_PARENT        ));        imageView.setScaleType(ImageView.ScaleType.FIT_XY);//设置剪裁方式//        传递给ViewHolder        return new MyViewHolder(imageView);    &#125;//    绑定事件    @Override    public void onBindView(MyViewHolder holder, String data, int position, int size) &#123;        Glide.with(context).load(data).into(holder.imageView);    &#125;    public class MyViewHolder extends RecyclerView.ViewHolder &#123;        private ImageView imageView;        public MyViewHolder(@NonNull View itemView) &#123;            super(itemView);            imageView = (ImageView) itemView;        &#125;    &#125;&#125;
轮播图数据的反序列化对象&ensp;&ensp;&ensp;&ensp;用于对请求到的轮播图json内容反序列化&ensp;&ensp;&ensp;&ensp;NewsBannerBean.javapackage com.SmartCity.Home;import java.util.List;public class NewsBannerBean &#123;    private int total;    private List&lt;RowsBean&gt; rows;    private int code;    private String msg;    public int getTotal() &#123;        return total;    &#125;    public void setTotal(int total) &#123;        this.total = total;    &#125;    public List&lt;RowsBean&gt; getRows() &#123;        return rows;    &#125;    public void setRows(List&lt;RowsBean&gt; rows) &#123;        this.rows = rows;    &#125;    public int getCode() &#123;        return code;    &#125;    public void setCode(int code) &#123;        this.code = code;    &#125;    public String getMsg() &#123;        return msg;    &#125;    public void setMsg(String msg) &#123;        this.msg = msg;    &#125;    public static class RowsBean &#123;        private Object searchValue;        private String createBy;        private String createTime;        private String updateBy;        private String updateTime;        private Object remark;        private ParamsBean params;        private int id;        private String appType;        private String status;        private int sort;        private String advTitle;        private String advImg;        private String servModule;        private int targetId;        private String type;        public Object getSearchValue() &#123;            return searchValue;        &#125;        public void setSearchValue(Object searchValue) &#123;            this.searchValue = searchValue;        &#125;        public String getCreateBy() &#123;            return createBy;        &#125;        public void setCreateBy(String createBy) &#123;            this.createBy = createBy;        &#125;        public String getCreateTime() &#123;            return createTime;        &#125;        public void setCreateTime(String createTime) &#123;            this.createTime = createTime;        &#125;        public String getUpdateBy() &#123;            return updateBy;        &#125;        public void setUpdateBy(String updateBy) &#123;            this.updateBy = updateBy;        &#125;        public String getUpdateTime() &#123;            return updateTime;        &#125;        public void setUpdateTime(String updateTime) &#123;            this.updateTime = updateTime;        &#125;        public Object getRemark() &#123;            return remark;        &#125;        public void setRemark(Object remark) &#123;            this.remark = remark;        &#125;        public ParamsBean getParams() &#123;            return params;        &#125;        public void setParams(ParamsBean params) &#123;            this.params = params;        &#125;        public int getId() &#123;            return id;        &#125;        public void setId(int id) &#123;            this.id = id;        &#125;        public String getAppType() &#123;            return appType;        &#125;        public void setAppType(String appType) &#123;            this.appType = appType;        &#125;        public String getStatus() &#123;            return status;        &#125;        public void setStatus(String status) &#123;            this.status = status;        &#125;        public int getSort() &#123;            return sort;        &#125;        public void setSort(int sort) &#123;            this.sort = sort;        &#125;        public String getAdvTitle() &#123;            return advTitle;        &#125;        public void setAdvTitle(String advTitle) &#123;            this.advTitle = advTitle;        &#125;        public String getAdvImg() &#123;            return advImg;        &#125;        public void setAdvImg(String advImg) &#123;            this.advImg = advImg;        &#125;        public String getServModule() &#123;            return servModule;        &#125;        public void setServModule(String servModule) &#123;            this.servModule = servModule;        &#125;        public int getTargetId() &#123;            return targetId;        &#125;        public void setTargetId(int targetId) &#123;            this.targetId = targetId;        &#125;        public String getType() &#123;            return type;        &#125;        public void setType(String type) &#123;            this.type = type;        &#125;        public static class ParamsBean &#123;        &#125;    &#125;&#125;
全部服务的反序列化对象类&ensp;&ensp;&ensp;&ensp;取“全部服务”中“推荐服务”的图标&ensp;&ensp;&ensp;&ensp;ServiceBean.javapackage com.SmartCity.Home;import java.util.List;public class ServiceBean &#123;    private int total;    private List&lt;RowsBean&gt; rows;    private int code;    private String msg;    public int getTotal() &#123;        return total;    &#125;    public void setTotal(int total) &#123;        this.total = total;    &#125;    public List&lt;RowsBean&gt; getRows() &#123;        return rows;    &#125;    public void setRows(List&lt;RowsBean&gt; rows) &#123;        this.rows = rows;    &#125;    public int getCode() &#123;        return code;    &#125;    public void setCode(int code) &#123;        this.code = code;    &#125;    public String getMsg() &#123;        return msg;    &#125;    public void setMsg(String msg) &#123;        this.msg = msg;    &#125;    public static class RowsBean &#123;        private Object searchValue;        private Object createBy;        private String createTime;        private Object updateBy;        private String updateTime;        private Object remark;        private ParamsBean params;        private int id;        private String serviceName;        private String serviceDesc;        private String serviceType;        private String imgUrl;        private int pid;        private String link;        private int sort;        private String isRecommend;        public Object getSearchValue() &#123;            return searchValue;        &#125;        public void setSearchValue(Object searchValue) &#123;            this.searchValue = searchValue;        &#125;        public Object getCreateBy() &#123;            return createBy;        &#125;        public void setCreateBy(Object createBy) &#123;            this.createBy = createBy;        &#125;        public String getCreateTime() &#123;            return createTime;        &#125;        public void setCreateTime(String createTime) &#123;            this.createTime = createTime;        &#125;        public Object getUpdateBy() &#123;            return updateBy;        &#125;        public void setUpdateBy(Object updateBy) &#123;            this.updateBy = updateBy;        &#125;        public String getUpdateTime() &#123;            return updateTime;        &#125;        public void setUpdateTime(String updateTime) &#123;            this.updateTime = updateTime;        &#125;        public Object getRemark() &#123;            return remark;        &#125;        public void setRemark(Object remark) &#123;            this.remark = remark;        &#125;        public ParamsBean getParams() &#123;            return params;        &#125;        public void setParams(ParamsBean params) &#123;            this.params = params;        &#125;        public int getId() &#123;            return id;        &#125;        public void setId(int id) &#123;            this.id = id;        &#125;        public String getServiceName() &#123;            return serviceName;        &#125;        public void setServiceName(String serviceName) &#123;            this.serviceName = serviceName;        &#125;        public String getServiceDesc() &#123;            return serviceDesc;        &#125;        public void setServiceDesc(String serviceDesc) &#123;            this.serviceDesc = serviceDesc;        &#125;        public String getServiceType() &#123;            return serviceType;        &#125;        public void setServiceType(String serviceType) &#123;            this.serviceType = serviceType;        &#125;        public String getImgUrl() &#123;            return imgUrl;        &#125;        public void setImgUrl(String imgUrl) &#123;            this.imgUrl = imgUrl;        &#125;        public int getPid() &#123;            return pid;        &#125;        public void setPid(int pid) &#123;            this.pid = pid;        &#125;        public String getLink() &#123;            return link;        &#125;        public void setLink(String link) &#123;            this.link = link;        &#125;        public int getSort() &#123;            return sort;        &#125;        public void setSort(int sort) &#123;            this.sort = sort;        &#125;        public String getIsRecommend() &#123;            return isRecommend;        &#125;        public void setIsRecommend(String isRecommend) &#123;            this.isRecommend = isRecommend;        &#125;        public static class ParamsBean &#123;        &#125;    &#125;&#125;
新闻类型的反序列化对象类&ensp;&ensp;&ensp;&ensp;一共有6个固定的类型，这里使用新闻类型反序列化对象的目的主要是得到每个类型对应的类型id&ensp;&ensp;&ensp;&ensp;NewsTypeBean.javapackage com.SmartCity.Home;import java.util.List;public class NewsTypeBean &#123;    private String msg;    private int code;    private List&lt;DataBean&gt; data;    public String getMsg() &#123;        return msg;    &#125;    public void setMsg(String msg) &#123;        this.msg = msg;    &#125;    public int getCode() &#123;        return code;    &#125;    public void setCode(int code) &#123;        this.code = code;    &#125;    public List&lt;DataBean&gt; getData() &#123;        return data;    &#125;    public void setData(List&lt;DataBean&gt; data) &#123;        this.data = data;    &#125;    public static class DataBean &#123;        private Object searchValue;        private Object createBy;        private Object createTime;        private Object updateBy;        private Object updateTime;        private Object remark;        private ParamsBean params;        private int id;        private String appType;        private String name;        private int sort;        private String status;        private Object parentId;        public Object getSearchValue() &#123;            return searchValue;        &#125;        public void setSearchValue(Object searchValue) &#123;            this.searchValue = searchValue;        &#125;        public Object getCreateBy() &#123;            return createBy;        &#125;        public void setCreateBy(Object createBy) &#123;            this.createBy = createBy;        &#125;        public Object getCreateTime() &#123;            return createTime;        &#125;        public void setCreateTime(Object createTime) &#123;            this.createTime = createTime;        &#125;        public Object getUpdateBy() &#123;            return updateBy;        &#125;        public void setUpdateBy(Object updateBy) &#123;            this.updateBy = updateBy;        &#125;        public Object getUpdateTime() &#123;            return updateTime;        &#125;        public void setUpdateTime(Object updateTime) &#123;            this.updateTime = updateTime;        &#125;        public Object getRemark() &#123;            return remark;        &#125;        public void setRemark(Object remark) &#123;            this.remark = remark;        &#125;        public ParamsBean getParams() &#123;            return params;        &#125;        public void setParams(ParamsBean params) &#123;            this.params = params;        &#125;        public int getId() &#123;            return id;        &#125;        public void setId(int id) &#123;            this.id = id;        &#125;        public String getAppType() &#123;            return appType;        &#125;        public void setAppType(String appType) &#123;            this.appType = appType;        &#125;        public String getName() &#123;            return name;        &#125;        public void setName(String name) &#123;            this.name = name;        &#125;        public int getSort() &#123;            return sort;        &#125;        public void setSort(int sort) &#123;            this.sort = sort;        &#125;        public String getStatus() &#123;            return status;        &#125;        public void setStatus(String status) &#123;            this.status = status;        &#125;        public Object getParentId() &#123;            return parentId;        &#125;        public void setParentId(Object parentId) &#123;            this.parentId = parentId;        &#125;        public static class ParamsBean &#123;        &#125;    &#125;&#125;
新闻列表的反序列化对象&ensp;&ensp;&ensp;&ensp;所有新闻的列表，包括新闻的id、标题等都在里边&ensp;&ensp;&ensp;&ensp;NewsContentBean.javapackage com.SmartCity.Home;import java.util.List;//新闻列表public class NewsContentBean &#123;    private int total;    private List&lt;RowsBean&gt; rows;    private int code;    private String msg;    public int getTotal() &#123;        return total;    &#125;    public void setTotal(int total) &#123;        this.total = total;    &#125;    public List&lt;RowsBean&gt; getRows() &#123;        return rows;    &#125;    public void setRows(List&lt;RowsBean&gt; rows) &#123;        this.rows = rows;    &#125;    public int getCode() &#123;        return code;    &#125;    public void setCode(int code) &#123;        this.code = code;    &#125;    public String getMsg() &#123;        return msg;    &#125;    public void setMsg(String msg) &#123;        this.msg = msg;    &#125;    public static class RowsBean &#123;        private Object searchValue;        private String createBy;        private String createTime;        private String updateBy;        private String updateTime;        private Object remark;        private ParamsBean params;        private int id;        private String appType;        private String cover;        private String title;        private Object subTitle;        private String content;        private String status;        private String publishDate;        private Object tags;        private int commentNum;        private int likeNum;        private int readNum;        private String type;        private String top;        private String hot;        public Object getSearchValue() &#123;            return searchValue;        &#125;        public void setSearchValue(Object searchValue) &#123;            this.searchValue = searchValue;        &#125;        public String getCreateBy() &#123;            return createBy;        &#125;        public void setCreateBy(String createBy) &#123;            this.createBy = createBy;        &#125;        public String getCreateTime() &#123;            return createTime;        &#125;        public void setCreateTime(String createTime) &#123;            this.createTime = createTime;        &#125;        public String getUpdateBy() &#123;            return updateBy;        &#125;        public void setUpdateBy(String updateBy) &#123;            this.updateBy = updateBy;        &#125;        public String getUpdateTime() &#123;            return updateTime;        &#125;        public void setUpdateTime(String updateTime) &#123;            this.updateTime = updateTime;        &#125;        public Object getRemark() &#123;            return remark;        &#125;        public void setRemark(Object remark) &#123;            this.remark = remark;        &#125;        public ParamsBean getParams() &#123;            return params;        &#125;        public void setParams(ParamsBean params) &#123;            this.params = params;        &#125;        public int getId() &#123;            return id;        &#125;        public void setId(int id) &#123;            this.id = id;        &#125;        public String getAppType() &#123;            return appType;        &#125;        public void setAppType(String appType) &#123;            this.appType = appType;        &#125;        public String getCover() &#123;            return cover;        &#125;        public void setCover(String cover) &#123;            this.cover = cover;        &#125;        public String getTitle() &#123;            return title;        &#125;        public void setTitle(String title) &#123;            this.title = title;        &#125;        public Object getSubTitle() &#123;            return subTitle;        &#125;        public void setSubTitle(Object subTitle) &#123;            this.subTitle = subTitle;        &#125;        public String getContent() &#123;            return content;        &#125;        public void setContent(String content) &#123;            this.content = content;        &#125;        public String getStatus() &#123;            return status;        &#125;        public void setStatus(String status) &#123;            this.status = status;        &#125;        public String getPublishDate() &#123;            return publishDate;        &#125;        public void setPublishDate(String publishDate) &#123;            this.publishDate = publishDate;        &#125;        public Object getTags() &#123;            return tags;        &#125;        public void setTags(Object tags) &#123;            this.tags = tags;        &#125;        public int getCommentNum() &#123;            return commentNum;        &#125;        public void setCommentNum(int commentNum) &#123;            this.commentNum = commentNum;        &#125;        public int getLikeNum() &#123;            return likeNum;        &#125;        public void setLikeNum(int likeNum) &#123;            this.likeNum = likeNum;        &#125;        public int getReadNum() &#123;            return readNum;        &#125;        public void setReadNum(int readNum) &#123;            this.readNum = readNum;        &#125;        public String getType() &#123;            return type;        &#125;        public void setType(String type) &#123;            this.type = type;        &#125;        public String getTop() &#123;            return top;        &#125;        public void setTop(String top) &#123;            this.top = top;        &#125;        public String getHot() &#123;            return hot;        &#125;        public void setHot(String hot) &#123;            this.hot = hot;        &#125;        public static class ParamsBean &#123;        &#125;    &#125;&#125;
重写ScrollView&ensp;&ensp;&ensp;&ensp;创建MyScrollView.java类继承ScrollView；通过重写ScrollView的onLayout和dispatchDraw，拿到ScrolloView的唯一子view，从它的唯一子view中遍历得到fixNavBar，并在ScrollView滑动的过程中判断fixNavBar是否到达顶部，当它到达顶部时，使RecyclerView允许滑动(默认禁止)，并绘制fixNavBar在窗口的顶部；当他没有位于顶部时，则禁用ScrollView的滑动&ensp;&ensp;&ensp;&ensp;MyScrollView.javapackage com.SmartCity.Home;import android.content.Context;import android.graphics.Canvas;import android.util.AttributeSet;import android.util.Log;import android.view.View;import android.widget.LinearLayout;import android.widget.ScrollView;import android.widget.Toast;public class MyScrollView extends ScrollView &#123;    public MyScrollView(Context context) &#123;        super(context);    &#125;    public MyScrollView(Context context, AttributeSet attrs) &#123;        super(context, attrs);    &#125;    public MyScrollView(Context context, AttributeSet attrs, int defStyleAttr) &#123;        super(context, attrs, defStyleAttr);    &#125;    private View view;//储存fixNavBar    @Override    protected void onLayout(boolean changed, int l, int t, int r, int b) &#123;        super.onLayout(changed, l, t, r, b);        if (changed)&#123;//            ScrollView的子View(ScrollView只能有一个子view)            LinearLayout layout = (LinearLayout) getChildAt(0);            if (layout != null)&#123;//                判断fixNavBar是否在layout中                for (int i = 0; i &lt; layout.getChildCount(); i++) &#123;                    if (layout.getChildAt(i).getTag() != null &amp;&amp; layout.getChildAt(i).getTag().equals(&quot;fixNavBar&quot;))&#123;                        view = layout.getChildAt(i);                        break;                    &#125;                &#125;            &#125;            else &#123;                Toast.makeText(getContext(),&quot;ScrollView没有子View&quot;,Toast.LENGTH_SHORT).show();            &#125;        &#125;    &#125;    @Override    protected void dispatchDraw(Canvas canvas) &#123;        super.dispatchDraw(canvas);//        Log.d(&quot;TAG&quot;, &quot;dispatchDraw: getScaleY():&quot; + getScrollY() + &quot;,view.getTop():&quot; + view.getTop() + &quot;,onFixNavBarLintener:&quot; + onFixNavBarLintener);        if (getScrollY() &gt;= view.getTop())&#123;//            说明滑动到了顶部            if (onFixNavBarLintener != null)&#123;                Log.d(&quot;TAG&quot;, &quot;dispatchDraw: NavBar固定&quot;);                onFixNavBarLintener.OnFix();//                绘制fixNavBar                canvas.save();                canvas.translate(0,getScrollY());                canvas.clipRect(0,0,view.getMeasuredWidth(),view.getMeasuredHeight());                view.draw(canvas);                canvas.restore();            &#125;        &#125;        else &#123;            if (onFixNavBarLintener != null)&#123;                Log.d(&quot;TAG&quot;, &quot;dispatchDraw: NavBar解除&quot;);                onFixNavBarLintener.OnReset();            &#125;        &#125;    &#125;    private OnFixNavBarLintener onFixNavBarLintener;    public void setOnFixNavBarLintener(OnFixNavBarLintener onFixNavBarLintener)&#123;        this.onFixNavBarLintener = onFixNavBarLintener;    &#125;    public interface OnFixNavBarLintener&#123;        void OnFix();        void OnReset();    &#125;&#125;
新闻列表的适配器&ensp;&ensp;&ensp;&ensp;显示新闻列表，动态加载封面图，点击item对返回对应的新闻id&ensp;&ensp;&ensp;&ensp;Home0NewsAdapter.javapackage com.SmartCity.Home;import android.content.Context;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import android.widget.ImageView;import android.widget.TextView;import androidx.annotation.NonNull;import androidx.recyclerview.widget.RecyclerView;import com.SmartCity.R;import com.SmartCity.SoftData;import com.bumptech.glide.Glide;import java.util.List;public class Home0NewsAdapter extends RecyclerView.Adapter&lt;Home0NewsAdapter.MyViewHolder&gt; &#123;    private List&lt;String&gt; newsCover;    private List&lt;String&gt; newsTitle;    private Context context;    public Home0NewsAdapter(List&lt;String&gt; newsCover,List&lt;String&gt; newsTitle,Context context)&#123;        this.newsCover = newsCover;        this.newsTitle = newsTitle;        this.context = context;    &#125;    @NonNull    @Override    public MyViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) &#123;        View view = LayoutInflater.from(context).inflate(R.layout.fragment_home0_news_item,parent,false);        return new MyViewHolder(view);    &#125;    @Override    public void onBindViewHolder(@NonNull MyViewHolder holder, int position) &#123;        Glide.with(context).load(&quot;http://&quot; + SoftData.ipPort + newsCover.get(position)).into(holder.cover);        holder.title.setText(newsTitle.get(position));    &#125;    @Override    public int getItemCount() &#123;        return newsTitle.size();    &#125;    public class MyViewHolder extends RecyclerView.ViewHolder &#123;        private ImageView cover;        private TextView title;        public MyViewHolder(@NonNull View itemView) &#123;            super(itemView);            cover = itemView.findViewById(R.id.cover);            title = itemView.findViewById(R.id.title);            itemView.setOnClickListener(new View.OnClickListener() &#123;                @Override                public void onClick(View v) &#123;                    if (onItemLintener != null)&#123;                        onItemLintener.OnItemClick(getAbsoluteAdapterPosition());                    &#125;                &#125;            &#125;);        &#125;    &#125;    private OnItemLintener onItemLintener;    public void setOnItemLintener(OnItemLintener onItemLintener) &#123;        this.onItemLintener = onItemLintener;    &#125;    public interface OnItemLintener&#123;        void OnItemClick(int position);    &#125;&#125;
页面设计及功能实现&ensp;&ensp;&ensp;&ensp;上面的准备工作都做完了，然后就是对智慧城市页的开发
智慧城市页页面布局&ensp;&ensp;&ensp;&ensp;这一页主要分4大块，轮播图、推荐服务、专题、新闻分类，布局可以说是整个App中最复杂的一页；这里的MyScrollView继承重写了ScrollView，所以view中是它的完整类名&ensp;&ensp;&ensp;&ensp;fragment_home0.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:tools=&quot;http://schemas.android.com/tools&quot;    android:layout_height=&quot;match_parent&quot;    android:layout_width=&quot;match_parent&quot;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;    android:orientation=&quot;vertical&quot;    android:background=&quot;@color/darker_gray&quot;    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;    &lt;com.SmartCity.Home.MyScrollView        android:id=&quot;@+id/myScrollView&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;match_parent&quot;&gt;        &lt;LinearLayout            android:orientation=&quot;vertical&quot;            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;match_parent&quot;&gt;            &lt;!--    轮播图--&gt;            &lt;com.youth.banner.Banner                android:layout_margin=&quot;10dp&quot;                android:background=&quot;@color/white&quot;                android:id=&quot;@+id/banner&quot;                android:layout_width=&quot;match_parent&quot;                android:layout_height=&quot;160dp&quot;/&gt;            &lt;!--    推荐服务--&gt;            &lt;LinearLayout                android:orientation=&quot;vertical&quot;                android:background=&quot;@color/white&quot;                android:layout_width=&quot;match_parent&quot;                android:layout_height=&quot;wrap_content&quot;&gt;                &lt;TextView                    android:text=&quot;推荐服务&quot;                    android:layout_marginLeft=&quot;10dp&quot;                    android:textColor=&quot;@color/black&quot;                    android:textSize=&quot;16sp&quot;                    android:layout_marginTop=&quot;10dp&quot;                    android:layout_marginBottom=&quot;5dp&quot;                    android:textStyle=&quot;bold&quot;                    android:layout_width=&quot;wrap_content&quot;                    android:layout_height=&quot;wrap_content&quot;                    android:layout_marginStart=&quot;10dp&quot; /&gt;                &lt;View                    android:background=&quot;@color/darker_gray&quot;                    android:layout_width=&quot;match_parent&quot;                    android:layout_height=&quot;1dp&quot;/&gt;                &lt;LinearLayout                    android:orientation=&quot;horizontal&quot;                    android:layout_width=&quot;match_parent&quot;                    android:layout_height=&quot;wrap_content&quot;&gt;                    &lt;LinearLayout                        android:layout_weight=&quot;1&quot;                        android:layout_width=&quot;0dp&quot;                        android:gravity=&quot;center&quot;                        android:id=&quot;@+id/serviceBtn0&quot;                        android:orientation=&quot;vertical&quot;                        android:layout_height=&quot;match_parent&quot;&gt;                        &lt;ImageView                            android:layout_marginTop=&quot;10dp&quot;                            android:layout_width=&quot;38dp&quot;                            android:layout_height=&quot;38dp&quot;/&gt;                        &lt;TextView                            android:text=&quot;name&quot;                            android:textSize=&quot;13dp&quot;                            android:textColor=&quot;@color/black&quot;                            android:layout_marginTop=&quot;5dp&quot;                            android:layout_marginBottom=&quot;10dp&quot;                            android:layout_width=&quot;wrap_content&quot;                            android:layout_height=&quot;wrap_content&quot;/&gt;                    &lt;/LinearLayout&gt;                    &lt;LinearLayout                        android:layout_weight=&quot;1&quot;                        android:layout_width=&quot;0dp&quot;                        android:gravity=&quot;center&quot;                        android:id=&quot;@+id/serviceBtn1&quot;                        android:orientation=&quot;vertical&quot;                        android:layout_height=&quot;match_parent&quot;&gt;                        &lt;ImageView                            android:layout_marginTop=&quot;10dp&quot;                            android:layout_width=&quot;38dp&quot;                            android:layout_height=&quot;38dp&quot;/&gt;                        &lt;TextView                            android:text=&quot;name&quot;                            android:textSize=&quot;13dp&quot;                            android:textColor=&quot;@color/black&quot;                            android:layout_marginTop=&quot;5dp&quot;                            android:layout_marginBottom=&quot;10dp&quot;                            android:layout_width=&quot;wrap_content&quot;                            android:layout_height=&quot;wrap_content&quot;/&gt;                    &lt;/LinearLayout&gt;                    &lt;LinearLayout                        android:layout_weight=&quot;1&quot;                        android:layout_width=&quot;0dp&quot;                        android:gravity=&quot;center&quot;                        android:id=&quot;@+id/serviceBtn2&quot;                        android:orientation=&quot;vertical&quot;                        android:layout_height=&quot;match_parent&quot;&gt;                        &lt;ImageView                            android:layout_marginTop=&quot;10dp&quot;                            android:layout_width=&quot;38dp&quot;                            android:layout_height=&quot;38dp&quot;/&gt;                        &lt;TextView                            android:text=&quot;name&quot;                            android:textSize=&quot;13dp&quot;                            android:textColor=&quot;@color/black&quot;                            android:layout_marginTop=&quot;5dp&quot;                            android:layout_marginBottom=&quot;10dp&quot;                            android:layout_width=&quot;wrap_content&quot;                            android:layout_height=&quot;wrap_content&quot;/&gt;                    &lt;/LinearLayout&gt;                    &lt;LinearLayout                        android:layout_weight=&quot;1&quot;                        android:layout_width=&quot;0dp&quot;                        android:gravity=&quot;center&quot;                        android:id=&quot;@+id/serviceBtn3&quot;                        android:orientation=&quot;vertical&quot;                        android:layout_height=&quot;match_parent&quot;&gt;                        &lt;ImageView                            android:layout_marginTop=&quot;10dp&quot;                            android:layout_width=&quot;38dp&quot;                            android:layout_height=&quot;38dp&quot;/&gt;                        &lt;TextView                            android:text=&quot;name&quot;                            android:textSize=&quot;13dp&quot;                            android:textColor=&quot;@color/black&quot;                            android:layout_marginTop=&quot;5dp&quot;                            android:layout_marginBottom=&quot;10dp&quot;                            android:layout_width=&quot;wrap_content&quot;                            android:layout_height=&quot;wrap_content&quot;/&gt;                    &lt;/LinearLayout&gt;                    &lt;LinearLayout                        android:layout_weight=&quot;1&quot;                        android:layout_width=&quot;0dp&quot;                        android:gravity=&quot;center&quot;                        android:id=&quot;@+id/serviceBtn4&quot;                        android:orientation=&quot;vertical&quot;                        android:layout_height=&quot;match_parent&quot;&gt;                        &lt;ImageView                            android:layout_marginTop=&quot;10dp&quot;                            android:layout_width=&quot;38dp&quot;                            android:layout_height=&quot;38dp&quot;/&gt;                        &lt;TextView                            android:text=&quot;name&quot;                            android:layout_marginTop=&quot;5dp&quot;                            android:layout_marginBottom=&quot;10dp&quot;                            android:textSize=&quot;13dp&quot;                            android:textColor=&quot;@color/black&quot;                            android:layout_width=&quot;wrap_content&quot;                            android:layout_height=&quot;wrap_content&quot;/&gt;                    &lt;/LinearLayout&gt;                &lt;/LinearLayout&gt;            &lt;/LinearLayout&gt;            &lt;!--    专题--&gt;            &lt;TextView                android:text=&quot;专题&quot;                android:layout_marginLeft=&quot;10dp&quot;                android:textColor=&quot;@color/black&quot;                android:textSize=&quot;16sp&quot;                android:layout_marginTop=&quot;10dp&quot;                android:textStyle=&quot;bold&quot;                android:layout_width=&quot;wrap_content&quot;                android:layout_height=&quot;wrap_content&quot;                android:layout_marginStart=&quot;10dp&quot; /&gt;            &lt;GridLayout                android:rowCount=&quot;2&quot;                android:columnCount=&quot;2&quot;                android:layout_margin=&quot;5dp&quot;                android:layout_width=&quot;match_parent&quot;                android:id=&quot;@+id/themeBtnGroup&quot;                android:layout_height=&quot;200dp&quot;&gt;                &lt;androidx.cardview.widget.CardView                    android:layout_rowWeight=&quot;1&quot;                    android:layout_columnWeight=&quot;1&quot;                    app:cardCornerRadius=&quot;5dp&quot;                    android:layout_margin=&quot;5dp&quot;                    android:layout_width=&quot;0dp&quot;                    android:layout_height=&quot;0dp&quot;                    tools:targetApi=&quot;lollipop&quot;&gt;                    &lt;LinearLayout                        android:background=&quot;@color/white&quot;                        android:orientation=&quot;horizontal&quot;                        android:id=&quot;@+id/themeBtn0&quot;                        android:layout_width=&quot;match_parent&quot;                        android:layout_height=&quot;match_parent&quot;&gt;                        &lt;ImageView                            android:scaleType=&quot;centerCrop&quot;                            android:layout_width=&quot;90dp&quot;                            android:layout_height=&quot;90dp&quot;/&gt;                        &lt;TextView                            android:gravity=&quot;center_vertical&quot;                            android:ellipsize=&quot;end&quot;                            android:textSize=&quot;15sp&quot;                            android:lines=&quot;3&quot;                            android:textColor=&quot;@color/black&quot;                            android:layout_margin=&quot;5dp&quot;                            android:layout_width=&quot;match_parent&quot;                            android:layout_height=&quot;match_parent&quot;/&gt;                    &lt;/LinearLayout&gt;                &lt;/androidx.cardview.widget.CardView&gt;                &lt;androidx.cardview.widget.CardView                    android:layout_rowWeight=&quot;1&quot;                    android:layout_columnWeight=&quot;1&quot;                    app:cardCornerRadius=&quot;5dp&quot;                    android:layout_margin=&quot;5dp&quot;                    android:layout_width=&quot;0dp&quot;                    android:layout_height=&quot;0dp&quot;                    tools:targetApi=&quot;lollipop&quot;&gt;                    &lt;LinearLayout                        android:background=&quot;@color/white&quot;                        android:id=&quot;@+id/themeBtn1&quot;                        android:orientation=&quot;horizontal&quot;                        android:layout_width=&quot;match_parent&quot;                        android:layout_height=&quot;match_parent&quot;&gt;                        &lt;ImageView                            android:scaleType=&quot;centerCrop&quot;                            android:layout_width=&quot;90dp&quot;                            android:layout_height=&quot;90dp&quot;/&gt;                        &lt;TextView                            android:gravity=&quot;center_vertical&quot;                            android:ellipsize=&quot;end&quot;                            android:textSize=&quot;15sp&quot;                            android:lines=&quot;3&quot;                            android:textColor=&quot;@color/black&quot;                            android:layout_margin=&quot;5dp&quot;                            android:layout_width=&quot;match_parent&quot;                            android:layout_height=&quot;match_parent&quot;/&gt;                    &lt;/LinearLayout&gt;                &lt;/androidx.cardview.widget.CardView&gt;                &lt;androidx.cardview.widget.CardView                    android:layout_rowWeight=&quot;1&quot;                    android:layout_columnWeight=&quot;1&quot;                    app:cardCornerRadius=&quot;5dp&quot;                    android:layout_margin=&quot;5dp&quot;                    android:layout_width=&quot;0dp&quot;                    android:layout_height=&quot;0dp&quot;                    tools:targetApi=&quot;lollipop&quot;&gt;                    &lt;LinearLayout                        android:background=&quot;@color/white&quot;                        android:orientation=&quot;horizontal&quot;                        android:id=&quot;@+id/themeBtn2&quot;                        android:layout_width=&quot;match_parent&quot;                        android:layout_height=&quot;match_parent&quot;&gt;                        &lt;ImageView                            android:scaleType=&quot;centerCrop&quot;                            android:layout_width=&quot;90dp&quot;                            android:layout_height=&quot;90dp&quot;/&gt;                        &lt;TextView                            android:gravity=&quot;center_vertical&quot;                            android:ellipsize=&quot;end&quot;                            android:textSize=&quot;15sp&quot;                            android:lines=&quot;3&quot;                            android:textColor=&quot;@color/black&quot;                            android:layout_margin=&quot;5dp&quot;                            android:layout_width=&quot;match_parent&quot;                            android:layout_height=&quot;match_parent&quot;/&gt;                    &lt;/LinearLayout&gt;                &lt;/androidx.cardview.widget.CardView&gt;                &lt;androidx.cardview.widget.CardView                    android:layout_rowWeight=&quot;1&quot;                    android:layout_columnWeight=&quot;1&quot;                    app:cardCornerRadius=&quot;5dp&quot;                    android:layout_margin=&quot;5dp&quot;                    android:layout_width=&quot;0dp&quot;                    android:layout_height=&quot;0dp&quot;                    tools:targetApi=&quot;lollipop&quot;&gt;                    &lt;LinearLayout                        android:background=&quot;@color/white&quot;                        android:orientation=&quot;horizontal&quot;                        android:id=&quot;@+id/themeBtn3&quot;                        android:layout_width=&quot;match_parent&quot;                        android:layout_height=&quot;match_parent&quot;&gt;                        &lt;ImageView                            android:scaleType=&quot;centerCrop&quot;                            android:layout_width=&quot;90dp&quot;                            android:layout_height=&quot;90dp&quot;/&gt;                        &lt;TextView                            android:gravity=&quot;center_vertical&quot;                            android:ellipsize=&quot;end&quot;                            android:textSize=&quot;15sp&quot;                            android:lines=&quot;3&quot;                            android:textColor=&quot;@color/black&quot;                            android:layout_margin=&quot;5dp&quot;                            android:layout_width=&quot;match_parent&quot;                            android:layout_height=&quot;match_parent&quot;/&gt;                    &lt;/LinearLayout&gt;                &lt;/androidx.cardview.widget.CardView&gt;            &lt;/GridLayout&gt;&lt;!--            新闻列表--&gt;            &lt;LinearLayout                android:orientation=&quot;vertical&quot;                android:id=&quot;@+id/fixNavBar&quot;                android:tag=&quot;fixNavBar&quot;                android:layout_width=&quot;match_parent&quot;                android:layout_height=&quot;60dp&quot;&gt;                &lt;HorizontalScrollView                    android:scrollbars=&quot;none&quot;                    android:id=&quot;@+id/newsTypeGroup&quot;                    android:background=&quot;@color/white&quot;                    android:layout_width=&quot;match_parent&quot;                    android:layout_height=&quot;59dp&quot;&gt;                    &lt;LinearLayout                        android:orientation=&quot;horizontal&quot;                        android:gravity=&quot;center_vertical&quot;                        android:layout_width=&quot;match_parent&quot;                        android:layout_height=&quot;match_parent&quot;&gt;                        &lt;TextView                            android:gravity=&quot;center&quot;                            android:textColor=&quot;@color/black&quot;                            android:textSize=&quot;15sp&quot;                            android:id=&quot;@+id/newsType0&quot;                            android:paddingLeft=&quot;10dp&quot;                            android:paddingRight=&quot;10dp&quot;                            android:textStyle=&quot;bold&quot;                            android:layout_width=&quot;wrap_content&quot;                            android:layout_height=&quot;match_parent&quot;/&gt;                        &lt;View                            android:background=&quot;@color/darker_gray&quot;                            android:layout_width=&quot;1dp&quot;                            android:layout_marginTop=&quot;10dp&quot;                            android:layout_marginBottom=&quot;10dp&quot;                            android:layout_height=&quot;match_parent&quot;/&gt;                        &lt;TextView                            android:gravity=&quot;center&quot;                            android:textColor=&quot;@color/black&quot;                            android:id=&quot;@+id/newsType1&quot;                            android:textSize=&quot;15sp&quot;                            android:paddingLeft=&quot;10dp&quot;                            android:paddingRight=&quot;10dp&quot;                            android:textStyle=&quot;bold&quot;                            android:layout_width=&quot;wrap_content&quot;                            android:layout_height=&quot;match_parent&quot;/&gt;                        &lt;View                            android:background=&quot;@color/darker_gray&quot;                            android:layout_width=&quot;1dp&quot;                            android:layout_marginTop=&quot;10dp&quot;                            android:layout_marginBottom=&quot;10dp&quot;                            android:layout_height=&quot;match_parent&quot;/&gt;                        &lt;TextView                            android:gravity=&quot;center&quot;                            android:textColor=&quot;@color/black&quot;                            android:id=&quot;@+id/newsType2&quot;                            android:textSize=&quot;15sp&quot;                            android:paddingLeft=&quot;10dp&quot;                            android:paddingRight=&quot;10dp&quot;                            android:textStyle=&quot;bold&quot;                            android:layout_width=&quot;wrap_content&quot;                            android:layout_height=&quot;match_parent&quot;/&gt;                        &lt;View                            android:background=&quot;@color/darker_gray&quot;                            android:layout_width=&quot;1dp&quot;                            android:layout_marginTop=&quot;10dp&quot;                            android:layout_marginBottom=&quot;10dp&quot;                            android:layout_height=&quot;match_parent&quot;/&gt;                        &lt;TextView                            android:gravity=&quot;center&quot;                            android:textColor=&quot;@color/black&quot;                            android:id=&quot;@+id/newsType3&quot;                            android:textSize=&quot;15sp&quot;                            android:paddingLeft=&quot;10dp&quot;                            android:paddingRight=&quot;10dp&quot;                            android:textStyle=&quot;bold&quot;                            android:layout_width=&quot;wrap_content&quot;                            android:layout_height=&quot;match_parent&quot;/&gt;                        &lt;View                            android:background=&quot;@color/darker_gray&quot;                            android:layout_width=&quot;1dp&quot;                            android:layout_marginTop=&quot;10dp&quot;                            android:layout_marginBottom=&quot;10dp&quot;                            android:layout_height=&quot;match_parent&quot;/&gt;                        &lt;TextView                            android:gravity=&quot;center&quot;                            android:textColor=&quot;@color/black&quot;                            android:id=&quot;@+id/newsType4&quot;                            android:textSize=&quot;15sp&quot;                            android:paddingLeft=&quot;10dp&quot;                            android:paddingRight=&quot;10dp&quot;                            android:textStyle=&quot;bold&quot;                            android:layout_width=&quot;wrap_content&quot;                            android:layout_height=&quot;match_parent&quot;/&gt;                        &lt;View                            android:background=&quot;@color/darker_gray&quot;                            android:layout_width=&quot;1dp&quot;                            android:layout_marginTop=&quot;10dp&quot;                            android:layout_marginBottom=&quot;10dp&quot;                            android:layout_height=&quot;match_parent&quot;/&gt;                        &lt;TextView                            android:gravity=&quot;center&quot;                            android:textColor=&quot;@color/black&quot;                            android:id=&quot;@+id/newsType5&quot;                            android:textSize=&quot;15sp&quot;                            android:paddingLeft=&quot;10dp&quot;                            android:paddingRight=&quot;10dp&quot;                            android:textStyle=&quot;bold&quot;                            android:layout_width=&quot;wrap_content&quot;                            android:layout_height=&quot;match_parent&quot;/&gt;                    &lt;/LinearLayout&gt;                &lt;/HorizontalScrollView&gt;                &lt;View                    android:background=&quot;@color/darker_gray&quot;                    android:layout_width=&quot;match_parent&quot;                    android:layout_height=&quot;1dp&quot;/&gt;            &lt;/LinearLayout&gt;            &lt;androidx.recyclerview.widget.RecyclerView                android:background=&quot;@color/white&quot;                android:paddingRight=&quot;10dp&quot;                android:paddingLeft=&quot;10dp&quot;                android:id=&quot;@+id/recyclerView&quot;                android:layout_width=&quot;match_parent&quot;                android:layout_height=&quot;wrap_content&quot;/&gt;        &lt;/LinearLayout&gt;    &lt;/com.SmartCity.Home.MyScrollView&gt;&lt;/LinearLayout&gt;
智慧城市页程序设计&ensp;&ensp;&ensp;&ensp;Banner轮播图：使用了banner2.2.2插件加载轮播图，通过重写banner的适配器，在适配器中使用Glide动态加载轮播图图片&ensp;&ensp;&ensp;&ensp;推荐服务：推荐服务虽然是固定的6个服务项，但是要通过网络获取他们对应的图标，所以向全部服务列表发送请求，得到对应的图标并使用Glide动态加载；推荐服务当前点击只提示服务名，等待对应服务开发完毕后再响应intent跳转&ensp;&ensp;&ensp;&ensp;专题：专题和新闻列表使用了同一个反序列化对象，这里没有兼容ipad，可以通过设置GridLayout的row和cul使其发生布局变化；专题当前点击仅提示点击的文章id，等文章显示页面开发完毕之后再响应intent跳转&ensp;&ensp;&ensp;&ensp;新闻分类：难就难在ScrollView嵌套RecyclerView中的导航栏固定，需要重写ScrollView，新闻列表当前点击仅提示点击的文章id，等文章显示页面开发完毕之后再响应intent跳转&ensp;&ensp;&ensp;&ensp;HomeFragment0.javapackage com.SmartCity.Home;import android.os.Bundle;import androidx.annotation.NonNull;import androidx.fragment.app.Fragment;import androidx.recyclerview.widget.DividerItemDecoration;import androidx.recyclerview.widget.LinearLayoutManager;import androidx.recyclerview.widget.RecyclerView;import android.os.Handler;import android.os.Looper;import android.os.Message;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import android.widget.GridLayout;import android.widget.ImageView;import android.widget.LinearLayout;import android.widget.TextView;import android.widget.Toast;import com.SmartCity.MyHttpRequest;import com.SmartCity.R;import com.SmartCity.SoftData;import com.bumptech.glide.Glide;import com.youth.banner.Banner;import com.youth.banner.indicator.CircleIndicator;import com.youth.banner.listener.OnBannerListener;import java.util.ArrayList;import java.util.List;public class HomeFragment0 extends Fragment implements View.OnClickListener &#123;    private static final String TAG = &quot;HomeFragment0&quot;;    private View viewRoot;//页面布局    private Banner banner;//轮播图    private RecyclerView recyclerView;//新闻分类列表    private GridLayout themeBtnGroup;//专题菜单按钮的父view    private Handler handler;//handler线程通信    private MyScrollView myScrollView;//滑动布局    private ServiceBean serviceBean;//服务的反序列化对象    private NewsBannerBean newsBannerBean;//轮播图的反序列化对象    private NewsContentBean newsContentBean;//新闻列表的反序列化对象    private List&lt;String&gt; listNewsTitles,listNewsCovers;//分类列表中新闻封面和新闻标题    private List&lt;Integer&gt; listNewsId;//分类列表中新闻id    private List&lt;String&gt; newsBannerData = new ArrayList&lt;&gt;();//轮播图中的图片链接    private TextView[] newsTypes = new TextView[6];//6个新闻分类    private TextView newsType;//上个点击过的分类    private LinearLayout[] themeBtns = new LinearLayout[4];//专题的4个按钮    private LinearLayout[] serviceBtns = new LinearLayout[5];//服务菜单的五项    private MyHttpRequest myHttpRequest = new MyHttpRequest();//封装的http请求    private String[] serviceName = new String[]&#123;&quot;城市地铁&quot;,&quot;智慧巴士&quot;,&quot;门诊预约&quot;,&quot;停哪儿&quot;,&quot;智慧交管&quot;&#125;;//推荐服务    private List&lt;String&gt; newsTypeName = new ArrayList&lt;&gt;();//新闻分类的分类名    private Home0NewsAdapter home0NewsAdapter;//新闻分类列表的适配器    private NewsTypeBean newsTypeBean;//新闻分类列表的反序列化对象    private boolean isFix = false;//fixNavBar的是否为悬浮状态    @Override    public void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);    &#125;    @Override    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123;        if (viewRoot == null)&#123; viewRoot = inflater.inflate(R.layout.fragment_home0, container, false); &#125;        myHandler();//handler通信        init();//初始化界面        setScrollView();//设置滚动控件中的固定导航栏        getBannerData();//获取Banner的数据        getServiceData();//获取推荐服务的数据        getThemeData();//获取专题和新闻分类中的数据        submit();//设置监听        return viewRoot;    &#125;//    线程通信    private void myHandler() &#123;        handler = new Handler(Looper.getMainLooper())&#123;            @Override            public void handleMessage(@NonNull Message msg) &#123;                super.handleMessage(msg);                if (msg.what == 1)&#123;                    setBanner();//设置banner                &#125;                else if (msg.what == 2)&#123;                    setService();//设置推荐服务                &#125;                else if (msg.what == 3)&#123;                    setThemes();//设置专题                    setNews(0);//设置新闻分类                &#125;            &#125;        &#125;;    &#125;//    设置banner    private void setBanner() &#123;        if (newsBannerBean == null)&#123;            Toast.makeText(getContext(),&quot;Banner数据获取失败: 未知原因&quot;,Toast.LENGTH_SHORT).show();        &#125;        else if (newsBannerBean.getCode() != 200)&#123;            Toast.makeText(getContext(),&quot;Banner数据获取失败: &quot; + newsBannerBean.getMsg(),Toast.LENGTH_SHORT).show();        &#125;        else &#123;//            实例化Banner的适配器            MyBannerAdapter myBannerAdapter = new MyBannerAdapter(newsBannerData,getContext());            banner.setAdapter(myBannerAdapter)                    .isAutoLoop(true)//是否自动轮播                    .setLoopTime(1500)//自动轮播切换间隔时间                    .addBannerLifecycleObserver(this)//观察者                    .setIndicator(new CircleIndicator(getContext()));//下面的小点//            banner的点击事件            banner.setOnBannerListener(new OnBannerListener() &#123;                @Override                public void OnBannerClick(Object data, int position) &#123;//                    这里说要跳转到对应页面，却没有告诉对应哪里的页面，那怎么跳转？                    Toast.makeText(getContext(),&quot;position: &quot; + position,Toast.LENGTH_SHORT).show();                &#125;            &#125;);        &#125;    &#125;//    设置推荐服务    private void setService() &#123;        if (serviceBean == null)&#123;            Toast.makeText(getContext(),&quot;Banner数据获取失败: 未知原因&quot;,Toast.LENGTH_SHORT).show();        &#125;        else if (serviceBean.getCode() != 200)&#123;            Toast.makeText(getContext(),&quot;Banner数据获取失败: &quot; + newsBannerBean.getMsg(),Toast.LENGTH_SHORT).show();        &#125;        else &#123;            for (int i = 0; i &lt;serviceBean.getTotal(); i++)&#123;                for (int j = 0; j &lt; serviceName.length; j++)&#123;                    if (serviceBean.getRows().get(i).getServiceName().equals(serviceName[j]))&#123;//                        加载服务的图片                        Glide.with(getContext()).load(&quot;http://&quot; + SoftData.ipPort + serviceBean.getRows().get(i).getImgUrl()).into((ImageView) serviceBtns[i].getChildAt(0));//                        加载服务的名字                        ((TextView)serviceBtns[i].getChildAt(1)).setText(serviceName[j]);                        serviceBtns[i].setTag(serviceName[j]);                        break;                    &#125;                &#125;            &#125;        &#125;    &#125;//    设置专题    private void setThemes() &#123;        if (newsContentBean == null)&#123;            Toast.makeText(getContext(),&quot;专题数据获取失败: 未知原因&quot;,Toast.LENGTH_SHORT).show();        &#125;        else if (newsContentBean.getCode() != 200)&#123;            Toast.makeText(getContext(),&quot;专题数据获取失败: &quot; + newsContentBean.getMsg(),Toast.LENGTH_SHORT).show();        &#125;        else &#123;            for (int i = 0; i &lt; themeBtnGroup.getChildCount(); i++)&#123;                int themeBtnId = newsContentBean.getRows().get(i).getId();//文章id                String imageViewCover = &quot;http://&quot; + SoftData.ipPort + newsContentBean.getRows().get(i).getCover();//图片链接                String textViewContent = setTextContent(newsContentBean.getRows().get(i).getContent());//文本中显示的内容                ImageView imageView = (ImageView) themeBtns[i].getChildAt(0);//专题中的图片控件                TextView textView = (TextView) themeBtns[i].getChildAt(1);//专题中的文本控件                Glide.with(getContext()).load(imageViewCover).into(imageView);//Glide加载图片                textView.setText(textViewContent);//设置内容                themeBtns[i].setTag(themeBtnId);//设置标签为id值            &#125;        &#125;    &#125;//    对专题中显示的的新闻内容进行处理    private String setTextContent(String textViewContent)&#123;        String temp = textViewContent.replaceAll(&quot; &quot;,&quot;&quot;);//去除空格        String temp2 = temp.substring(temp.indexOf(&quot;&lt;p&gt;&quot;)+3,temp.length());//去除&lt;p&gt;标签        return temp2;    &#125;//    设置新闻列表    private void setNews(int position) &#123;        if (newsTypeBean == null)&#123;            Toast.makeText(getContext(),&quot;新闻数据获取失败: 未知原因&quot;,Toast.LENGTH_SHORT).show();        &#125;        else if (newsTypeBean.getCode() != 200)&#123;            Toast.makeText(getContext(),&quot;新闻数据获取失败: &quot; + newsTypeBean.getMsg(),Toast.LENGTH_SHORT).show();        &#125;        else &#123;            for (int i = 0; i &lt; newsTypes.length; i++) &#123;                newsTypes[i].setText(newsTypeBean.getData().get(i).getName());//设置分类名显示                newsTypes[i].setTag(String.valueOf(newsTypeBean.getData().get(i).getId()));//把分类的id添加到tag            &#125;        &#125;//        设置被选中分类名的颜色，加载列表        setNewsType(position);    &#125;//    设置被选中分类名的颜色，加载列表    private void setNewsType(int position) &#123;        if (newsType != null)&#123;            newsType.setTextColor(getContext().getResources().getColor(R.color.black));        &#125;        newsType = newsTypes[position];        newsTypes[position].setTextColor(getContext().getResources().getColor(R.color.red));//        加载列表        setRecycler(position);    &#125;    private void setRecycler(int position) &#123;        setList(position);//得到要显示的数据        if (home0NewsAdapter == null)&#123;//            设置列表高度            int pxHeight = getContext().getResources().getDisplayMetrics().heightPixels;            int delHeight = (int) (176 * getContext().getResources().getDisplayMetrics().density + 0.5f);            recyclerView.getLayoutParams().height = pxHeight - delHeight;//            设置RecyclerView的LayoutManager、设置Adapter            LinearLayoutManager layoutManager = new LinearLayoutManager(getContext(),RecyclerView.VERTICAL,false);            recyclerView.addItemDecoration(new DividerItemDecoration(getContext(),DividerItemDecoration.VERTICAL));//默认的分割线            home0NewsAdapter = new Home0NewsAdapter(listNewsCovers,listNewsTitles,getContext());            recyclerView.setLayoutManager(layoutManager);            recyclerView.setAdapter(home0NewsAdapter);            recyclerView.setNestedScrollingEnabled(false);//滑动状体初始是禁用//            滑动监听            recyclerView.addOnScrollListener(new RecyclerView.OnScrollListener() &#123;                @Override                public void onScrolled(@NonNull RecyclerView recyclerView, int dx, int dy) &#123;                    super.onScrolled(recyclerView, dx, dy);//                    当recyclerView滑动到顶部时canScrollVertically(-1)返回false，禁用它的滑动                    if (!recyclerView.canScrollVertically(-1))&#123;                        recyclerView.setNestedScrollingEnabled(false);                    &#125;                &#125;            &#125;);//            设置新闻分类列表的item单击事件            home0NewsAdapter.setOnItemLintener(new Home0NewsAdapter.OnItemLintener() &#123;                @Override                public void OnItemClick(int position) &#123;                    startNewsActivity(listNewsId.get(position));                &#125;            &#125;);        &#125;        else &#123;//            刷新列表            home0NewsAdapter.notifyDataSetChanged();        &#125;    &#125;    private void setList(int position) &#123;//        清空或创建        if (listNewsTitles != null &amp;&amp; listNewsCovers != null &amp;&amp; listNewsId != null)&#123;            listNewsTitles.clear();            listNewsCovers.clear();            listNewsId.clear();        &#125;        else &#123;            listNewsTitles = new ArrayList&lt;&gt;();            listNewsCovers = new ArrayList&lt;&gt;();            listNewsId = new ArrayList&lt;&gt;();        &#125;//        拿到数据        for (int i = 0; i &lt; newsContentBean.getTotal(); i++) &#123;            String type = newsContentBean.getRows().get(i).getType();            String string = newsTypes[position].getTag().toString();            if (type.equals(string))&#123;                listNewsTitles.add(newsContentBean.getRows().get(i).getTitle());                listNewsCovers.add(newsContentBean.getRows().get(i).getCover());                listNewsId.add(newsContentBean.getRows().get(i).getId());            &#125;        &#125;    &#125;//    启动新闻内容显示页面    private void startNewsActivity(int id) &#123;//        这里先获取到新闻的id就够了，等新闻页面写出来再让它启动        Toast.makeText(getContext(),&quot;id: &quot; + id,Toast.LENGTH_SHORT).show();    &#125;//    初始化页面    private void init() &#123;        banner = viewRoot.findViewById(R.id.banner);//轮播图        recyclerView = viewRoot.findViewById(R.id.recyclerView);//新闻分类列表        myScrollView = viewRoot.findViewById(R.id.myScrollView);//重写的滑动窗体//        推荐服务        serviceBtns[0] = viewRoot.findViewById(R.id.serviceBtn0);        serviceBtns[1] = viewRoot.findViewById(R.id.serviceBtn1);        serviceBtns[2] = viewRoot.findViewById(R.id.serviceBtn2);        serviceBtns[3] = viewRoot.findViewById(R.id.serviceBtn3);        serviceBtns[4] = viewRoot.findViewById(R.id.serviceBtn4);//        专题        themeBtns[0] = viewRoot.findViewById(R.id.themeBtn0);        themeBtns[1] = viewRoot.findViewById(R.id.themeBtn1);        themeBtns[2] = viewRoot.findViewById(R.id.themeBtn2);        themeBtns[3] = viewRoot.findViewById(R.id.themeBtn3);        themeBtnGroup = viewRoot.findViewById(R.id.themeBtnGroup);//专题按钮的父view//        新闻分类        newsTypes[0] = viewRoot.findViewById(R.id.newsType0);        newsTypes[1] = viewRoot.findViewById(R.id.newsType1);        newsTypes[2] = viewRoot.findViewById(R.id.newsType2);        newsTypes[3] = viewRoot.findViewById(R.id.newsType3);        newsTypes[4] = viewRoot.findViewById(R.id.newsType4);        newsTypes[5] = viewRoot.findViewById(R.id.newsType5);    &#125;//    设置滚动    private void setScrollView() &#123;        myScrollView.setOnFixNavBarLintener(new MyScrollView.OnFixNavBarLintener() &#123;//            当导航栏滑动至顶部时，设置RecyclerView可以滑动            @Override            public void OnFix() &#123;                if (!isFix)&#123;                    recyclerView.setNestedScrollingEnabled(true);                    isFix = true;                &#125;            &#125;//            当导航栏离开顶部时，禁止RecyclerView滑动            @Override            public void OnReset() &#123;                if (isFix)&#123;                    recyclerView.setNestedScrollingEnabled(false);                    isFix = false;                &#125;            &#125;        &#125;);    &#125;//    设置一些监听    private void submit() &#123;        serviceBtns[0].setOnClickListener(this);        serviceBtns[1].setOnClickListener(this);        serviceBtns[2].setOnClickListener(this);        serviceBtns[3].setOnClickListener(this);        serviceBtns[4].setOnClickListener(this);        themeBtns[0].setOnClickListener(this);        themeBtns[1].setOnClickListener(this);        themeBtns[2].setOnClickListener(this);        themeBtns[3].setOnClickListener(this);        newsTypes[0].setOnClickListener(this);        newsTypes[1].setOnClickListener(this);        newsTypes[2].setOnClickListener(this);        newsTypes[3].setOnClickListener(this);        newsTypes[4].setOnClickListener(this);        newsTypes[5].setOnClickListener(this);    &#125;//    获取banner中的数据    private void getBannerData() &#123;        new Thread()&#123;            @Override            public void run() &#123;                super.run();                newsBannerBean = (NewsBannerBean) myHttpRequest.myHttp(&quot;/prod-api/api/rotation/list?pageNum=1&amp;pageSize=8&amp;type=2&quot;,null,NewsBannerBean.class,null,&quot;get&quot;);                if (newsBannerBean != null)&#123;                    for (int i = 0; i &lt; newsBannerBean.getTotal(); i++)&#123;                        newsBannerData.add(&quot;http://&quot; + SoftData.ipPort + newsBannerBean.getRows().get(i).getAdvImg());                    &#125;                &#125;                Message message = Message.obtain();                message.what = 1;                handler.sendMessage(message);            &#125;        &#125;.start();    &#125;//    获取服务中的数据    private void getServiceData() &#123;        new Thread()&#123;            @Override            public void run() &#123;                super.run();                serviceBean = (ServiceBean) myHttpRequest.myHttp(&quot;/prod-api/api/service/list&quot;,null,ServiceBean.class,null,&quot;get&quot;);                Message message = Message.obtain();                message.what = 2;                handler.sendMessage(message);            &#125;        &#125;.start();    &#125;//    获取专题和新闻分类中的数据    private void getThemeData() &#123;        new Thread()&#123;            @Override            public void run() &#123;                super.run();                newsContentBean = (NewsContentBean) myHttpRequest.myHttp(&quot;/prod-api/press/press/list&quot;,null,NewsContentBean.class,null,&quot;get&quot;);                newsTypeBean = (NewsTypeBean) myHttpRequest.myHttp(&quot;/prod-api/press/category/list&quot;,null,NewsTypeBean.class,null,&quot;get&quot;);                if (newsTypeBean != null)&#123;                    for (int i = 0; i &lt; newsTypes.length; i++) &#123;                        newsTypeName.add(newsTypeBean.getData().get(i).getName());                    &#125;                &#125;                Message message = Message.obtain();                message.what = 3;                handler.sendMessage(message);            &#125;        &#125;.start();    &#125;    @Override    public void onClick(View v) &#123;        switch (v.getId())&#123;//            推荐服务            case R.id.serviceBtn0:            case R.id.serviceBtn1:            case R.id.serviceBtn2:            case R.id.serviceBtn3:            case R.id.serviceBtn4:                Toast.makeText(getContext(),v.getTag().toString(),Toast.LENGTH_SHORT).show();                break;//                专题            case R.id.themeBtn0:                startNewsActivity(Integer.parseInt(themeBtns[0].getTag().toString()));                break;            case R.id.themeBtn1:                startNewsActivity(Integer.parseInt(themeBtns[1].getTag().toString()));                break;            case R.id.themeBtn2:                startNewsActivity(Integer.parseInt(themeBtns[2].getTag().toString()));                break;            case R.id.themeBtn3:                startNewsActivity(Integer.parseInt(themeBtns[3].getTag().toString()));                break;//                新闻分类            case R.id.newsType0:                setNewsType(0);                break;            case R.id.newsType1:                setNewsType(1);                break;            case R.id.newsType2:                setNewsType(2);                break;            case R.id.newsType3:                setNewsType(3);                break;            case R.id.newsType4:                setNewsType(4);                break;            case R.id.newsType5:                setNewsType(5);                break;        &#125;    &#125;&#125;
当前效果预览
  (function(){var player = new DPlayer({"container":document.getElementById("dplayer0"),"autoplay":true,"hotkey":true,"preload":"metadata","video":{"url":"https://blog.xxin.xyz/2021/11/02/Android实战-智慧城市-2/movies.mp4"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})() 


&ensp;&ensp;&ensp;&ensp;到这里为止，“智慧城市页”已经可以完全显示并响应事件，因为没有其它对应的界面，所以点击时还不能跳转
&ensp;&ensp;&ensp;&ensp;下一篇中主要写“新闻详情”页的实现，使“智慧城市”页点击新闻列表或专题后可以跳转到对应的新闻列表。欲知后事如何，且听下回分解
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android开发手记</tag>
        <tag>智慧城市</tag>
      </tags>
  </entry>
  <entry>
    <title>Android实战-智慧城市(4)</title>
    <url>/2021/11/04/Android%E5%AE%9E%E6%88%98-%E6%99%BA%E6%85%A7%E5%9F%8E%E5%B8%82-4/</url>
    <content><![CDATA[上回说到，Android实战-智慧城市(3)
软件设计个人中心&ensp;&ensp;&ensp;&ensp;这一页没啥技术含量
关闭HomeActivity&ensp;&ensp;&ensp;&ensp;当点击”退出登录“按钮时关闭HomeAvtivity，并不是说什么时候都关闭HomeActivity&ensp;&ensp;&ensp;&ensp;在HomeActivity.java的类中声明类变量public static HomeActivity homeActivity;
&ensp;&ensp;&ensp;&ensp;在HomeActivity的init方法中给homeActivity变量赋值homeActivity = HomeActivity.this;
用户信息的反序列化对象类&ensp;&ensp;&ensp;&ensp;GetInfoBean中的类全部都实现了Serializable接口，因为等下要把它传递给资料修改页&ensp;&ensp;&ensp;&ensp;GetInfoBean.javapackage com.SmartCity.UserInfo;import java.io.Serializable;public class GetInfoBean implements Serializable &#123;    private String msg;    private int code;    private UserBean user;    public String getMsg() &#123;        return msg;    &#125;    public void setMsg(String msg) &#123;        this.msg = msg;    &#125;    public int getCode() &#123;        return code;    &#125;    public void setCode(int code) &#123;        this.code = code;    &#125;    public UserBean getUser() &#123;        return user;    &#125;    public void setUser(UserBean user) &#123;        this.user = user;    &#125;    public static class UserBean implements Serializable &#123;        private int userId;        private String userName;        private String nickName;        private String email;        private String phonenumber;        private String sex;        private String avatar;        private String idCard;        private int balance;        private int score;        public int getUserId() &#123;            return userId;        &#125;        public void setUserId(int userId) &#123;            this.userId = userId;        &#125;        public String getUserName() &#123;            return userName;        &#125;        public void setUserName(String userName) &#123;            this.userName = userName;        &#125;        public String getNickName() &#123;            return nickName;        &#125;        public void setNickName(String nickName) &#123;            this.nickName = nickName;        &#125;        public String getEmail() &#123;            return email;        &#125;        public void setEmail(String email) &#123;            this.email = email;        &#125;        public String getPhonenumber() &#123;            return phonenumber;        &#125;        public void setPhonenumber(String phonenumber) &#123;            this.phonenumber = phonenumber;        &#125;        public String getSex() &#123;            return sex;        &#125;        public void setSex(String sex) &#123;            this.sex = sex;        &#125;        public String getAvatar() &#123;            return avatar;        &#125;        public void setAvatar(String avatar) &#123;            this.avatar = avatar;        &#125;        public String getIdCard() &#123;            return idCard;        &#125;        public void setIdCard(String idCard) &#123;            this.idCard = idCard;        &#125;        public int getBalance() &#123;            return balance;        &#125;        public void setBalance(int balance) &#123;            this.balance = balance;        &#125;        public int getScore() &#123;            return score;        &#125;        public void setScore(int score) &#123;            this.score = score;        &#125;    &#125;&#125;
界面布局&ensp;&ensp;&ensp;&ensp;抄了QQ资料的布局&ensp;&ensp;&ensp;&ensp;fragment_home3.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout android:layout_height=&quot;match_parent&quot;    android:layout_width=&quot;match_parent&quot;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;    android:gravity=&quot;center_horizontal&quot;    android:orientation=&quot;vertical&quot;    android:background=&quot;@color/darker_gray&quot;    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;    &lt;LinearLayout        android:orientation=&quot;horizontal&quot;        android:padding=&quot;30dp&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;wrap_content&quot;&gt;        &lt;androidx.cardview.widget.CardView            android:outlineProvider=&quot;none&quot;            android:elevation=&quot;0dp&quot;            app:cardCornerRadius=&quot;34dp&quot;            android:layout_width=&quot;68dp&quot;            android:layout_height=&quot;68dp&quot;&gt;            &lt;ImageView                android:id=&quot;@+id/userAvatar&quot;                android:src=&quot;@mipmap/avatar&quot;                android:layout_width=&quot;match_parent&quot;                android:layout_height=&quot;match_parent&quot;/&gt;        &lt;/androidx.cardview.widget.CardView&gt;        &lt;LinearLayout            android:layout_marginLeft=&quot;20dp&quot;            android:gravity=&quot;center_vertical&quot;            android:orientation=&quot;vertical&quot;            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;68dp&quot;&gt;            &lt;TextView                android:text=&quot;userName&quot;                android:id=&quot;@+id/userName&quot;                android:gravity=&quot;center&quot;                android:textStyle=&quot;bold&quot;                android:textColor=&quot;@color/black&quot;                android:textSize=&quot;16sp&quot;                android:layout_width=&quot;wrap_content&quot;                android:layout_height=&quot;0dp&quot;                android:layout_weight=&quot;1&quot;/&gt;            &lt;TextView                android:text=&quot;nickName&quot;                android:id=&quot;@+id/nickName&quot;                android:textStyle=&quot;bold&quot;                android:textColor=&quot;@color/black&quot;                android:textSize=&quot;16sp&quot;                android:gravity=&quot;center&quot;                android:layout_width=&quot;wrap_content&quot;                android:layout_height=&quot;0dp&quot;                android:layout_weight=&quot;1&quot;/&gt;        &lt;/LinearLayout&gt;    &lt;/LinearLayout&gt;    &lt;LinearLayout        android:orientation=&quot;vertical&quot;        android:background=&quot;@color/white&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;wrap_content&quot;&gt;        &lt;LinearLayout            android:layout_width=&quot;match_parent&quot;            android:layout_marginRight=&quot;30dp&quot;            android:layout_marginLeft=&quot;30dp&quot;            android:layout_height=&quot;48dp&quot;            android:gravity=&quot;center_vertical&quot;            android:orientation=&quot;horizontal&quot;&gt;            &lt;TextView                android:text=&quot;个人设置&quot;                android:id=&quot;@+id/setInfo&quot;                android:textSize=&quot;18sp&quot;                android:textColor=&quot;@color/black&quot;                android:textStyle=&quot;bold&quot;                android:gravity=&quot;center_vertical&quot;                android:layout_weight=&quot;1&quot;                android:layout_width=&quot;0dp&quot;                android:layout_height=&quot;match_parent&quot;/&gt;            &lt;ImageView                android:src=&quot;@mipmap/forword&quot;                android:layout_width=&quot;18dp&quot;                android:layout_height=&quot;18dp&quot;/&gt;        &lt;/LinearLayout&gt;        &lt;View            android:background=&quot;@color/darker_gray&quot;            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;1dp&quot;/&gt;        &lt;LinearLayout            android:layout_width=&quot;match_parent&quot;            android:layout_marginRight=&quot;30dp&quot;            android:layout_marginLeft=&quot;30dp&quot;            android:layout_height=&quot;48dp&quot;            android:gravity=&quot;center_vertical&quot;            android:orientation=&quot;horizontal&quot;&gt;            &lt;TextView                android:text=&quot;我的订单&quot;                android:id=&quot;@+id/myOrder&quot;                android:textSize=&quot;18sp&quot;                android:textColor=&quot;@color/black&quot;                android:textStyle=&quot;bold&quot;                android:gravity=&quot;center_vertical&quot;                android:layout_weight=&quot;1&quot;                android:layout_width=&quot;0dp&quot;                android:layout_height=&quot;match_parent&quot;/&gt;            &lt;ImageView                android:src=&quot;@mipmap/forword&quot;                android:layout_width=&quot;18dp&quot;                android:layout_height=&quot;18dp&quot;/&gt;        &lt;/LinearLayout&gt;        &lt;View            android:background=&quot;@color/darker_gray&quot;            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;1dp&quot;/&gt;        &lt;LinearLayout            android:layout_width=&quot;match_parent&quot;            android:layout_marginRight=&quot;30dp&quot;            android:layout_marginLeft=&quot;30dp&quot;            android:layout_height=&quot;48dp&quot;            android:gravity=&quot;center_vertical&quot;            android:orientation=&quot;horizontal&quot;&gt;            &lt;TextView                android:text=&quot;修改密码&quot;                android:id=&quot;@+id/setPwd&quot;                android:textSize=&quot;18sp&quot;                android:textColor=&quot;@color/black&quot;                android:textStyle=&quot;bold&quot;                android:gravity=&quot;center_vertical&quot;                android:layout_weight=&quot;1&quot;                android:layout_width=&quot;0dp&quot;                android:layout_height=&quot;match_parent&quot;/&gt;            &lt;ImageView                android:src=&quot;@mipmap/forword&quot;                android:layout_width=&quot;18dp&quot;                android:layout_height=&quot;18dp&quot;/&gt;        &lt;/LinearLayout&gt;        &lt;View            android:background=&quot;@color/darker_gray&quot;            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;1dp&quot;/&gt;        &lt;LinearLayout            android:layout_width=&quot;match_parent&quot;            android:layout_marginRight=&quot;30dp&quot;            android:layout_marginLeft=&quot;30dp&quot;            android:layout_height=&quot;48dp&quot;            android:gravity=&quot;center_vertical&quot;            android:orientation=&quot;horizontal&quot;&gt;            &lt;TextView                android:text=&quot;意见反馈&quot;                android:id=&quot;@+id/commitOpinion&quot;                android:textSize=&quot;18sp&quot;                android:textColor=&quot;@color/black&quot;                android:textStyle=&quot;bold&quot;                android:gravity=&quot;center_vertical&quot;                android:layout_weight=&quot;1&quot;                android:layout_width=&quot;0dp&quot;                android:layout_height=&quot;match_parent&quot;/&gt;            &lt;ImageView                android:src=&quot;@mipmap/forword&quot;                android:layout_width=&quot;18dp&quot;                android:layout_height=&quot;18dp&quot;/&gt;        &lt;/LinearLayout&gt;    &lt;/LinearLayout&gt;    &lt;LinearLayout        android:gravity=&quot;center_horizontal&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;0dp&quot;        android:layout_weight=&quot;1&quot;&gt;        &lt;Button            android:text=&quot;退出登录&quot;            android:id=&quot;@+id/userExit&quot;            android:textSize=&quot;18sp&quot;            android:textColor=&quot;@color/white&quot;            android:textStyle=&quot;bold&quot;            android:background=&quot;@drawable/button_style2&quot;            android:layout_marginRight=&quot;30dp&quot;            android:layout_marginLeft=&quot;30dp&quot;            android:layout_marginTop=&quot;20dp&quot;            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;wrap_content&quot;/&gt;    &lt;/LinearLayout&gt;&lt;/LinearLayout&gt;
程序设计&ensp;&ensp;&ensp;&ensp;这一页还真不难，就是这样跳转那样跳转的&ensp;&ensp;&ensp;&ensp;HomeFragment3.javapackage com.SmartCity.Home;import android.annotation.SuppressLint;import android.content.Context;import android.content.Intent;import android.content.SharedPreferences;import android.os.Bundle;import androidx.annotation.NonNull;import androidx.annotation.Nullable;import androidx.fragment.app.Fragment;import android.os.Handler;import android.os.Looper;import android.os.Message;import android.util.Log;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import android.widget.Button;import android.widget.ImageView;import android.widget.TextView;import com.SmartCity.MyHttpRequest;import com.SmartCity.R;import com.SmartCity.RegisAndLogin.LoginActivity;import com.SmartCity.SoftData;import com.SmartCity.UserInfo.GetInfoBean;import com.SmartCity.UserInfo.SetInfoActivity;import com.bumptech.glide.Glide;import java.io.File;public class HomeFragment3 extends Fragment implements View.OnClickListener &#123;    private static final String TAG = &quot;HomeFragment3&quot;;    private View viewRoot;//界面资源    private Handler handler;//线程通信    private GetInfoBean getInfoBean;//获取用户信息的json反序列化对象    protected MyHttpRequest myHttpRequest = new MyHttpRequest();//服务器通信封装    private TextView userName,nickName;//用户账号和用户昵称    private ImageView userAvatar;//用户头像    private TextView setInfo,myOrder,setPwd,commitOpinion;//个人设置、我的订单、修改密码、意见反馈    private Button userExit;//退出登录    private SharedPreferences sharedPreferences;//本地轻量库    @Override    public void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);    &#125;    @Override    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123;        if (viewRoot == null)&#123; viewRoot = inflater.inflate(R.layout.fragment_home3, container, false); &#125;                myHanlder();        init();//界面初始化        submit();//添加监听        getInfo();//获取用户信息        return viewRoot;    &#125;    private void myHanlder() &#123;        handler = new Handler(Looper.getMainLooper())&#123;            @Override            public void handleMessage(@NonNull Message msg) &#123;                super.handleMessage(msg);                if (msg.what == 1)&#123;                    setInfo();//设置用户信息显示                &#125;            &#125;        &#125;;    &#125;//    设置用户信息显示    @SuppressLint(&quot;SetTextI18n&quot;)    private void setInfo() &#123;        Log.d(TAG, &quot;setInfo: userName:&quot; + getInfoBean.getUser().getUserName() + &quot;,\nnickName:&quot; + getInfoBean.getUser().getNickName() + &quot;,\nuserAvatar:&quot; + getInfoBean.getUser().getAvatar());        userName.setText(&quot;用户账号: &quot; + getInfoBean.getUser().getUserName());        nickName.setText(&quot;用户昵称: &quot; + getInfoBean.getUser().getNickName());//        头像上传到官方接口后不可用，所以这里用本地链接代替        File file = new File(getInfoBean.getUser().getAvatar());        if (file.exists())&#123;//            skipMemoryCache(true) .diskCacheStrategy(DiskCacheStrategy.NONE) ;不缓存            Glide.with(getContext()).load(file).skipMemoryCache(true).diskCacheStrategy(DiskCacheStrategy.NONE).into(userAvatar);        &#125;        else &#123;            Log.d(TAG, &quot;setInfo: 本地不存在图片&quot;);        &#125;    &#125;    //    界面初始化    private void init() &#123;        userAvatar = viewRoot.findViewById(R.id.userAvatar);        userName = viewRoot.findViewById(R.id.userName);        nickName = viewRoot.findViewById(R.id.nickName);        setInfo = viewRoot.findViewById(R.id.setInfo);        myOrder = viewRoot.findViewById(R.id.myOrder);        setPwd = viewRoot.findViewById(R.id.setPwd);        commitOpinion = viewRoot.findViewById(R.id.commitOpinion);        userExit = viewRoot.findViewById(R.id.userExit);        sharedPreferences = getActivity().getSharedPreferences(&quot;SoftData&quot;, Context.MODE_PRIVATE);    &#125;//    设置监听事件    private void submit() &#123;        setInfo.setOnClickListener(this);        myOrder.setOnClickListener(this);        setPwd.setOnClickListener(this);        commitOpinion.setOnClickListener(this);        userExit.setOnClickListener(this);    &#125;//    获取用户信息    private void getInfo() &#123;        new Thread()&#123;            @Override            public void run() &#123;                super.run();                getInfoBean = (GetInfoBean) myHttpRequest.myHttp(&quot;/prod-api/api/common/user/getInfo&quot;,null,GetInfoBean.class, SoftData.token,&quot;get&quot;);                Message message = Message.obtain();                message.what = 1;                handler.sendMessage(message);            &#125;        &#125;.start();    &#125;    @Override    public void onClick(View v) &#123;        Intent intent = new Intent();        switch (v.getId())&#123;            case R.id.setInfo://                携带获取到的资料的反序列化对象跳转到资料修改页                intent.setClass(getContext(), SetInfoActivity.class);                Bundle bundle = new Bundle();                bundle.putSerializable(&quot;getInfoBean&quot;,getInfoBean);                intent.putExtras(bundle);                startActivityForResult(intent,1);                break;            case R.id.myOrder://                我的订单                break;            case R.id.setPwd://                修改密码                break;            case R.id.commitOpinion://                意见反馈                break;            case R.id.userExit://                退出登录，干掉一系列和账号密码有关的东西                SoftData.userName = &quot;noValue&quot;;                SoftData.password = &quot;noValue&quot;;                SoftData.token = &quot;noValue&quot;;                SharedPreferences.Editor editor = sharedPreferences.edit();                editor.putString(&quot;userName&quot;,&quot;noValue&quot;);                editor.putString(&quot;password&quot;,&quot;noValue&quot;);                editor.commit();//                跳转到登陆页面                intent.setClass(getContext(), LoginActivity.class);                startActivity(intent);//                关闭页面                getActivity().finish();                break;        &#125;    &#125;    @Override    public void onActivityResult(int requestCode, int resultCode, @Nullable Intent data) &#123;        super.onActivityResult(requestCode, resultCode, data);        if (requestCode == 1)&#123;//如果从信息修改页返回来            getInfo();//刷新用户信息        &#125;    &#125;&#125;
个人设置自定义dialog弹窗&ensp;&ensp;&ensp;&ensp;自定义一个弹窗。使其显示从底部弹出的效果，在修改头像时选择相机和相册两种方式
弹窗样式&ensp;&ensp;&ensp;&ensp;布局和普通的页面布局一样&ensp;&ensp;&ensp;&ensp;dialog_avatar_choose.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:orientation=&quot;vertical&quot;    android:gravity=&quot;bottom&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;wrap_content&quot;&gt;    &lt;TextView        android:id=&quot;@+id/camera&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;50dp&quot;        android:clickable=&quot;true&quot;        android:gravity=&quot;center&quot;        android:text=&quot;拍摄&quot;        android:background=&quot;@color/white&quot;        android:textColor=&quot;@android:color/background_dark&quot;        android:textSize=&quot;15sp&quot;        android:focusable=&quot;true&quot; /&gt;    &lt;View        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;1dp&quot;        android:background=&quot;@android:color/darker_gray&quot; /&gt;    &lt;TextView        android:id=&quot;@+id/picture&quot;        android:clickable=&quot;true&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;50dp&quot;        android:gravity=&quot;center&quot;        android:background=&quot;@color/white&quot;        android:text=&quot;从相册选择&quot;        android:textColor=&quot;@android:color/background_dark&quot;        android:textSize=&quot;15sp&quot;        android:focusable=&quot;true&quot; /&gt;    &lt;View        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;5dp&quot;        android:background=&quot;@android:color/darker_gray&quot; /&gt;    &lt;TextView        android:clickable=&quot;true&quot;        android:id=&quot;@+id/cancel&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;50dp&quot;        android:gravity=&quot;center&quot;        android:background=&quot;@color/white&quot;        android:text=&quot;取消&quot;        android:textColor=&quot;@android:color/background_dark&quot;        android:textSize=&quot;15sp&quot;        android:focusable=&quot;true&quot; /&gt;&lt;/LinearLayout&gt;
弹窗动画&ensp;&ensp;&ensp;&ensp;弹窗的进入动画和退出动画，注意，动画的xml是anim文件&ensp;&ensp;&ensp;&ensp;check_avatar_dialog_in.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;    &lt;!--    duration:动画执行时间    fromXDelta:X轴开始的位置    fromYDelta:Y轴开始的位置    toXDelta:X轴结束的位置    toYDelta:Y轴结束的位置    --&gt;    &lt;translate        android:duration=&quot;300&quot;        android:fromXDelta=&quot;0&quot;        android:fromYDelta=&quot;1000&quot;        android:toXDelta=&quot;0&quot;        android:toYDelta=&quot;0&quot;        /&gt;&lt;/set&gt;
&ensp;&ensp;&ensp;&ensp;check_avatar_dialog_out.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;    &lt;!--    duration:动画执行时间    fromXDelta:X轴开始的位置    fromYDelta:Y轴开始的位置    toXDelta:X轴结束的位置    toYDelta:Y轴结束的位置    --&gt;    &lt;translate        android:duration=&quot;300&quot;        android:fromYDelta=&quot;0&quot;        android:fromXDelta=&quot;0&quot;        android:toYDelta=&quot;1000&quot;        android:toXDelta=&quot;0&quot;    /&gt;&lt;/set&gt;
修改弹窗布局的样式&ensp;&ensp;&ensp;&ensp;在themes.xml布局文件中添加&lt;!--    dialog的样式--&gt;&lt;style name=&quot;check_avatar_dialog_style&quot; parent=&quot;@android:style/Theme.Dialog&quot;&gt;    &lt;!--        边框--&gt;    &lt;item name=&quot;android:windowFrame&quot;&gt;@null&lt;/item&gt;    &lt;!--        是否浮现在Activity上--&gt;    &lt;item name=&quot;android:windowIsFloating&quot;&gt;true&lt;/item&gt;    &lt;!--        半透明--&gt;    &lt;item name=&quot;android:windowIsTranslucent&quot;&gt;true&lt;/item&gt;    &lt;!--        无标题--&gt;    &lt;item name=&quot;android:windowNoTitle&quot;&gt;true&lt;/item&gt;    &lt;item name=&quot;android:background&quot;&gt;@android:color/transparent&lt;/item&gt;    &lt;!--        背景透明--&gt;    &lt;item name=&quot;android:windowBackground&quot;&gt;@android:color/transparent&lt;/item&gt;    &lt;!--        模糊--&gt;    &lt;item name=&quot;android:backgroundDimEnabled&quot;&gt;true&lt;/item&gt;    &lt;!--        遮罩层--&gt;    &lt;item name=&quot;android:backgroundDimAmount&quot;&gt;0.5&lt;/item&gt;&lt;/style&gt;
&ensp;&ensp;&ensp;&ensp;设置动画&lt;!--    dialog的动画--&gt;&lt;style name=&quot;check_avatar_dialog_anim&quot;&gt;    &lt;!--        进入--&gt;    &lt;item name=&quot;android:windowEnterAnimation&quot;&gt;@anim/check_avatar_dialog_in&lt;/item&gt;    &lt;!--        退出--&gt;    &lt;item name=&quot;android:windowExitAnimation&quot;&gt;@anim/check_avatar_dialog_out&lt;/item&gt;&lt;/style&gt;
页面布局&ensp;&ensp;&ensp;&ensp;头像邮箱这啊那的，还是比较麻烦&ensp;&ensp;&ensp;&ensp;activity_set_info.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:tools=&quot;http://schemas.android.com/tools&quot;    android:layout_height=&quot;match_parent&quot;    android:layout_width=&quot;match_parent&quot;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;    android:orientation=&quot;vertical&quot;    android:gravity=&quot;center_horizontal&quot;    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;    &lt;!--    Title--&gt;    &lt;LinearLayout        android:background=&quot;@color/blue&quot;        android:orientation=&quot;horizontal&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;58dp&quot;&gt;        &lt;LinearLayout            android:onClick=&quot;finishActivity&quot;            android:gravity=&quot;center&quot;            android:layout_width=&quot;58dp&quot;            android:layout_height=&quot;58dp&quot;&gt;            &lt;ImageView                android:src=&quot;@mipmap/back&quot;                android:layout_width=&quot;20dp&quot;                android:layout_height=&quot;20dp&quot;/&gt;        &lt;/LinearLayout&gt;        &lt;LinearLayout            android:gravity=&quot;center&quot;            android:layout_weight=&quot;1&quot;            android:layout_width=&quot;0dp&quot;            android:layout_height=&quot;match_parent&quot;&gt;            &lt;TextView                android:text=&quot;个人设置&quot;                android:textStyle=&quot;bold&quot;                android:textSize=&quot;18sp&quot;                android:textColor=&quot;@color/white&quot;                android:layout_width=&quot;wrap_content&quot;                android:layout_height=&quot;wrap_content&quot;/&gt;        &lt;/LinearLayout&gt;        &lt;LinearLayout            android:gravity=&quot;center&quot;            android:layout_width=&quot;58dp&quot;            android:layout_height=&quot;58dp&quot;&gt;        &lt;/LinearLayout&gt;    &lt;/LinearLayout&gt;    &lt;!--    Content--&gt;    &lt;LinearLayout        android:orientation=&quot;vertical&quot;        android:background=&quot;@color/white&quot;        android:gravity=&quot;center_horizontal&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;match_parent&quot;&gt;        &lt;LinearLayout            android:gravity=&quot;center_vertical|right&quot;            android:onClick=&quot;setAvatarClick&quot;            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;wrap_content&quot;&gt;            &lt;TextView                android:text=&quot;头像&quot;                android:textSize=&quot;18sp&quot;                android:textStyle=&quot;bold&quot;                android:textColor=&quot;@color/black&quot;                android:layout_marginRight=&quot;20dp&quot;                android:layout_marginLeft=&quot;20dp&quot;                android:layout_weight=&quot;1&quot;                android:layout_width=&quot;0dp&quot;                android:layout_height=&quot;wrap_content&quot;/&gt;            &lt;androidx.cardview.widget.CardView                android:outlineProvider=&quot;none&quot;                android:elevation=&quot;0dp&quot;                app:cardCornerRadius=&quot;34dp&quot;                android:layout_marginRight=&quot;20dp&quot;                android:layout_marginTop=&quot;10dp&quot;                android:layout_marginBottom=&quot;10dp&quot;                android:layout_width=&quot;68dp&quot;                android:layout_height=&quot;68dp&quot;&gt;                &lt;ImageView                    android:id=&quot;@+id/userAvatar&quot;                    android:src=&quot;@mipmap/avatar&quot;                    android:layout_width=&quot;match_parent&quot;                    android:layout_height=&quot;match_parent&quot;/&gt;            &lt;/androidx.cardview.widget.CardView&gt;        &lt;/LinearLayout&gt;        &lt;View            android:background=&quot;@color/darker_gray&quot;            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;1dp&quot;/&gt;        &lt;LinearLayout            android:background=&quot;@color/white&quot;            android:gravity=&quot;center_vertical|right&quot;            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;wrap_content&quot;&gt;            &lt;TextView                android:text=&quot;昵称&quot;                android:textSize=&quot;18sp&quot;                android:textStyle=&quot;bold&quot;                android:textColor=&quot;@color/black&quot;                android:layout_marginRight=&quot;20dp&quot;                android:layout_marginLeft=&quot;20dp&quot;                android:layout_weight=&quot;1&quot;                android:layout_width=&quot;0dp&quot;                android:layout_height=&quot;wrap_content&quot;/&gt;            &lt;EditText                android:hint=&quot;请输入昵称&quot;                android:gravity=&quot;right|center_vertical&quot;                android:id=&quot;@+id/nickName&quot;                android:lines=&quot;1&quot;                android:inputType=&quot;text&quot;                android:background=&quot;@color/white&quot;                android:layout_width=&quot;160dp&quot;                android:layout_marginRight=&quot;20dp&quot;                android:layout_height=&quot;48dp&quot;                tools:ignore=&quot;RtlHardcoded&quot; /&gt;        &lt;/LinearLayout&gt;        &lt;View            android:background=&quot;@color/darker_gray&quot;            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;1dp&quot;/&gt;        &lt;LinearLayout            android:background=&quot;@color/white&quot;            android:gravity=&quot;center_vertical|right&quot;            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;wrap_content&quot;&gt;            &lt;TextView                android:text=&quot;性别&quot;                android:textSize=&quot;18sp&quot;                android:textStyle=&quot;bold&quot;                android:textColor=&quot;@color/black&quot;                android:layout_marginRight=&quot;20dp&quot;                android:layout_marginLeft=&quot;20dp&quot;                android:layout_weight=&quot;1&quot;                android:layout_width=&quot;0dp&quot;                android:layout_height=&quot;wrap_content&quot;/&gt;            &lt;RadioGroup                android:layout_marginRight=&quot;20dp&quot;                android:id=&quot;@+id/userSex&quot;                android:gravity=&quot;center&quot;                android:orientation=&quot;horizontal&quot;                android:layout_width=&quot;wrap_content&quot;                android:layout_height=&quot;48dp&quot;&gt;                &lt;RadioButton                    android:text=&quot;男&quot;                    android:layout_width=&quot;wrap_content&quot;                    android:layout_height=&quot;wrap_content&quot;/&gt;                &lt;RadioButton                    android:text=&quot;女&quot;                    android:layout_width=&quot;wrap_content&quot;                    android:layout_height=&quot;wrap_content&quot;/&gt;            &lt;/RadioGroup&gt;        &lt;/LinearLayout&gt;        &lt;View            android:background=&quot;@color/darker_gray&quot;            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;1dp&quot;/&gt;        &lt;LinearLayout            android:background=&quot;@color/white&quot;            android:gravity=&quot;center_vertical|right&quot;            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;wrap_content&quot;&gt;            &lt;TextView                android:text=&quot;手机号&quot;                android:textSize=&quot;18sp&quot;                android:textStyle=&quot;bold&quot;                android:textColor=&quot;@color/black&quot;                android:layout_marginRight=&quot;20dp&quot;                android:layout_marginLeft=&quot;20dp&quot;                android:layout_weight=&quot;1&quot;                android:layout_width=&quot;0dp&quot;                android:layout_height=&quot;wrap_content&quot;/&gt;            &lt;EditText                android:hint=&quot;请输入手机号&quot;                android:gravity=&quot;right|center_vertical&quot;                android:id=&quot;@+id/phoneNumber&quot;                android:lines=&quot;1&quot;                android:inputType=&quot;number&quot;                android:background=&quot;@color/white&quot;                android:layout_width=&quot;160dp&quot;                android:layout_marginRight=&quot;20dp&quot;                android:layout_height=&quot;48dp&quot;                tools:ignore=&quot;RtlHardcoded&quot; /&gt;        &lt;/LinearLayout&gt;        &lt;View            android:background=&quot;@color/darker_gray&quot;            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;1dp&quot;/&gt;        &lt;LinearLayout            android:background=&quot;@color/white&quot;            android:gravity=&quot;center_vertical|right&quot;            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;wrap_content&quot;&gt;            &lt;TextView                android:text=&quot;身份证号&quot;                android:textSize=&quot;18sp&quot;                android:textStyle=&quot;bold&quot;                android:textColor=&quot;@color/black&quot;                android:layout_marginRight=&quot;20dp&quot;                android:layout_marginLeft=&quot;20dp&quot;                android:layout_weight=&quot;1&quot;                android:layout_width=&quot;0dp&quot;                android:layout_height=&quot;wrap_content&quot;/&gt;            &lt;EditText                android:hint=&quot;请输入身份证号&quot;                android:gravity=&quot;right|center_vertical&quot;                android:id=&quot;@+id/userIdNumber&quot;                android:lines=&quot;1&quot;                android:inputType=&quot;number&quot;                android:background=&quot;@color/white&quot;                android:layout_width=&quot;160dp&quot;                android:layout_marginRight=&quot;20dp&quot;                android:layout_height=&quot;48dp&quot;/&gt;        &lt;/LinearLayout&gt;        &lt;View            android:background=&quot;@color/darker_gray&quot;            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;1dp&quot;/&gt;        &lt;LinearLayout            android:background=&quot;@color/white&quot;            android:gravity=&quot;center_vertical|right&quot;            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;wrap_content&quot;&gt;            &lt;TextView                android:text=&quot;邮箱&quot;                android:textSize=&quot;18sp&quot;                android:textStyle=&quot;bold&quot;                android:textColor=&quot;@color/black&quot;                android:layout_marginRight=&quot;20dp&quot;                android:layout_marginLeft=&quot;20dp&quot;                android:layout_weight=&quot;1&quot;                android:layout_width=&quot;0dp&quot;                android:layout_height=&quot;wrap_content&quot;/&gt;            &lt;EditText                android:hint=&quot;请输入邮箱&quot;                android:gravity=&quot;right|center_vertical&quot;                android:id=&quot;@+id/userEmail&quot;                android:lines=&quot;1&quot;                android:inputType=&quot;textEmailAddress&quot;                android:background=&quot;@color/white&quot;                android:layout_width=&quot;160dp&quot;                android:layout_marginRight=&quot;20dp&quot;                android:layout_height=&quot;48dp&quot;/&gt;        &lt;/LinearLayout&gt;        &lt;View            android:background=&quot;@color/darker_gray&quot;            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;1dp&quot;/&gt;        &lt;Button            android:text=&quot;保存&quot;            android:onClick=&quot;saveInfo&quot;            android:textColor=&quot;@color/white&quot;            android:textStyle=&quot;bold&quot;            android:textSize=&quot;18sp&quot;            android:layout_marginRight=&quot;20dp&quot;            android:layout_marginLeft=&quot;20dp&quot;            android:layout_marginTop=&quot;10dp&quot;            android:background=&quot;@drawable/button_style2&quot;            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;wrap_content&quot;/&gt;    &lt;/LinearLayout&gt;&lt;/LinearLayout&gt;
程序设计&ensp;&ensp;&ensp;&ensp;陌生点：自定义dialog弹窗、调用相机和相册选择图片、view转bitmap保存至本地&ensp;&ensp;&ensp;&ensp;SetInfoActivity.javapackage com.SmartCity.UserInfo;import androidx.annotation.NonNull;import androidx.annotation.Nullable;import androidx.appcompat.app.AppCompatActivity;import androidx.core.app.ActivityCompat;import android.Manifest;import android.app.Dialog;import android.content.Intent;import android.content.pm.PackageManager;import android.graphics.Bitmap;import android.graphics.drawable.BitmapDrawable;import android.net.Uri;import android.os.Bundle;import android.os.Handler;import android.os.Looper;import android.os.Message;import android.provider.MediaStore;import android.text.TextUtils;import android.util.Log;import android.view.Gravity;import android.view.View;import android.view.Window;import android.widget.EditText;import android.widget.ImageView;import android.widget.RadioButton;import android.widget.RadioGroup;import android.widget.TextView;import android.widget.Toast;import com.SmartCity.Bean;import com.SmartCity.MyHttpRequest;import com.SmartCity.R;import com.SmartCity.SoftData;import com.bumptech.glide.Glide;import java.io.File;import java.io.FileOutputStream;import java.io.IOException;public class SetInfoActivity extends AppCompatActivity implements View.OnClickListener &#123;    private static final String TAG = &quot;SetInfoActivity&quot;;    private GetInfoBean getInfoBean;//获取用户资料的json反序列化对象    private ImageView userAvatar;//用户头像    private RadioGroup userSex;//用户性别    private EditText nickName,phoneNumber,userIdNumber,userEmail;//昵称、手机号、身份证、邮箱    private Dialog dialog;//自定义弹窗    private TextView dialogCamera,dialogPicture,dialogCancel;//相机拍摄、从相册选择、取消    private final int CAREMA = 101;//调用相机回执判断码    private final int PICTURE = 102;//调用相册回执判断码    private final int REQUEST_CAMERA = 201;//相机权限请求码    private Bean bean;//最简单的json反序列化对象    private Handler handler;//线程通信    private MyHttpRequest myHttpRequest = new MyHttpRequest();//封装的服务器通信    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_set_info);        myHandler();        init();//初始化界面        setData();//显示用户信息    &#125;    private void myHandler() &#123;        handler = new Handler(Looper.getMainLooper())&#123;            @Override            public void handleMessage(@NonNull Message msg) &#123;                super.handleMessage(msg);                if (msg.what == 1)&#123;                    if (bean == null)&#123;                        MyToast(&quot;修改失败: 未知原因&quot;);                    &#125;                    else if (bean.getCode() != 200)&#123;                        MyToast(&quot;修改失败: &quot; + bean.getMsg());                    &#125;                    else &#123;                        MyToast(&quot;保存成功&quot;);                    &#125;                &#125;            &#125;        &#125;;    &#125;    //    显示用户信息    private void setData() &#123;//        加载用户头像        File avatarPath = new File(getInfoBean.getUser().getAvatar());        if (avatarPath.exists())&#123;//            .skipMemoryCache(true).diskCacheStrategy(DiskCacheStrategy.NONE)//不缓存            Glide.with(this).load(avatarPath).skipMemoryCache(true).diskCacheStrategy(DiskCacheStrategy.NONE).into(userAvatar);        &#125;//        设置用户性别        if (getInfoBean.getUser().getSex().equals(&quot;0&quot;))&#123;            ((RadioButton)userSex.getChildAt(0)).setChecked(true);        &#125;        else &#123;            ((RadioButton)userSex.getChildAt(1)).setChecked(true);        &#125;        nickName.setText(getInfoBean.getUser().getNickName());//昵称        phoneNumber.setText(getInfoBean.getUser().getPhonenumber());//手机号        userIdNumber.setText(getInfoBean.getUser().getIdCard());//身份证号        userEmail.setText(getInfoBean.getUser().getEmail());//邮箱    &#125;//    初始化界面    private void init() &#123;        getInfoBean = (GetInfoBean) getIntent().getExtras().getSerializable(&quot;getInfoBean&quot;);        userAvatar = findViewById(R.id.userAvatar);        userSex = findViewById(R.id.userSex);        nickName = findViewById(R.id.nickName);        phoneNumber = findViewById(R.id.phoneNumber);        userIdNumber = findViewById(R.id.userIdNumber);        userEmail = findViewById(R.id.userEmail);    &#125;//    点击保存按钮时    public void saveInfo(View view) &#123;        saveUserAvatar();//保存用户头像到本地//        开始读取填写的资料并保存        String nickNameContent = nickName.getText().toString();        String sexContent = ((RadioButton)userSex.getChildAt(0)).isChecked() ? &quot;0&quot;:&quot;1&quot;;        String phoneNumberContent = phoneNumber.getText().toString();        String IdNumberContent = userIdNumber.getText().toString();        String emailContent = userEmail.getText().toString();        String avatarContent = getExternalCacheDir() + &quot;/userInfo/avatar.png&quot;;        if (TextUtils.isEmpty(nickNameContent))&#123;            MyToast(&quot;昵称不可为空&quot;);        &#125;        else if (TextUtils.isEmpty(phoneNumberContent))&#123;            MyToast(&quot;手机号不可为空&quot;);        &#125;        else if (phoneNumberContent.length() &lt; 11)&#123;            MyToast(&quot;手机号格式不正确&quot;);        &#125;        else if (IdNumberContent.length() &lt; 18)&#123;            MyToast(&quot;身份证号格式不正确&quot;);        &#125;        else &#123;            String json = &quot;&#123;\n&quot; +                    &quot;\&quot;avatar\&quot;: \&quot;&quot; + avatarContent +&quot;\&quot;,\n&quot; +                    &quot;\&quot;email\&quot;: \&quot;&quot; + emailContent + &quot;\&quot;,\n&quot; +                    &quot;\&quot;idCard\&quot;: \&quot;&quot; + IdNumberContent +&quot;\&quot;,\n&quot; +                    &quot;\&quot;nickName\&quot;: \&quot;&quot; + nickNameContent + &quot;\&quot;,\n&quot; +                    &quot;\&quot;phonenumber\&quot;: \&quot;&quot; + phoneNumberContent + &quot;\&quot;,\n&quot; +                    &quot;\&quot;sex\&quot;: \&quot;&quot; + sexContent + &quot;\&quot;\n&quot; +                    &quot;&#125;&quot;;            Log.d(TAG, &quot;saveInfo: \n&quot; + json);            sendInfo(json);//发送json数据        &#125;    &#125;//    发送json数据    private void sendInfo(String json)&#123;        new Thread()&#123;            @Override            public void run() &#123;                super.run();                bean = (Bean) myHttpRequest.myHttp(&quot;/prod-api/api/common/user&quot;,json,Bean.class, SoftData.token,&quot;put&quot;);                Message message = Message.obtain();                message.what = 1;                handler.sendMessage(message);            &#125;        &#125;.start();    &#125;    private void saveUserAvatar() &#123;        BitmapDrawable bitmapDrawable = (BitmapDrawable) userAvatar.getDrawable();        Bitmap bitmap = bitmapDrawable.getBitmap();//得到用户头像view的bitmap        if (bitmap != null)&#123;            FileOutputStream fileOutputStream = null;            File folder = new File(getExternalCacheDir(),&quot;userInfo&quot;);//外部储存私有目录缓存目录下的userInfo文件夹            File file = new File(folder,&quot;avatar.png&quot;);//上述目录中的avatar.png文件            try &#123;//                如果不存在则创建路径中的文件夹                if (!folder.exists())&#123; folder.mkdirs(); &#125;//                如果不存在则创建文件                if (!file.exists())&#123; file.createNewFile(); &#125;//                输出流实例化                fileOutputStream = new FileOutputStream(file);//                保存文件的参数                bitmap.compress(Bitmap.CompressFormat.PNG,100,fileOutputStream);                fileOutputStream.flush();//清空io流            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125; finally &#123;                if (!file.exists())&#123;                    Toast.makeText(SetInfoActivity.this,&quot;头像保存失败&quot;,Toast.LENGTH_SHORT).show();                &#125;                if (fileOutputStream != null)&#123;                    try &#123;                        fileOutputStream.close();//关闭输出流                    &#125; catch (IOException e) &#123;                        e.printStackTrace();                    &#125;                &#125;            &#125;        &#125;        else &#123;            Toast.makeText(SetInfoActivity.this,&quot;头像保存失败&quot;,Toast.LENGTH_SHORT).show();        &#125;    &#125;    //    点击头像修改时,出现弹窗    public void setAvatarClick(View view) &#123;//        选择在Theme中定义好的dialog样式        dialog = new Dialog(this,R.style.check_avatar_dialog_style);//        设置dialog的布局文件        dialog.setContentView(View.inflate(this,R.layout.dialog_avatar_choose,null));//        获取dialog在窗口中的对象        Window window = dialog.getWindow();//        设置在窗口中的位置        window.setGravity(Gravity.BOTTOM);//        设置弹出的动画效果        window.setWindowAnimations(R.style.check_avatar_dialog_anim);//        设置dialog宽高        window.setLayout(-1,-2);//        显示dialog        dialog.show();//        设置弹窗中view的事件监听        dialogSubmit();    &#125;    private void dialogSubmit() &#123;        dialogCamera = dialog.findViewById(R.id.camera);        dialogPicture = dialog.findViewById(R.id.picture);        dialogCancel = dialog.findViewById(R.id.cancel);        dialogCamera.setOnClickListener(this);        dialogPicture.setOnClickListener(this);        dialogCancel.setOnClickListener(this);    &#125;    @Override    public void onClick(View v) &#123;        switch (v.getId())&#123;            case R.id.camera://                用相机拍摄                chooseCamera();                dialog.dismiss();                break;            case R.id.picture://                从相册选择                choosePicture();                dialog.dismiss();                break;            case R.id.cancel://                关闭窗口                dialog.dismiss();                break;        &#125;    &#125;//    从相册选择    private void choosePicture()&#123;//        说实话这么简单的调用相册选择,我是头一次见,简单且强大        Intent intent = new Intent(Intent.ACTION_PICK,null);        intent.setDataAndType(MediaStore.Images.Media.EXTERNAL_CONTENT_URI,&quot;image/*&quot;);        startActivityForResult(intent,PICTURE);    &#125;//    用相机拍摄    private void chooseCamera()&#123;//        判断有无权限        if (ActivityCompat.checkSelfPermission(this, Manifest.permission.CAMERA) == PackageManager.PERMISSION_GRANTED)&#123;            Intent intent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);            startActivityForResult(intent,CAREMA);        &#125;        else &#123;            ActivityCompat.requestPermissions(this,new String[]&#123;Manifest.permission.CAMERA&#125;,REQUEST_CAMERA);        &#125;    &#125;    @Override//    权限申请回调    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123;        super.onRequestPermissionsResult(requestCode, permissions, grantResults);        if (requestCode == 1)&#123;            if (ActivityCompat.checkSelfPermission(this,Manifest.permission.CAMERA) == PackageManager.PERMISSION_GRANTED)&#123;                Toast.makeText(this,&quot;权限请求成功&quot;,Toast.LENGTH_SHORT).show();            &#125;            else &#123;                Toast.makeText(this,&quot;权限请求失败&quot;,Toast.LENGTH_SHORT).show();            &#125;        &#125;    &#125;    @Override//    返回页面回调    protected void onActivityResult(int requestCode, int resultCode, @Nullable Intent data) &#123;        super.onActivityResult(requestCode, resultCode, data);        if (requestCode == CAREMA)&#123;            /*             * 这里有个坑,跳转到相机拍摄页面后,             * 如果点击系统提供的&quot;x&quot;号返回,那么data不为空值,可以用getExtra从data中取数据,但是取到的数据是空值             * 如果使用手机物理返回键返回,那data直接是空值,从空值data中get会直接报错             * 所以应该用短路按位与,或者用两个if分别来判断data和data.getExtras()             * data或data.getExtras为空值时,说明没有拍照             */            if (data != null &amp;&amp; data.getExtras() != null)&#123;                Bitmap bitmap = (Bitmap) data.getExtras().get(&quot;data&quot;);                userAvatar.setImageBitmap(bitmap);//设置图片            &#125;        &#125;//        如果是调用相册选择        else if(requestCode == PICTURE)&#123;            if (data != null)&#123;                Uri uri = data.getData();                userAvatar.setImageURI(uri);//设置图片            &#125;        &#125;    &#125;//    关闭页面    public void finishActivity(View view) &#123;  finish();  &#125;//    Toast    private void MyToast(String message)&#123;        Toast.makeText(this,message,Toast.LENGTH_SHORT).show();    &#125;&#125;
我的订单界面布局&ensp;&ensp;&ensp;&ensp;activity_order.xml
程序设计&ensp;&ensp;&ensp;&ensp;OrderActivity.java
修改密码&ensp;&ensp;&ensp;&ensp;简单的，不做描述
页面布局&ensp;&ensp;&ensp;&ensp;activity_seting_pwd.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout android:layout_height=&quot;match_parent&quot;    android:layout_width=&quot;match_parent&quot;    android:orientation=&quot;vertical&quot;    android:gravity=&quot;center_horizontal&quot;    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;    &lt;!--    Title--&gt;    &lt;LinearLayout        android:background=&quot;@color/blue&quot;        android:orientation=&quot;horizontal&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;58dp&quot;&gt;        &lt;LinearLayout            android:onClick=&quot;finishActivity&quot;            android:gravity=&quot;center&quot;            android:layout_width=&quot;58dp&quot;            android:layout_height=&quot;58dp&quot;&gt;            &lt;ImageView                android:src=&quot;@mipmap/back&quot;                android:layout_width=&quot;20dp&quot;                android:layout_height=&quot;20dp&quot;/&gt;        &lt;/LinearLayout&gt;        &lt;LinearLayout            android:gravity=&quot;center&quot;            android:layout_weight=&quot;1&quot;            android:layout_width=&quot;0dp&quot;            android:layout_height=&quot;match_parent&quot;&gt;            &lt;TextView                android:text=&quot;修改密码&quot;                android:textStyle=&quot;bold&quot;                android:textSize=&quot;18sp&quot;                android:textColor=&quot;@color/white&quot;                android:layout_width=&quot;wrap_content&quot;                android:layout_height=&quot;wrap_content&quot;/&gt;        &lt;/LinearLayout&gt;        &lt;LinearLayout            android:gravity=&quot;center&quot;            android:layout_width=&quot;58dp&quot;            android:layout_height=&quot;58dp&quot;&gt;        &lt;/LinearLayout&gt;    &lt;/LinearLayout&gt;    &lt;!--    Content--&gt;    &lt;LinearLayout        android:orientation=&quot;vertical&quot;        android:gravity=&quot;center_horizontal&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;match_parent&quot;&gt;        &lt;EditText            android:background=&quot;@drawable/edit_text_style&quot;            android:layout_marginTop=&quot;68dp&quot;            android:hint=&quot;请输入原始密码&quot;            android:layout_marginLeft=&quot;20dp&quot;            android:layout_marginRight=&quot;20dp&quot;            android:lines=&quot;1&quot;            android:inputType=&quot;textPassword&quot;            android:gravity=&quot;center&quot;            android:id=&quot;@+id/oldPwd&quot;            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;48dp&quot;/&gt;        &lt;EditText            android:background=&quot;@drawable/edit_text_style&quot;            android:layout_marginTop=&quot;10dp&quot;            android:hint=&quot;请输入新密码&quot;            android:layout_marginLeft=&quot;20dp&quot;            android:layout_marginRight=&quot;20dp&quot;            android:lines=&quot;1&quot;            android:inputType=&quot;textPassword&quot;            android:gravity=&quot;center&quot;            android:id=&quot;@+id/newPwd&quot;            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;48dp&quot;/&gt;        &lt;EditText            android:background=&quot;@drawable/edit_text_style&quot;            android:layout_marginTop=&quot;10dp&quot;            android:hint=&quot;再次输入新密码&quot;            android:layout_marginLeft=&quot;20dp&quot;            android:layout_marginRight=&quot;20dp&quot;            android:lines=&quot;1&quot;            android:inputType=&quot;textPassword&quot;            android:gravity=&quot;center&quot;            android:id=&quot;@+id/againNewPwd&quot;            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;48dp&quot;/&gt;        &lt;Button            android:background=&quot;@drawable/edit_text_style&quot;            android:text=&quot;修改密码&quot;            android:onClick=&quot;settingPwd&quot;            android:textColor=&quot;@color/black&quot;            android:textSize=&quot;18sp&quot;            android:id=&quot;@+id/button&quot;            android:layout_marginTop=&quot;28dp&quot;            android:layout_marginLeft=&quot;30dp&quot;            android:layout_marginRight=&quot;30dp&quot;            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;wrap_content&quot;/&gt;    &lt;/LinearLayout&gt;&lt;/LinearLayout&gt;
程序设计&ensp;&ensp;&ensp;&ensp;SetingPwdActivitypackage com.SmartCity.UserInfo;import androidx.annotation.NonNull;import androidx.appcompat.app.AppCompatActivity;import android.content.Intent;import android.content.SharedPreferences;import android.os.Bundle;import android.os.Handler;import android.os.Looper;import android.os.Message;import android.text.TextUtils;import android.view.View;import android.widget.EditText;import android.widget.Toast;import com.SmartCity.Bean;import com.SmartCity.Home.HomeActivity;import com.SmartCity.MyHttpRequest;import com.SmartCity.R;import com.SmartCity.RegisAndLogin.LoginActivity;import com.SmartCity.SoftData;public class SetingPwdActivity extends AppCompatActivity &#123;    private EditText oldPwd,newPwd,againNewPwd;//原密码、新密码、再次输入新密码    private Bean bean;//基本json字符串反序列化对象    private MyHttpRequest myHttpRequest = new MyHttpRequest();//服务器通信模块    private Handler handler;//线程通信    private SharedPreferences sharedPreferences;//本地轻量库    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_seting_pwd);        myHandler();//线程通信        init();//初始化界面    &#125;//    线程通信    private void myHandler() &#123;        handler = new Handler(Looper.getMainLooper())&#123;            @Override            public void handleMessage(@NonNull Message msg) &#123;                super.handleMessage(msg);                if (msg.what == 1)&#123;//                    请求结果验证                    if (bean == null)&#123;                        Toast.makeText(SetingPwdActivity.this,&quot;修改失败: 未知原因&quot;,Toast.LENGTH_SHORT).show();                    &#125;                    else if (bean.getCode() != 200)&#123;                        Toast.makeText(SetingPwdActivity.this,&quot;修改失败: &quot; + bean.getMsg(),Toast.LENGTH_SHORT).show();                    &#125;                    else &#123;//                        清理本地密码、清理SoftData类中的类变量，结束页面、关闭HomeActivity、跳转到登陆页面                        SharedPreferences.Editor editor = sharedPreferences.edit();                        editor.putString(&quot;password&quot;,&quot;noValue&quot;);                        SoftData.password = &quot;noValue&quot;;                        Toast.makeText(SetingPwdActivity.this,&quot;修改成功&quot;,Toast.LENGTH_SHORT).show();                        Intent intent = new Intent(SetingPwdActivity.this, LoginActivity.class);                        startActivity(intent);                        finish();                        HomeActivity.homeActivity.finish();                    &#125;                &#125;            &#125;        &#125;;    &#125;    private void init() &#123;        oldPwd = findViewById(R.id.oldPwd);        newPwd = findViewById(R.id.newPwd);        againNewPwd = findViewById(R.id.againNewPwd);        sharedPreferences = getSharedPreferences(&quot;SoftData&quot;,MODE_PRIVATE);    &#125;//    修改密码按钮    public void settingPwd(View view) &#123;        String oldPwdContent = oldPwd.getText().toString();        String newPwdContent = newPwd.getText().toString();        String againNewPwdContent = againNewPwd.getText().toString();        if (TextUtils.isEmpty(oldPwdContent))&#123;            Toast.makeText(this,&quot;初始密码不可为空&quot;,Toast.LENGTH_SHORT).show();        &#125;        else if (oldPwdContent.length() &lt; 6)&#123;            Toast.makeText(this,&quot;密码不小于位&quot;,Toast.LENGTH_SHORT).show();        &#125;        else if (TextUtils.isEmpty(newPwdContent))&#123;            Toast.makeText(this,&quot;请输入新密码&quot;,Toast.LENGTH_SHORT).show();        &#125;        else if (newPwdContent.length() &lt; 6)&#123;            Toast.makeText(this,&quot;密码不小于6位&quot;,Toast.LENGTH_SHORT).show();        &#125;        else if (TextUtils.isEmpty(againNewPwdContent))&#123;            Toast.makeText(this,&quot;请再次输入密码&quot;,Toast.LENGTH_SHORT).show();        &#125;        else if (againNewPwdContent.length() &lt; 6)&#123;            Toast.makeText(this,&quot;密码不小于6位&quot;,Toast.LENGTH_SHORT).show();        &#125;        else if (!againNewPwdContent.equals(newPwdContent))&#123;            Toast.makeText(this,&quot;两次输入的密码不一样&quot;,Toast.LENGTH_SHORT).show();        &#125;        else &#123;            String json = &quot;&#123;\n&quot; +                    &quot;\&quot;newPassword\&quot;: \&quot;&quot; + newPwdContent + &quot;\&quot;,\n&quot; +                    &quot;\&quot;oldPassword\&quot;: \&quot;&quot; + oldPwdContent + &quot;\&quot;\n&quot; +                    &quot;&#125;&quot;;            new Thread()&#123;                @Override                public void run() &#123;                    super.run();                    bean = (Bean) myHttpRequest.myHttp(&quot;/prod-api/api/common/user/resetPwd&quot;,json,Bean.class, SoftData.token,&quot;put&quot;);                    Message message = Message.obtain();                    message.what = 1;                    handler.sendMessage(message);                &#125;            &#125;.start();        &#125;    &#125;//    结束页面    public void finishActivity(View view) &#123;  finish();  &#125;&#125;
意见反馈&ensp;&ensp;&ensp;&ensp;简单的，不做描述
页面布局&ensp;&ensp;&ensp;&ensp;activity_feedback.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout android:layout_height=&quot;match_parent&quot;    android:layout_width=&quot;match_parent&quot;    android:orientation=&quot;vertical&quot;    android:gravity=&quot;center_horizontal&quot;    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;    &lt;!--    Title--&gt;    &lt;LinearLayout        android:background=&quot;@color/blue&quot;        android:orientation=&quot;horizontal&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;58dp&quot;&gt;        &lt;LinearLayout            android:onClick=&quot;finishActivity&quot;            android:gravity=&quot;center&quot;            android:layout_width=&quot;58dp&quot;            android:layout_height=&quot;58dp&quot;&gt;            &lt;ImageView                android:src=&quot;@mipmap/back&quot;                android:layout_width=&quot;20dp&quot;                android:layout_height=&quot;20dp&quot;/&gt;        &lt;/LinearLayout&gt;        &lt;LinearLayout            android:gravity=&quot;center&quot;            android:layout_weight=&quot;1&quot;            android:layout_width=&quot;0dp&quot;            android:layout_height=&quot;match_parent&quot;&gt;            &lt;TextView                android:text=&quot;意见反馈&quot;                android:textStyle=&quot;bold&quot;                android:textSize=&quot;18sp&quot;                android:textColor=&quot;@color/white&quot;                android:layout_width=&quot;wrap_content&quot;                android:layout_height=&quot;wrap_content&quot;/&gt;        &lt;/LinearLayout&gt;        &lt;LinearLayout            android:gravity=&quot;center&quot;            android:layout_width=&quot;58dp&quot;            android:layout_height=&quot;58dp&quot;&gt;        &lt;/LinearLayout&gt;    &lt;/LinearLayout&gt;    &lt;!--    Content--&gt;    &lt;LinearLayout        android:orientation=&quot;vertical&quot;        android:gravity=&quot;center_horizontal&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;match_parent&quot;&gt;        &lt;EditText            android:background=&quot;@drawable/edit_text_style&quot;            android:layout_marginTop=&quot;10dp&quot;            android:maxLength=&quot;150&quot;            android:hint=&quot;请输入反馈内容(不超过150字)&quot;            android:layout_marginLeft=&quot;20dp&quot;            android:layout_marginRight=&quot;20dp&quot;            android:gravity=&quot;top&quot;            android:id=&quot;@+id/editText&quot;            android:padding=&quot;8dp&quot;            android:layout_width=&quot;match_parent&quot;            android:minHeight=&quot;148dp&quot;            android:layout_height=&quot;wrap_content&quot;/&gt;        &lt;Button            android:background=&quot;@drawable/edit_text_style&quot;            android:text=&quot;提交反馈&quot;            android:textColor=&quot;@color/black&quot;            android:onClick=&quot;commit&quot;            android:textSize=&quot;18sp&quot;            android:layout_marginTop=&quot;28dp&quot;            android:layout_marginLeft=&quot;20dp&quot;            android:layout_marginRight=&quot;20dp&quot;            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;wrap_content&quot;/&gt;    &lt;/LinearLayout&gt;&lt;/LinearLayout&gt;
程序设计&ensp;&ensp;&ensp;&ensp;FeedbackActivity.javapackage com.SmartCity.UserInfo;import androidx.annotation.NonNull;import androidx.appcompat.app.AppCompatActivity;import android.os.Bundle;import android.os.Handler;import android.os.Looper;import android.os.Message;import android.text.TextUtils;import android.view.View;import android.widget.EditText;import android.widget.Toast;import com.SmartCity.Bean;import com.SmartCity.MyHttpRequest;import com.SmartCity.R;import com.SmartCity.SoftData;public class FeedbackActivity extends AppCompatActivity &#123;    private EditText editText;//反馈意见输入框    private Bean bean;//基础json反序列化对象    private MyHttpRequest myHttpRequest = new MyHttpRequest();//封装的服务器通信模块    private Handler handler;//线程通信    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_feedback);        myHandler();//线程通信        init();//初始化界面    &#125;//    线程通信    private void myHandler() &#123;        handler = new Handler(Looper.getMainLooper())&#123;            @Override            public void handleMessage(@NonNull Message msg) &#123;                super.handleMessage(msg);                if (msg.what == 1)&#123;//                    请求结果判断                    if (bean == null)&#123;                        Toast.makeText(FeedbackActivity.this,&quot;提交失败: 未知原因&quot;,Toast.LENGTH_SHORT).show();                    &#125;                    else if (bean.getCode() != 200)&#123;                        Toast.makeText(FeedbackActivity.this,&quot;提交失败: &quot; + bean.getMsg(),Toast.LENGTH_SHORT).show();                    &#125;                    else &#123;                        Toast.makeText(FeedbackActivity.this,&quot;提交成功&quot;,Toast.LENGTH_SHORT).show();                        editText.setText(&quot;&quot;);//清空编辑框                    &#125;                &#125;            &#125;        &#125;;    &#125;//    初始化界面    private void init() &#123;        editText = findViewById(R.id.editText);    &#125;    //    点击提交反馈意见按钮    public void commit(View view) &#123;        String editTextContent = editText.getText().toString();        if (TextUtils.isEmpty(editTextContent))&#123;            Toast.makeText(this,&quot;反馈的内容不可为空&quot;,Toast.LENGTH_SHORT).show();        &#125;        else &#123;            String json = &quot;&#123;\n&quot; +                    &quot;\&quot;content\&quot;: \&quot;&quot; + editTextContent + &quot;\&quot;,\n&quot; +                    &quot;\&quot;title\&quot;: \&quot;发现错误\&quot;\n&quot; +                    &quot;&#125;&quot;;            new Thread()&#123;                @Override                public void run() &#123;                    super.run();                    bean = (Bean) myHttpRequest.myHttp(&quot;/prod-api/api/common/feedback&quot;,json,Bean.class, SoftData.token,&quot;post&quot;);                    Message message = Message.obtain();                    message.what = 1;                    handler.sendMessage(message);                &#125;            &#125;.start();        &#125;    &#125;//    结束页面    public void finishActivity(View view) &#123;  finish();  &#125;&#125;
下一节，“全部服务页”和“新闻页”开发，Android实战-智慧城市(5)
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android开发手记</tag>
        <tag>智慧城市</tag>
      </tags>
  </entry>
  <entry>
    <title>Android实战-智慧城市(6)</title>
    <url>/2021/11/06/Android%E5%AE%9E%E6%88%98-%E6%99%BA%E6%85%A7%E5%9F%8E%E5%B8%82-6/</url>
    <content><![CDATA[上一节，“全部服务页”和“新闻页”开发Android实战-智慧城市(5)
&ensp;&ensp;&ensp;&ensp;在开发”服务“之前，得线对之前的HomeFragment0和HomeFragment1做出一些修改，使他们能够跳转到对应的服务页面&ensp;&ensp;&ensp;&ensp;在HomeFragment0中，添加startActivityService(String serviceName)方法，把”推荐服务“点击时的服务名的Toast删掉，使其调用startActivityService(String serviceName)方法并传入服务名，然后根据服务名和服务页面class的对应关系做跳转//    跳转到对应的服务页面，只需要传入正确的服务名就OK了    private void startActivityService(String serviceName)&#123;//        服务名与服务页面一定要成对应关系        String[] allServiceName = new String[]&#123;&quot;城市地铁&quot;&#125;;        Class[] allServiceClass = new Class[]&#123;MetroActivity.class&#125;;        Intent intent = new Intent();        if (allServiceName.length == allServiceClass.length)&#123;            int sum = 0;            for (int i = 0; i &lt; allServiceName.length; i++) &#123;                if (allServiceName[i].equals(serviceName))&#123;                    sum++;                    intent.setClass(getContext(),allServiceClass[i]);                    startActivity(intent);                    break;                &#125;            &#125;            if (sum == 0)&#123;                Toast.makeText(getContext(),&quot;没有找到对应的服务&quot;,Toast.LENGTH_SHORT).show();            &#125;        &#125;        else &#123;            Toast.makeText(getContext(),&quot;页面跳转对应关系错误&quot;,Toast.LENGTH_SHORT).show();        &#125;    &#125;
&ensp;&ensp;&ensp;&ensp;在HomeFragment1中大同小异，把RecyclerView的item点击事件的服务名的Toast删掉，使其调用startActivityService(String serviceName)并传入服务名//同上
软件设计城市地铁
创建经过站点的线路的反序列化对象&ensp;&ensp;&ensp;&ensp;经过当前所在的站点的所有路线的json反序列化对象&ensp;&ensp;&ensp;&ensp;StationLinesBean.javapackage com.SmartCity.Metro;import java.util.List;//当前站点的所有路线的json反序列化对象public class StationLinesBean &#123;    private String msg;    private int code;    private List&lt;DataBean&gt; data;    public String getMsg() &#123;        return msg;    &#125;    public void setMsg(String msg) &#123;        this.msg = msg;    &#125;    public int getCode() &#123;        return code;    &#125;    public void setCode(int code) &#123;        this.code = code;    &#125;    public List&lt;DataBean&gt; getData() &#123;        return data;    &#125;    public void setData(List&lt;DataBean&gt; data) &#123;        this.data = data;    &#125;    public static class DataBean &#123;        private int lineId;        private String lineName;        private PreStepBean preStep;        private NextStepBean nextStep;        private String currentName;        private int reachTime;        public int getLineId() &#123;            return lineId;        &#125;        public void setLineId(int lineId) &#123;            this.lineId = lineId;        &#125;        public String getLineName() &#123;            return lineName;        &#125;        public void setLineName(String lineName) &#123;            this.lineName = lineName;        &#125;        public PreStepBean getPreStep() &#123;            return preStep;        &#125;        public void setPreStep(PreStepBean preStep) &#123;            this.preStep = preStep;        &#125;        public NextStepBean getNextStep() &#123;            return nextStep;        &#125;        public void setNextStep(NextStepBean nextStep) &#123;            this.nextStep = nextStep;        &#125;        public String getCurrentName() &#123;            return currentName;        &#125;        public void setCurrentName(String currentName) &#123;            this.currentName = currentName;        &#125;        public int getReachTime() &#123;            return reachTime;        &#125;        public void setReachTime(int reachTime) &#123;            this.reachTime = reachTime;        &#125;        public static class PreStepBean &#123;            private String name;            private List&lt;LinesBean&gt; lines;            public String getName() &#123;                return name;            &#125;            public void setName(String name) &#123;                this.name = name;            &#125;            public List&lt;LinesBean&gt; getLines() &#123;                return lines;            &#125;            public void setLines(List&lt;LinesBean&gt; lines) &#123;                this.lines = lines;            &#125;            public static class LinesBean &#123;                private int lineId;                private String lineName;                public int getLineId() &#123;                    return lineId;                &#125;                public void setLineId(int lineId) &#123;                    this.lineId = lineId;                &#125;                public String getLineName() &#123;                    return lineName;                &#125;                public void setLineName(String lineName) &#123;                    this.lineName = lineName;                &#125;            &#125;        &#125;        public static class NextStepBean &#123;            private String name;            private List&lt;LinesBean&gt; lines;            public String getName() &#123;                return name;            &#125;            public void setName(String name) &#123;                this.name = name;            &#125;            public List&lt;LinesBean&gt; getLines() &#123;                return lines;            &#125;            public void setLines(List&lt;LinesBean&gt; lines) &#123;                this.lines = lines;            &#125;            public static class LinesBean &#123;                private int lineId;                private String lineName;                public int getLineId() &#123;                    return lineId;                &#125;                public void setLineId(int lineId) &#123;                    this.lineId = lineId;                &#125;                public String getLineName() &#123;                    return lineName;                &#125;                public void setLineName(String lineName) &#123;                    this.lineName = lineName;                &#125;            &#125;        &#125;    &#125;&#125;
创建线路列表的item布局&ensp;&ensp;&ensp;&ensp;只有简单的数据显示，线路名、下一站、剩余时间&ensp;&ensp;&ensp;&ensp;activity_metro_item.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot;    android:layout_marginTop=&quot;5dp&quot;    android:layout_marginRight=&quot;15dp&quot;    android:layout_marginLeft=&quot;15dp&quot;    android:layout_marginBottom=&quot;5dp&quot;    android:layout_height=&quot;68dp&quot;&gt;    &lt;LinearLayout        android:layout_width=&quot;match_parent&quot;        android:layout_weight=&quot;1&quot;        android:orientation=&quot;horizontal&quot;        android:layout_height=&quot;0dp&quot;&gt;        &lt;TextView            android:text=&quot;线路名称: &quot;            android:id=&quot;@+id/stationName&quot;            android:gravity=&quot;center_vertical&quot;            android:layout_width=&quot;0dp&quot;            android:layout_height=&quot;match_parent&quot;            android:textStyle=&quot;bold&quot;            android:textSize=&quot;18sp&quot;            android:textColor=&quot;@color/black&quot;            android:layout_weight=&quot;1&quot;/&gt;        &lt;TextView            android:text=&quot;下一站: &quot;            android:id=&quot;@+id/nextStation&quot;            android:gravity=&quot;center_vertical&quot;            android:textStyle=&quot;bold&quot;            android:textSize=&quot;18sp&quot;            android:textColor=&quot;@color/black&quot;            android:layout_width=&quot;0dp&quot;            android:layout_height=&quot;match_parent&quot;            android:layout_weight=&quot;1&quot;/&gt;    &lt;/LinearLayout&gt;    &lt;TextView        android:text=&quot;s分钟后到达本站&quot;        android:id=&quot;@+id/times&quot;        android:textStyle=&quot;bold&quot;        android:textSize=&quot;18sp&quot;        android:textColor=&quot;@color/black&quot;        android:gravity=&quot;center_vertical&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;0dp&quot;        android:layout_weight=&quot;1&quot;/&gt;&lt;/LinearLayout&gt;
创建线路列表的适配器&ensp;&ensp;&ensp;&ensp;在适配器中设置了item的click，当item点击时，返该item的线路对应的id和线路名&ensp;&ensp;&ensp;&ensp;MetroAdapter.javapackage com.SmartCity.Metro;import android.annotation.SuppressLint;import android.content.Context;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import android.widget.TextView;import androidx.annotation.NonNull;import androidx.recyclerview.widget.RecyclerView;import com.SmartCity.R;import java.util.List;public class MetroAdapter extends RecyclerView.Adapter&lt;MetroAdapter.MyViewHolder&gt; &#123;    private List&lt;String&gt; lineNames,nextSteps;//线路名称、下一站名称    private List&lt;Integer&gt; reachTimes,lineIds;//到达本站时长    private Context context;    public MetroAdapter(List&lt;String&gt; lineNames, List&lt;String&gt; nextSteps, List&lt;Integer&gt; reachTimes, List&lt;Integer&gt; lineIds, Context context) &#123;        this.lineNames = lineNames;        this.nextSteps = nextSteps;        this.reachTimes = reachTimes;        this.lineIds = lineIds;        this.context = context;    &#125;    @NonNull    @Override    public MyViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) &#123;        View view = LayoutInflater.from(context).inflate(R.layout.activity_metro_item,parent,false);        return new MyViewHolder(view);    &#125;    @SuppressLint(&quot;SetTextI18n&quot;)    @Override    public void onBindViewHolder(@NonNull MyViewHolder holder, int position) &#123;        holder.times.setText(reachTimes.get(position) + &quot;分钟后到达本站&quot;);        holder.nextStation.setText(&quot;下一站: &quot; + nextSteps.get(position));        holder.stationName.setText(&quot;线路名称: &quot; + lineNames.get(position));    &#125;    @Override    public int getItemCount() &#123;        return lineNames.size();    &#125;    public class MyViewHolder extends RecyclerView.ViewHolder &#123;        private TextView nextStation,stationName,times;        public MyViewHolder(@NonNull View itemView) &#123;            super(itemView);            nextStation = itemView.findViewById(R.id.nextStation);            stationName = itemView.findViewById(R.id.stationName);            times = itemView.findViewById(R.id.times);            itemView.setOnClickListener(new View.OnClickListener() &#123;                @Override                public void onClick(View v) &#123;                    if (onRecyclerItemListener != null)&#123;                        onRecyclerItemListener.OnItemClick(lineIds.get(getAbsoluteAdapterPosition()),lineNames.get(getAbsoluteAdapterPosition()));                    &#125;                &#125;            &#125;);        &#125;    &#125;    private OnRecyclerItemListener onRecyclerItemListener;    public void setOnRecyclerItemListener(OnRecyclerItemListener onRecyclerItemListener) &#123;        this.onRecyclerItemListener = onRecyclerItemListener;    &#125;    public interface OnRecyclerItemListener&#123;        void OnItemClick(int lineId,String lineName);    &#125;&#125;
页面布局&ensp;&ensp;&ensp;&ensp;注意搜索框右边”搜索“按钮的显示和隐藏，若要使搜索框显示软键盘时右下角有”搜索“按钮，需要给EditText添加android:imeOptions=”actionSearch”&ensp;&ensp;&ensp;&ensp;activity_metro.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout android:layout_height=&quot;match_parent&quot;    android:layout_width=&quot;match_parent&quot;    android:orientation=&quot;vertical&quot;    android:gravity=&quot;center_horizontal&quot;    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;    &lt;!--    Title--&gt;    &lt;LinearLayout        android:background=&quot;@color/blue&quot;        android:orientation=&quot;horizontal&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;58dp&quot;&gt;        &lt;LinearLayout            android:onClick=&quot;finishActivity&quot;            android:gravity=&quot;center&quot;            android:layout_width=&quot;58dp&quot;            android:layout_height=&quot;58dp&quot;&gt;            &lt;ImageView                android:src=&quot;@mipmap/back&quot;                android:layout_width=&quot;20dp&quot;                android:layout_height=&quot;20dp&quot;/&gt;        &lt;/LinearLayout&gt;        &lt;LinearLayout            android:gravity=&quot;center&quot;            android:layout_weight=&quot;1&quot;            android:layout_width=&quot;0dp&quot;            android:layout_height=&quot;match_parent&quot;&gt;            &lt;TextView                android:layout_width=&quot;wrap_content&quot;                android:layout_height=&quot;wrap_content&quot;                android:text=&quot;城市地铁&quot;                android:textColor=&quot;@color/white&quot;                android:textSize=&quot;18sp&quot;                android:textStyle=&quot;bold&quot; /&gt;        &lt;/LinearLayout&gt;        &lt;LinearLayout            android:gravity=&quot;center&quot;            android:layout_width=&quot;58dp&quot;            android:layout_height=&quot;58dp&quot;&gt;        &lt;/LinearLayout&gt;    &lt;/LinearLayout&gt;    &lt;!--    Content--&gt;    &lt;LinearLayout        android:orientation=&quot;vertical&quot;        android:gravity=&quot;center_horizontal&quot;        android:background=&quot;@color/darker_gray&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;match_parent&quot;&gt;        &lt;LinearLayout            android:orientation=&quot;horizontal&quot;            android:gravity=&quot;center_vertical&quot;            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;wrap_content&quot;&gt;            &lt;EditText                android:hint=&quot;搜索地铁站&quot;                android:id=&quot;@+id/search_edit&quot;                android:paddingLeft=&quot;8dp&quot;                android:paddingRight=&quot;8dp&quot;                android:lines=&quot;1&quot;                android:inputType=&quot;text&quot;                android:layout_margin=&quot;10dp&quot;                android:imeOptions=&quot;actionSearch&quot;                android:background=&quot;@drawable/edit_text_style&quot;                android:layout_width=&quot;0dp&quot;                android:layout_weight=&quot;1&quot;                android:layout_height=&quot;38dp&quot;/&gt;            &lt;Button                android:text=&quot;搜索&quot;                android:visibility=&quot;gone&quot;                android:id=&quot;@+id/search_button&quot;                android:textColor=&quot;@color/white&quot;                android:textStyle=&quot;bold&quot;                android:textSize=&quot;16sp&quot;                android:layout_marginRight=&quot;10dp&quot;                android:background=&quot;@drawable/button_style2&quot;                android:layout_width=&quot;58dp&quot;                android:layout_height=&quot;38dp&quot;/&gt;        &lt;/LinearLayout&gt;        &lt;ScrollView            android:layout_marginLeft=&quot;10dp&quot;            android:layout_marginRight=&quot;10dp&quot;            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;wrap_content&quot;&gt;            &lt;LinearLayout                android:orientation=&quot;vertical&quot;                android:layout_width=&quot;match_parent&quot;                android:layout_height=&quot;wrap_content&quot;&gt;                &lt;TextView                    android:text=&quot;我的位置: 建国门&quot;                    android:id=&quot;@+id/userStation&quot;                    android:textColor=&quot;@color/black&quot;                    android:textSize=&quot;20sp&quot;                    android:layout_marginLeft=&quot;5dp&quot;                    android:textStyle=&quot;bold&quot;                    android:layout_marginTop=&quot;10dp&quot;                    android:layout_width=&quot;wrap_content&quot;                    android:layout_height=&quot;wrap_content&quot;/&gt;                &lt;androidx.recyclerview.widget.RecyclerView                    android:visibility=&quot;visible&quot;                    android:background=&quot;@color/white&quot;                    android:layout_marginTop=&quot;10dp&quot;                    android:layout_marginBottom=&quot;10dp&quot;                    android:id=&quot;@+id/recyclerView&quot;                    android:layout_width=&quot;match_parent&quot;                    android:layout_height=&quot;wrap_content&quot;/&gt;                &lt;LinearLayout                    android:gravity=&quot;center&quot;                    android:visibility=&quot;gone&quot;                    android:id=&quot;@+id/metroMapGroup&quot;                    android:orientation=&quot;vertical&quot;                    android:layout_marginTop=&quot;10dp&quot;                    android:layout_width=&quot;match_parent&quot;                    android:layout_height=&quot;wrap_content&quot;&gt;                    &lt;TextView                        android:textStyle=&quot;bold&quot;                        android:textSize=&quot;18sp&quot;                        android:textColor=&quot;@color/red&quot;                        android:gravity=&quot;center&quot;                        android:text=&quot;我求求你\n好好看看北京的地铁线路吧&quot;                        android:layout_width=&quot;wrap_content&quot;                        android:layout_height=&quot;wrap_content&quot;/&gt;                    &lt;ImageView                        android:id=&quot;@+id/metroMap&quot;                        android:layout_marginTop=&quot;10dp&quot;                        android:layout_width=&quot;match_parent&quot;                        android:layout_height=&quot;200dp&quot;/&gt;                &lt;/LinearLayout&gt;            &lt;/LinearLayout&gt;        &lt;/ScrollView&gt;    &lt;/LinearLayout&gt;&lt;/LinearLayout&gt;
程序设计&ensp;&ensp;&ensp;&ensp;陌生点：键盘有下角”搜索“按钮响应事件；这里虽然实现了站点线路的列表显示、站点搜索等，但是点击某一线路跳转到地铁线路详情的页面暂时还没有添加&ensp;&ensp;&ensp;&ensp;MetroActivity.xmlpackage com.SmartCity.Metro;import androidx.annotation.NonNull;import androidx.appcompat.app.AppCompatActivity;import androidx.recyclerview.widget.DividerItemDecoration;import androidx.recyclerview.widget.LinearLayoutManager;import androidx.recyclerview.widget.RecyclerView;import android.annotation.SuppressLint;import android.content.Intent;import android.os.Bundle;import android.os.Handler;import android.os.Looper;import android.os.Message;import android.text.Editable;import android.text.TextUtils;import android.text.TextWatcher;import android.view.KeyEvent;import android.view.View;import android.view.inputmethod.EditorInfo;import android.widget.Button;import android.widget.EditText;import android.widget.ImageView;import android.widget.LinearLayout;import android.widget.TextView;import android.widget.Toast;import com.SmartCity.MyHttpRequest;import com.SmartCity.NewsHome.MyLinearLayoutManager;import com.SmartCity.R;import com.SmartCity.SoftData;import com.bumptech.glide.Glide;import java.util.ArrayList;import java.util.List;public class MetroActivity extends AppCompatActivity &#123;    private String userPosition = &quot;建国门&quot;;//默认的用户位置    private Handler handler;//线程通信    private MyHttpRequest myHttpRequest = new MyHttpRequest();//服务器通信封装    private TextView userStation;//用户当前所在的地铁站    private RecyclerView recyclerView;//地铁站的线路列表    private StationLinesBean stationLinesBean;//当前站点的所有路线的json反序列化对象    private List&lt;String&gt; lineNames,nextSteps;//线路名称、下一站名称    private List&lt;Integer&gt; reachTimes,lineIds;//到达本站时长、线路id    private EditText search_edit;//搜索输入框    private Button search_button;//搜索按钮    private MetroAdapter metroAdapter;//列表适配器    private ImageView metroMap;//北京地铁线路图    private LinearLayout metroMapGroup;//北京地铁线路图的父View    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_metro);        myHandler();//线程通信        init();//初始化界面        submit();//设置监听        getStationLine(userPosition);//获取当前站点的所有路线    &#125;//    线程通信    private void myHandler() &#123;        handler = new Handler(Looper.getMainLooper())&#123;            @Override            public void handleMessage(@NonNull Message msg) &#123;                super.handleMessage(msg);                if (msg.what == 1)&#123;                    getStationData();//获得站点的所有数据                &#125;            &#125;        &#125;;    &#125;//    从站点所有数据中获取我们用到的数据    private void getStationData() &#123;        if (stationLinesBean == null)&#123;            Toast.makeText(this,&quot;线路信息获取失败: 未知原因&quot;,Toast.LENGTH_SHORT).show();        &#125;        else if (stationLinesBean.getCode() != 200)&#123;            Toast.makeText(this,&quot;线路信息获取失败: &quot; + stationLinesBean.getMsg(),Toast.LENGTH_SHORT).show();        &#125;        else &#123;            setList();//清空或创建搜索的站点的线路的集合//        判断是否存在该线路            if (stationLinesBean.getData().size() != 0)&#123;//            存在就正常加载显示                metroMapGroup.setVisibility(View.GONE);                recyclerView.setVisibility(View.VISIBLE);                for (int i = 0; i &lt; stationLinesBean.getData().size(); i++) &#123;                    lineNames.add(stationLinesBean.getData().get(i).getLineName());//线路名                    nextSteps.add(stationLinesBean.getData().get(i).getNextStep().getName());//下一站站名                    reachTimes.add(stationLinesBean.getData().get(i).getReachTime());//到达本站的剩余时间                    lineIds.add(stationLinesBean.getData().get(i).getLineId());//线路id                &#125;                setRecycler();//设置列表显示数据            &#125;            else &#123;//                不存在就显示北京地铁线路图，提示不存在                metroMapGroup.setVisibility(View.VISIBLE);                recyclerView.setVisibility(View.GONE);            &#125;        &#125;    &#125;//    设置列表显示数据    private void setRecycler() &#123;        if (metroAdapter == null)&#123;//            线路名、下一站站名、剩余时间、线路id            metroAdapter = new MetroAdapter(lineNames,nextSteps,reachTimes,lineIds,this);            MyLinearLayoutManager myLinearLayoutManager = new MyLinearLayoutManager(this, LinearLayoutManager.VERTICAL,false);            recyclerView.setAdapter(metroAdapter);            recyclerView.setLayoutManager(myLinearLayoutManager);//            添加一条默认的分割线            recyclerView.addItemDecoration(new DividerItemDecoration(this,DividerItemDecoration.VERTICAL));//            item点击监听事件            metroAdapter.setOnRecyclerItemListener(new MetroAdapter.OnRecyclerItemListener() &#123;                @Override                public void OnItemClick(int lineId,String lineName) &#123;                    Intent intent = new Intent(MetroActivity.this,LinesActivity.class);                    intent.putExtra(&quot;lineId&quot;,lineId);//把线路的id传递过去                    intent.putExtra(&quot;lineName&quot;,lineName);//把线路名传递过去                    startActivity(intent);//跳转到地铁线路详情页面                &#125;            &#125;);        &#125;        else &#123;//            刷新列表            metroAdapter.notifyDataSetChanged();        &#125;    &#125;//    初始化界面    private void init() &#123;        userStation = findViewById(R.id.userStation);        recyclerView = findViewById(R.id.recyclerView);        search_edit = findViewById(R.id.search_edit);        search_button = findViewById(R.id.search_button);        metroMap = findViewById(R.id.metroMap);        metroMapGroup = findViewById(R.id.metroMapGroup);//        加载北京地铁线路图总览，当搜索不到输入的站点时会展示        Glide.with(this).load(&quot;http://&quot; + SoftData.ipPort + &quot;/prod-api/profile/upload/image/2021/05/08/554f2392-1e1c-4449-b95c-327a5f7ec91d.jpeg&quot;)                .into(metroMap);    &#125;    private void submit() &#123;//        编辑框内容改变回调        search_edit.addTextChangedListener(new TextWatcher() &#123;            @Override            public void beforeTextChanged(CharSequence s, int start, int count, int after) &#123; &#125;            @Override            public void onTextChanged(CharSequence s, int start, int before, int count) &#123; &#125;            @Override            public void afterTextChanged(Editable s) &#123;                String searchContent = search_edit.getText().toString();//                显示隐藏搜索按钮                if (TextUtils.isEmpty(searchContent))&#123;                    search_button.setVisibility(View.GONE);                &#125;                else &#123;                    search_button.setVisibility(View.VISIBLE);                &#125;            &#125;        &#125;);//        搜索线路的按钮点击        search_button.setOnClickListener(new View.OnClickListener() &#123;            @Override            public void onClick(View v) &#123;//                去除空格                String searchContent = search_edit.getText().toString().replaceAll(&quot; &quot;,&quot;&quot;);                search(searchContent);            &#125;        &#125;);//        响应键盘右下角搜索        search_edit.setOnEditorActionListener(new TextView.OnEditorActionListener() &#123;            @Override            public boolean onEditorAction(TextView v, int actionId, KeyEvent event) &#123;                if (actionId == EditorInfo.IME_ACTION_SEARCH)&#123;//                    去除空格                    String searchContent = search_edit.getText().toString().replaceAll(&quot; &quot;,&quot;&quot;);                    search(searchContent);                &#125;                return false;            &#125;        &#125;);    &#125;//    获取站点的所有线路    private void getStationLine(String userPosition) &#123;        new Thread()&#123;            @Override            public void run() &#123;                super.run();                stationLinesBean = (StationLinesBean) myHttpRequest.myHttp(&quot;/prod-api/api/metro/list?currentName=&quot; + userPosition,null,StationLinesBean.class,null,&quot;get&quot;);                Message message = Message.obtain();                message.what = 1;                handler.sendMessage(message);            &#125;        &#125;.start();    &#125;//    搜索线路    @SuppressLint(&quot;SetTextI18n&quot;)    private void search(String searchContent) &#123;        if (TextUtils.isEmpty(searchContent))&#123;            Toast.makeText(this,&quot;搜索内容不可为空&quot;,Toast.LENGTH_SHORT).show();        &#125;        else &#123;            userStation.setText(&quot;我的位置: &quot; + searchContent);//设置位置显示为搜索框中输入的位置            getStationLine(searchContent);        &#125;    &#125;//    清空或创建列表    private void setList() &#123;        if (lineNames != null)&#123;//            清空列表项            lineNames.clear();            nextSteps.clear();            reachTimes.clear();            lineIds.clear();        &#125;        else &#123;//            创建列表            lineNames = new ArrayList&lt;&gt;();            nextSteps = new ArrayList&lt;&gt;();            reachTimes = new ArrayList&lt;&gt;();            lineIds = new ArrayList&lt;&gt;();        &#125;    &#125;    //    关闭页面    public void finishActivity(View view) &#123;  finish();  &#125;&#125;
地铁详情页面&ensp;&ensp;&ensp;&ensp;地铁详情页面其实就是你在上页点击了某个地铁路线后，显示的这个线路的详细信息
地铁详情的反序列化对象&ensp;&ensp;&ensp;&ensp;获取到当前地铁线路的详细信息，线路经过的所有站点、线路名、起点、终点等信息的json反序列化对象&ensp;&ensp;&ensp;&ensp;LineStationsBean.javapackage com.SmartCity.Metro;import java.util.List;//当前线路的所有站点的json反序列化对象public class LineStationsBean &#123;    private String msg;    private int code;    private DataBean data;    public String getMsg() &#123;        return msg;    &#125;    public void setMsg(String msg) &#123;        this.msg = msg;    &#125;    public int getCode() &#123;        return code;    &#125;    public void setCode(int code) &#123;        this.code = code;    &#125;    public DataBean getData() &#123;        return data;    &#125;    public void setData(DataBean data) &#123;        this.data = data;    &#125;    public static class DataBean &#123;        private int id;        private String name;        private String first;        private String end;        private String startTime;        private String endTime;        private int cityId;        private int stationsNumber;        private int km;        private String runStationsName;        private List&lt;MetroStepListBean&gt; metroStepList;        private int remainingTime;        public int getId() &#123;            return id;        &#125;        public void setId(int id) &#123;            this.id = id;        &#125;        public String getName() &#123;            return name;        &#125;        public void setName(String name) &#123;            this.name = name;        &#125;        public String getFirst() &#123;            return first;        &#125;        public void setFirst(String first) &#123;            this.first = first;        &#125;        public String getEnd() &#123;            return end;        &#125;        public void setEnd(String end) &#123;            this.end = end;        &#125;        public String getStartTime() &#123;            return startTime;        &#125;        public void setStartTime(String startTime) &#123;            this.startTime = startTime;        &#125;        public String getEndTime() &#123;            return endTime;        &#125;        public void setEndTime(String endTime) &#123;            this.endTime = endTime;        &#125;        public int getCityId() &#123;            return cityId;        &#125;        public void setCityId(int cityId) &#123;            this.cityId = cityId;        &#125;        public int getStationsNumber() &#123;            return stationsNumber;        &#125;        public void setStationsNumber(int stationsNumber) &#123;            this.stationsNumber = stationsNumber;        &#125;        public int getKm() &#123;            return km;        &#125;        public void setKm(int km) &#123;            this.km = km;        &#125;        public String getRunStationsName() &#123;            return runStationsName;        &#125;        public void setRunStationsName(String runStationsName) &#123;            this.runStationsName = runStationsName;        &#125;        public List&lt;MetroStepListBean&gt; getMetroStepList() &#123;            return metroStepList;        &#125;        public void setMetroStepList(List&lt;MetroStepListBean&gt; metroStepList) &#123;            this.metroStepList = metroStepList;        &#125;        public int getRemainingTime() &#123;            return remainingTime;        &#125;        public void setRemainingTime(int remainingTime) &#123;            this.remainingTime = remainingTime;        &#125;        public static class MetroStepListBean &#123;            private Object searchValue;            private Object createBy;            private String createTime;            private Object updateBy;            private String updateTime;            private Object remark;            private ParamsBean params;            private int id;            private String name;            private int seq;            private int lineId;            private String firstCh;            public Object getSearchValue() &#123;                return searchValue;            &#125;            public void setSearchValue(Object searchValue) &#123;                this.searchValue = searchValue;            &#125;            public Object getCreateBy() &#123;                return createBy;            &#125;            public void setCreateBy(Object createBy) &#123;                this.createBy = createBy;            &#125;            public String getCreateTime() &#123;                return createTime;            &#125;            public void setCreateTime(String createTime) &#123;                this.createTime = createTime;            &#125;            public Object getUpdateBy() &#123;                return updateBy;            &#125;            public void setUpdateBy(Object updateBy) &#123;                this.updateBy = updateBy;            &#125;            public String getUpdateTime() &#123;                return updateTime;            &#125;            public void setUpdateTime(String updateTime) &#123;                this.updateTime = updateTime;            &#125;            public Object getRemark() &#123;                return remark;            &#125;            public void setRemark(Object remark) &#123;                this.remark = remark;            &#125;            public ParamsBean getParams() &#123;                return params;            &#125;            public void setParams(ParamsBean params) &#123;                this.params = params;            &#125;            public int getId() &#123;                return id;            &#125;            public void setId(int id) &#123;                this.id = id;            &#125;            public String getName() &#123;                return name;            &#125;            public void setName(String name) &#123;                this.name = name;            &#125;            public int getSeq() &#123;                return seq;            &#125;            public void setSeq(int seq) &#123;                this.seq = seq;            &#125;            public int getLineId() &#123;                return lineId;            &#125;            public void setLineId(int lineId) &#123;                this.lineId = lineId;            &#125;            public String getFirstCh() &#123;                return firstCh;            &#125;            public void setFirstCh(String firstCh) &#123;                this.firstCh = firstCh;            &#125;            public static class ParamsBean &#123;            &#125;        &#125;    &#125;&#125;
地铁站列表的item布局&ensp;&ensp;&ensp;&ensp;最前端的地铁图标不是累赘，一定要添加的&ensp;&ensp;&ensp;&ensp;activity_lines_item.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout android:layout_height=&quot;48dp&quot;    android:layout_width=&quot;match_parent&quot;    android:orientation=&quot;horizontal&quot;    android:gravity=&quot;center_vertical&quot;    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;    &lt;ImageView        android:src=&quot;@mipmap/subway&quot;        android:layout_width=&quot;28dp&quot;        android:id=&quot;@+id/icon&quot;        android:layout_marginRight=&quot;10dp&quot;        android:layout_marginLeft=&quot;10dp&quot;        android:layout_height=&quot;28dp&quot;/&gt;    &lt;View        android:layout_width=&quot;2dp&quot;        android:background=&quot;@color/blue&quot;        android:layout_height=&quot;match_parent&quot;/&gt;    &lt;TextView        android:text=&quot;name&quot;        android:id=&quot;@+id/stationName&quot;        android:textSize=&quot;16sp&quot;        android:textColor=&quot;@color/black&quot;        android:textStyle=&quot;bold&quot;        android:layout_marginLeft=&quot;20dp&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;/&gt;&lt;/LinearLayout&gt;
地铁线路中途径的站点列表的适配器&ensp;&ensp;&ensp;&ensp;在加载列表项的内容的方法中对列表item的地铁小图标进行了显示隐藏处理&ensp;&ensp;&ensp;&ensp;LineAdapter.javapackage com.SmartCity.Metro;import android.content.Context;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import android.widget.ImageView;import android.widget.TextView;import androidx.annotation.NonNull;import androidx.recyclerview.widget.RecyclerView;import com.SmartCity.R;import java.util.List;public class LineAdapter extends RecyclerView.Adapter&lt;LineAdapter.MyViewHolder&gt; &#123;    private String runStationsNameContent;//车辆运行站名称    private List&lt;String&gt; lineStation;//线路上所有站点的站点名    private Context context;    public LineAdapter(String runStationsNameContent, List&lt;String&gt; lineStation, Context context) &#123;        this.runStationsNameContent = runStationsNameContent;        this.lineStation = lineStation;        this.context = context;    &#125;    @NonNull    @Override    public MyViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) &#123;        View view = LayoutInflater.from(context).inflate(R.layout.activity_lines_item,parent,false);        return new MyViewHolder(view);    &#125;    @Override    public void onBindViewHolder(@NonNull MyViewHolder holder, int position) &#123;        holder.stationName.setText(lineStation.get(position));//        只显示地铁当前所到的站点前的地铁图标        if (lineStation.get(position).equals(runStationsNameContent))&#123;            holder.icon.setVisibility(View.VISIBLE);        &#125;        else &#123;            holder.icon.setVisibility(View.INVISIBLE);        &#125;    &#125;    @Override    public int getItemCount() &#123;        return lineStation.size();    &#125;    public class MyViewHolder extends RecyclerView.ViewHolder &#123;        private TextView stationName;//站点名        private ImageView icon;//地铁图标        public MyViewHolder(@NonNull View itemView) &#123;            super(itemView);            stationName = itemView.findViewById(R.id.stationName);            icon = itemView.findViewById(R.id.icon);        &#125;    &#125;&#125;
界面布局&ensp;&ensp;&ensp;&ensp;界面布局比较简单，没啥好说的&ensp;&ensp;&ensp;&ensp;activity_lines.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout android:layout_height=&quot;match_parent&quot;    android:layout_width=&quot;match_parent&quot;    android:orientation=&quot;vertical&quot;    android:gravity=&quot;center_horizontal&quot;    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;    &lt;!--    Title--&gt;    &lt;LinearLayout        android:background=&quot;@color/blue&quot;        android:orientation=&quot;horizontal&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;58dp&quot;&gt;        &lt;LinearLayout            android:onClick=&quot;finishActivity&quot;            android:gravity=&quot;center&quot;            android:layout_width=&quot;58dp&quot;            android:layout_height=&quot;58dp&quot;&gt;            &lt;ImageView                android:src=&quot;@mipmap/back&quot;                android:layout_width=&quot;20dp&quot;                android:layout_height=&quot;20dp&quot;/&gt;        &lt;/LinearLayout&gt;        &lt;LinearLayout            android:gravity=&quot;center&quot;            android:layout_weight=&quot;1&quot;            android:layout_width=&quot;0dp&quot;            android:layout_height=&quot;match_parent&quot;&gt;            &lt;TextView                android:text=&quot;线路名&quot;                android:id=&quot;@+id/lineInfo&quot;                android:textStyle=&quot;bold&quot;                android:textSize=&quot;18sp&quot;                android:textColor=&quot;@color/white&quot;                android:layout_width=&quot;wrap_content&quot;                android:layout_height=&quot;wrap_content&quot;/&gt;        &lt;/LinearLayout&gt;        &lt;LinearLayout            android:gravity=&quot;center&quot;            android:layout_width=&quot;58dp&quot;            android:layout_height=&quot;58dp&quot;&gt;        &lt;/LinearLayout&gt;    &lt;/LinearLayout&gt;    &lt;!--    Content--&gt;    &lt;LinearLayout        android:orientation=&quot;vertical&quot;        android:layout_marginTop=&quot;20dp&quot;        android:gravity=&quot;center_horizontal&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;match_parent&quot;&gt;        &lt;LinearLayout            android:orientation=&quot;horizontal&quot;            android:gravity=&quot;center_vertical&quot;            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;wrap_content&quot;&gt;            &lt;TextView                android:text=&quot;始发站&quot;                android:id=&quot;@+id/firstStation&quot;                android:gravity=&quot;center&quot;                android:textSize=&quot;16sp&quot;                android:textStyle=&quot;bold&quot;                android:textColor=&quot;@color/black&quot;                android:layout_width=&quot;0dp&quot;                android:layout_weight=&quot;1&quot;                android:layout_height=&quot;wrap_content&quot;/&gt;            &lt;ImageView                android:src=&quot;@mipmap/mark_left&quot;                android:scaleType=&quot;fitXY&quot;                android:layout_width=&quot;120dp&quot;                android:layout_height=&quot;10dp&quot;/&gt;            &lt;ImageView                android:src=&quot;@mipmap/mark_right&quot;                android:scaleType=&quot;fitXY&quot;                android:layout_width=&quot;48dp&quot;                android:layout_height=&quot;18dp&quot;/&gt;            &lt;TextView                android:text=&quot;终点站&quot;                android:id=&quot;@+id/endStation&quot;                android:gravity=&quot;center&quot;                android:textStyle=&quot;bold&quot;                android:textSize=&quot;16sp&quot;                android:textColor=&quot;@color/black&quot;                android:layout_width=&quot;0dp&quot;                android:layout_weight=&quot;1&quot;                android:layout_height=&quot;wrap_content&quot;/&gt;        &lt;/LinearLayout&gt;        &lt;LinearLayout            android:layout_marginTop=&quot;20dp&quot;            android:orientation=&quot;horizontal&quot;            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;wrap_content&quot;&gt;            &lt;LinearLayout                android:orientation=&quot;vertical&quot;                android:gravity=&quot;center&quot;                android:layout_width=&quot;0dp&quot;                android:layout_height=&quot;wrap_content&quot;                android:layout_weight=&quot;1&quot;&gt;                &lt;TextView                    android:text=&quot;首班时间: &quot;                    android:id=&quot;@+id/startTime&quot;                    android:textStyle=&quot;bold&quot;                    android:textColor=&quot;@color/black&quot;                    android:textSize=&quot;15sp&quot;                    android:layout_width=&quot;wrap_content&quot;                    android:layout_height=&quot;wrap_content&quot;/&gt;                &lt;TextView                    android:text=&quot;末班时间: &quot;                    android:textStyle=&quot;bold&quot;                    android:id=&quot;@+id/endTime&quot;                    android:textColor=&quot;@color/black&quot;                    android:textSize=&quot;15sp&quot;                    android:layout_width=&quot;wrap_content&quot;                    android:layout_height=&quot;wrap_content&quot;/&gt;            &lt;/LinearLayout&gt;            &lt;LinearLayout                android:orientation=&quot;vertical&quot;                android:gravity=&quot;center&quot;                android:layout_width=&quot;0dp&quot;                android:layout_height=&quot;wrap_content&quot;                android:layout_weight=&quot;1&quot;&gt;                &lt;TextView                    android:text=&quot;站数/距离: &quot;                    android:textStyle=&quot;bold&quot;                    android:id=&quot;@+id/stationNumber&quot;                    android:textColor=&quot;@color/black&quot;                    android:textSize=&quot;15sp&quot;                    android:layout_width=&quot;wrap_content&quot;                    android:layout_height=&quot;wrap_content&quot;/&gt;                &lt;TextView                    android:text=&quot;剩余时间: &quot;                    android:id=&quot;@+id/remainingTime&quot;                    android:textStyle=&quot;bold&quot;                    android:textColor=&quot;@color/black&quot;                    android:textSize=&quot;15sp&quot;                    android:layout_width=&quot;wrap_content&quot;                    android:layout_height=&quot;wrap_content&quot;/&gt;            &lt;/LinearLayout&gt;        &lt;/LinearLayout&gt;        &lt;androidx.recyclerview.widget.RecyclerView            android:id=&quot;@+id/recyclerView&quot;            android:layout_marginLeft=&quot;10dp&quot;            android:layout_marginRight=&quot;10dp&quot;            android:layout_marginTop=&quot;10dp&quot;            android:layout_marginBottom=&quot;10dp&quot;            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;match_parent&quot;/&gt;    &lt;/LinearLayout&gt;&lt;/LinearLayout&gt;
程序设计&ensp;&ensp;&ensp;&ensp;注意这里使RecyclerView滑动到指定的item的位置，在showRecyclerItem()方法中&ensp;&ensp;&ensp;&ensp;LinesActivity.javapackage com.SmartCity.Metro;import androidx.annotation.NonNull;import androidx.appcompat.app.AppCompatActivity;import androidx.recyclerview.widget.LinearLayoutManager;import androidx.recyclerview.widget.RecyclerView;import android.annotation.SuppressLint;import android.os.Bundle;import android.os.Handler;import android.os.Looper;import android.os.Message;import android.view.View;import android.widget.TextView;import android.widget.Toast;import com.SmartCity.MyHttpRequest;import com.SmartCity.R;import java.util.ArrayList;import java.util.List;public class LinesActivity extends AppCompatActivity &#123;    private int lineId;//线路id    private String lineName;//线路名    private MyHttpRequest myHttpRequest = new MyHttpRequest();//封装的服务器通信模块    private LineStationsBean lineStationsBean;//当前线路信息的json反序列化对象    private Handler handler;//线程通信    private String firstStationContent,endStationContent,runStationsNameContent,startTimeContent,endTimeContent;//始发站、终点站、车辆运行站名称、首班时间、末班时间    private int runStationsNameIndex;//当前运行车站在线路中的索引值    private int stationNumberContent,kmContent,remainingTimeContent;//站数、距离、剩余时间    private List&lt;String&gt; lineStation = new ArrayList&lt;&gt;();//线路上的所有站点    private TextView firstStation,endStation,startTime,endTime,stationNumber,remainingTime;//始发站、终点站、首班时间、末班时间、站数、剩余时间    private RecyclerView recyclerView;//列表项    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_lines);        myHandler();//线程通信        init();//初始化界面        getLineData();//获取线路的数据    &#125;//    线程通信    private void myHandler() &#123;        handler = new Handler(Looper.getMainLooper())&#123;            @Override            public void handleMessage(@NonNull Message msg) &#123;                super.handleMessage(msg);                if (msg.what == 1)&#123;                    setLineData();//获取地铁详细信息                &#125;            &#125;        &#125;;    &#125;//    获取地铁详细信息    private void setLineData() &#123;        if (lineStationsBean == null)&#123;            Toast.makeText(this,&quot;线路信息获取错误: 未知原因&quot;,Toast.LENGTH_SHORT).show();        &#125;        else if (lineStationsBean.getCode() != 200)&#123;            Toast.makeText(this,&quot;线路信息获取错误: &quot; + lineStationsBean.getMsg(),Toast.LENGTH_SHORT).show();        &#125;        else &#123;            /*             * 这个接口是我比较佩服的             * stationsNumber(站数)只有当这条路经过建国门的时候才会有值，否则为null             * runStationsName(车辆运行站的名称)             * km(runStationsName到当前站的距离)             *   - 在经过建国门的线路上就是runStationsName到当前站(建国门)的距离;             *   - 在没经过建国门的线路上，就是runStationsName到始发站的距离             *   - 总起来说一句话，离了建国门活不了             */            firstStationContent = lineStationsBean.getData().getFirst();//始发站            endStationContent = lineStationsBean.getData().getEnd();//终点站            runStationsNameContent = lineStationsBean.getData().getRunStationsName();//车辆运行站            startTimeContent = lineStationsBean.getData().getStartTime();//首班时间            endTimeContent = lineStationsBean.getData().getEndTime();//末班时间            stationNumberContent = lineStationsBean.getData().getStationsNumber();//站数            kmContent = lineStationsBean.getData().getKm();//距离            remainingTimeContent = lineStationsBean.getData().getRemainingTime();//剩余时间//            拿到所有站点名、拿到车辆当前所在站点在所有站点中的索引值            for (int i = 0; i &lt; lineStationsBean.getData().getMetroStepList().size(); i++) &#123;//                站点名                lineStation.add(lineStationsBean.getData().getMetroStepList().get(i).getName());//                索引值                if (lineStationsBean.getData().getMetroStepList().get(i).getName().equals(runStationsNameContent))&#123;                    runStationsNameIndex = i;                &#125;            &#125;            showData();//显示详细信息            setRecycler();//显示途径站点列表        &#125;    &#125;//    显示详细信息    @SuppressLint(&quot;SetTextI18n&quot;)    private void showData() &#123;        firstStation.setText(&quot;始发站\n&quot; + firstStationContent);        endStation.setText(&quot;终点站\n&quot; + endStationContent);        startTime.setText(&quot;首班时间: &quot; + startTimeContent);        endTime.setText(&quot;末班时间: &quot; + endTimeContent);        stationNumber.setText(&quot;站数/距离: &quot; +stationNumberContent + &quot;站/&quot; + kmContent + &quot;km&quot;);        remainingTime.setText(&quot;剩余时间: &quot; + remainingTimeContent + &quot;分钟&quot;);    &#125;//    显示途径站点列表    private void setRecycler() &#123;        LineAdapter lineAdapter = new LineAdapter(runStationsNameContent,lineStation,this);        LinearLayoutManager layoutManager = new LinearLayoutManager(this,RecyclerView.VERTICAL,false);        recyclerView.setAdapter(lineAdapter);        recyclerView.setLayoutManager(layoutManager);        showRecyclerItem(layoutManager,recyclerView,runStationsNameIndex);//滑动RecyclerView到地铁当前所在站点的位置    &#125;//    滑动RecyclerView到指定的item的位置;列表的布局管理器、列表对象、指定的item的position    private void showRecyclerItem(LinearLayoutManager layoutManager, RecyclerView recyclerView,int position) &#123;        int firstItem = layoutManager.findFirstVisibleItemPosition();//列表中的第一个item        int lastItem = layoutManager.findLastVisibleItemPosition();//列表中的最后一个item        if (position &lt;= firstItem)&#123;//            如果目标是第一个item，则列表滚动至第一个item的位置（其实根本不用动）            recyclerView.scrollToPosition(position);        &#125;        else if (position &lt;= lastItem)&#123;//            其它位置，则计算item到顶部的距离并滑动Y轴            int top = recyclerView.getChildAt(position - firstItem).getTop();            recyclerView.scrollBy(0,top);        &#125;        else &#123;//            防止出现异常，这行不会被调用到的，除非传入的position有毛病            recyclerView.scrollToPosition(position);        &#125;    &#125;    //    初始化界面    private void init() &#123;        lineId = getIntent().getExtras().getInt(&quot;lineId&quot;);        lineName = getIntent().getExtras().getString(&quot;lineName&quot;);        ((TextView)findViewById(R.id.lineInfo)).setText(lineName);//显示顶部标题为线路名        firstStation = findViewById(R.id.firstStation);        endStation = findViewById(R.id.endStation);        startTime = findViewById(R.id.startTime);        endTime = findViewById(R.id.endTime);        stationNumber = findViewById(R.id.stationNumber);        remainingTime = findViewById(R.id.remainingTime);        recyclerView = findViewById(R.id.recyclerView);    &#125;//    获取线路的信息    private void getLineData() &#123;        new Thread()&#123;            @Override            public void run() &#123;                super.run();                lineStationsBean = (LineStationsBean) myHttpRequest.myHttp(&quot;/prod-api/api/metro/line/&quot; + lineId,null,LineStationsBean.class,null,&quot;get&quot;);                Message message = Message.obtain();                message.what = 1;                handler.sendMessage(message);            &#125;        &#125;.start();    &#125;    //    关闭页面    public void finishActivity(View view) &#123;  finish();  &#125;&#125;
好吧好吧，城市地铁页面就这么结束了，下一节是智慧巴士的开发，Android实战-智慧城市(7)
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android开发手记</tag>
        <tag>智慧城市</tag>
      </tags>
  </entry>
  <entry>
    <title>Android实战-智慧城市(5)</title>
    <url>/2021/11/06/Android%E5%AE%9E%E6%88%98-%E6%99%BA%E6%85%A7%E5%9F%8E%E5%B8%82-5/</url>
    <content><![CDATA[上回说到，Android实战-智慧城市(4)
软件设计全部服务&nesp;&nesp;&nesp;&nesp;好像就一个软键盘搜索有些陌生，都不难
弹窗布局&nesp;&nesp;&nesp;&nesp;创建一个新布局作为搜索服务时dialog弹窗的布局&ensp;&ensp;&ensp;&ensp;dialog_service_search.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout android:layout_height=&quot;wrap_content&quot;    android:layout_width=&quot;match_parent&quot;    android:background=&quot;#00000000&quot;    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;    &lt;LinearLayout        android:orientation=&quot;vertical&quot;        android:background=&quot;@drawable/dialog_service_search_style&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;wrap_content&quot;&gt;        &lt;TextView            android:text=&quot;没有找到对应服务OvO&quot;            android:id=&quot;@+id/tip_dialog&quot;            android:visibility=&quot;gone&quot;            android:gravity=&quot;center&quot;            android:textSize=&quot;20sp&quot;            android:textStyle=&quot;bold&quot;            android:textColor=&quot;@color/black&quot;            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;160dp&quot;/&gt;        &lt;androidx.recyclerview.widget.RecyclerView            android:layout_margin=&quot;10dp&quot;            android:id=&quot;@+id/recyclerView_dialog&quot;            android:minHeight=&quot;160dp&quot;            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;wrap_content&quot;/&gt;    &lt;/LinearLayout&gt;&lt;/LinearLayout&gt;
创建适配器&ensp;&ensp;&ensp;&ensp;适配器用于显示服务，显示搜索后弹窗中对应的服务，该适配器中创建了RecyclerItemListener接口，通过该接口中的onItemClick(int position,List serviceName)方法响应item的onClick事件&ensp;&ensp;&ensp;&ensp;SearchAdapter.javapackage com.SmartCity.Home;import android.content.Context;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import android.widget.ImageView;import android.widget.TextView;import androidx.annotation.NonNull;import androidx.recyclerview.widget.RecyclerView;import com.SmartCity.R;import com.SmartCity.SoftData;import com.bumptech.glide.Glide;import java.util.List;public class ServiceAdapter extends RecyclerView.Adapter&lt;ServiceAdapter.MyViewHolder&gt; &#123;    private List&lt;String&gt; serviceName;    private List&lt;String&gt; serviceIcon;    private Context context;    public ServiceAdapter(List&lt;String&gt; serviceName, List&lt;String&gt; serviceIcon, Context context) &#123;        this.serviceName = serviceName;        this.serviceIcon = serviceIcon;        this.context = context;    &#125;    @NonNull    @Override    public MyViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) &#123;        View view = LayoutInflater.from(context).inflate(R.layout.fragment_home1_service_item,parent,false);        return new MyViewHolder(view);    &#125;    @Override    public void onBindViewHolder(@NonNull MyViewHolder holder, int position) &#123;        Glide.with(context).load(&quot;http://&quot; + SoftData.ipPort + serviceIcon.get(position)).into(holder.icon);        holder.name.setText(serviceName.get(position));    &#125;    @Override    public int getItemCount() &#123;        return serviceName.size();    &#125;    public class MyViewHolder extends RecyclerView.ViewHolder &#123;        private ImageView icon;        private TextView name;        public MyViewHolder(@NonNull View itemView) &#123;            super(itemView);            icon = itemView.findViewById(R.id.icon);            name = itemView.findViewById(R.id.name);            itemView.setOnClickListener(new View.OnClickListener() &#123;                @Override                public void onClick(View v) &#123;                    if (recyclerItemListener != null)&#123;                        recyclerItemListener.onItemClick(getAbsoluteAdapterPosition(),serviceName);                    &#125;                &#125;            &#125;);        &#125;    &#125;    private RecyclerItemListener recyclerItemListener;    public void setRecyclerItemListener(RecyclerItemListener recyclerItemListener) &#123;        this.recyclerItemListener = recyclerItemListener;    &#125;    public interface RecyclerItemListener&#123;        void onItemClick(int position,List&lt;String&gt; serviceName);    &#125;&#125;
item的布局&ensp;&ensp;&ensp;&ensp;fragment_home1_service_item.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout android:layout_height=&quot;wrap_content&quot;    android:layout_width=&quot;match_parent&quot;    android:gravity=&quot;center&quot;    android:orientation=&quot;vertical&quot;    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;    &lt;ImageView        android:layout_marginTop=&quot;5dp&quot;        android:id=&quot;@+id/icon&quot;        android:layout_width=&quot;48dp&quot;        android:layout_height=&quot;48dp&quot;/&gt;    &lt;TextView        android:text=&quot;serviceName&quot;        android:id=&quot;@+id/name&quot;        android:textColor=&quot;@color/black&quot;        android:textStyle=&quot;bold&quot;        android:textSize=&quot;14sp&quot;        android:layout_marginTop=&quot;10dp&quot;        android:layout_marginBottom=&quot;5dp&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;/&gt;&lt;/LinearLayout&gt;
继承GridLayoutManager&ensp;&ensp;&ensp;&ensp;创建MyGridLayoutManager类继承GridLayoutManager类，并重写它的canScrollVertivally()方法，使其永远返回false，这样用重写的布局管理器传递给RecyclerView后，RecyclerView将彻底不响应滑动事件&ensp;&ensp;&ensp;&ensp;MyGridLayoutManager.javapackage com.SmartCity.Home;import android.content.Context;import android.util.AttributeSet;import androidx.recyclerview.widget.GridLayoutManager;public class MyGridLayoutManager extends GridLayoutManager &#123;    public MyGridLayoutManager(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) &#123;        super(context, attrs, defStyleAttr, defStyleRes);    &#125;    public MyGridLayoutManager(Context context, int spanCount) &#123;        super(context, spanCount);    &#125;    public MyGridLayoutManager(Context context, int spanCount, int orientation, boolean reverseLayout) &#123;        super(context, spanCount, orientation, reverseLayout);    &#125;    @Override    public boolean canScrollVertically() &#123;        return false;    &#125;&#125;
界面布局&ensp;&ensp;&ensp;&ensp;“全部服务”页面的布局&ensp;&ensp;&ensp;&ensp;fragment_home1.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout android:layout_height=&quot;match_parent&quot;    android:layout_width=&quot;match_parent&quot;    android:orientation=&quot;vertical&quot;    android:background=&quot;@color/white&quot;    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;    &lt;LinearLayout        android:orientation=&quot;horizontal&quot;        android:gravity=&quot;center_vertical&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;wrap_content&quot;&gt;        &lt;EditText            android:hint=&quot;搜索服务&quot;            android:id=&quot;@+id/search_edit&quot;            android:paddingLeft=&quot;8dp&quot;            android:paddingRight=&quot;8dp&quot;            android:lines=&quot;1&quot;            android:inputType=&quot;text&quot;            android:layout_margin=&quot;10dp&quot;            android:imeOptions=&quot;actionSearch&quot;            android:background=&quot;@drawable/edit_text_style&quot;            android:layout_width=&quot;0dp&quot;            android:layout_weight=&quot;1&quot;            android:layout_height=&quot;38dp&quot;/&gt;        &lt;Button            android:text=&quot;搜索&quot;            android:visibility=&quot;gone&quot;            android:id=&quot;@+id/search_button&quot;            android:textColor=&quot;@color/white&quot;            android:textStyle=&quot;bold&quot;            android:textSize=&quot;16sp&quot;            android:layout_marginRight=&quot;10dp&quot;            android:background=&quot;@drawable/button_style2&quot;            android:layout_width=&quot;58dp&quot;            android:layout_height=&quot;38dp&quot;/&gt;    &lt;/LinearLayout&gt;    &lt;ScrollView        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;match_parent&quot;&gt;        &lt;LinearLayout            android:orientation=&quot;vertical&quot;            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;match_parent&quot;&gt;            &lt;TextView                android:text=&quot;生活服务&quot;                android:textSize=&quot;18sp&quot;                android:textStyle=&quot;bold&quot;                android:textColor=&quot;@color/black&quot;                android:layout_marginTop=&quot;10dp&quot;                android:layout_marginLeft=&quot;10dp&quot;                android:layout_width=&quot;wrap_content&quot;                android:layout_height=&quot;wrap_content&quot;/&gt;            &lt;androidx.recyclerview.widget.RecyclerView                android:layout_width=&quot;match_parent&quot;                android:layout_marginLeft=&quot;5dp&quot;                android:id=&quot;@+id/lifeService&quot;                android:layout_marginRight=&quot;5dp&quot;                android:layout_marginTop=&quot;10dp&quot;                android:layout_height=&quot;wrap_content&quot;/&gt;            &lt;View                android:background=&quot;@color/darker_gray&quot;                android:layout_width=&quot;match_parent&quot;                android:layout_height=&quot;1dp&quot;/&gt;            &lt;TextView                android:text=&quot;便民服务&quot;                android:layout_marginTop=&quot;10dp&quot;                android:textSize=&quot;18sp&quot;                android:textStyle=&quot;bold&quot;                android:textColor=&quot;@color/black&quot;                android:layout_marginLeft=&quot;10dp&quot;                android:layout_width=&quot;wrap_content&quot;                android:layout_height=&quot;wrap_content&quot;/&gt;            &lt;androidx.recyclerview.widget.RecyclerView                android:layout_width=&quot;match_parent&quot;                android:layout_marginLeft=&quot;5dp&quot;                android:layout_marginRight=&quot;5dp&quot;                android:id=&quot;@+id/convenienceService&quot;                android:layout_marginTop=&quot;10dp&quot;                android:layout_height=&quot;wrap_content&quot;/&gt;            &lt;View                android:background=&quot;@color/darker_gray&quot;                android:layout_width=&quot;match_parent&quot;                android:layout_height=&quot;1dp&quot;/&gt;            &lt;TextView                android:text=&quot;车主服务&quot;                android:layout_marginTop=&quot;10dp&quot;                android:textSize=&quot;18sp&quot;                android:textStyle=&quot;bold&quot;                android:textColor=&quot;@color/black&quot;                android:layout_marginLeft=&quot;10dp&quot;                android:layout_width=&quot;wrap_content&quot;                android:layout_height=&quot;wrap_content&quot;/&gt;            &lt;androidx.recyclerview.widget.RecyclerView                android:layout_width=&quot;match_parent&quot;                android:layout_marginLeft=&quot;5dp&quot;                android:id=&quot;@+id/ownerService&quot;                android:layout_marginRight=&quot;5dp&quot;                android:layout_marginTop=&quot;10dp&quot;                android:layout_height=&quot;wrap_content&quot;/&gt;        &lt;/LinearLayout&gt;    &lt;/ScrollView&gt;&lt;/LinearLayout&gt;
程序设计&ensp;&ensp;&ensp;&ensp;“全部服务”页的程序设计&ensp;&ensp;&ensp;&ensp;HomeFragment1.javapackage com.SmartCity.Home;import android.app.Dialog;import android.os.Bundle;import androidx.annotation.NonNull;import androidx.fragment.app.Fragment;import androidx.recyclerview.widget.LinearLayoutManager;import androidx.recyclerview.widget.RecyclerView;import android.os.Handler;import android.os.Looper;import android.os.Message;import android.text.Editable;import android.text.TextUtils;import android.text.TextWatcher;import android.util.Log;import android.view.Gravity;import android.view.KeyEvent;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import android.view.Window;import android.view.inputmethod.EditorInfo;import android.widget.Button;import android.widget.EditText;import android.widget.TextView;import android.widget.Toast;import com.SmartCity.MyHttpRequest;import com.SmartCity.R;import java.util.ArrayList;import java.util.List;public class HomeFragment1 extends Fragment implements ServiceAdapter.RecyclerItemListener &#123;    private static final String TAG = &quot;HomeFragment1&quot;;    private View viewRoot;    private EditText search_edit;//搜索编辑框    private Button search_button;//搜索按钮    private TextView tip_dialog;//弹窗中没有搜索到对应服务时    private RecyclerView lifeService,convenienceService,ownerService,recyclerView_dialog;//生活服务、便民服务、车主服务、弹窗中的列表    private Handler handler;//线程通信    private MyHttpRequest myHttpRequest = new MyHttpRequest();//服务器通信封装    private ServiceBean serviceBean;//&quot;全部服务&quot;的json反序列化对象    private List&lt;String&gt; lifeServiceName,lifeServiceIcon,convenienceServiceName,convenienceServiceIcon,ownerServiceName,ownerServiceIcon;    private List&lt;String&gt; searchServiceName,searchServiceIcon;//搜索到的服务名和服务图标    @Override    public void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);    &#125;    @Override    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123;        if (viewRoot == null)&#123; viewRoot = inflater.inflate(R.layout.fragment_home1, container, false); &#125;        myHandler();//线程通信        init();//初始化界面        submit();//设置监听        getAllService();//获取全部服务信息        return viewRoot;    &#125;    //    线程通信    private void myHandler() &#123;        handler = new Handler(Looper.getMainLooper())&#123;            @Override            public void handleMessage(@NonNull Message msg) &#123;                super.handleMessage(msg);                if (msg.what == 1)&#123;                    setAllServiceData();//设置数据                &#125;            &#125;        &#125;;    &#125;//    设置三个服务中对应的列表中的集合    private void setAllServiceData() &#123;        setList();        for (int i = 0; i &lt; serviceBean.getTotal(); i++) &#123;            String serviceType = serviceBean.getRows().get(i).getServiceType();            String serviceName = serviceBean.getRows().get(i).getServiceName();            String serviceIcon = serviceBean.getRows().get(i).getImgUrl();            switch (serviceType) &#123;                case &quot;生活服务&quot;:                    lifeServiceName.add(serviceName);                    lifeServiceIcon.add(serviceIcon);                    break;                case &quot;便民服务&quot;:                    convenienceServiceName.add(serviceName);                    convenienceServiceIcon.add(serviceIcon);                    break;                case &quot;车主服务&quot;:                    ownerServiceName.add(serviceName);                    ownerServiceIcon.add(serviceIcon);                    break;            &#125;        &#125;        setRecycler();    &#125;//    设置列表显示    private void setRecycler() &#123;//        创建适适配器        ServiceAdapter lifeServiceAdapter = new ServiceAdapter(lifeServiceName,lifeServiceIcon,getContext());        ServiceAdapter convenienceServiceAdapter = new ServiceAdapter(convenienceServiceName,convenienceServiceIcon,getContext());        ServiceAdapter ownerServiceAdapter = new ServiceAdapter(ownerServiceName,ownerServiceIcon,getContext());//        创建布局管理器        MyGridLayoutManager myGridLayoutManager1 = new MyGridLayoutManager(getContext(),4, LinearLayoutManager.VERTICAL,false);        MyGridLayoutManager myGridLayoutManager2 = new MyGridLayoutManager(getContext(),4, LinearLayoutManager.VERTICAL,false);        MyGridLayoutManager myGridLayoutManager3 = new MyGridLayoutManager(getContext(),4, LinearLayoutManager.VERTICAL,false);//        设置适配器        lifeService.setAdapter(lifeServiceAdapter);        convenienceService.setAdapter(convenienceServiceAdapter);        ownerService.setAdapter(ownerServiceAdapter);//        设置RecyclerView布局方式        lifeService.setLayoutManager(myGridLayoutManager1);        convenienceService.setLayoutManager(myGridLayoutManager2);        ownerService.setLayoutManager(myGridLayoutManager3);//        设置item点击事件        lifeServiceAdapter.setRecyclerItemListener(this);        convenienceServiceAdapter.setRecyclerItemListener(this);        ownerServiceAdapter.setRecyclerItemListener(this);    &#125;//    RecyclerView的item点击事件    @Override    public void onItemClick(int position,List&lt;String&gt; serviceName) &#123;//        暂时不做跳转，只提示点击的服务名        Toast.makeText(getContext(),serviceName.get(position),Toast.LENGTH_SHORT).show();    &#125;//    清空或创建三个列表中的集合    private void setList() &#123;        if (lifeServiceName != null)&#123;            lifeServiceName.clear();            lifeServiceIcon.clear();            convenienceServiceName.clear();            convenienceServiceIcon.clear();            ownerServiceName.clear();            ownerServiceIcon.clear();        &#125;        else &#123;            lifeServiceName = new ArrayList&lt;&gt;();            lifeServiceIcon = new ArrayList&lt;&gt;();            convenienceServiceName = new ArrayList&lt;&gt;();            convenienceServiceIcon = new ArrayList&lt;&gt;();            ownerServiceName = new ArrayList&lt;&gt;();            ownerServiceIcon = new ArrayList&lt;&gt;();        &#125;    &#125;    //    初始化界面    private void init() &#123;        search_button = viewRoot.findViewById(R.id.search_button);        search_edit = viewRoot.findViewById(R.id.search_edit);        lifeService = viewRoot.findViewById(R.id.lifeService);        convenienceService = viewRoot.findViewById(R.id.convenienceService);        ownerService = viewRoot.findViewById(R.id.ownerService);    &#125;//    设置一些监听    private void submit() &#123;//        内容改变监听        search_edit.addTextChangedListener(new TextWatcher() &#123;            @Override            public void beforeTextChanged(CharSequence s, int start, int count, int after) &#123;            &#125;            @Override            public void onTextChanged(CharSequence s, int start, int before, int count) &#123;            &#125;            @Override            public void afterTextChanged(Editable s) &#123;                String searchContent = search_edit.getText().toString();                if (TextUtils.isEmpty(searchContent))&#123;                    search_button.setVisibility(View.GONE);                &#125;                else &#123;                    search_button.setVisibility(View.VISIBLE);                &#125;            &#125;        &#125;);//        点击按钮搜索        search_button.setOnClickListener(new View.OnClickListener() &#123;            @Override            public void onClick(View v) &#123;                search();            &#125;        &#125;);//        键盘右下角按钮监听        search_edit.setOnEditorActionListener(new TextView.OnEditorActionListener() &#123;            @Override            public boolean onEditorAction(TextView v, int actionId, KeyEvent event) &#123;                if (actionId == EditorInfo.IME_ACTION_SEARCH)&#123;//                    调用搜索服务                    search();                &#125;                return false;            &#125;        &#125;);    &#125;    //    搜索服务    private void search() &#123;        String searchContent = search_edit.getText().toString();        if (TextUtils.isEmpty(searchContent))&#123;            Toast.makeText(getContext(),&quot;空的，你搜索什么&quot;,Toast.LENGTH_SHORT).show();        &#125;        else &#123;            setSearchServiceList();//清空或创建搜索服务的集合            for (int i = 0; i &lt; serviceBean.getTotal(); i++) &#123;                String serviceName = serviceBean.getRows().get(i).getServiceName();                String serviceIcon = serviceBean.getRows().get(i).getImgUrl();                if (serviceName.contains(searchContent))&#123;                    searchServiceName.add(serviceName);                    searchServiceIcon.add(serviceIcon);                    Log.d(TAG, &quot;search: &quot; + serviceName);                &#125;            &#125;//            显示弹窗            dialogShow();        &#125;    &#125;    //    清空或创建搜索服务的集合    private void setSearchServiceList() &#123;        if (searchServiceIcon != null)&#123;            searchServiceIcon.clear();            searchServiceName.clear();        &#125;        else &#123;            searchServiceIcon = new ArrayList&lt;&gt;();            searchServiceName = new ArrayList&lt;&gt;();        &#125;    &#125;    //    弹窗显示    private void dialogShow()&#123;//        创建一个弹窗        Dialog dialog = new Dialog(getContext());        View view = View.inflate(getContext(),R.layout.dialog_service_search,null);//得到弹窗的布局        dialog.setContentView(view);//设置弹窗布局        Window window = dialog.getWindow();//弹窗窗口中的对象        window.setGravity(Gravity.BOTTOM);//设置出现位置        window.setWindowAnimations(R.style.check_avatar_dialog_anim);//设置动画        window.setLayout(ViewGroup.LayoutParams.MATCH_PARENT,ViewGroup.LayoutParams.WRAP_CONTENT);//宽高        dialog.show();//显示弹窗        dialogInit(dialog);//初始化弹窗中的控件        dialogEvent();//设置弹窗中的一些事件    &#125;    //    初始化弹窗中的控件    private void dialogInit(Dialog dialog) &#123;        recyclerView_dialog = dialog.findViewById(R.id.recyclerView_dialog);//弹窗中的recyclerView列表        tip_dialog = dialog.findViewById(R.id.tip_dialog);//弹窗中没有搜索项时的提示    &#125;    //    设置弹窗中的一些事件    private void dialogEvent() &#123;//        设置列表        if (searchServiceName.size() == 0)&#123;//            没有搜索到对应服务时出现提示            recyclerView_dialog.setVisibility(View.GONE);            tip_dialog.setVisibility(View.VISIBLE);        &#125;        else &#123;            recyclerView_dialog.setVisibility(View.VISIBLE);            tip_dialog.setVisibility(View.GONE);//            对应服务的列表            ServiceAdapter serviceAdapter = new ServiceAdapter(searchServiceName,searchServiceIcon,getContext());            MyGridLayoutManager myGridLayoutManager = new MyGridLayoutManager(getContext(),4,LinearLayoutManager.VERTICAL,false);            recyclerView_dialog.setAdapter(serviceAdapter);            recyclerView_dialog.setLayoutManager(myGridLayoutManager);            serviceAdapter.setRecyclerItemListener(this);        &#125;    &#125;//    获取全部服务信息    private void getAllService() &#123;        new Thread()&#123;            @Override            public void run() &#123;                super.run();                serviceBean = (ServiceBean) myHttpRequest.myHttp(&quot;/prod-api/api/service/list&quot;,null, ServiceBean.class,null,&quot;get&quot;);                Message message = Message.obtain();                message.what = 1;                handler.sendMessage(message);            &#125;        &#125;.start();    &#125;&#125;
新闻&ensp;&ensp;&ensp;&ensp;没啥好写的，对着首页抄就是了
界面布局&ensp;&ensp;&ensp;&ensp;fragment_home2.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout    android:layout_height=&quot;match_parent&quot;    android:layout_width=&quot;match_parent&quot;    android:orientation=&quot;vertical&quot;    android:background=&quot;@color/darker_gray&quot;    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;    &lt;com.SmartCity.Home.MyScrollView        android:id=&quot;@+id/myScrollView&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;match_parent&quot;&gt;        &lt;LinearLayout            android:orientation=&quot;vertical&quot;            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;match_parent&quot;&gt;            &lt;!--    轮播图--&gt;            &lt;com.youth.banner.Banner                android:layout_margin=&quot;10dp&quot;                android:background=&quot;@color/white&quot;                android:id=&quot;@+id/banner&quot;                android:layout_width=&quot;match_parent&quot;                android:layout_height=&quot;160dp&quot;/&gt;            &lt;!--            新闻列表--&gt;            &lt;LinearLayout                android:orientation=&quot;vertical&quot;                android:id=&quot;@+id/fixNavBar&quot;                android:tag=&quot;fixNavBar&quot;                android:layout_width=&quot;match_parent&quot;                android:layout_height=&quot;60dp&quot;&gt;                &lt;HorizontalScrollView                    android:scrollbars=&quot;none&quot;                    android:id=&quot;@+id/newsTypeGroup&quot;                    android:background=&quot;@color/white&quot;                    android:layout_width=&quot;match_parent&quot;                    android:layout_height=&quot;59dp&quot;&gt;                    &lt;LinearLayout                        android:orientation=&quot;horizontal&quot;                        android:gravity=&quot;center_vertical&quot;                        android:layout_width=&quot;wrap_content&quot;                        android:layout_height=&quot;match_parent&quot;&gt;                        &lt;TextView                            android:gravity=&quot;center&quot;                            android:textColor=&quot;@color/black&quot;                            android:textSize=&quot;15sp&quot;                            android:id=&quot;@+id/newsType0&quot;                            android:paddingLeft=&quot;10dp&quot;                            android:paddingRight=&quot;10dp&quot;                            android:textStyle=&quot;bold&quot;                            android:layout_width=&quot;wrap_content&quot;                            android:layout_height=&quot;match_parent&quot;/&gt;                        &lt;View                            android:background=&quot;@color/darker_gray&quot;                            android:layout_width=&quot;1dp&quot;                            android:layout_marginTop=&quot;10dp&quot;                            android:layout_marginBottom=&quot;10dp&quot;                            android:layout_height=&quot;match_parent&quot;/&gt;                        &lt;TextView                            android:gravity=&quot;center&quot;                            android:textColor=&quot;@color/black&quot;                            android:id=&quot;@+id/newsType1&quot;                            android:textSize=&quot;15sp&quot;                            android:paddingLeft=&quot;10dp&quot;                            android:paddingRight=&quot;10dp&quot;                            android:textStyle=&quot;bold&quot;                            android:layout_width=&quot;wrap_content&quot;                            android:layout_height=&quot;match_parent&quot;/&gt;                        &lt;View                            android:background=&quot;@color/darker_gray&quot;                            android:layout_width=&quot;1dp&quot;                            android:layout_marginTop=&quot;10dp&quot;                            android:layout_marginBottom=&quot;10dp&quot;                            android:layout_height=&quot;match_parent&quot;/&gt;                        &lt;TextView                            android:gravity=&quot;center&quot;                            android:textColor=&quot;@color/black&quot;                            android:id=&quot;@+id/newsType2&quot;                            android:textSize=&quot;15sp&quot;                            android:paddingLeft=&quot;10dp&quot;                            android:paddingRight=&quot;10dp&quot;                            android:textStyle=&quot;bold&quot;                            android:layout_width=&quot;wrap_content&quot;                            android:layout_height=&quot;match_parent&quot;/&gt;                        &lt;View                            android:background=&quot;@color/darker_gray&quot;                            android:layout_width=&quot;1dp&quot;                            android:layout_marginTop=&quot;10dp&quot;                            android:layout_marginBottom=&quot;10dp&quot;                            android:layout_height=&quot;match_parent&quot;/&gt;                        &lt;TextView                            android:gravity=&quot;center&quot;                            android:textColor=&quot;@color/black&quot;                            android:id=&quot;@+id/newsType3&quot;                            android:textSize=&quot;15sp&quot;                            android:paddingLeft=&quot;10dp&quot;                            android:paddingRight=&quot;10dp&quot;                            android:textStyle=&quot;bold&quot;                            android:layout_width=&quot;wrap_content&quot;                            android:layout_height=&quot;match_parent&quot;/&gt;                        &lt;View                            android:background=&quot;@color/darker_gray&quot;                            android:layout_width=&quot;1dp&quot;                            android:layout_marginTop=&quot;10dp&quot;                            android:layout_marginBottom=&quot;10dp&quot;                            android:layout_height=&quot;match_parent&quot;/&gt;                        &lt;TextView                            android:gravity=&quot;center&quot;                            android:textColor=&quot;@color/black&quot;                            android:id=&quot;@+id/newsType4&quot;                            android:textSize=&quot;15sp&quot;                            android:paddingLeft=&quot;10dp&quot;                            android:paddingRight=&quot;10dp&quot;                            android:textStyle=&quot;bold&quot;                            android:layout_width=&quot;wrap_content&quot;                            android:layout_height=&quot;match_parent&quot;/&gt;                        &lt;View                            android:background=&quot;@color/darker_gray&quot;                            android:layout_width=&quot;1dp&quot;                            android:layout_marginTop=&quot;10dp&quot;                            android:layout_marginBottom=&quot;10dp&quot;                            android:layout_height=&quot;match_parent&quot;/&gt;                        &lt;TextView                            android:gravity=&quot;center&quot;                            android:textColor=&quot;@color/black&quot;                            android:id=&quot;@+id/newsType5&quot;                            android:textSize=&quot;15sp&quot;                            android:paddingLeft=&quot;10dp&quot;                            android:paddingRight=&quot;10dp&quot;                            android:textStyle=&quot;bold&quot;                            android:layout_width=&quot;wrap_content&quot;                            android:layout_height=&quot;match_parent&quot;/&gt;                    &lt;/LinearLayout&gt;                &lt;/HorizontalScrollView&gt;                &lt;View                    android:background=&quot;@color/darker_gray&quot;                    android:layout_width=&quot;match_parent&quot;                    android:layout_height=&quot;1dp&quot;/&gt;            &lt;/LinearLayout&gt;            &lt;androidx.recyclerview.widget.RecyclerView                android:background=&quot;@color/white&quot;                android:paddingRight=&quot;10dp&quot;                android:paddingLeft=&quot;10dp&quot;                android:id=&quot;@+id/recyclerView&quot;                android:layout_width=&quot;match_parent&quot;                android:layout_height=&quot;wrap_content&quot;/&gt;        &lt;/LinearLayout&gt;    &lt;/com.SmartCity.Home.MyScrollView&gt;&lt;/LinearLayout&gt;
程序设计&ensp;&ensp;&ensp;&ensp;HomeFragment2.javapackage com.SmartCity.Home;import android.content.Intent;import android.os.Bundle;import androidx.annotation.NonNull;import androidx.fragment.app.Fragment;import androidx.recyclerview.widget.DividerItemDecoration;import androidx.recyclerview.widget.LinearLayoutManager;import androidx.recyclerview.widget.RecyclerView;import android.os.Handler;import android.os.Looper;import android.os.Message;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import android.widget.TextView;import android.widget.Toast;import com.SmartCity.MyHttpRequest;import com.SmartCity.NewsHome.NewsHomeActivity;import com.SmartCity.R;import com.SmartCity.SoftData;import com.youth.banner.Banner;import com.youth.banner.indicator.CircleIndicator;import com.youth.banner.listener.OnBannerListener;import java.util.ArrayList;import java.util.List;public class HomeFragment2 extends Fragment implements View.OnClickListener &#123;    private static final String TAG = &quot;HomeFragment2&quot;;    private View viewRoot;//页面布局    private Banner banner;//轮播图    private RecyclerView recyclerView;//新闻分类列表    private Handler handler;//handler线程通信    private MyScrollView myScrollView;//滑动布局    private NewsBannerBean newsBannerBean;//轮播图的反序列化对象    private NewsContentBean newsContentBean;//新闻列表的反序列化对象    private List&lt;String&gt; listNewsTitles,listNewsCovers;//分类列表中新闻封面和新闻标题    private List&lt;Integer&gt; listNewsId;//分类列表中新闻id    private List&lt;String&gt; newsBannerData = new ArrayList&lt;&gt;();//轮播图中的图片链接    private TextView[] newsTypes = new TextView[6];//6个新闻分类    private TextView newsType;//上个点击过的分类    private MyHttpRequest myHttpRequest = new MyHttpRequest();//封装的http请求    private List&lt;String&gt; newsTypeName = new ArrayList&lt;&gt;();//新闻分类的分类名    private Home0NewsAdapter home0NewsAdapter;//新闻分类列表的适配器    private NewsTypeBean newsTypeBean;//新闻分类列表的反序列化对象    private boolean isFix = false;//fixNavBar的是否为悬浮状态    @Override    public void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);    &#125;    @Override    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123;        if (viewRoot == null)&#123; viewRoot = inflater.inflate(R.layout.fragment_home2, container, false); &#125;        myHandler();//handler通信        init();//初始化界面        setScrollView();//设置滚动控件中的固定导航栏        getBannerData();//获取Banner的数据        getThemeData();//获取新闻分类中的数据        submit();//设置监听        return viewRoot;    &#125;    //    线程通信    private void myHandler() &#123;        handler = new Handler(Looper.getMainLooper())&#123;            @Override            public void handleMessage(@NonNull Message msg) &#123;                super.handleMessage(msg);                if (msg.what == 1)&#123;                    setBanner();//设置banner                &#125;                else if (msg.what == 3)&#123;                    setNews(0);//设置新闻分类                &#125;            &#125;        &#125;;    &#125;    //    设置banner    private void setBanner() &#123;        if (newsBannerBean == null)&#123;            Toast.makeText(getContext(),&quot;Banner数据获取失败: 未知原因&quot;,Toast.LENGTH_SHORT).show();        &#125;        else if (newsBannerBean.getCode() != 200)&#123;            Toast.makeText(getContext(),&quot;Banner数据获取失败: &quot; + newsBannerBean.getMsg(),Toast.LENGTH_SHORT).show();        &#125;        else &#123;//            实例化Banner的适配器            MyBannerAdapter myBannerAdapter = new MyBannerAdapter(newsBannerData,getContext());            banner.setAdapter(myBannerAdapter)                    .isAutoLoop(true)//是否自动轮播                    .setLoopTime(1500)//自动轮播切换间隔时间                    .addBannerLifecycleObserver(this)//观察者                    .setIndicator(new CircleIndicator(getContext()));//下面的小点//            banner的点击事件            banner.setOnBannerListener(new OnBannerListener() &#123;                @Override                public void OnBannerClick(Object data, int position) &#123;//                    这里说要跳转到对应页面，却没有告诉对应哪里的页面，那怎么跳转？                    Toast.makeText(getContext(),&quot;position: &quot; + position,Toast.LENGTH_SHORT).show();                &#125;            &#125;);        &#125;    &#125;    //    设置新闻列表    private void setNews(int position) &#123;        if (newsTypeBean == null)&#123;            Toast.makeText(getContext(),&quot;新闻数据获取失败: 未知原因&quot;,Toast.LENGTH_SHORT).show();        &#125;        else if (newsTypeBean.getCode() != 200)&#123;            Toast.makeText(getContext(),&quot;新闻数据获取失败: &quot; + newsTypeBean.getMsg(),Toast.LENGTH_SHORT).show();        &#125;        else &#123;            for (int i = 0; i &lt; newsTypes.length; i++) &#123;                newsTypes[i].setText(newsTypeBean.getData().get(i).getName());//设置分类名显示                newsTypes[i].setTag(String.valueOf(newsTypeBean.getData().get(i).getId()));//把分类的id添加到tag            &#125;        &#125;//        设置被选中分类名的颜色，加载列表        setNewsType(position);    &#125;    //    设置被选中分类名的颜色，加载列表    private void setNewsType(int position) &#123;        if (newsType != null)&#123;            newsType.setTextColor(getContext().getResources().getColor(R.color.black));        &#125;        newsType = newsTypes[position];        newsTypes[position].setTextColor(getContext().getResources().getColor(R.color.red));//        加载列表        setRecycler(position);    &#125;    private void setRecycler(int position) &#123;        setList(position);//得到要显示的数据        if (home0NewsAdapter == null)&#123;//            设置列表高度            int pxHeight = getContext().getResources().getDisplayMetrics().heightPixels;            int delHeight = (int) (176 * getContext().getResources().getDisplayMetrics().density + 0.5f);            recyclerView.getLayoutParams().height = pxHeight - delHeight;//            设置RecyclerView的LayoutManager、设置Adapter            LinearLayoutManager layoutManager = new LinearLayoutManager(getContext(),RecyclerView.VERTICAL,false);            recyclerView.addItemDecoration(new DividerItemDecoration(getContext(),DividerItemDecoration.VERTICAL));//默认的分割线            home0NewsAdapter = new Home0NewsAdapter(listNewsCovers,listNewsTitles,getContext());            recyclerView.setLayoutManager(layoutManager);            recyclerView.setAdapter(home0NewsAdapter);            recyclerView.setNestedScrollingEnabled(false);//滑动状体初始是禁用//            滑动监听            recyclerView.addOnScrollListener(new RecyclerView.OnScrollListener() &#123;                @Override                public void onScrolled(@NonNull RecyclerView recyclerView, int dx, int dy) &#123;                    super.onScrolled(recyclerView, dx, dy);//                    当recyclerView滑动到顶部时canScrollVertically(-1)返回false，禁用它的滑动                    if (!recyclerView.canScrollVertically(-1))&#123;                        recyclerView.setNestedScrollingEnabled(false);                    &#125;                &#125;            &#125;);//            设置新闻分类列表的item单击事件            home0NewsAdapter.setOnItemLintener(new Home0NewsAdapter.OnItemLintener() &#123;                @Override                public void OnItemClick(int position) &#123;                    startNewsActivity(listNewsId.get(position));                &#125;            &#125;);        &#125;        else &#123;//            刷新列表            home0NewsAdapter.notifyDataSetChanged();        &#125;    &#125;//    获取专题和新闻分类中的数据    private void getThemeData() &#123;        new Thread()&#123;            @Override            public void run() &#123;                super.run();                newsContentBean = (NewsContentBean) myHttpRequest.myHttp(&quot;/prod-api/press/press/list&quot;,null,NewsContentBean.class,null,&quot;get&quot;);                newsTypeBean = (NewsTypeBean) myHttpRequest.myHttp(&quot;/prod-api/press/category/list&quot;,null,NewsTypeBean.class,null,&quot;get&quot;);                if (newsTypeBean != null)&#123;                    for (int i = 0; i &lt; newsTypes.length; i++) &#123;                        newsTypeName.add(newsTypeBean.getData().get(i).getName());                    &#125;                &#125;                Message message = Message.obtain();                message.what = 3;                handler.sendMessage(message);            &#125;        &#125;.start();    &#125;    private void setList(int position) &#123;//        清空或创建        if (listNewsTitles != null &amp;&amp; listNewsCovers != null &amp;&amp; listNewsId != null)&#123;            listNewsTitles.clear();            listNewsCovers.clear();            listNewsId.clear();        &#125;        else &#123;            listNewsTitles = new ArrayList&lt;&gt;();            listNewsCovers = new ArrayList&lt;&gt;();            listNewsId = new ArrayList&lt;&gt;();        &#125;//        拿到数据        for (int i = 0; i &lt; newsContentBean.getTotal(); i++) &#123;            String type = newsContentBean.getRows().get(i).getType();            String string = newsTypes[position].getTag().toString();            if (type.equals(string))&#123;                listNewsTitles.add(newsContentBean.getRows().get(i).getTitle());                listNewsCovers.add(newsContentBean.getRows().get(i).getCover());                listNewsId.add(newsContentBean.getRows().get(i).getId());            &#125;        &#125;    &#125;    //    启动新闻内容显示页面    private void startNewsActivity(int id) &#123;//        获取到点击的专题或新闻列表中的新闻的id并将新闻的id值传递给新闻显示页        Intent intent = new Intent(getContext(), NewsHomeActivity.class);        intent.putExtra(&quot;newsId&quot;,id);        startActivity(intent);    &#125;    //    初始化页面    private void init() &#123;        banner = viewRoot.findViewById(R.id.banner);//轮播图        recyclerView = viewRoot.findViewById(R.id.recyclerView);//新闻分类列表        myScrollView = viewRoot.findViewById(R.id.myScrollView);//重写的滑动窗体//        新闻分类        newsTypes[0] = viewRoot.findViewById(R.id.newsType0);        newsTypes[1] = viewRoot.findViewById(R.id.newsType1);        newsTypes[2] = viewRoot.findViewById(R.id.newsType2);        newsTypes[3] = viewRoot.findViewById(R.id.newsType3);        newsTypes[4] = viewRoot.findViewById(R.id.newsType4);        newsTypes[5] = viewRoot.findViewById(R.id.newsType5);    &#125;//    设置滚动    private void setScrollView() &#123;        myScrollView.setOnFixNavBarLintener(new MyScrollView.OnFixNavBarLintener() &#123;            //            当导航栏滑动至顶部时，设置RecyclerView可以滑动            @Override            public void OnFix() &#123;                if (!isFix)&#123;                    recyclerView.setNestedScrollingEnabled(true);                    isFix = true;                &#125;            &#125;            //            当导航栏离开顶部时，禁止RecyclerView滑动            @Override            public void OnReset() &#123;                if (isFix)&#123;                    recyclerView.setNestedScrollingEnabled(false);                    isFix = false;                &#125;            &#125;        &#125;);    &#125;//    获取banner中的数据    private void getBannerData() &#123;        new Thread()&#123;            @Override            public void run() &#123;                super.run();                newsBannerBean = (NewsBannerBean) myHttpRequest.myHttp(&quot;/prod-api/api/rotation/list?pageNum=1&amp;pageSize=8&amp;type=2&quot;,null,NewsBannerBean.class,null,&quot;get&quot;);                if (newsBannerBean != null)&#123;                    for (int i = 0; i &lt; newsBannerBean.getTotal(); i++)&#123;                        newsBannerData.add(&quot;http://&quot; + SoftData.ipPort + newsBannerBean.getRows().get(i).getAdvImg());                    &#125;                &#125;                Message message = Message.obtain();                message.what = 1;                handler.sendMessage(message);            &#125;        &#125;.start();    &#125;//    设置一些监听    private void submit() &#123;        newsTypes[0].setOnClickListener(this);        newsTypes[1].setOnClickListener(this);        newsTypes[2].setOnClickListener(this);        newsTypes[3].setOnClickListener(this);        newsTypes[4].setOnClickListener(this);        newsTypes[5].setOnClickListener(this);    &#125;    @Override    public void onClick(View v) &#123;        switch (v.getId())&#123;//                新闻分类            case R.id.newsType0:                setNewsType(0);                break;            case R.id.newsType1:                setNewsType(1);                break;            case R.id.newsType2:                setNewsType(2);                break;            case R.id.newsType3:                setNewsType(3);                break;            case R.id.newsType4:                setNewsType(4);                break;            case R.id.newsType5:                setNewsType(5);                break;        &#125;    &#125;&#125;
效果预览&ensp;&ensp;&ensp;&ensp;到这里大体上已经非常OK了，还差一些模块的开发

下个博客，城市地铁功能开发Android实战-智慧城市(6)
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android开发手记</tag>
        <tag>智慧城市</tag>
      </tags>
  </entry>
  <entry>
    <title>Android工程结构</title>
    <url>/2021/09/07/Android%E5%B7%A5%E7%A8%8B%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[注意：下列所有目录均在Project目录模式下
.gradle和.idea目录在创建项目时Android Studio自动生成的目录，移动源码时也会删掉这两个文件夹
app目录项目中的代码、资源等，核心目录
app/buildmake project生成的缓存文件
app/libs存放jar包
app/src/放置java代码、软件清单文件、xml布局文件、资源文件等。核心目录其中，app/src/main/res/values/themes.xml中style标签内的parent属性需要做出下面的修改，否则软件内的部分控件属性将不会对修改做出变动Theme.MaterialComponents.DayNight.DarkActionBar修改为Theme.MaterialComponents.DayNight.DarkActionBar.Bridge
gradle目录构建器
gradle/wapper目录存放gradle/wapper
.gitignore文件项目版本控制文件
build.gradle文件项目全局的gradle构建脚本
gradle.properties文件项目全局的gradle配置文件
gradlew和gradle.bat文件执行gradle命令
local.properties文指定安卓sdk路径
setting.gradle指定项目中所有引入的模块
External Libraries第三方库
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Android无障碍开发</title>
    <url>/2023/08/05/Android%E6%97%A0%E9%9A%9C%E7%A2%8D%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[创建无障碍服务&ensp;&ensp;创建MyAccessibilityService类并继承AccessibilityService类，重写其中的onAccessibilityEvent方法和onInterrupt方法
public class MyAccessibilityService extends AccessibilityService &#123;    @Override    public void onAccessibilityEvent(AccessibilityEvent event) &#123;            &#125;    @Override    public void onInterrupt() &#123;    &#125;&#125;
清单声明和权限&ensp;&ensp;在清单文件中注册无障碍服务MyAccessibilityService，使用BIND_ACCESSIBILITY_SERVICE保护无障碍服务，确保只有系统有权限绑定服务，禁止第三方软件绑定
&ensp;&ensp;label属性定义服务在系统中显示的名称&lt;service android:name=&quot;.service.MyAccessibilityService&quot;    android:permission=&quot;android.permission.BIND_ACCESSIBILITY_SERVICE&quot;    android:label=&quot;@string/accessibility_service_label&quot;    android:exported=&quot;false&quot;&gt;&lt;/service&gt;
&ensp;&ensp;添加无障碍服务过滤器
&ensp;&ensp;添加一个&lt;meta-data&gt;元素，用于定义无障碍服务的属性&lt;service android:name=&quot;.service.MyAccessibilityService&quot;    android:permission=&quot;android.permission.BIND_ACCESSIBILITY_SERVICE&quot;    android:label=&quot;@string/accessibility_service_label&quot;    android:exported=&quot;false&quot;&gt;    &lt;intent-filter&gt;        &lt;action android:name=&quot;android.accessibilityservice.AccessibilityService&quot;/&gt;    &lt;/intent-filter&gt;    &lt;meta-data        android:name=&quot;android.accessibilityservice&quot;        android:resource=&quot;@xml/accessibility_service_config&quot; /&gt;&lt;/service&gt;
&ensp;&ensp;无障碍服务定义在xml文件accessibility_service_config中
&ensp;&ensp;其中属性的作用如下

description:   无障碍服务启用页面的详细描述
packageNames:  填入需要支持无障碍服务的包名，可以定义多个，以逗号分隔，留空代表支持所有应用
accessibilityEventTypes: 服务要接收的事件类型，在AccessibilityService中响应,只有声明之后系统才会调用服务类的onAccessibilityEvent
typeViewClicked:  点击事件
typeViewSelected:  View被选择
typeViewScrolled:   滑动事件
typeWindowContentChanged: 窗口内容改变
typeAllMask:   所有事件


accessibilityFlags: 额外声明
accessibilityFeedbackType: 反馈类型
feedbackSpoken 语音反馈
feedbackHaptic 触觉(震动)反馈
feedbackAudible 音频反馈
feedbackVisual 视频反馈
feedbackGeneric 通用反馈
feedbackAllMask 以上所有


notificationTimeout: 同一种事件类型触发的最短时间间隔
canRetrieveWindowContent: 是否允许获取屏幕信息
canPerformGestures: 是否允许手势，自定义xy坐标点击或者自定义手势必须打开
settingsActivity: 允许修改此服务设置的activity

&lt;accessibility-service xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:description=&quot;@string/accessibility_service_description&quot;    android:packageNames=&quot;com.example.android.apis&quot;    android:accessibilityEventTypes=&quot;typeAllMask&quot;    android:accessibilityFlags=&quot;flagDefault&quot;    android:accessibilityFeedbackType=&quot;feedbackAllMask&quot;    android:notificationTimeout=&quot;100&quot;    android:canRetrieveWindowContent=&quot;true&quot;    android:canPerformGestures=&quot;true&quot;    android:settingsActivity=&quot;com.example.android.accessibility.ServiceSettingsActivity&quot;/&gt;
无障碍服务方法onServiceConnected&ensp;&ensp;当系统成功连接到无障碍服务时，会调用此方法。
onAccessibilityEvent&ensp;&ensp;当系统检测到与无障碍服务指定的事件过滤参数匹配的AccessibilityEvent时，会回调此方法
onInterrupt&ensp;&ensp;当系统要中断服务正在提供的反馈（通常是为了响应将焦点移到其他控件等用户操作）时，会调用此方法
onUnbind&ensp;&ensp;当系统将要关闭无障碍服务时，会调用此方法
自动点击点击指定x、y坐标public void simulateClick(float x, float y) &#123;    GestureDescription.Builder gestureBuilder = new GestureDescription.Builder();    Path clickPath = new Path();    clickPath.moveTo(x, y);    gestureBuilder.addStroke(new GestureDescription.StrokeDescription(clickPath, 0, 100));    GestureDescription gesture = gestureBuilder.build();    dispatchGesture(gesture, new GestureResultCallback() &#123;        @Override        public void onCompleted(GestureDescription gestureDescription) &#123;            super.onCompleted(gestureDescription);            // 点击完成后的回调        &#125;        @Override        public void onCancelled(GestureDescription gestureDescription) &#123;            super.onCancelled(gestureDescription);            // 点击取消后的回调        &#125;    &#125;, mHandler);&#125;
自定义手势public void simulateGesture(float fromX, float fromY, float toX, float toY) &#123;    GestureDescription.Builder gestureBuilder = new GestureDescription.Builder();    Path gesturePath = new Path();    gesturePath.moveTo(fromX, fromY); // 启点    gesturePath.lineTo(toX, toY);     // 终点    gestureBuilder.addStroke(new GestureDescription.StrokeDescription(gesturePath, 0, 100));    GestureDescription gesture = gestureBuilder.build();    dispatchGesture(gesture, new GestureResultCallback() &#123;        @Override        public void onCompleted(GestureDescription gestureDescription) &#123;            super.onCompleted(gestureDescription);            // 手势完成后的回调        &#125;        @Override        public void onCancelled(GestureDescription gestureDescription) &#123;            super.onCancelled(gestureDescription);            // 手势取消后的回调        &#125;    &#125;, mHandler);&#125;
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android开发手记</tag>
      </tags>
  </entry>
  <entry>
    <title>Android常用权限</title>
    <url>/2021/09/09/Android%E5%B8%B8%E7%94%A8%E6%9D%83%E9%99%90/</url>
    <content><![CDATA[详细参考：https://blog.csdn.net/NakajimaFN/article/details/126700494
访问网络android.permission.INTERNET，访问网络连接，可能产生GPRS流量android.permission.CHANGE_WIFI_STATE  Wifi 改变状态android.permission.ACCESS_WIFI_STATE WiFi 状态android.permission.ACCESS_NETWORK_STATE 网络状态录制视频android.permission.CAMERAandroid.permission.RECORD_AUDIOandroid.permission.WRITE_EXTERNAL_STORAGE底层访问权限android.permission.CWJ_GROUP，允许CWJ账户组访问底层信息手机优化大师扩展权限android.permission.CELL_PHONE_MASTER_EX，手机优化大师扩展权限控制定位更新android.permission.CONTROL_LOCATION_UPDATES，允许获得移动网络定位信息改变删除缓存文件android.permission.DELETE_CACHE_FILES，允许应用删除缓存文件删除应用android.permission.DELETE_PACKAGES，允许程序删除应用电源管理android.permission.DEVICE_POWER，允许访问底层电源管理应用诊断android.permission.DIAGNOSTIC，允许程序到RW到诊断资源禁用键盘锁android.permission.DISABLE_KEYGUARD，允许程序禁用键盘锁转存系统信息android.permission.DUMP，允许程序获取系统dump信息从系统服务状态栏控制android.permission.EXPAND_STATUS_BAR，允许程序扩展或收缩状态栏工厂测试模式android.permission.FACTORY_TEST，允许程序运行工厂测试模式使用闪光灯android.permission.FLASHLIGHT，允许访问闪光灯强制后退android.permission.FORCE_BACK，允许程序强制使用back后退按键，无论Activity是否在顶层访问账户Gmail列表android.permission.GET_ACCOUNTS，访问GMail账户列表获取应用大小android.permission.GET_PACKAGE_SIZE，获取应用的文件大小获取任务信息android.permission.GET_TASKS，允许程序获取当前或最近运行的应用允许全局搜索android.permission.GLOBAL_SEARCH，允许程序使用全局搜索功能硬件测试android.permission.HARDWARE_TEST，访问硬件辅助设备，用于硬件测试注射事件android.permission.INJECT_EVENTS，允许访问本程序的底层事件，获取按键、轨迹球的事件流安装定位提供android.permission.INSTALL_LOCATION_PROVIDER，安装定位提供安装应用程序android.permission.INSTALL_PACKAGES，允许程序安装应用内部系统窗口android.permission.INTERNAL_SYSTEM_WINDOW，允许程序打开内部窗口，不对第三方应用程序开放此权限结束后台进程android.permission.KILL_BACKGROUND_PROCESSES，允许程序调用killBackgroundProcesses(String).方法结束后台进程管理账户android.permission.MANAGE_ACCOUNTS，允许程序管理AccountManager中的账户列表管理程序引用android.permission.MANAGE_APP_TOKENS，管理创建、摧毁、Z轴顺序，仅用于系统高级权限android.permission.MTWEAK_USER，允许mTweak用户访问高级系统权限社区权限android.permission.MTWEAK_FORUM，允许使用mTweak社区权限软格式化android.permission.MASTER_CLEAR，允许程序执行软格式化，删除系统配置信息修改声音设置android.permission.MODIFY_AUDIO_SETTINGS，修改声音设置信息修改电话状态android.permission.MODIFY_PHONE_STATE，修改电话状态，如飞行模式，但不包含替换系统拨号器界面格式化文件系统android.permission.MOUNT_FORMAT_FILESYSTEMS，格式化可移动文件系统，比如格式化清空SD卡挂载文件系统android.permission.MOUNT_UNMOUNT_FILESYSTEMS，挂载、反挂载外部文件系统允许NFC通讯android.permission.NFC，允许程序执行NFC近距离通讯操作，用于移动支持永久Activityandroid.permission.PERSISTENT_ACTIVITY，创建一个永久的Activity，该功能标记为将来将被移除处理拨出电话android.permission.PROCESS_OUTGOING_CALLS，允许程序监视，修改或放弃播出电话读取日程提醒android.permission.READ_CALENDAR，允许程序读取用户的日程信息读取联系人android.permission.READ_CONTACTS，允许应用访问联系人通讯录信息屏幕截图android.permission.READ_FRAME_BUFFER，读取帧缓存用于屏幕截图读取收藏夹和历史记录com.android.browser.permission.READ_HISTORY_BOOKMARKS，读取浏览器收藏夹和历史记录读取输入状态android.permission.READ_INPUT_STATE，读取当前键的输入状态，仅用于系统读取系统日志android.permission.READ_LOGS，读取系统底层日志读取电话状态android.permission.READ_PHONE_STATE，访问电话状态读取短信内容android.permission.READ_SMS，读取短信内容读取同步设置android.permission.READ_SYNC_SETTINGS，读取同步设置，读取Google在线同步设置读取同步状态android.permission.READ_SYNC_STATS，读取同步状态，获得Google在线同步状态重启设备android.permission.REBOOT，允许程序重新启动设备开机自动允许android.permission.RECEIVE_BOOT_COMPLETED，允许程序开机自动运行接收彩信android.permission.RECEIVE_MMS，接收彩信接收短信android.permission.RECEIVE_SMS，接收短信接收Wap Pushandroid.permission.RECEIVE_WAP_PUSH，接收WAP PUSH信息录音android.permission.RECORD_AUDIO，录制声音通过手机或耳机的麦克排序系统任务android.permission.REORDER_TASKS，重新排序系统Z轴运行中的任务结束系统任务android.permission.RESTART_PACKAGES，结束任务通过restartPackage(String)方法，该方式将在外来放弃发送短信android.permission.SEND_SMS，发送短信设置Activity观察其android.permission.SET_ACTIVITY_WATCHER，设置Activity观察器一般用于monkey测试设置闹铃提醒com.android.alarm.permission.SET_ALARM，设置闹铃提醒设置总是退出android.permission.SET_ALWAYS_FINISH，设置程序在后台是否总是退出设置动画缩放android.permission.SET_ANIMATION_SCALE，设置全局动画缩放设置调试程序android.permission.SET_DEBUG_APP，设置调试程序，一般用于开发设置屏幕方向android.permission.SET_ORIENTATION，设置屏幕方向为横屏或标准方式显示，不用于普通应用设置应用参数android.permission.SET_PREFERRED_APPLICATIONS，设置应用的参数，已不再工作具体查看addPackageToPreferred(String)介绍设置进程限制android.permission.SET_PROCESS_LIMIT，允许程序设置最大的进程数量的限制设置系统时间android.permission.SET_TIME，设置系统时间设置系统时区android.permission.SET_TIME_ZONE，设置系统时区设置桌面壁纸android.permission.SET_WALLPAPER，设置桌面壁纸设置壁纸建议android.permission.SET_WALLPAPER_HINTS，设置壁纸建议发送永久进程信号android.permission.SIGNAL_PERSISTENT_PROCESSES，发送一个永久的进程信号状态栏控制android.permission.STATUS_BAR，允许程序打开、关闭、禁用状态栏访问订阅内容android.permission.SUBSCRIBED_FEEDS_READ，访问订阅信息的数据库写入订阅内容android.permission.SUBSCRIBED_FEEDS_WRITE，写入或修改订阅内容的数据库显示系统窗口android.permission.SYSTEM_ALERT_WINDOW，显示系统窗口更新设备状态android.permission.UPDATE_DEVICE_STATS，更新设备状态使用证书android.permission.USE_CREDENTIALS，允许程序请求验证从AccountManager使用SIP视频android.permission.USE_SIP，允许程序使用SIP视频服务使用振动android.permission.VIBRATE，允许振动唤醒锁定android.permission.WAKE_LOCK，允许程序在手机屏幕关闭后后台进程仍然运行写入GPRS接入点设置android.permission.WRITE_APN_SETTINGS，写入网络GPRS接入点设置写入日程提醒android.permission.WRITE_CALENDAR，写入日程，但不可读取写入联系人android.permission.WRITE_CONTACTS，写入联系人，但不可读取写入外部存储android.permission.WRITE_EXTERNAL_STORAGE，允许程序写入外部存储，如SD卡上写文件写入Google地图数据android.permission.WRITE_GSERVICES，允许程序写入Google Map服务数据写入收藏夹和历史记录com.android.browser.permission.WRITE_HISTORY_BOOKMARKS，写入浏览器历史记录或收藏夹，但不可读取读写系统敏感设置android.permission.WRITE_SECURE_SETTINGS，允许程序读写系统安全敏感的设置项读写系统设置android.permission.WRITE_SETTINGS，允许读写系统设置项编写短信android.permission.WRITE_SMS，允许编写短信写入在线同步设置android.permission.WRITE_SYNC_SETTINGS，写入Google在线同步设置
访问登记属性android.permission.ACCESS_CHECKIN_PROPERTIES ，读取或写入登记check-in数据库属性表的权限获取错略位置android.permission.ACCESS_COARSE_LOCATION，通过WiFi或移动基站的方式获取用户错略的经纬度信息，定位精度大概误差在30~1500米获取精确位置android.permission.ACCESS_FINE_LOCATION，通过GPS芯片接收卫星的定位信息，定位精度达10米以内访问定位额外命令android.permission.ACCESS_LOCATION_EXTRA_COMMANDS，允许程序访问额外的定位提供者指令GPS定位获取模拟定位信息android.permission.ACCESS_MOCK_LOCATION，获取模拟定位信息，一般用于帮助开发者调试应用获取网络状态
android.permission.ACCESS_NETWORK_STATE，获取网络信息状态，如当前的网络连接是否有效访问Surface Flingerandroid.permission.ACCESS_SURFACE_FLINGER，Android平台上底层的图形显示支持，一般用于游戏或照相机预览界面和底层模式的屏幕截图获取WiFi状态android.permission.ACCESS_WIFI_STATE，获取当前WiFi接入的状态以及WLAN热点的信息账户管理android.permission.ACCOUNT_MANAGER，获取账户验证信息，主要为GMail账户信息，只有系统级进程才能访问的权限验证账户android.permission.AUTHENTICATE_ACCOUNTS，允许一个程序通过账户验证方式访问账户管理ACCOUNT_MANAGER相关信息电量统计android.permission.BATTERY_STATS，获取电池电量统计信息绑定小插件android.permission.BIND_APPWIDGET，允许一个程序告诉appWidget服务需要访问小插件的数据库，只有非常少的应用才用到此权限绑定设备管理android.permission.BIND_DEVICE_ADMIN，请求系统管理员接收者receiver，只有系统才能使用绑定输入法android.permission.BIND_INPUT_METHOD ，请求InputMethodService服务，只有系统才能使用绑定RemoteViewandroid.permission.BIND_REMOTEVIEWS，必须通过RemoteViewsService服务来请求，只有系统才能用绑定壁纸android.permission.BIND_WALLPAPER，必须通过WallpaperService服务来请求，只有系统才能用使用蓝牙android.permission.BLUETOOTH，允许程序连接配对过的蓝牙设备蓝牙管理android.permission.BLUETOOTH_ADMIN，允许程序进行发现和配对新的蓝牙设备变成砖头android.permission.BRICK，能够禁用手机，非常危险，顾名思义就是让手机变成砖头应用删除时广播android.permission.BROADCAST_PACKAGE_REMOVED，当一个应用在删除时触发一个广播收到短信时广播android.permission.BROADCAST_SMS，当收到短信时触发一个广播连续广播android.permission.BROADCAST_STICKY，允许一个程序收到广播后快速收到下一个广播WAP PUSH广播android.permission.BROADCAST_WAP_PUSH，WAP PUSH服务收到后触发一个广播拨打电话android.permission.CALL_PHONE，允许程序从非系统拨号器里输入电话号码通话权限android.permission.CALL_PRIVILEGED，允许程序拨打电话，替换系统的拨号器界面拍照权限android.permission.CAMERA，允许访问摄像头进行拍照改变组件状态android.permission.CHANGE_COMPONENT_ENABLED_STATE，改变组件是否启用状态改变配置android.permission.CHANGE_CONFIGURATION，允许当前应用改变配置，如定位改变网络状态android.permission.CHANGE_NETWORK_STATE，改变网络状态如是否能联网改变WiFi多播状态android.permission.CHANGE_WIFI_MULTICAST_STATE，改变WiFi多播状态改变WiFi状态android.permission.CHANGE_WIFI_STATE，改变WiFi状态清除应用缓存android.permission.CLEAR_APP_CACHE，清除应用缓存清除用户数据android.permission.CLEAR_APP_USER_DATA，清除应用的用户数据
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>频繁查阅</tag>
      </tags>
  </entry>
  <entry>
    <title>Android实战-智慧城市</title>
    <url>/2021/10/30/Android%E5%AE%9E%E6%88%98-%E6%99%BA%E6%85%A7%E5%9F%8E%E5%B8%82/</url>
    <content><![CDATA[创建项目创建项目&ensp;&ensp;&ensp;&ensp;创建一个新项目，命名为“智慧城市”，包名com.SmartCity

引入阿里云仓库&ensp;&ensp;&ensp;&ensp;在build.gradle中添加阿里云云效maven的依赖&ensp;&ensp;&ensp;&ensp;(具体配置方式可以参考在Android项目中使用阿里云maven)

添加第三方依赖包&ensp;&ensp;&ensp;&ensp;把所需要用到的第三方工具的依赖添加进app的build.gradle文件中，因为我们事先引入过阿里云仓库，所以这些第三方依赖包会从仓库中下载
添加权限&ensp;&ensp;&ensp;&ensp;在清单文件AndroidManifest.xml中添加权限，先添加上，暂时不做动态申请&lt;!--    网络权限--&gt;    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt;&lt;!--    外部读取权限--&gt;    &lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot;/&gt;&lt;!--    外部写入权限--&gt;    &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;/&gt;
允许http请求&ensp;&ensp;&ensp;&ensp;在Android 9及以上的版本中，不支持http访问，在xml文件夹中创建一个新文件”http_request.xml”&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;network-security-config&gt;    &lt;base-config cleartextTrafficPermitted=&quot;true&quot; /&gt;&lt;/network-security-config&gt;
&ensp;&ensp;&ensp;&ensp;在清单文件的application标签中添加&lt;application    ...	...    android:networkSecurityConfig=&quot;@xml/http_request&quot;	...	...&gt;
修改默认样式&ensp;&ensp;&ensp;&ensp;创建安卓项目后的软件样式并不如人意，在values → themes → Base application theme中的parent值修改掉
软件设计启动页&ensp;&ensp;&ensp;&ensp;软件的第一页，在MainActivity中使用SharedPreferences轻量储存库读取本地是否已经存有账号、密码和ip端口，如果有，则将它存入SoftData.java类的类变量中方便其他页面使用，如果没有则使其值为noValue，等待这些数据加载完毕后即进入下一个页面WelcomActivity
静态全局变量库&ensp;&ensp;&ensp;&ensp;userName和password用来储存账号和密码，ipPort储存ip端口，token会在用户登录后记录用户的token值&ensp;&ensp;&ensp;&ensp;SoftData.javapackage com.SmartCity;public class SoftData &#123;    public static String userName;//用户名    public static String password;//用户密码    public static String ipPort;//ip端口    public static String token;//用户登录后的token值&#125;
首页程序设计&ensp;&ensp;&ensp;&ensp;在MainActivity中读取账号、密码、ip端口等，读取完毕后跳转至下一页WelcomActivity&ensp;&ensp;&ensp;&ensp;MainActivity.javapackage com.SmartCity;import androidx.appcompat.app.AppCompatActivity;import android.content.Intent;import android.content.SharedPreferences;import android.os.Bundle;import com.SmartCity.Welcom.WelcomActivity;public class MainActivity extends AppCompatActivity &#123;    private SharedPreferences sharedPreferences;//本地轻量储存库    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        init();//初始化界面        getData();//获取数据        startNextActivity();//启动下个页面    &#125;//    初始化界面    private void init() &#123;        sharedPreferences = getSharedPreferences(&quot;SoftData&quot;,MODE_PRIVATE);    &#125;    private void getData() &#123;//        读取本地账号和密码并赋值SoftData类的类变量，如果没有则返回noValue        SoftData.userName = sharedPreferences.getString(&quot;userName&quot;,&quot;noValue&quot;);        SoftData.password = sharedPreferences.getString(&quot;password&quot;,&quot;noValue&quot;);        SoftData.ipPort = sharedPreferences.getString(&quot;ipPort&quot;,&quot;noValue&quot;);//ip端口    &#125;//    启动下个页面    private void startNextActivity()&#123;        Intent intent = new Intent(this, WelcomActivity.class);        startActivity(intent);        finish();    &#125;&#125;
页面布局&ensp;&ensp;&ensp;&ensp;该页不需要展示什么数据，所以布局比较简单&ensp;&ensp;&ensp;&ensp;activity_main.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout android:layout_height=&quot;match_parent&quot;    android:layout_width=&quot;match_parent&quot;    android:orientation=&quot;vertical&quot;    android:gravity=&quot;center&quot;    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;    &lt;ImageView        android:src=&quot;@mipmap/soft_icon&quot;        android:layout_width=&quot;120dp&quot;        android:layout_marginBottom=&quot;20dp&quot;        android:layout_height=&quot;120dp&quot;/&gt;    &lt;TextView        android:text=&quot;智慧城市&quot;        android:textSize=&quot;26sp&quot;        android:textColor=&quot;@color/black&quot;        android:layout_marginBottom=&quot;160dp&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;/&gt;&lt;/LinearLayout&gt;
引导页&ensp;&ensp;&ensp;&ensp;在引导页WelcomActivity中使用了ViewPager2+Fragment的方式实现滑动窗口，当ViewPager2滑动到最后一个item，Fragment中显示“立即体验”和“ip端口设置”两个按钮，对应事件用户登录和设置ip端口，引导页底部显示小圆点，小圆点和引导页对应，点击小圆点可以切换到对应的页面
小圆点背景的实现&ensp;&ensp;&ensp;&ensp;创建一个seletor类型的xml文件，设置其在被选中或不被选中使显示的背景不同，那么就要再创建两个不同色的圆形图片或xml作为它的选项
point_true/false.xml&ensp;&ensp;&ensp;&ensp;在drawable中创建一黑一白两个小圆点，作为小圆点被选中和不被选中的两个背景色
point_selector.xml&ensp;&ensp;&ensp;&ensp;创建一个selector类型xml文件做小圆点的背景，使小圆点被选中和未被选中时展示不同的背景
&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!--把刚刚创建的一黑一白两个背景图添加进来--&gt;&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;    &lt;item android:drawable=&quot;@drawable/point_true&quot; android:state_selected=&quot;true&quot;/&gt;    &lt;item android:drawable=&quot;@drawable/point_false&quot; android:state_selected=&quot;false&quot;/&gt;&lt;/selector&gt;
通用的反序列化对象类&ensp;&ensp;&ensp;&ensp;每个页面都能用的最简单的反序列化对象类&ensp;&ensp;&ensp;&ensp;Bean.javapackage com.SmartCity;//通用的最简单的反序列化对象public class Bean &#123;    private int code;    private String msg;    public int getCode() &#123;        return code;    &#125;    public void setCode(int code) &#123;        this.code = code;    &#125;    public String getMsg() &#123;        return msg;    &#125;    public void setMsg(String msg) &#123;        this.msg = msg;    &#125;&#125;
封装OkHttp&ensp;&ensp;&ensp;&ensp;把用到的OkHttp请求方式封装到MyHttpRequest类中，在该类中自动请求并返回已经反序列化完毕的对象，使用了异步请求+线程等待的方式&ensp;&ensp;&ensp;&ensp;参数说明

url: 请求的地址，只填ip端口的后半部分即可
json: put或post提交的json，get时可以传递一个null
cls: 反序列化对象的class
token: 用户token，不需要token时，则传递null
type: 请求的类型，默认为get，可选post、put和getpackage com.SmartCity;import com.google.gson.Gson;import org.jetbrains.annotations.NotNull;import java.io.IOException;import java.util.concurrent.CountDownLatch;import okhttp3.Call;import okhttp3.Callback;import okhttp3.MediaType;import okhttp3.OkHttpClient;import okhttp3.Request;import okhttp3.RequestBody;import okhttp3.Response;public class MyHttpRequest &#123;    private Gson gson = new Gson();//    url地址，要发送的json字符串，用户token，反序列化对象的class，请求类型(默认get)    public Object myHttp(String url,String json,Class cls,String token,String type)&#123;        final Object[] bean = new Object[]&#123;null&#125;;        CountDownLatch countDownLatch = new CountDownLatch(1);//线程等待        OkHttpClient okHttpClient = new OkHttpClient();        RequestBody requestBody = null;        Request request = null;        Request.Builder builder = new Request.Builder().url(&quot;http://&quot; + SoftData.ipPort + url);//        判断是否为post或get        if (type.equals(&quot;post&quot;))&#123;            requestBody = RequestBody.create(json, MediaType.parse(&quot;application/json&quot;));            builder.post(requestBody);        &#125;        else if (type.equals(&quot;put&quot;))&#123;            requestBody = RequestBody.create(json, MediaType.parse(&quot;application/json&quot;));            builder.put(requestBody);        &#125;//        是否需要添加请求头        if (token != null)&#123;            request = builder.addHeader(&quot;authorization&quot;,token).build();        &#125;        else &#123;            request = builder.build();        &#125;//        请求结果        okHttpClient.newCall(request).enqueue(new Callback() &#123;            @Override            public void onFailure(@NotNull Call call, @NotNull IOException e) &#123;                bean = null;                countDownLatch.countDown();            &#125;            @Override            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException &#123;                if (response.isSuccessful())&#123;//                    反序列化                    bean = gson.fromJson(response.body().string(),cls);                &#125;                else &#123;                    bean = null;                &#125;                countDownLatch.countDown();            &#125;        &#125;);        try &#123;            countDownLatch.await();        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;        return bean;    &#125;&#125;


封装用户注册和用户登录方法&ensp;&ensp;&ensp;&ensp;用户登录和用户注册可能会被多次调用，所以把他们封装到User.java类中方便随时调用，它的主要作用是作为中继，设置登录或注册时的json参数，调用MyHttpRequest发送注册或登录请求package com.SmartCity;import android.util.Log;import com.SmartCity.RegisAndLogin.LoginBean;public class User &#123;    private static final String TAG = &quot;User&quot;;    private MyHttpRequest myHttpRequest = new MyHttpRequest();//    用户登录    public Object Login(String userName,String password)&#123;        String json = &quot;&#123;\n&quot; +                &quot;\&quot;username\&quot;:\&quot;&quot; + userName + &quot;\&quot;,\n&quot; +                &quot;\&quot;password\&quot;:\&quot;&quot; + password + &quot;\&quot;\n&quot; +                &quot;&#125;&quot;;        Log.d(TAG, &quot;Register: \n&quot; + json);        return myHttpRequest.myHttp(&quot;/prod-api/api/login&quot;,json, LoginBean.class,null,&quot;post&quot;);    &#125;//    用户注册    public Object Register(String userName,String nickName,String phonenumber,String password)&#123;        String json = &quot;&#123;\n&quot; +                &quot;\&quot;userName\&quot;: \&quot;&quot; + userName + &quot;\&quot;,\n&quot; +                &quot;\&quot;nickName\&quot;: \&quot;&quot; + nickName + &quot;\&quot;,\n&quot; +                &quot;\&quot;password\&quot;: \&quot;&quot; + password + &quot;\&quot;,\n&quot; +                &quot;\&quot;phonenumber\&quot;: \&quot;&quot; + phonenumber + &quot;\&quot;,\n&quot; +                &quot;\&quot;sex\&quot;: \&quot;0\&quot;\n&quot; +                &quot;&#125;&quot;;        Log.d(TAG, &quot;Register: \n&quot; + json);        return myHttpRequest.myHttp(&quot;/prod-api/api/register&quot;,json,LoginBean.class,null,&quot;post&quot;);    &#125;&#125;
EditText和Button的Style&ensp;&ensp;&ensp;&ensp;创建一个drawable类型xml文件，定义EditText和Button的样式，等下要用到这两个
白色边框透明背景的圆角Button&ensp;&ensp;&ensp;&ensp;创建button_style.xml文件&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;&lt;!--    背景--&gt;    &lt;solid android:color=&quot;#00000000&quot;/&gt;&lt;!--    圆角--&gt;    &lt;corners android:topRightRadius=&quot;10dp&quot;        android:topLeftRadius=&quot;10dp&quot;        android:bottomLeftRadius=&quot;10dp&quot;        android:bottomRightRadius=&quot;10dp&quot;/&gt;&lt;!--    边框--&gt;    &lt;stroke android:width=&quot;2dp&quot; android:color=&quot;@color/white&quot;/&gt;&lt;/shape&gt;
白色背景的圆角EditText&ensp;&ensp;&ensp;&ensp;创建edit_text_style.xml文件&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;    &lt;solid android:color=&quot;@color/white&quot;/&gt;    &lt;corners android:bottomRightRadius=&quot;10dp&quot;        android:topLeftRadius=&quot;10dp&quot;        android:topRightRadius=&quot;10dp&quot;        android:bottomLeftRadius=&quot;10dp&quot;/&gt;    &lt;stroke android:width=&quot;1dp&quot; android:color=&quot;@android:color/darker_gray&quot;/&gt;&lt;/shape&gt;
ip端口设置页面&ensp;&ensp;&ensp;&ensp;进入ViewPager2的最后一个item后，点击右上角的ip端口设置则进入ip端口设置页，用于设置ip端口的值，在该页面中用到了上面自定义的Button和EditText样式
页面布局&ensp;&ensp;&ensp;&ensp;activity_ip_port.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout android:layout_height=&quot;match_parent&quot;    android:layout_width=&quot;match_parent&quot;    android:orientation=&quot;vertical&quot;    android:gravity=&quot;center_horizontal&quot;    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;&lt;!--    Title--&gt;    &lt;LinearLayout        android:background=&quot;@android:color/holo_blue_dark&quot;        android:orientation=&quot;horizontal&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;58dp&quot;&gt;        &lt;LinearLayout            android:onClick=&quot;finishActivity&quot;            android:gravity=&quot;center&quot;            android:layout_width=&quot;58dp&quot;            android:layout_height=&quot;58dp&quot;&gt;            &lt;ImageView                android:src=&quot;@mipmap/back&quot;                android:layout_width=&quot;20dp&quot;                android:layout_height=&quot;20dp&quot;/&gt;        &lt;/LinearLayout&gt;        &lt;LinearLayout            android:gravity=&quot;center&quot;            android:layout_weight=&quot;1&quot;            android:layout_width=&quot;0dp&quot;            android:layout_height=&quot;match_parent&quot;&gt;            &lt;TextView                android:text=&quot;设置端口&quot;                android:textStyle=&quot;bold&quot;                android:textSize=&quot;18sp&quot;                android:textColor=&quot;@color/black&quot;                android:layout_width=&quot;wrap_content&quot;                android:layout_height=&quot;wrap_content&quot;/&gt;        &lt;/LinearLayout&gt;        &lt;LinearLayout            android:gravity=&quot;center&quot;            android:layout_width=&quot;58dp&quot;            android:layout_height=&quot;58dp&quot;&gt;        &lt;/LinearLayout&gt;    &lt;/LinearLayout&gt;&lt;!--    Content--&gt;    &lt;LinearLayout        android:orientation=&quot;vertical&quot;        android:gravity=&quot;center_horizontal&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;match_parent&quot;&gt;        &lt;EditText            android:background=&quot;@drawable/edit_text_style&quot;            android:layout_marginTop=&quot;68dp&quot;            android:hint=&quot;请输入ip端口&quot;            android:layout_marginLeft=&quot;20dp&quot;            android:layout_marginRight=&quot;20dp&quot;            android:lines=&quot;1&quot;            android:inputType=&quot;text&quot;            android:gravity=&quot;center&quot;            android:id=&quot;@+id/editText&quot;            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;48dp&quot;/&gt;        &lt;Button            android:background=&quot;@drawable/edit_text_style&quot;            android:text=&quot;保存端口&quot;            android:textColor=&quot;@color/black&quot;            android:textSize=&quot;18sp&quot;            android:id=&quot;@+id/button&quot;            android:layout_marginTop=&quot;28dp&quot;            android:layout_marginLeft=&quot;30dp&quot;            android:layout_marginRight=&quot;30dp&quot;            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;wrap_content&quot;/&gt;    &lt;/LinearLayout&gt;&lt;/LinearLayout&gt;
程序设计&ensp;&ensp;&ensp;&ensp;这一页相对比较简单，布局也简单，操作也简单，就是读取写入一下本地轻量库中的ip端口就好了&ensp;&ensp;&ensp;&ensp;IpPortActivity.javapackage com.SmartCity.Welcom;import androidx.appcompat.app.AppCompatActivity;import android.content.SharedPreferences;import android.os.Bundle;import android.text.TextUtils;import android.view.View;import android.widget.Button;import android.widget.EditText;import android.widget.Toast;import com.SmartCity.R;import com.SmartCity.SoftData;public class IpPortActivity extends AppCompatActivity &#123;    private EditText editText;//IP端口的输入框    private Button button;//保存按钮    private SharedPreferences sharedPreferences;//本地轻量库    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_ip_port);        init();//初始化页面        submit();//设置监听事件    &#125;    private void submit() &#123;        button.setOnClickListener(new View.OnClickListener() &#123;            @Override            public void onClick(View v) &#123;                String string = editText.getText().toString();//                输入是否不为空                if (!TextUtils.isEmpty(string))&#123;//                    把ip端口的值储存到本地                    SharedPreferences.Editor editor = sharedPreferences.edit();                    editor.putString(&quot;ipPort&quot;,string);                    editor.commit();                    SoftData.ipPort = string;//添加到SoftData类中                    Toast.makeText(IpPortActivity.this,&quot;IP端口设置成功&quot;,Toast.LENGTH_SHORT).show();                &#125;                else &#123;                    Toast.makeText(IpPortActivity.this,&quot;IP端口不可为空&quot;,Toast.LENGTH_SHORT).show();                &#125;            &#125;        &#125;);    &#125;    private void init() &#123;        editText = findViewById(R.id.editText);        button = findViewById(R.id.button);        sharedPreferences = getSharedPreferences(&quot;SoftData&quot;,MODE_PRIVATE);//        读取SoftData类中是否存在ip端口，如果有则在编辑框中显示端口        if (!SoftData.ipPort.equals(&quot;noValue&quot;))&#123;            editText.setText(SoftData.ipPort);        &#125;    &#125;//    左上角的关闭页面    public void finishActivity(View view) &#123; finish(); &#125;&#125;
创建Fragment作为ViewPager2的item&ensp;&ensp;&ensp;&ensp;创建一个Fragment页面，该页面作为ViewPager2的item显示引导页轮播图的图片，当ViewPager2滑动到最后一个item时，该Fragment页面显示按钮
item的布局&ensp;&ensp;&ensp;&ensp;fragment_welcom.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;RelativeLayout android:layout_height=&quot;match_parent&quot;    android:layout_width=&quot;match_parent&quot;    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;    &lt;ImageView        android:id=&quot;@+id/imageView&quot;        android:scaleType=&quot;fitXY&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;match_parent&quot;/&gt;    &lt;TextView        android:text=&quot;IP端口设置&quot;        android:id=&quot;@+id/button2&quot;        android:textStyle=&quot;bold&quot;        android:visibility=&quot;gone&quot;        android:textSize=&quot;18sp&quot;        android:textColor=&quot;@android:color/holo_blue_light&quot;        android:layout_alignParentRight=&quot;true&quot;        android:layout_marginTop=&quot;20dp&quot;        android:layout_marginRight=&quot;20dp&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;/&gt;    &lt;Button        android:id=&quot;@+id/button1&quot;        android:textColor=&quot;@color/white&quot;        android:textSize=&quot;18sp&quot;        android:visibility=&quot;gone&quot;        android:layout_alignParentBottom=&quot;true&quot;        android:layout_centerHorizontal=&quot;true&quot;        android:layout_marginBottom=&quot;80dp&quot;        android:text=&quot;立即体验&quot;        android:textStyle=&quot;bold&quot;        android:background=&quot;@drawable/button_style&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;/&gt;&lt;/RelativeLayout&gt;
item的程序设计&ensp;&ensp;&ensp;&ensp;WelcomFragment.java作为前几页时没什么故事，相比而言最后一页可谓是沧桑，每一页展示其对应的轮播图，当最后一页时，显示“立即体验”和“IP端口设置”按钮

立即体验按钮: 读取SoftData中的ipPort(ip端口)，若ipPort值为”noValue”，说明并没有设置过ip端口，跳转到ip端口设置界面，若有ip端口则读取SoftData中的userName和password，若没有则跳转到用户登录，有就登录，登录成功就跳转到主页
ip端口设置按钮: 跳转到ip端口设置界面

package com.SmartCity.Welcom;import android.content.Intent;import android.os.Bundle;import androidx.annotation.NonNull;import androidx.fragment.app.Fragment;import android.os.Handler;import android.os.Looper;import android.os.Message;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import android.widget.Button;import android.widget.ImageView;import android.widget.TextView;import android.widget.Toast;import com.SmartCity.Home.HomeActivity;import com.SmartCity.IpPortActivity;import com.SmartCity.R;import com.SmartCity.RegisAndLogin.LoginActivity;import com.SmartCity.RegisAndLogin.LoginBean;import com.SmartCity.SoftData;import com.SmartCity.User;public class WelcomFragment extends Fragment implements View.OnClickListener &#123;    private View viewRoot;    private int itemBack,position;//构造器中传入的图片资源,item定位    private ImageView imageView;//背景    private Button button1;//立即体验    private TextView button2;//ip端口设置    private Intent intent = new Intent();//跳转界面    private User user = new User();//用户注册登录封装类    private LoginBean loginBean;//反序列化对象    private Handler handler;//handler通信    public WelcomFragment(int itemBack,int position) &#123;        this.itemBack = itemBack;//传入图片的id        this.position = position;//传入当前页面的position    &#125;    @Override    public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); &#125;    @Override    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123;        if (viewRoot == null)&#123; viewRoot = inflater.inflate(R.layout.fragment_welcom, container, false); &#125;        myHandler();//handler线程通信        init();//初始化界面        setBack();//设置图片背景        setButton();//设置按钮显示        return viewRoot;    &#125;//    handler线程通信    private void myHandler() &#123;        handler = new Handler(Looper.getMainLooper())&#123;            @Override            public void handleMessage(@NonNull Message msg) &#123;                super.handleMessage(msg);                if (msg.what == 1)&#123;                    userLogin();//自动登录                &#125;            &#125;        &#125;;    &#125;//    初始化界面    private void init() &#123;        imageView = viewRoot.findViewById(R.id.imageView);        button1 = viewRoot.findViewById(R.id.button1);        button2 = viewRoot.findViewById(R.id.button2);    &#125;//    设置背景图    private void setBack() &#123; imageView.setImageResource(itemBack); &#125;//    如果是最后一页,设置按钮显示,并设置按钮事件    private void setButton() &#123;        if (position == 4)&#123;            button1.setVisibility(View.VISIBLE);            button2.setVisibility(View.VISIBLE);        &#125;        button1.setOnClickListener(this);        button2.setOnClickListener(this);    &#125;//    自动登录，当本地储存有账号密码，并异步请求成功时在handler中被调用    private void userLogin() &#123;//        登陆成功跳转到主页面        if (loginBean != null &amp;&amp; loginBean.getCode() == 200)&#123;            Toast.makeText(getContext(),&quot;自动登录成功&quot;,Toast.LENGTH_SHORT).show();            SoftData.token = loginBean.getToken();            intent.setClass(getContext(), HomeActivity.class);            startActivity(intent);            getActivity().finish();        &#125;        else &#123;//            自动登录失败,则跳转到手动登录页面            Toast.makeText(getContext(),&quot;请求失败,试试手动登录吧&quot;,Toast.LENGTH_SHORT).show();            intent.setClass(getContext(), LoginActivity.class);            startActivity(intent);        &#125;    &#125;    @Override    public void onClick(View v) &#123;        switch (v.getId())&#123;            case R.id.button1://                &quot;立即体验&quot;按钮响应的事件                startNextActivity();                break;            case R.id.button2://                跳转到ip端口设置界面                startIpPortActivity();                break;        &#125;    &#125;//    &quot;立即体验&quot;按钮响应的事件    private void startNextActivity() &#123;        if (SoftData.ipPort.equals(&quot;noValue&quot;))&#123;//            跳转到ip端口设置界面            Toast.makeText(getContext(),&quot;请先设置ip端口&quot;,Toast.LENGTH_SHORT).show();            startIpPortActivity();//跳转到ip端口设置页面        &#125;//        根据本地账号密码储存情况,确定手动登录还是自动登录        else if (SoftData.userName.equals(&quot;noValue&quot;) &amp;&amp; SoftData.password.equals(&quot;noValue&quot;))&#123;            Toast.makeText(getContext(),&quot;请先登录&quot;,Toast.LENGTH_SHORT).show();            intent.setClass(getContext(), LoginActivity.class);            startActivity(intent);//跳转到用户登录        &#125;//        调用自动登录方法,返回反序列化对象后向handler发送消息        else &#123;            new Thread()&#123;                @Override                public void run() &#123;                    super.run();                    loginBean = (LoginBean) user.Login(SoftData.userName,SoftData.password);                    Message message = new Message();                    message.what = 1;                    handler.sendMessage(message);                &#125;            &#125;.start();        &#125;    &#125;//    跳转到ip端口设置页面    private void startIpPortActivity() &#123;        intent.setClass(getContext(), IpPortActivity.class);        startActivity(intent);    &#125;&#125;
ViewPager2的适配器&ensp;&ensp;&ensp;&ensp;创建一个ViewPagerAdapter.java类作为ViewPager2控件的适配器，该类继承了FragmentStateAdapter类package com.SmartCity.Welcom;import androidx.annotation.NonNull;import androidx.fragment.app.Fragment;import androidx.fragment.app.FragmentManager;import androidx.lifecycle.Lifecycle;import androidx.viewpager2.adapter.FragmentStateAdapter;import java.util.List;public class ViewPagerAdapter extends FragmentStateAdapter &#123;    private List&lt;Fragment&gt; fragments;//    构造器中参数传入fragment管理类、lifecycle、和fragment的集合    public ViewPagerAdapter(@NonNull FragmentManager fragmentManager, @NonNull Lifecycle lifecycle, List&lt;Fragment&gt; fragments) &#123;        super(fragmentManager, lifecycle);        this.fragments = fragments;    &#125;    @NonNull    @Override//    创建Fragment    public Fragment createFragment(int position) &#123;        return fragments.get(position);    &#125;    @Override//    获取页面总数    public int getItemCount() &#123;        return fragments.size();    &#125;&#125;
WelcomActivity中实现&ensp;&ensp;&ensp;&ensp;在WelcomActivity中将上面设置的适配器、Fragment等串联，实现引导页滑动轮播、底部小圆点根据轮播位置变化、点击小圆点轮播图改变
页面布局&ensp;&ensp;&ensp;&ensp;activity_welcom.xml中除了一个ViewPager2和五个小点，真的没什么了&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;RelativeLayout android:layout_height=&quot;match_parent&quot;    android:layout_width=&quot;match_parent&quot;    android:orientation=&quot;vertical&quot;    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;&lt;!--    滑动窗体--&gt;    &lt;androidx.viewpager2.widget.ViewPager2        android:id=&quot;@+id/viewPager2&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;match_parent&quot;/&gt;&lt;!--    5个小点--&gt;    &lt;LinearLayout        android:gravity=&quot;center&quot;        android:layout_alignParentBottom=&quot;true&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;100dp&quot;&gt;        &lt;LinearLayout            android:id=&quot;@+id/point0&quot;            android:orientation=&quot;vertical&quot;            android:background=&quot;@drawable/point_selector&quot;            android:layout_marginLeft=&quot;10dp&quot;            android:layout_marginRight=&quot;10dp&quot;            android:layout_width=&quot;10dp&quot;            android:layout_height=&quot;10dp&quot;/&gt;        &lt;LinearLayout            android:id=&quot;@+id/point1&quot;            android:orientation=&quot;vertical&quot;            android:background=&quot;@drawable/point_selector&quot;            android:layout_marginLeft=&quot;10dp&quot;            android:layout_marginRight=&quot;10dp&quot;            android:layout_width=&quot;10dp&quot;            android:layout_height=&quot;10dp&quot;/&gt;        &lt;LinearLayout            android:id=&quot;@+id/point2&quot;            android:orientation=&quot;vertical&quot;            android:background=&quot;@drawable/point_selector&quot;            android:layout_marginLeft=&quot;10dp&quot;            android:layout_marginRight=&quot;10dp&quot;            android:layout_width=&quot;10dp&quot;            android:layout_height=&quot;10dp&quot;/&gt;        &lt;LinearLayout            android:id=&quot;@+id/point3&quot;            android:orientation=&quot;vertical&quot;            android:background=&quot;@drawable/point_selector&quot;            android:layout_marginLeft=&quot;10dp&quot;            android:layout_marginRight=&quot;10dp&quot;            android:layout_width=&quot;10dp&quot;            android:layout_height=&quot;10dp&quot;/&gt;        &lt;LinearLayout            android:id=&quot;@+id/point4&quot;            android:orientation=&quot;vertical&quot;            android:background=&quot;@drawable/point_selector&quot;            android:layout_marginLeft=&quot;10dp&quot;            android:layout_marginRight=&quot;10dp&quot;            android:layout_width=&quot;10dp&quot;            android:layout_height=&quot;10dp&quot;/&gt;    &lt;/LinearLayout&gt;&lt;/RelativeLayout&gt;
程序设计&ensp;&ensp;&ensp;&ensp;这里有个注意点，ViewPager2的滑动监听使用注册(register)的方式添加viewPager2.registerOnPageChangeCallback()，然后重写它的onPageSelected()方法，会在页面滑动切换结束后回调&ensp;&ensp;&ensp;&ensp;WelcomActivity.javapackage com.SmartCity.Welcom;import androidx.appcompat.app.AppCompatActivity;import androidx.fragment.app.Fragment;import androidx.viewpager2.widget.ViewPager2;import android.os.Bundle;import android.view.View;import android.widget.LinearLayout;import com.SmartCity.R;import java.util.ArrayList;import java.util.List;public class WelcomActivity extends AppCompatActivity implements View.OnClickListener &#123;    private LinearLayout[] points = new LinearLayout[5];//储存5个小点    private LinearLayout point;//储存上一个小圆点    private ViewPager2 viewPager2;//滑动窗体    private List&lt;Fragment&gt; fragments;//储存ViewPager中显示的Fragment    public static WelcomActivity welcomActivity;//使其他页面调用    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_welcom);        init();//初始化界面        submit();//设置监听        setViewPager();//设置ViewPager的背景    &#125;    private void init() &#123;          //五个小圆点        points[0] = findViewById(R.id.point0);        points[1] = findViewById(R.id.point1);        points[2] = findViewById(R.id.point2);        points[3] = findViewById(R.id.point3);        points[4] = findViewById(R.id.point4);        viewPager2 = findViewById(R.id.viewPager2);        fragments = new ArrayList&lt;&gt;();//fragment页面储存的集合        welcomActivity = WelcomActivity.this;//使其它类中可以调用该变量关闭HomeActivity    &#125;    private void submit() &#123;          //给小圆点添加onClick监听        points[0].setOnClickListener(this);        points[1].setOnClickListener(this);        points[2].setOnClickListener(this);        points[3].setOnClickListener(this);        points[4].setOnClickListener(this);//        页面切换完成时回调        viewPager2.registerOnPageChangeCallback(new ViewPager2.OnPageChangeCallback() &#123;            @Override            public void onPageSelected(int position) &#123;                super.onPageSelected(position);                setPoint(position);//设置小圆点            &#125;        &#125;);    &#125;//    设置小圆点的背景色    private void setPoint(int position) &#123;        if (point != null)&#123;            point.setSelected(false);        &#125;        point = points[position];        points[position].setSelected(true);    &#125;    @Override//    点击小圆点时,使ViewPager2切换页面    public void onClick(View v) &#123;        switch (v.getId())&#123;            case R.id.point0:                viewPager2.setCurrentItem(0);                break;            case R.id.point1:                viewPager2.setCurrentItem(1);                break;            case R.id.point2:                viewPager2.setCurrentItem(2);                break;            case R.id.point3:                viewPager2.setCurrentItem(3);                break;            case R.id.point4:                viewPager2.setCurrentItem(4);                break;        &#125;    &#125;    private void setViewPager() &#123;//        创建Fragment作为ViewPager2的item，并按构造函数要求传入当页背景的资源文件和int类型的position        fragments.add(new WelcomFragment(R.mipmap.guide_img1,0));        fragments.add(new WelcomFragment(R.mipmap.guide_img2,1));        fragments.add(new WelcomFragment(R.mipmap.guide_img3,2));        fragments.add(new WelcomFragment(R.mipmap.guide_img4,3));        fragments.add(new WelcomFragment(R.mipmap.guide_img5,4));//        实例化ViewPager2的适配器        ViewPagerAdapter viewPagerAdapter = new ViewPagerAdapter(getSupportFragmentManager(),getLifecycle(),fragments);        viewPager2.setAdapter(viewPagerAdapter);//添加适配器    &#125;&#125;
注册和登录&ensp;&ensp;&ensp;&ensp;用户注册和用户登录，因为已经封装好了注册登录模块，所以这一页实现起来会比较简单
注册登录的反序列化对象&ensp;&ensp;&ensp;&ensp;创建注册登录的反序列化对象LoginBean.javapackage com.SmartCity.RegisAndLogin;public class LoginBean &#123;    private int code;    private String msg;    private String token;    public int getCode() &#123;        return code;    &#125;    public void setCode(int code) &#123;        this.code = code;    &#125;    public String getMsg() &#123;        return msg;    &#125;    public void setMsg(String msg) &#123;        this.msg = msg;    &#125;    public String getToken() &#123;        return token;    &#125;    public void setToken(String token) &#123;        this.token = token;    &#125;&#125;
用户登录页面页面布局&ensp;&ensp;&ensp;&ensp;两个编辑框和按钮都使用了自定义的编辑框的样式&ensp;&ensp;&ensp;&ensp;activity_login.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout android:layout_height=&quot;match_parent&quot;    android:layout_width=&quot;match_parent&quot;    android:orientation=&quot;vertical&quot;    android:gravity=&quot;center_horizontal&quot;    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;    &lt;!--    Title--&gt;    &lt;LinearLayout        android:background=&quot;@android:color/holo_blue_dark&quot;        android:orientation=&quot;horizontal&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;58dp&quot;&gt;        &lt;LinearLayout            android:onClick=&quot;finishActivity&quot;            android:gravity=&quot;center&quot;            android:layout_width=&quot;58dp&quot;            android:layout_height=&quot;58dp&quot;&gt;            &lt;ImageView                android:src=&quot;@mipmap/back&quot;                android:layout_width=&quot;20dp&quot;                android:layout_height=&quot;20dp&quot;/&gt;        &lt;/LinearLayout&gt;        &lt;LinearLayout            android:gravity=&quot;center&quot;            android:layout_weight=&quot;1&quot;            android:layout_width=&quot;0dp&quot;            android:layout_height=&quot;match_parent&quot;&gt;            &lt;TextView                android:text=&quot;用户登录&quot;                android:textStyle=&quot;bold&quot;                android:textSize=&quot;18sp&quot;                android:textColor=&quot;@color/black&quot;                android:layout_width=&quot;wrap_content&quot;                android:layout_height=&quot;wrap_content&quot;/&gt;        &lt;/LinearLayout&gt;        &lt;LinearLayout            android:gravity=&quot;center&quot;            android:layout_width=&quot;58dp&quot;            android:layout_height=&quot;58dp&quot;&gt;        &lt;/LinearLayout&gt;    &lt;/LinearLayout&gt;    &lt;!--    Content--&gt;    &lt;LinearLayout        android:orientation=&quot;vertical&quot;        android:gravity=&quot;center_horizontal&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;match_parent&quot;&gt;        &lt;EditText            android:background=&quot;@drawable/edit_text_style&quot;            android:layout_marginTop=&quot;68dp&quot;            android:hint=&quot;请输入用户名&quot;            android:layout_marginLeft=&quot;20dp&quot;            android:layout_marginRight=&quot;20dp&quot;            android:lines=&quot;1&quot;            android:inputType=&quot;text&quot;            android:gravity=&quot;center&quot;            android:id=&quot;@+id/userName&quot;            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;48dp&quot;/&gt;        &lt;EditText            android:background=&quot;@drawable/edit_text_style&quot;            android:layout_marginTop=&quot;18dp&quot;            android:hint=&quot;请输入密码&quot;            android:layout_marginLeft=&quot;20dp&quot;            android:layout_marginRight=&quot;20dp&quot;            android:lines=&quot;1&quot;            android:inputType=&quot;textPassword&quot;            android:gravity=&quot;center&quot;            android:id=&quot;@+id/password&quot;            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;48dp&quot;/&gt;        &lt;LinearLayout            android:orientation=&quot;horizontal&quot;            android:layout_marginTop=&quot;28dp&quot;            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;wrap_content&quot;&gt;            &lt;Button                android:background=&quot;@drawable/edit_text_style&quot;                android:text=&quot;立即登录&quot;                android:textColor=&quot;@color/black&quot;                android:textSize=&quot;18sp&quot;                android:id=&quot;@+id/login&quot;                android:layout_marginLeft=&quot;20dp&quot;                android:layout_marginRight=&quot;10dp&quot;                android:layout_weight=&quot;1&quot;                android:layout_width=&quot;0dp&quot;                android:layout_height=&quot;wrap_content&quot;/&gt;            &lt;Button                android:background=&quot;@drawable/edit_text_style&quot;                android:text=&quot;注册账号&quot;                android:textColor=&quot;@color/black&quot;                android:textSize=&quot;18sp&quot;                android:id=&quot;@+id/register&quot;                android:layout_marginLeft=&quot;10dp&quot;                android:layout_marginRight=&quot;20dp&quot;                android:layout_weight=&quot;1&quot;                android:layout_width=&quot;0dp&quot;                android:layout_height=&quot;wrap_content&quot;/&gt;        &lt;/LinearLayout&gt;    &lt;/LinearLayout&gt;&lt;/LinearLayout&gt;
程序设计&ensp;&ensp;&ensp;&ensp;点击用户登录时调用封装的用户登录方法，登录失败会提示失败原因，点击注册时跳转到注册页面&ensp;&ensp;&ensp;&ensp;LoginActivity.javapackage com.SmartCity.RegisAndLogin;import androidx.annotation.NonNull;import androidx.appcompat.app.AppCompatActivity;import android.content.Intent;import android.content.SharedPreferences;import android.os.Bundle;import android.os.Handler;import android.os.Looper;import android.os.Message;import android.text.TextUtils;import android.view.View;import android.widget.Button;import android.widget.EditText;import android.widget.Toast;import com.SmartCity.Home.HomeActivity;import com.SmartCity.R;import com.SmartCity.SoftData;import com.SmartCity.User;import com.SmartCity.Welcom.WelcomActivity;public class LoginActivity extends AppCompatActivity implements View.OnClickListener &#123;    private Button login,register; //登录和注册按钮    private EditText userName,password;//账号和密码    private User user = new User();//注册登录的封装类    private LoginBean loginBean;//反序列化对象    private Handler handler;//handler通信    private Intent intent = new Intent();//intent跳转    private SharedPreferences sharedPreferences;//本地轻量库    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_login);        myHandler();//handler通信        init();//初始化界面        submit();//设置监听    &#125;//    handler通信    private void myHandler() &#123;        handler = new Handler(Looper.getMainLooper())&#123;            @Override            public void handleMessage(@NonNull Message msg) &#123;                super.handleMessage(msg);                if (msg.what == 1)&#123;                    startNextActivity();                &#125;            &#125;        &#125;;    &#125;//    初始化界面    private void init() &#123;        login = findViewById(R.id.login);//立即登录按钮        register = findViewById(R.id.register);//注册按钮        userName = findViewById(R.id.userName);//用户名编辑框        password = findViewById(R.id.password);//密码编辑框        sharedPreferences = getSharedPreferences(&quot;SoftData&quot;,MODE_PRIVATE);//本地轻量库    &#125;//    设置监听    private void submit() &#123;        login.setOnClickListener(this);        register.setOnClickListener(this);    &#125;    @Override    public void onClick(View v) &#123;        switch (v.getId())&#123;            case R.id.login:                Login();//输入账号密码后，用户登录                break;            case R.id.register:                Register();//跳转到用户注册                break;        &#125;    &#125;//    输入用户名和密码后，用户登录    private void Login() &#123;        String userNameContent = userName.getText().toString();        String passwordContent = password.getText().toString();//        判断是否为空        if (TextUtils.isEmpty(userNameContent))&#123;            Toast.makeText(this,&quot;请输入用户名&quot;,Toast.LENGTH_SHORT).show();        &#125;        else if (TextUtils.isEmpty(passwordContent))&#123;            Toast.makeText(this,&quot;请输入密码&quot;,Toast.LENGTH_SHORT).show();        &#125;        else if (passwordContent.length() &lt; 6)&#123;            Toast.makeText(this,&quot;密码至少6位&quot;,Toast.LENGTH_SHORT).show();        &#125;        else &#123;            new Thread()&#123;                @Override                public void run() &#123;                    super.run();//                    拿到登录接口的反序列化对象                    loginBean = (LoginBean) user.Login(userNameContent,passwordContent);//                    向handler发送消息                    Message message = Message.obtain();                    message.what = 1;                    handler.sendMessage(message);                &#125;            &#125;.start();        &#125;    &#125;//    请求到登录接口的返回数据后调用    private void startNextActivity() &#123;//        判断请求结果        if (loginBean == null)&#123;            MyToast(&quot;登录失败: 未知原因&quot;);        &#125;        else if (loginBean.getCode() != 200)&#123;            MyToast(&quot;登录失败: &quot; + loginBean.getMsg());        &#125;        else &#123;            MyToast(&quot;登陆成功&quot;);//            请求成功，写入本地轻量库，赋值SoftData.java类中的类变量            SoftData.userName = userName.getText().toString();            SoftData.password = userName.getText().toString();            SoftData.token = loginBean.getToken();            SharedPreferences.Editor editor = sharedPreferences.edit();            editor.putString(&quot;userName&quot;,userName.getText().toString());            editor.putString(&quot;password&quot;,password.getText().toString());            editor.commit();//            跳转到主页面            intent.setClass(this, HomeActivity.class);            startActivity(intent);            WelcomActivity.welcomActivity.finish();            finish();        &#125;    &#125;//    跳转到登录页面    private void Register() &#123;        intent.setClass(this,RegisterActivity.class);        startActivity(intent);    &#125;//    Toast弹窗    private void MyToast(String content)&#123;        Toast.makeText(this,content,Toast.LENGTH_SHORT).show();    &#125;//    点击左上角关闭页面    public void finishActivity(View view) &#123; finish(); &#125;&#125;
用户注册页面页面布局&ensp;&ensp;&ensp;&ensp;与用户登录页面相同，编辑框和按钮也都使用了相同的样式&ensp;&ensp;&ensp;&amp;enspactivity_register.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout android:layout_height=&quot;match_parent&quot;    android:layout_width=&quot;match_parent&quot;    android:orientation=&quot;vertical&quot;    android:gravity=&quot;center_horizontal&quot;    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;    &lt;!--    Title--&gt;    &lt;LinearLayout        android:background=&quot;@android:color/holo_blue_dark&quot;        android:orientation=&quot;horizontal&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;58dp&quot;&gt;        &lt;LinearLayout            android:onClick=&quot;finishActivity&quot;            android:gravity=&quot;center&quot;            android:layout_width=&quot;58dp&quot;            android:layout_height=&quot;58dp&quot;&gt;            &lt;ImageView                android:src=&quot;@mipmap/back&quot;                android:layout_width=&quot;20dp&quot;                android:layout_height=&quot;20dp&quot;/&gt;        &lt;/LinearLayout&gt;        &lt;LinearLayout            android:gravity=&quot;center&quot;            android:layout_weight=&quot;1&quot;            android:layout_width=&quot;0dp&quot;            android:layout_height=&quot;match_parent&quot;&gt;            &lt;TextView                android:text=&quot;用户注册&quot;                android:textStyle=&quot;bold&quot;                android:textSize=&quot;18sp&quot;                android:textColor=&quot;@color/black&quot;                android:layout_width=&quot;wrap_content&quot;                android:layout_height=&quot;wrap_content&quot;/&gt;        &lt;/LinearLayout&gt;        &lt;LinearLayout            android:gravity=&quot;center&quot;            android:layout_width=&quot;58dp&quot;            android:layout_height=&quot;58dp&quot;&gt;        &lt;/LinearLayout&gt;    &lt;/LinearLayout&gt;    &lt;!--    Content--&gt;    &lt;LinearLayout        android:orientation=&quot;vertical&quot;        android:gravity=&quot;center_horizontal&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;match_parent&quot;&gt;        &lt;EditText            android:background=&quot;@drawable/edit_text_style&quot;            android:layout_marginTop=&quot;68dp&quot;            android:hint=&quot;请输入用户名&quot;            android:layout_marginLeft=&quot;20dp&quot;            android:layout_marginRight=&quot;20dp&quot;            android:lines=&quot;1&quot;            android:inputType=&quot;text&quot;            android:gravity=&quot;center&quot;            android:id=&quot;@+id/userName&quot;            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;48dp&quot;/&gt;        &lt;EditText            android:background=&quot;@drawable/edit_text_style&quot;            android:layout_marginTop=&quot;18dp&quot;            android:hint=&quot;请输入昵称&quot;            android:layout_marginLeft=&quot;20dp&quot;            android:layout_marginRight=&quot;20dp&quot;            android:lines=&quot;1&quot;            android:inputType=&quot;text&quot;            android:gravity=&quot;center&quot;            android:id=&quot;@+id/nickName&quot;            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;48dp&quot;/&gt;        &lt;EditText            android:background=&quot;@drawable/edit_text_style&quot;            android:layout_marginTop=&quot;18dp&quot;            android:hint=&quot;请输入手机号&quot;            android:layout_marginLeft=&quot;20dp&quot;            android:layout_marginRight=&quot;20dp&quot;            android:lines=&quot;1&quot;            android:inputType=&quot;number&quot;            android:gravity=&quot;center&quot;            android:id=&quot;@+id/phoneNumber&quot;            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;48dp&quot;/&gt;        &lt;EditText            android:background=&quot;@drawable/edit_text_style&quot;            android:layout_marginTop=&quot;18dp&quot;            android:hint=&quot;请输入密码&quot;            android:layout_marginLeft=&quot;20dp&quot;            android:layout_marginRight=&quot;20dp&quot;            android:lines=&quot;1&quot;            android:inputType=&quot;textPassword&quot;            android:gravity=&quot;center&quot;            android:id=&quot;@+id/password&quot;            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;48dp&quot;/&gt;        &lt;LinearLayout            android:orientation=&quot;horizontal&quot;            android:layout_marginTop=&quot;28dp&quot;            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;wrap_content&quot;&gt;            &lt;Button                android:background=&quot;@drawable/edit_text_style&quot;                android:text=&quot;立即注册&quot;                android:textColor=&quot;@color/black&quot;                android:textSize=&quot;18sp&quot;                android:id=&quot;@+id/register&quot;                android:layout_marginLeft=&quot;20dp&quot;                android:layout_marginRight=&quot;10dp&quot;                android:layout_weight=&quot;1&quot;                android:layout_width=&quot;0dp&quot;                android:layout_height=&quot;wrap_content&quot;/&gt;            &lt;Button                android:background=&quot;@drawable/edit_text_style&quot;                android:text=&quot;已有账号&quot;                android:onClick=&quot;finishActivity&quot;                android:textColor=&quot;@color/black&quot;                android:textSize=&quot;18sp&quot;                android:layout_marginLeft=&quot;10dp&quot;                android:layout_marginRight=&quot;20dp&quot;                android:layout_weight=&quot;1&quot;                android:layout_width=&quot;0dp&quot;                android:layout_height=&quot;wrap_content&quot;/&gt;        &lt;/LinearLayout&gt;    &lt;/LinearLayout&gt;&lt;/LinearLayout&gt;
程序设计&ensp;&ensp;&ensp;&ensp;RegisterActivity.java，主要对4个输入框内容进行判断，输入正确的话即调用封装在User类中的用户注册方法，并判断其返回的注册结果package com.SmartCity.RegisAndLogin;import androidx.annotation.NonNull;import androidx.appcompat.app.AppCompatActivity;import android.os.Bundle;import android.os.Handler;import android.os.Looper;import android.os.Message;import android.text.TextUtils;import android.view.View;import android.widget.Button;import android.widget.EditText;import android.widget.Toast;import com.SmartCity.R;import com.SmartCity.User;public class RegisterActivity extends AppCompatActivity &#123;    private Button register;//注册按钮    private EditText userName,nickName,phonenumber,password;//四个编辑框    private User user = new User();//注册登录封装类    private LoginBean loginBean;//反序列化对象    private Handler handler;//handler通信    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_register);        myHandler();//handler通信        init();//初始化界面        submit();//设置监听    &#125;//    handler通信    private void myHandler() &#123;        handler = new Handler(Looper.getMainLooper())&#123;            @Override            public void handleMessage(@NonNull Message msg) &#123;                super.handleMessage(msg);                if (msg.what == 1)&#123;                    userRegister();//判断注册结果                &#125;            &#125;        &#125;;    &#125;//    判断注册结果    private void userRegister() &#123;        if (loginBean == null)&#123;            MyToast(&quot;注册失败: 未知原因&quot;);        &#125;        if (loginBean.getCode() != 200)&#123;            MyToast(&quot;注册失败: &quot; + loginBean.getMsg());        &#125;        else &#123;            MyToast(&quot;注册成功，可以登陆了&quot;);            finish();        &#125;    &#125;//    初始化界面    private void init() &#123;        register = findViewById(R.id.register);        userName = findViewById(R.id.userName);        nickName = findViewById(R.id.nickName);        phonenumber = findViewById(R.id.phoneNumber);        password = findViewById(R.id.password);    &#125;//    设置监听    private void submit() &#123;        register.setOnClickListener(new View.OnClickListener() &#123;            @Override            public void onClick(View v) &#123;                UserRegister();            &#125;        &#125;);    &#125;//    用户点击注册    private void UserRegister() &#123;        String userNameContent = userName.getText().toString();        String nickNameContent = nickName.getText().toString();        String phonenumberContent = phonenumber.getText().toString();        String passwordContent = password.getText().toString();//        判断输入的内容        if (TextUtils.isEmpty(userNameContent))&#123;            MyToast(&quot;用户名不能为空&quot;);        &#125;        else if (TextUtils.isEmpty(nickNameContent))&#123;            MyToast(&quot;昵称不可为空&quot;);        &#125;        else if (TextUtils.isEmpty(phonenumberContent))&#123;            MyToast(&quot;手机号不可为空&quot;);        &#125;        else if (phonenumberContent.length() &lt; 11)&#123;            MyToast(&quot;手机号不小于11位&quot;);        &#125;        else if (TextUtils.isEmpty(passwordContent))&#123;            MyToast(&quot;密码不可为空&quot;);        &#125;        else if (passwordContent.length() &lt; 6)&#123;            MyToast(&quot;密码不小于6位&quot;);        &#125;        else &#123;            new Thread()&#123;                @Override                public void run() &#123;                    super.run();//                    拿到反序列化对象，向handler发送消息                    loginBean = (LoginBean) user.Register(userName.getText().toString(),nickName.getText().toString(),phonenumber.getText().toString(),password.getText().toString());                    Message message = Message.obtain();                    message.what = 1;                    handler.sendMessage(message);                &#125;            &#125;.start();        &#125;    &#125;//    结束页面    public void finishActivity(View view) &#123;  finish();  &#125;//    toast    private void MyToast(String content)&#123;        Toast.makeText(this,content,Toast.LENGTH_SHORT).show();    &#125;&#125;
主页面&ensp;&ensp;&ensp;&ensp;主页面是个大工程，首先用ViewPager2+Fragment的方式实现了4页切换，与引导页不同的是每页有一个单独的Fragment页面，底部的四个按钮与四个页面相呼应
菜单切换&ensp;&ensp;&ensp;&ensp;底部四个菜单与四个页面对应切换即可，与引导页的小点大同小异，创建4个Fragment页面(分别对应首页、全部服务、新闻、个人中心)并添加到List中，实例化ViewPagerAdapter时把List作为参数发送给适配器
主页面布局&ensp;&ensp;&ensp;&ensp;如果觉得布局臃肿，可以将顶部标题栏和底部菜单栏分开布局，然后使用&lt;include layout=&quot;&quot; /&gt;的方式将其添加进来&ensp;&ensp;&ensp;&ensp;activity_home.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout android:layout_height=&quot;match_parent&quot;    android:layout_width=&quot;match_parent&quot;    android:orientation=&quot;vertical&quot;    android:gravity=&quot;center_horizontal&quot;    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;    &lt;!--    Title--&gt;    &lt;LinearLayout        android:gravity=&quot;center&quot;        android:background=&quot;@color/blue&quot;        android:orientation=&quot;horizontal&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;58dp&quot;&gt;        &lt;TextView            android:text=&quot;智慧城市&quot;            android:textStyle=&quot;bold&quot;            android:id=&quot;@+id/title&quot;            android:textSize=&quot;18sp&quot;            android:textColor=&quot;@color/white&quot;            android:layout_width=&quot;wrap_content&quot;            android:layout_height=&quot;wrap_content&quot;/&gt;    &lt;/LinearLayout&gt;    &lt;!--    Content--&gt;    &lt;androidx.viewpager2.widget.ViewPager2        android:background=&quot;@color/darker_gray&quot;        android:id=&quot;@+id/viewPager2&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_weight=&quot;1&quot;        android:layout_height=&quot;0dp&quot;/&gt;    &lt;!--    foot--&gt;    &lt;LinearLayout        android:background=&quot;@color/white&quot;        android:orientation=&quot;horizontal&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;58dp&quot;&gt;        &lt;LinearLayout            android:orientation=&quot;vertical&quot;            android:gravity=&quot;center&quot;            android:layout_weight=&quot;1&quot;            android:layout_width=&quot;0dp&quot;            android:id=&quot;@+id/button0&quot;            android:layout_height=&quot;match_parent&quot;&gt;            &lt;ImageView                android:background=&quot;@drawable/home_back&quot;                android:layout_width=&quot;26dp&quot;                android:layout_height=&quot;26dp&quot;/&gt;            &lt;TextView                android:text=&quot;首页&quot;                android:textSize=&quot;13dp&quot;                android:textColor=&quot;@color/black&quot;                android:layout_width=&quot;wrap_content&quot;                android:layout_height=&quot;wrap_content&quot;/&gt;        &lt;/LinearLayout&gt;        &lt;LinearLayout            android:orientation=&quot;vertical&quot;            android:gravity=&quot;center&quot;            android:layout_weight=&quot;1&quot;            android:layout_width=&quot;0dp&quot;            android:id=&quot;@+id/button1&quot;            android:layout_height=&quot;match_parent&quot;&gt;            &lt;ImageView                android:background=&quot;@drawable/service_back&quot;                android:layout_width=&quot;26dp&quot;                android:layout_height=&quot;26dp&quot;/&gt;            &lt;TextView                android:text=&quot;全部服务&quot;                android:textSize=&quot;13dp&quot;                android:textColor=&quot;@color/black&quot;                android:layout_width=&quot;wrap_content&quot;                android:layout_height=&quot;wrap_content&quot;/&gt;        &lt;/LinearLayout&gt;        &lt;LinearLayout            android:orientation=&quot;vertical&quot;            android:gravity=&quot;center&quot;            android:layout_weight=&quot;1&quot;            android:layout_width=&quot;0dp&quot;            android:id=&quot;@+id/button2&quot;            android:layout_height=&quot;match_parent&quot;&gt;            &lt;ImageView                android:background=&quot;@drawable/news_back&quot;                android:layout_width=&quot;26dp&quot;                android:layout_height=&quot;26dp&quot;/&gt;            &lt;TextView                android:text=&quot;新闻&quot;                android:textSize=&quot;13dp&quot;                android:textColor=&quot;@color/black&quot;                android:layout_width=&quot;wrap_content&quot;                android:layout_height=&quot;wrap_content&quot;/&gt;        &lt;/LinearLayout&gt;        &lt;LinearLayout            android:orientation=&quot;vertical&quot;            android:gravity=&quot;center&quot;            android:layout_weight=&quot;1&quot;            android:layout_width=&quot;0dp&quot;            android:id=&quot;@+id/button3&quot;            android:layout_height=&quot;match_parent&quot;&gt;            &lt;ImageView                android:background=&quot;@drawable/userself_back&quot;                android:layout_width=&quot;26dp&quot;                android:layout_height=&quot;26dp&quot;/&gt;            &lt;TextView                android:text=&quot;个人中心&quot;                android:textSize=&quot;13dp&quot;                android:textColor=&quot;@color/black&quot;                android:layout_width=&quot;wrap_content&quot;                android:layout_height=&quot;wrap_content&quot;/&gt;        &lt;/LinearLayout&gt;    &lt;/LinearLayout&gt;&lt;/LinearLayout&gt;
主页面程序设计&ensp;&ensp;&ensp;&ensp;说明一下，HomeActivity.java这里只配置了主页面，包括顶部标题栏和底部菜单栏以及4个Fragment在ViewPager2的显示，把题目中的五个要求做了分离，其余四个要求(轮播图、推荐服务、专题、新闻分类)作为一个单独的模块放在了“智慧城市页(HomeFragment0)”的代码中，HomeActivity只能算是实现了五个模块中的最后一个
package com.SmartCity.Home;import androidx.appcompat.app.AppCompatActivity;import androidx.fragment.app.Fragment;import androidx.viewpager2.widget.ViewPager2;import android.os.Bundle;import android.view.View;import android.widget.LinearLayout;import android.widget.TextView;import com.SmartCity.R;import com.SmartCity.Welcom.ViewPagerAdapter;import java.util.ArrayList;import java.util.List;public class HomeActivity extends AppCompatActivity implements View.OnClickListener &#123;    private ViewPager2 viewPager2;//滑动窗体    private LinearLayout[] buttons = new LinearLayout[4];//底部菜单    private LinearLayout button;//上一个按钮    private List&lt;Fragment&gt; fragments = new ArrayList&lt;&gt;();//储存ViewPager2的4个item    private String[] titleContent = new String[]&#123;&quot;智慧城市&quot;,&quot;全部服务&quot;,&quot;新闻&quot;,&quot;个人中心&quot;&#125;;//标题的内容    private TextView title;//标题    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_home);        init();//初始化界面        submit();//设置监听        setViewPager();//加载ViewPager2    &#125;//    初始化界面    private void init() &#123;        viewPager2 = findViewById(R.id.viewPager2);        title = findViewById(R.id.title);//顶部标题//        底部菜单栏四个按钮        buttons[0] = findViewById(R.id.button0);        buttons[1] = findViewById(R.id.button1);        buttons[2] = findViewById(R.id.button2);        buttons[3] = findViewById(R.id.button3);//        把四个fragment页面添加到List集合中        fragments.add(new HomeFragment0());        fragments.add(new HomeFragment1());        fragments.add(new HomeFragment2());        fragments.add(new HomeFragment3());    &#125;//    设置监听    private void submit() &#123;//        底部菜单栏事件监听        buttons[0].setOnClickListener(this);        buttons[1].setOnClickListener(this);        buttons[2].setOnClickListener(this);        buttons[3].setOnClickListener(this);//        给滑动窗体注册页面切换监听        viewPager2.registerOnPageChangeCallback(new ViewPager2.OnPageChangeCallback() &#123;            @Override            public void onPageSelected(int position) &#123;                super.onPageSelected(position);                setButton(position);//设置菜单栏变化            &#125;        &#125;);    &#125;//    改变菜单栏状态    private void setButton(int position)&#123;        if (button != null)&#123;//            还原上个按钮的颜色            button.getChildAt(0).setSelected(false);            ((TextView) button.getChildAt(1)).setTextColor(getResources().getColor(R.color.black));        &#125;//        记录点击的按钮        button = buttons[position];//        设置选中的按钮的颜色        buttons[position].getChildAt(0).setSelected(true);        ((TextView) buttons[position].getChildAt(1)).setTextColor(getResources().getColor(R.color.blue));//        设置标题        title.setText(titleContent[position]);    &#125;    private void setViewPager() &#123;//        适配器依然是前面WelcomActivity页中使用的适配器        ViewPagerAdapter viewPagerAdapter = new ViewPagerAdapter(getSupportFragmentManager(),getLifecycle(),fragments);        viewPager2.setAdapter(viewPagerAdapter);    &#125;//    当菜单栏被点击时，切换到对应的页面    @Override    public void onClick(View v) &#123;        switch (v.getId())&#123;            case R.id.button0:                viewPager2.setCurrentItem(0);                break;            case R.id.button1:                viewPager2.setCurrentItem(1);                break;            case R.id.button2:                viewPager2.setCurrentItem(2);                break;            case R.id.button3:                viewPager2.setCurrentItem(3);                break;        &#125;    &#125;&#125;
&ensp;&ensp;&ensp;&ensp;到这里为止，已经可以显示四个可滑动的页面，称他们为“智慧城市页”、“全部服务页”、“新闻列表页”、“个人中心页”
&ensp;&ensp;&ensp;&ensp;下一篇中主要写“智慧城市页”的实现。欲知后事如何，且听下回分解
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android开发手记</tag>
        <tag>智慧城市</tag>
      </tags>
  </entry>
  <entry>
    <title>Android版本号与API级别关系对应表</title>
    <url>/2021/09/25/Android%E7%89%88%E6%9C%AC%E5%8F%B7%E4%B8%8EAPI%E7%BA%A7%E5%88%AB%E5%85%B3%E7%B3%BB%E5%AF%B9%E5%BA%94%E8%A1%A8/</url>
    <content><![CDATA[



version name
version code
API
build version
release time




Tiramisu
13.0
33
Build.VERSION_CODES.TIRAMISU
2022-08-15


Snow Cone
12.1
32
Build.VERSION_CODES.S_V2
2022-03-08


Snow Cone
12.0
31
Build.VERSION_CODES.S
2021-02-18


Red Velvet Cake
11.0
30
Build.VERSION_CODES.R
2020-09-08


Quince Tart
10.0
29
Build.VERSION_CODES.Q
2019-09-03


Pie
9.0
28
Build.VERSION_CODES.P
2018-08-01


Oreo
8.1
27
Build.VERSION_CODES.OMr1
2017-12-01


Oreo
8.0
26
Build.VERSION_CODES.O
2017-08-01


Nougat
7.1
25
Build.VERSION_CODES.NMr1
2016-12-01


Nougat
7.0
24
Build.VERSION_CODES.N
2016-08-01


Marshmallow
6.0
23
Build.VERSION_CODES.M
2015-08-01


Lollipop
5.1
22
Build.VERSION_CODES.LollipopMr1
2015-03-01


Lollipop
5.0
21
Build.VERSION_CODES.Lollipop
2014-11-01


Kitkat Watch
4.4W
20
Build.VERSION_CODES.KitKatWatch
2014-06-01


Kitkat
4.4
19
Build.VERSION_CODES.KitKat
2013-10-01


Jelly Bean
4.3
18
Build.VERSION_CODES.JellyBeanMr2
2013-07-01


Jelly Bean
4.2-4.2.2
17
Build.VERSION_CODES.JellyBeanMr1
2012-11-01


Jelly Bean
4.1-4.1.1
16
Build.VERSION_CODES.JellyBean
2012-06-01


Ice Cream Sandwich
4.0.3-4.0.4
15
Build.VERSION_CODES.IceCreamSandwichMr1
2011-12-01


Ice Cream Sandwich
4.0-4.0.2
14
Build.VERSION_CODES.IceCreamSandwich
2011-10-01


Honeycomb
3.2
13
Build.VERSION_CODES.HoneyCombMr2
2011-06-01


Honeycomb
3.1.x
12
Build.VERSION_CODES.HoneyCombMr1
2011-05-01


Honeycomb
3.0.x
11
Build.VERSION_CODES.HoneyComb
2011-02-01


Gingerbread
2.3.3-2.3.4
10
Build.VERSION_CODES.GingerBreadMr1
2011-02-01


Gingerbread
2.3-2.3.2
9
Build.VERSION_CODES.GingerBread
2010-11-01


Froyo
2.2.x
8
Build.VERSION_CODES.Froyo
2010-06-01


Eclair
2.1.x
7
Build.VERSION_CODES.EclairMr1
2010-01-01


Eclair
2.0.1
6
Build.VERSION_CODES.Eclair01
2009-12-01


Eclair
2.0
5
Build.VERSION_CODES.Eclair
2009-11-01


Donut
1.6
4
Build.VERSION_CODES.Donut
2009-09-01


Cupcake
1.5
3
Build.VERSION_CODES.Cupcake
2009-05-01


Base
1.1
2
Build.VERSION_CODES.Base11
2009-02-01


Base
1.0
1
Build.VERSION_CODES.Base
2008-10-01




]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>频繁查阅</tag>
      </tags>
  </entry>
  <entry>
    <title>Android自定义ImageView的四个角圆角</title>
    <url>/2021/11/30/Android%E8%87%AA%E5%AE%9A%E4%B9%89ImageView%E7%9A%84%E5%9B%9B%E4%B8%AA%E8%A7%92%E5%9C%86%E8%A7%92/</url>
    <content><![CDATA[使用重写ImageView的方式实现图片圆角，以下程序中注释内容中的字母与此图相匹配
创建MyImageView&ensp;&ensp;&ensp;&ensp;创建MyImageView类继承自AppCompatImageView，并默认添加了三个构造器，重写onDraw()方法public class MyImageView extends AppCompatImageView &#123;    public MyImageView(Context context) &#123;        super(context);    &#125;    public MyImageView(Context context, @Nullable AttributeSet attrs) &#123;        super(context, attrs);    &#125;    public MyImageView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123;        super(context, attrs, defStyleAttr);    &#125;    @Override    protected void onDraw(Canvas canvas) &#123;        super.onDraw(canvas);    &#125;&#125;
绘制图片显示区域使用Path类绘制圆角矩形，并用Canvas.clipPath将其显示出来；用到的path方法：

moveTo(); 移动下一次操作的起点位置
lineTo(); 添加上一个点到当前点之间的直线到Path
quadTo(); 二次贝塞尔曲线

public class MyImageView extends AppCompatImageView &#123;    public MyImageView(Context context) &#123;        super(context);    &#125;    public MyImageView(Context context, @Nullable AttributeSet attrs) &#123;        super(context, attrs);    &#125;    public MyImageView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123;        super(context, attrs, defStyleAttr);    &#125;    @Override    protected void onDraw(Canvas canvas) &#123;        /*         * 百度关键词: Android开发Path详解         * 演示方法:         * - moveTo(); 移动下一次操作的起点位置         * - lineTo(); 添加上一个点到当前点之间的直线到Path         * - quadTo(); 二次贝塞尔曲线         * */        int topleft = 60;//左上角度        int topright = 60;//右上角度        int bottomleft = 0;//左下角度        int bottomright = 0;//右下角度        float width = this.getWidth();//图片的宽度        float height = this.getHeight();//图片的高度        Path path = new Path();//定义绘制路径类        path.moveTo(topleft,0);//定义起始点，点A的位置//        从点A绘制到当前点B        path.lineTo(width - topright,0);//        x1、y1确定图形右上角的点C，x2、y2定义右上角圆角结束点D，点B、C、D通过贝塞尔曲线画弧        path.quadTo(width,0,width,topright);//        从点D绘制到当前点E        path.lineTo(width,height - bottomright);//        x1、y1确定图形右下角的点F，x2、y2定义右下角圆角结束点G        path.quadTo(width,height,width - bottomright,height);//        从点G绘制到当前点H        path.lineTo(bottomright,height);//        x1、y1确定图形左下角的点I，x2、y2定义右下角圆角结束点J        path.quadTo(0,height,0,height - bottomleft);//        从点J绘制到当前点K        path.lineTo(0,topleft);//        x1、y1确定图形左上角的点L，x2、y2定义左上角圆角结束点A，形成闭环，路径绘制结束        path.quadTo(0,0,topleft,0);        canvas.clipPath(path);//绘制定义的路径        super.onDraw(canvas);    &#125;&#125;
&ensp;&ensp;&ensp;&ensp;注意：代码中的角度值是px值，getWidth和getHeight返回的也都是px值，如果需要设置dp值，必须手动转换，Android dp、px互转
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android开发手记</tag>
      </tags>
  </entry>
  <entry>
    <title>Android物理按键事件</title>
    <url>/2021/10/12/Android%E7%89%A9%E7%90%86%E6%8C%89%E9%94%AE%E4%BA%8B%E4%BB%B6/</url>
    <content><![CDATA[Android常用的物理按键及其触发事件
物理键

KEYCODE_POWER: 电源键
KEYCODE_MENU: 菜单键
KEYCODE_BACK: 后退键
KEYCODE_HOME: Home键
KEYCODE_CAMERA: 相机键
KEYCODE_SEARCH: 查找键
KEYCODE_VOLUME_UP: 音量键+
KEYCODE_VOLUME_DOWN: 音量键-
KEYCODE_VOLUME_MUTE: 静音

方向键

KEYCODE_DPAD_CENTER
KEYCODE_DPAD_UP
KEYCODE_DPAD_DOWN
KEYCODE_DPAD_LEFT
KEYCODE_DPAD_RIGHT

键盘键 

KEYCODE_0 ~ KEYCODE_9: 数字0~9
KEYCODE_A ~ KEYCODE_Z: 字母A~Z

提供的回调方法有onKeyUp() 按键被按下，松开后触发OnKeyDown() 按键被按下触发onKeyLongPress() 按键被长按触发
注意：让系统调用onKeyLongPress方法，必须要在onKeyDown方法中调用event.startTracking()方法并返回true才可以。
例如这个例子，按下两次返回键退出页面    @Override//    重写onKeyDown方法可以拦截系统默认的处理    public boolean onKeyDown(int keyCode, KeyEvent event) &#123;//        后退键将不再响应系统默认事件        if (keyCode == KeyEvent.KEYCODE_BACK) &#123;            exitActivity();            return true;        &#125;        return super.onKeyDown(keyCode, event);    &#125;    private void exitActivity() &#123;//        System.currentTimeMillis()相当于new Date()的毫秒数        if (System.currentTimeMillis() - exitTime &gt; 2000)&#123;            Toast.makeText(this,&quot;再次点击返回键退出&quot;,Toast.LENGTH_SHORT).show();            exitTime = System.currentTimeMillis();        &#125;        else &#123;            finish();        &#125;    &#125;
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>频繁查阅</tag>
      </tags>
  </entry>
  <entry>
    <title>Android获取RecyclerView的ItemView</title>
    <url>/2021/12/02/Android%E8%8E%B7%E5%8F%96RecyclerView%E7%9A%84ItemView/</url>
    <content><![CDATA[&ensp;&ensp;&ensp;&ensp;正常创建RecyclerView布局，正常创建Adapter设配器类，正常对Activity中的RecyclerView添加适配器及布局管理器。。。&ensp;&ensp;&ensp;&ensp;看下效果
&ensp;&ensp;&ensp;&ensp;怎么获取到列表的第一个Item并修改字体为红色？&ensp;&ensp;&ensp;&ensp;刚开始我想到了getChildAt()，这个方法只能获取RecyclerView中第一页加载的可见Item的View，再向下就不行了，接下来看操作20-25行public class MainActivity extends AppCompatActivity &#123;    private RecyclerView recyclerView;    private List&lt;String&gt; datas = new ArrayList&lt;&gt;();    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        init();        setData();        setRecycler();    &#125;    private void setRecycler() &#123;        MyRecyclerViewAdapter myRecyclerViewAdapter = new MyRecyclerViewAdapter(datas,this);        LinearLayoutManager linearLayoutManager = new LinearLayoutManager(this,RecyclerView.VERTICAL,false);        recyclerView.setAdapter(myRecyclerViewAdapter);        recyclerView.setLayoutManager(linearLayoutManager);        int position = 0;//想要获取到的item的position//        因为item的根布局是LinearLayout，所以将获取到的itemView强转为LinearLayout        LinearLayout linearLayout = (LinearLayout) recyclerView.getLayoutManager().findViewByPosition(position);//        根布局LinearLayout仅包含了一个TextView        TextView textView = (TextView) linearLayout.getChildAt(0);        textView.setTextColor(MainActivity.this.getResources().getColor(R.color.red));    &#125;    private void setData() &#123;        for (int i = 0; i &lt; 10; i++) &#123;            datas.add(&quot;数据&quot; + i);        &#125;    &#125;    private void init() &#123;        recyclerView = findViewById(R.id.recyclerView);    &#125;&#125;&ensp;&ensp;&ensp;&ensp;RecyclerView加载完毕后，获取通过它的布局管理器获取它的第一个item，理论是可以的，但是运行会报错，找不到代码中linearLayout变量的对象
&ensp;&ensp;&ensp;&ensp;这是因为Activity的onCreate()方法中，只是对页面进行初始化，View还没有被绘制，所以RecyclerView的item无法获取；当onResume方法被调用时，View才会被绘制，软件进入运行状态(例如oncreate中View.getWidth和View.getHeight无法获得view的高度和宽度)&ensp;&ensp;&ensp;&ensp;解决：OnGlobalLayoutListener 是ViewTreeObserver的内部类，当一个视图树的布局发生改变时，可以被ViewTreeObserver监听到，这是一个注册监听视图树的观察者(observer)，在视图树的全局事件改变时得到通知。ViewTreeObserver不能直接实例化，而是通过getViewTreeObserver()获得。public class MainActivity extends AppCompatActivity &#123;    private RecyclerView recyclerView;    private List&lt;String&gt; datas = new ArrayList&lt;&gt;();    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        init();        setData();        setRecycler();    &#125;    private void setRecycler() &#123;        MyRecyclerViewAdapter myRecyclerViewAdapter = new MyRecyclerViewAdapter(datas,this);        LinearLayoutManager linearLayoutManager = new LinearLayoutManager(this,RecyclerView.VERTICAL,false);        recyclerView.setAdapter(myRecyclerViewAdapter);        recyclerView.setLayoutManager(linearLayoutManager);//        获取recyclerView视图树的观察者，添加一个布局的监听器当布局改变时调用        recyclerView.getViewTreeObserver().addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() &#123;            @Override            public void onGlobalLayout() &#123;                int position = 0;//想要获取到的item的position//                因为item的根布局是LinearLayout，所以将获取到的itemView强转为LinearLayout                LinearLayout linearLayout = (LinearLayout) recyclerView.getLayoutManager().findViewByPosition(position);//                根布局LinearLayout仅包含了一个TextView                TextView textView = (TextView) linearLayout.getChildAt(0);                textView.setTextColor(MainActivity.this.getResources().getColor(R.color.red));            &#125;        &#125;);    &#125;    private void setData() &#123;        for (int i = 0; i &lt; 10; i++) &#123;            datas.add(&quot;数据&quot; + i);        &#125;    &#125;    private void init() &#123;        recyclerView = findViewById(R.id.recyclerView);    &#125;&#125;
&ensp;&ensp;&ensp;&ensp;看下效果
&ensp;&ensp;&ensp;&ensp;Fragment布局中同样适用
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android开发手记</tag>
      </tags>
  </entry>
  <entry>
    <title>Android软键盘显示“搜索”</title>
    <url>/2021/11/17/Android%E8%BD%AF%E9%94%AE%E7%9B%98%E6%98%BE%E7%A4%BA%E2%80%9C%E6%90%9C%E7%B4%A2%E2%80%9D/</url>
    <content><![CDATA[效果预览
布局属性&ensp;&ensp;&ensp;&ensp;首先需要在EditText的布局中插入android:imeOptions=”actionSearch”和android:inputType=”text”属性，使键盘右下角显示搜索按钮&lt;EditText    android:hint=&quot;新闻搜索&quot;    android:id=&quot;@+id/edit_newsSearch&quot;    android:inputType=&quot;text&quot;    android:lines=&quot;1&quot;    android:imeOptions=&quot;actionSearch&quot;    android:layout_marginTop=&quot;10dp&quot;    android:paddingRight=&quot;10dp&quot;    android:paddingLeft=&quot;10dp&quot;    android:layout_marginRight=&quot;20dp&quot;    android:layout_marginLeft=&quot;20dp&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;48dp&quot;/&gt;
注意：这里一定不要添加android:maxLength=”1”，添加后会无视android:imeOptions=”actionSearch”的效果
程序实现&ensp;&ensp;&ensp;&ensp;然后在java代码中给软键盘添加监听事件//    给键盘添加监听    edit_newsSearch.setOnKeyListener(new View.OnKeyListener() &#123;        @Override        public boolean onKey(View view, int i, KeyEvent keyEvent) &#123;            /*             * i就是actionId或者keyId，通过actionId判断点击的按钮是否是软键盘的搜索             * 这里有一个坑，应该算是sdk版本不同留下的坑             * 在sdk30开发中，i的变量名叫做actionId，             * 我非常确定，当点击搜索按钮时actionId和EditorInfo.IME_ACTION_SEARCH是相等的，             * 即action == EditorInfo.IME_ACTION_SEARCH == 3             * 但是在sdk26中i = 66，EditorInfo.IME_ACTION_SEARCH = 3             * 不过keyEvent.KEYCODE_ENTER = 66，所以我要他妈使用keyEvent.KEYCODE_ENTER？             * 原理是因为搜索按钮把回车按钮取代了吗？？？？             * */            if (i == keyEvent.KEYCODE_ENTER)&#123;//                执行的事件                Toast.makeText(getContext(),edit_newsSearch.getText().toString(),Toast.LENGTH_SHORT).show();            &#125;            return false;        &#125;    &#125;);
拓展：在EditText的父布局或者顶层布局中添加属性android:focusableInTouchMode=”true”和android:focusable=”true”，可以禁止EditText自动获取焦点
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android开发手记</tag>
      </tags>
  </entry>
  <entry>
    <title>Apktool</title>
    <url>/2021/08/15/Apktool/</url>
    <content><![CDATA[开源地址: https://github.com/iBotPeaches/Apktool官方地址: https://ibotpeaches.github.io/Apktool/
安装JDK 1.8&ensp;&ensp;&ensp;&ensp;至少安装了java jdk1.8
apktool.bat&ensp;&ensp;&ensp;&ensp;下载包装器脚本点击下载
apktool.jar&ensp;&ensp;&ensp;&ensp;下载apktool工具(2.6.0)点击下载
使用反编译&ensp;&ensp;&ensp;&ensp;将apktool.bat和apktool.jar放在同一目录下，并将想要解码的apk也放在该目录下
&ensp;&ensp;&ensp;&ensp;打开cmd窗口，进入该目录，并执行apktool decode test.apk// 将目录下的test.apk解码到test文件夹apktool d test.apk// 将目录下的test.apk解码到test文件夹，简写apktool d test.apk -o bar\test// 将目录下的test.apk解码到bar\test文件夹// 当然，apk的路径你也可以指定，比如apktool d bar\test.apk -o bar\test

回编译apktool build test// 回编译指定文件夹，回编译后的apk文件存放在test\dist\test.apkapktool b test// 回编译指定文件夹，回编译后的apk文件存放在test\dist\test.apk，简写apktool b .// 将当前目录编译到dist文件夹中apktool b test -o new_test.apk// 回编译指定文件夹，回编译后的apk文件重命名为new_test.apk并存放在当前目录下

&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;
]]></content>
      <categories>
        <category>菜鸡手记</category>
      </categories>
      <tags>
        <tag>软件与工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Android实战-智慧城市(7)</title>
    <url>/2021/11/10/Android%E5%AE%9E%E6%88%98-%E6%99%BA%E6%85%A7%E5%9F%8E%E5%B8%82-7/</url>
    <content><![CDATA[续前节，城市地铁功能开发Android实战-智慧城市(6)
软件设计智慧巴士&ensp;&ensp;&ensp;&ensp;RecyclerView嵌套RecyclerView思路比较复杂，后边有一个Spinner比较陌生，剩下的都还好

巴士所有线路信息的反序列化对象&ensp;&ensp;&ensp;&ensp;所有巴士路线的所有信息的json的反序列化对象&ensp;&ensp;&ensp;&ensp;BusLineBean.javapackage com.SmartCity.Bus;import java.util.List;//巴士路线列表的反序列化对象public class BusLineBean &#123;    private int total;    private List&lt;RowsBean&gt; rows;    private int code;    private String msg;    public int getTotal() &#123;        return total;    &#125;    public void setTotal(int total) &#123;        this.total = total;    &#125;    public List&lt;RowsBean&gt; getRows() &#123;        return rows;    &#125;    public void setRows(List&lt;RowsBean&gt; rows) &#123;        this.rows = rows;    &#125;    public int getCode() &#123;        return code;    &#125;    public void setCode(int code) &#123;        this.code = code;    &#125;    public String getMsg() &#123;        return msg;    &#125;    public void setMsg(String msg) &#123;        this.msg = msg;    &#125;    public static class RowsBean &#123;        private Object searchValue;        private Object createBy;        private String createTime;        private Object updateBy;        private String updateTime;        private Object remark;        private ParamsBean params;        private int id;        private String name;        private String first;        private String end;        private String startTime;        private String endTime;        private double price;        private String mileage;        public Object getSearchValue() &#123;            return searchValue;        &#125;        public void setSearchValue(Object searchValue) &#123;            this.searchValue = searchValue;        &#125;        public Object getCreateBy() &#123;            return createBy;        &#125;        public void setCreateBy(Object createBy) &#123;            this.createBy = createBy;        &#125;        public String getCreateTime() &#123;            return createTime;        &#125;        public void setCreateTime(String createTime) &#123;            this.createTime = createTime;        &#125;        public Object getUpdateBy() &#123;            return updateBy;        &#125;        public void setUpdateBy(Object updateBy) &#123;            this.updateBy = updateBy;        &#125;        public String getUpdateTime() &#123;            return updateTime;        &#125;        public void setUpdateTime(String updateTime) &#123;            this.updateTime = updateTime;        &#125;        public Object getRemark() &#123;            return remark;        &#125;        public void setRemark(Object remark) &#123;            this.remark = remark;        &#125;        public ParamsBean getParams() &#123;            return params;        &#125;        public void setParams(ParamsBean params) &#123;            this.params = params;        &#125;        public int getId() &#123;            return id;        &#125;        public void setId(int id) &#123;            this.id = id;        &#125;        public String getName() &#123;            return name;        &#125;        public void setName(String name) &#123;            this.name = name;        &#125;        public String getFirst() &#123;            return first;        &#125;        public void setFirst(String first) &#123;            this.first = first;        &#125;        public String getEnd() &#123;            return end;        &#125;        public void setEnd(String end) &#123;            this.end = end;        &#125;        public String getStartTime() &#123;            return startTime;        &#125;        public void setStartTime(String startTime) &#123;            this.startTime = startTime;        &#125;        public String getEndTime() &#123;            return endTime;        &#125;        public void setEndTime(String endTime) &#123;            this.endTime = endTime;        &#125;        public double getPrice() &#123;            return price;        &#125;        public void setPrice(double price) &#123;            this.price = price;        &#125;        public String getMileage() &#123;            return mileage;        &#125;        public void setMileage(String mileage) &#123;            this.mileage = mileage;        &#125;        public static class ParamsBean &#123;        &#125;    &#125;&#125;
巴士路线的列表item布局&ensp;&ensp;&ensp;&ensp;因为是列表嵌套，所以在这个item中还有一个RecyclerView，默认它是不可见状态&ensp;&ensp;&ensp;&ensp;activity_bus_item.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout android:layout_height=&quot;wrap_content&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_marginTop=&quot;10dp&quot;    android:layout_marginLeft=&quot;10dp&quot;    android:layout_marginRight=&quot;10dp&quot;    android:orientation=&quot;vertical&quot;    android:background=&quot;@color/white&quot;    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;    &lt;TextView        android:text=&quot;lineName&quot;        android:id=&quot;@+id/lineName&quot;        android:gravity=&quot;center&quot;        android:padding=&quot;10dp&quot;        android:textStyle=&quot;bold&quot;        android:textSize=&quot;18sp&quot;        android:textColor=&quot;@color/white&quot;        android:background=&quot;@color/blue&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;wrap_content&quot;/&gt;    &lt;LinearLayout        android:layout_marginTop=&quot;10dp&quot;        android:layout_marginBottom=&quot;10dp&quot;        android:orientation=&quot;horizontal&quot;        android:gravity=&quot;center_vertical&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;wrap_content&quot;&gt;        &lt;TextView            android:text=&quot;始发站&quot;            android:id=&quot;@+id/firstStation&quot;            android:gravity=&quot;center&quot;            android:textSize=&quot;16sp&quot;            android:textStyle=&quot;bold&quot;            android:textColor=&quot;@color/black&quot;            android:layout_width=&quot;0dp&quot;            android:layout_weight=&quot;1&quot;            android:layout_height=&quot;wrap_content&quot;/&gt;        &lt;ImageView            android:src=&quot;@mipmap/mark_left&quot;            android:scaleType=&quot;fitXY&quot;            android:layout_width=&quot;120dp&quot;            android:layout_height=&quot;10dp&quot;/&gt;        &lt;ImageView            android:src=&quot;@mipmap/mark_right&quot;            android:scaleType=&quot;fitXY&quot;            android:layout_width=&quot;48dp&quot;            android:layout_height=&quot;18dp&quot;/&gt;        &lt;TextView            android:text=&quot;终点站&quot;            android:id=&quot;@+id/endStation&quot;            android:gravity=&quot;center&quot;            android:textStyle=&quot;bold&quot;            android:textSize=&quot;16sp&quot;            android:textColor=&quot;@color/black&quot;            android:layout_width=&quot;0dp&quot;            android:layout_weight=&quot;1&quot;            android:layout_height=&quot;wrap_content&quot;/&gt;    &lt;/LinearLayout&gt;    &lt;LinearLayout        android:orientation=&quot;horizontal&quot;        android:gravity=&quot;center_vertical&quot;        android:layout_marginBottom=&quot;10dp&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;wrap_content&quot;&gt;        &lt;TextView            android:text=&quot;票价: &quot;            android:id=&quot;@+id/price&quot;            android:gravity=&quot;center&quot;            android:textSize=&quot;16sp&quot;            android:textStyle=&quot;bold&quot;            android:textColor=&quot;@color/black&quot;            android:layout_width=&quot;0dp&quot;            android:layout_weight=&quot;1&quot;            android:layout_height=&quot;wrap_content&quot;/&gt;        &lt;TextView            android:text=&quot;里程: &quot;            android:id=&quot;@+id/mileage&quot;            android:gravity=&quot;center&quot;            android:textStyle=&quot;bold&quot;            android:textSize=&quot;16sp&quot;            android:textColor=&quot;@color/black&quot;            android:layout_width=&quot;0dp&quot;            android:layout_weight=&quot;1&quot;            android:layout_height=&quot;wrap_content&quot;/&gt;    &lt;/LinearLayout&gt;    &lt;View        android:background=&quot;@color/darker_gray&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;1dp&quot;/&gt;    &lt;LinearLayout        android:orientation=&quot;horizontal&quot;        android:gravity=&quot;center_vertical&quot;        android:id=&quot;@+id/recyclerControl&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;38dp&quot;&gt;        &lt;TextView            android:gravity=&quot;center_vertical&quot;            android:paddingLeft=&quot;20dp&quot;            android:textColor=&quot;@color/black&quot;            android:textSize=&quot;14sp&quot;            android:textStyle=&quot;bold&quot;            android:text=&quot;线路列表&quot;            android:layout_weight=&quot;1&quot;            android:layout_width=&quot;0dp&quot;            android:layout_height=&quot;match_parent&quot;/&gt;        &lt;ImageView            android:src=&quot;@mipmap/forword&quot;            android:layout_marginRight=&quot;10dp&quot;            android:layout_width=&quot;12dp&quot;            android:layout_height=&quot;12dp&quot;/&gt;    &lt;/LinearLayout&gt;    &lt;androidx.recyclerview.widget.RecyclerView        android:visibility=&quot;gone&quot;        android:id=&quot;@+id/recyclerView&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;wrap_content&quot;/&gt;&lt;/LinearLayout&gt;
巴士线路列表的适配器&ensp;&ensp;&ensp;&ensp;适配器中有两个item的click，一个供外部调用显示和隐藏站点列表，一个点击跳转到定制班车&ensp;&ensp;&ensp;&ensp;BusAdapter.javapackage com.SmartCity.Bus;import android.annotation.SuppressLint;import android.content.Context;import android.content.Intent;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import android.widget.LinearLayout;import android.widget.TextView;import androidx.annotation.NonNull;import androidx.recyclerview.widget.RecyclerView;import com.SmartCity.R;import java.util.List;public class BusAdapter extends RecyclerView.Adapter&lt;BusAdapter.MyViewHolder&gt; &#123;    private List&lt;String&gt; lineName,firstStation,endStation,price,mileage;//路线名、起点、终点、票价、里程    private List&lt;Integer&gt; id;//路线id    private Context context;    public BusAdapter(List&lt;String&gt; lineName, List&lt;String&gt; firstStation, List&lt;String&gt; endStation, List&lt;String&gt; price, List&lt;String&gt; mileage, List&lt;Integer&gt; id, Context context) &#123;        this.lineName = lineName;        this.firstStation = firstStation;        this.endStation = endStation;        this.price = price;        this.mileage = mileage;        this.context = context;        this.id = id;    &#125;    @NonNull    @Override    public MyViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) &#123;        View view = LayoutInflater.from(context).inflate(R.layout.activity_bus_item,parent,false);        return new MyViewHolder(view);    &#125;    @SuppressLint(&quot;SetTextI18n&quot;)    @Override    public void onBindViewHolder(@NonNull MyViewHolder holder, int position) &#123;        holder.lineName.setText(lineName.get(position));        holder.firstStation.setText(&quot;始发站\n&quot; + firstStation.get(position));        holder.endStation.setText(&quot;终点站\n&quot; + endStation.get(position));        holder.price.setText(&quot;票价: &quot; + price.get(position));        holder.mileage.setText(&quot;里程: &quot; + mileage.get(position) + &quot;km&quot;);    &#125;    @Override    public int getItemCount() &#123;        return lineName.size();    &#125;    public class MyViewHolder extends RecyclerView.ViewHolder &#123;        private TextView lineName,firstStation,endStation,price,mileage;        private LinearLayout recyclerControl;        private RecyclerView recyclerView;        public MyViewHolder(@NonNull View itemView) &#123;            super(itemView);            lineName = itemView.findViewById(R.id.lineName);            firstStation = itemView.findViewById(R.id.firstStation);            endStation = itemView.findViewById(R.id.endStation);            price = itemView.findViewById(R.id.price);            mileage = itemView.findViewById(R.id.mileage);            recyclerControl = itemView.findViewById(R.id.recyclerControl);            recyclerView = itemView.findViewById(R.id.recyclerView);//            单击时二级列表显示或隐藏            recyclerControl.setOnClickListener(new View.OnClickListener() &#123;                @Override                public void onClick(View v) &#123;                    if (onRecyclerItemListener != null)&#123;//                        把线路id和列表对象作为参数传递                        onRecyclerItemListener.onItemClick(id.get(getAbsoluteAdapterPosition()),recyclerView);                    &#125;                &#125;            &#125;);//            点击顶部的线路名就跳转到定制班车，并把线路id作为参数传递过去            lineName.setOnClickListener(new View.OnClickListener() &#123;                @Override                public void onClick(View v) &#123;                    Intent intent = new Intent(context,BusMoreInfoActivity.class);                    intent.putExtra(&quot;BusId&quot;,id.get(getAbsoluteAdapterPosition()));                    context.startActivity(intent);                &#125;            &#125;);        &#125;    &#125;//    供外部调用，设置二级列表    private OnRecyclerItemListener onRecyclerItemListener;    public void setOnRecyclerItemListener(OnRecyclerItemListener onRecyclerItemListener) &#123;        this.onRecyclerItemListener = onRecyclerItemListener;    &#125;    public interface OnRecyclerItemListener&#123;        void onItemClick(int id,RecyclerView recyclerView);    &#125;&#125;
二级列表(线路的站点预览)的设置&ensp;&ensp;&ensp;&ensp;二级列表就是线路列表中的线路站点预览列表
二级列表站点的反序列化对象&ensp;&ensp;&ensp;&ensp;二级列表中线路所经过的所有站点的反序列化对象&ensp;&ensp;&ensp;&ensp;LineStationBean.javapackage com.SmartCity.Bus;import java.util.List;public class LineStationBean &#123;    private int total;    private List&lt;RowsBean&gt; rows;    private int code;    private String msg;    public int getTotal() &#123;        return total;    &#125;    public void setTotal(int total) &#123;        this.total = total;    &#125;    public List&lt;RowsBean&gt; getRows() &#123;        return rows;    &#125;    public void setRows(List&lt;RowsBean&gt; rows) &#123;        this.rows = rows;    &#125;    public int getCode() &#123;        return code;    &#125;    public void setCode(int code) &#123;        this.code = code;    &#125;    public String getMsg() &#123;        return msg;    &#125;    public void setMsg(String msg) &#123;        this.msg = msg;    &#125;    public static class RowsBean &#123;        private Object searchValue;        private Object createBy;        private Object createTime;        private Object updateBy;        private Object updateTime;        private Object remark;        private ParamsBean params;        private int linesId;        private int stepsId;        private String name;        private int sequence;        public Object getSearchValue() &#123;            return searchValue;        &#125;        public void setSearchValue(Object searchValue) &#123;            this.searchValue = searchValue;        &#125;        public Object getCreateBy() &#123;            return createBy;        &#125;        public void setCreateBy(Object createBy) &#123;            this.createBy = createBy;        &#125;        public Object getCreateTime() &#123;            return createTime;        &#125;        public void setCreateTime(Object createTime) &#123;            this.createTime = createTime;        &#125;        public Object getUpdateBy() &#123;            return updateBy;        &#125;        public void setUpdateBy(Object updateBy) &#123;            this.updateBy = updateBy;        &#125;        public Object getUpdateTime() &#123;            return updateTime;        &#125;        public void setUpdateTime(Object updateTime) &#123;            this.updateTime = updateTime;        &#125;        public Object getRemark() &#123;            return remark;        &#125;        public void setRemark(Object remark) &#123;            this.remark = remark;        &#125;        public ParamsBean getParams() &#123;            return params;        &#125;        public void setParams(ParamsBean params) &#123;            this.params = params;        &#125;        public int getLinesId() &#123;            return linesId;        &#125;        public void setLinesId(int linesId) &#123;            this.linesId = linesId;        &#125;        public int getStepsId() &#123;            return stepsId;        &#125;        public void setStepsId(int stepsId) &#123;            this.stepsId = stepsId;        &#125;        public String getName() &#123;            return name;        &#125;        public void setName(String name) &#123;            this.name = name;        &#125;        public int getSequence() &#123;            return sequence;        &#125;        public void setSequence(int sequence) &#123;            this.sequence = sequence;        &#125;        public static class ParamsBean &#123;        &#125;    &#125;&#125;
二级列表的item布局&ensp;&ensp;&ensp;&ensp;简单到不能再简单的列表item&ensp;&ensp;&ensp;&ensp;activity_bus_line_item.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout android:layout_height=&quot;38dp&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_marginLeft=&quot;18dp&quot;    android:orientation=&quot;horizontal&quot;    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;    &lt;View        android:background=&quot;@color/blue&quot;        android:layout_width=&quot;2dp&quot;        android:layout_height=&quot;match_parent&quot;/&gt;    &lt;TextView        android:text=&quot;stationName&quot;        android:id=&quot;@+id/stationName&quot;        android:gravity=&quot;center_vertical&quot;        android:textStyle=&quot;bold&quot;        android:layout_marginLeft=&quot;10dp&quot;        android:textSize=&quot;14sp&quot;        android:textColor=&quot;@color/black&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;match_parent&quot;/&gt;&lt;/LinearLayout&gt;
二级列表的适配器&ensp;&ensp;&ensp;&ensp;简单到不能再简单的适配器&ensp;&ensp;&ensp;&ensp;BusLineAdapter.javapackage com.SmartCity.Bus;import android.content.Context;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import android.widget.TextView;import androidx.annotation.NonNull;import androidx.recyclerview.widget.RecyclerView;import com.SmartCity.R;import java.util.List;public class BusLineAdapter extends RecyclerView.Adapter&lt;BusLineAdapter.MyViewHolder&gt; &#123;    private List&lt;String&gt; stationName;//线路名    private Context context;    public BusLineAdapter(List&lt;String&gt; stationName, Context context) &#123;        this.stationName = stationName;        this.context = context;    &#125;    @NonNull    @Override    public MyViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) &#123;        View view = LayoutInflater.from(context).inflate(R.layout.activity_bus_line_item,parent,false);        return new MyViewHolder(view);    &#125;    @Override    public void onBindViewHolder(@NonNull MyViewHolder holder, int position) &#123;        holder.stationName.setText(stationName.get(position));    &#125;    @Override    public int getItemCount() &#123;        return stationName.size();    &#125;    public class MyViewHolder extends RecyclerView.ViewHolder &#123;        private TextView stationName;        public MyViewHolder(@NonNull View itemView) &#123;            super(itemView);            stationName = itemView.findViewById(R.id.stationName);        &#125;    &#125;&#125;
定制班车路线详情的发序列化对象&ensp;&ensp;&ensp;&ensp;路线的详细信息的json反序列化对象&ensp;&ensp;&ensp;&ensp;LineInfoBean.javapackage com.SmartCity.Bus;public class LineInfoBean &#123;    private String msg;    private int code;    private DataBean data;    public String getMsg() &#123;        return msg;    &#125;    public void setMsg(String msg) &#123;        this.msg = msg;    &#125;    public int getCode() &#123;        return code;    &#125;    public void setCode(int code) &#123;        this.code = code;    &#125;    public DataBean getData() &#123;        return data;    &#125;    public void setData(DataBean data) &#123;        this.data = data;    &#125;    public static class DataBean &#123;        private Object searchValue;        private Object createBy;        private String createTime;        private Object updateBy;        private String updateTime;        private Object remark;        private ParamsBean params;        private int id;        private String name;        private String first;        private String end;        private String startTime;        private String endTime;        private double price;        private String mileage;        public Object getSearchValue() &#123;            return searchValue;        &#125;        public void setSearchValue(Object searchValue) &#123;            this.searchValue = searchValue;        &#125;        public Object getCreateBy() &#123;            return createBy;        &#125;        public void setCreateBy(Object createBy) &#123;            this.createBy = createBy;        &#125;        public String getCreateTime() &#123;            return createTime;        &#125;        public void setCreateTime(String createTime) &#123;            this.createTime = createTime;        &#125;        public Object getUpdateBy() &#123;            return updateBy;        &#125;        public void setUpdateBy(Object updateBy) &#123;            this.updateBy = updateBy;        &#125;        public String getUpdateTime() &#123;            return updateTime;        &#125;        public void setUpdateTime(String updateTime) &#123;            this.updateTime = updateTime;        &#125;        public Object getRemark() &#123;            return remark;        &#125;        public void setRemark(Object remark) &#123;            this.remark = remark;        &#125;        public ParamsBean getParams() &#123;            return params;        &#125;        public void setParams(ParamsBean params) &#123;            this.params = params;        &#125;        public int getId() &#123;            return id;        &#125;        public void setId(int id) &#123;            this.id = id;        &#125;        public String getName() &#123;            return name;        &#125;        public void setName(String name) &#123;            this.name = name;        &#125;        public String getFirst() &#123;            return first;        &#125;        public void setFirst(String first) &#123;            this.first = first;        &#125;        public String getEnd() &#123;            return end;        &#125;        public void setEnd(String end) &#123;            this.end = end;        &#125;        public String getStartTime() &#123;            return startTime;        &#125;        public void setStartTime(String startTime) &#123;            this.startTime = startTime;        &#125;        public String getEndTime() &#123;            return endTime;        &#125;        public void setEndTime(String endTime) &#123;            this.endTime = endTime;        &#125;        public double getPrice() &#123;            return price;        &#125;        public void setPrice(double price) &#123;            this.price = price;        &#125;        public String getMileage() &#123;            return mileage;        &#125;        public void setMileage(String mileage) &#123;            this.mileage = mileage;        &#125;        public static class ParamsBean &#123;        &#125;    &#125;&#125;
路线所有站点的反序列化对象&ensp;&ensp;&ensp;&ensp;某一路线途径的所有站点的反序列化对象&ensp;&ensp;&ensp;&ensp;LineStationBean.javapackage com.SmartCity.Bus;import java.util.List;public class LineStationBean &#123;    private int total;    private List&lt;RowsBean&gt; rows;    private int code;    private String msg;    public int getTotal() &#123;        return total;    &#125;    public void setTotal(int total) &#123;        this.total = total;    &#125;    public List&lt;RowsBean&gt; getRows() &#123;        return rows;    &#125;    public void setRows(List&lt;RowsBean&gt; rows) &#123;        this.rows = rows;    &#125;    public int getCode() &#123;        return code;    &#125;    public void setCode(int code) &#123;        this.code = code;    &#125;    public String getMsg() &#123;        return msg;    &#125;    public void setMsg(String msg) &#123;        this.msg = msg;    &#125;    public static class RowsBean &#123;        private Object searchValue;        private Object createBy;        private Object createTime;        private Object updateBy;        private Object updateTime;        private Object remark;        private ParamsBean params;        private int linesId;        private int stepsId;        private String name;        private int sequence;        public Object getSearchValue() &#123;            return searchValue;        &#125;        public void setSearchValue(Object searchValue) &#123;            this.searchValue = searchValue;        &#125;        public Object getCreateBy() &#123;            return createBy;        &#125;        public void setCreateBy(Object createBy) &#123;            this.createBy = createBy;        &#125;        public Object getCreateTime() &#123;            return createTime;        &#125;        public void setCreateTime(Object createTime) &#123;            this.createTime = createTime;        &#125;        public Object getUpdateBy() &#123;            return updateBy;        &#125;        public void setUpdateBy(Object updateBy) &#123;            this.updateBy = updateBy;        &#125;        public Object getUpdateTime() &#123;            return updateTime;        &#125;        public void setUpdateTime(Object updateTime) &#123;            this.updateTime = updateTime;        &#125;        public Object getRemark() &#123;            return remark;        &#125;        public void setRemark(Object remark) &#123;            this.remark = remark;        &#125;        public ParamsBean getParams() &#123;            return params;        &#125;        public void setParams(ParamsBean params) &#123;            this.params = params;        &#125;        public int getLinesId() &#123;            return linesId;        &#125;        public void setLinesId(int linesId) &#123;            this.linesId = linesId;        &#125;        public int getStepsId() &#123;            return stepsId;        &#125;        public void setStepsId(int stepsId) &#123;            this.stepsId = stepsId;        &#125;        public String getName() &#123;            return name;        &#125;        public void setName(String name) &#123;            this.name = name;        &#125;        public int getSequence() &#123;            return sequence;        &#125;        public void setSequence(int sequence) &#123;            this.sequence = sequence;        &#125;        public static class ParamsBean &#123;        &#125;    &#125;&#125;
站点列表的item&ensp;&ensp;&ensp;&ensp;注意这item是纵向的&ensp;&ensp;&ensp;&ensp;activity_bus_more_info_item.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout android:layout_height=&quot;match_parent&quot;    android:layout_width=&quot;48dp&quot;    android:orientation=&quot;vertical&quot;    android:gravity=&quot;center_horizontal&quot;    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;    &lt;ImageView        android:src=&quot;@mipmap/subway&quot;        android:layout_marginTop=&quot;10dp&quot;        android:layout_width=&quot;18dp&quot;        android:layout_height=&quot;18dp&quot;/&gt;    &lt;View        android:layout_marginTop=&quot;10dp&quot;        android:background=&quot;@color/blue&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;2dp&quot;/&gt;    &lt;TextView        android:text=&quot;n\na\nm\ne&quot;        android:textStyle=&quot;bold&quot;        android:textSize=&quot;16sp&quot;        android:id=&quot;@+id/stationName&quot;        android:textColor=&quot;@color/black&quot;        android:gravity=&quot;center_horizontal&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;wrap_content&quot;/&gt;&lt;/LinearLayout&gt;
站点列表的反序列化对象&ensp;&ensp;&ensp;&ensp;因为列表是纵向的，所以这里给线路名中间加入了\n&ensp;&ensp;&ensp;&ensp;BusMoreInfoAdapter.javapackage com.SmartCity.Bus;import android.content.Context;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import android.widget.TextView;import androidx.annotation.NonNull;import androidx.recyclerview.widget.RecyclerView;import com.SmartCity.R;import java.util.List;public class BusMoreInfoAdapter extends RecyclerView.Adapter&lt;BusMoreInfoAdapter.MyViewHolder&gt; &#123;    private Context context;    private List&lt;String&gt; lineStationList;    public BusMoreInfoAdapter(Context context, List&lt;String&gt; lineStationList) &#123;        this.context = context;        this.lineStationList = lineStationList;    &#125;    @NonNull    @Override    public MyViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) &#123;        View view = LayoutInflater.from(context).inflate(R.layout.activity_bus_more_info_item,parent,false);        return new MyViewHolder(view);    &#125;    @Override    public void onBindViewHolder(@NonNull MyViewHolder holder, int position) &#123;        String str = lineStationList.get(position).replaceAll(&quot;&quot;,&quot;\n&quot;);        holder.stationName.setText(str);    &#125;    @Override    public int getItemCount() &#123;        return lineStationList.size();    &#125;    public class MyViewHolder extends RecyclerView.ViewHolder &#123;        private TextView stationName;        public MyViewHolder(@NonNull View itemView) &#123;            super(itemView);            stationName = itemView.findViewById(R.id.stationName);        &#125;    &#125;&#125;
界面布局&ensp;&ensp;&ensp;&ensp;spinner是比较陌生的，重点看一下&ensp;&ensp;&ensp;&ensp;activity_bus_more_info.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:tools=&quot;http://schemas.android.com/tools&quot;    android:layout_height=&quot;match_parent&quot;    android:layout_width=&quot;match_parent&quot;    android:orientation=&quot;vertical&quot;    android:gravity=&quot;center_horizontal&quot;    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;    &lt;!--    Title--&gt;    &lt;LinearLayout        android:background=&quot;@color/blue&quot;        android:orientation=&quot;horizontal&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;58dp&quot;&gt;        &lt;LinearLayout            android:onClick=&quot;finishActivity&quot;            android:gravity=&quot;center&quot;            android:layout_width=&quot;58dp&quot;            android:layout_height=&quot;58dp&quot;&gt;            &lt;ImageView                android:src=&quot;@mipmap/back&quot;                android:layout_width=&quot;20dp&quot;                android:layout_height=&quot;20dp&quot;/&gt;        &lt;/LinearLayout&gt;        &lt;LinearLayout            android:gravity=&quot;center&quot;            android:layout_weight=&quot;1&quot;            android:layout_width=&quot;0dp&quot;            android:layout_height=&quot;match_parent&quot;&gt;            &lt;TextView                android:text=&quot;定制班车&quot;                android:textStyle=&quot;bold&quot;                android:textSize=&quot;18sp&quot;                android:textColor=&quot;@color/white&quot;                android:layout_width=&quot;wrap_content&quot;                android:layout_height=&quot;wrap_content&quot;/&gt;        &lt;/LinearLayout&gt;        &lt;LinearLayout            android:gravity=&quot;center&quot;            android:layout_width=&quot;58dp&quot;            android:layout_height=&quot;58dp&quot;&gt;        &lt;/LinearLayout&gt;    &lt;/LinearLayout&gt;    &lt;!--    Content--&gt;    &lt;ScrollView        android:background=&quot;@color/darker_gray&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;match_parent&quot;&gt;        &lt;LinearLayout            android:orientation=&quot;vertical&quot;            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;match_parent&quot;&gt;            &lt;LinearLayout                android:layout_marginTop=&quot;10dp&quot;                android:background=&quot;@color/white&quot;                android:orientation=&quot;horizontal&quot;                android:layout_width=&quot;match_parent&quot;                android:layout_height=&quot;wrap_content&quot;&gt;                &lt;TextView                    android:gravity=&quot;center&quot;                    android:id=&quot;@+id/firstStation&quot;                    android:text=&quot;起点: &quot;                    android:textColor=&quot;@color/black&quot;                    android:textSize=&quot;16sp&quot;                    android:textStyle=&quot;bold&quot;                    android:layout_width=&quot;0dp&quot;                    android:layout_height=&quot;48dp&quot;                    android:layout_weight=&quot;1&quot;/&gt;                &lt;TextView                    android:gravity=&quot;center&quot;                    android:text=&quot;终点: &quot;                    android:textColor=&quot;@color/black&quot;                    android:textSize=&quot;16sp&quot;                    android:id=&quot;@+id/endStation&quot;                    android:textStyle=&quot;bold&quot;                    android:layout_width=&quot;0dp&quot;                    android:layout_height=&quot;48dp&quot;                    android:layout_weight=&quot;1&quot;/&gt;            &lt;/LinearLayout&gt;            &lt;View                android:background=&quot;@color/darker_gray&quot;                android:layout_width=&quot;match_parent&quot;                android:layout_height=&quot;1dp&quot;/&gt;            &lt;LinearLayout                android:background=&quot;@color/white&quot;                android:orientation=&quot;horizontal&quot;                android:layout_width=&quot;match_parent&quot;                android:layout_height=&quot;wrap_content&quot;&gt;                &lt;TextView                    android:gravity=&quot;center&quot;                    android:text=&quot;票价: &quot;                    android:textColor=&quot;@color/black&quot;                    android:textSize=&quot;16sp&quot;                    android:id=&quot;@+id/price&quot;                    android:textStyle=&quot;bold&quot;                    android:layout_width=&quot;0dp&quot;                    android:layout_height=&quot;48dp&quot;                    android:layout_weight=&quot;1&quot;/&gt;                &lt;TextView                    android:gravity=&quot;center&quot;                    android:text=&quot;里程: &quot;                    android:textColor=&quot;@color/black&quot;                    android:textSize=&quot;16sp&quot;                    android:textStyle=&quot;bold&quot;                    android:id=&quot;@+id/mileage&quot;                    android:layout_width=&quot;0dp&quot;                    android:layout_height=&quot;48dp&quot;                    android:layout_weight=&quot;1&quot;/&gt;            &lt;/LinearLayout&gt;            &lt;androidx.recyclerview.widget.RecyclerView                android:id=&quot;@+id/recyclerView&quot;                android:layout_marginTop=&quot;10dp&quot;                android:layout_marginLeft=&quot;10dp&quot;                android:layout_marginRight=&quot;10dp&quot;                android:background=&quot;@color/white&quot;                android:layout_width=&quot;match_parent&quot;                android:layout_height=&quot;wrap_content&quot;/&gt;            &lt;LinearLayout                android:layout_marginTop=&quot;10dp&quot;                android:background=&quot;@color/white&quot;                android:orientation=&quot;horizontal&quot;                android:layout_width=&quot;match_parent&quot;                android:layout_height=&quot;48dp&quot;&gt;                &lt;TextView                    android:paddingLeft=&quot;20dp&quot;                    android:text=&quot;日期选择&quot;                    android:textColor=&quot;@color/black&quot;                    android:textSize=&quot;14sp&quot;                    android:textStyle=&quot;bold&quot;                    android:layout_width=&quot;0dp&quot;                    android:layout_weight=&quot;1&quot;                    android:gravity=&quot;center_vertical&quot;                    android:layout_height=&quot;match_parent&quot;/&gt;                &lt;TextView                    android:text=&quot;1999-01-01&quot;                    android:paddingRight=&quot;20dp&quot;                    android:textStyle=&quot;bold&quot;                    android:id=&quot;@+id/dateContent&quot;                    android:textSize=&quot;14sp&quot;                    android:textColor=&quot;@color/black&quot;                    android:layout_width=&quot;0dp&quot;                    android:layout_weight=&quot;1&quot;                    android:gravity=&quot;center_vertical|right&quot;                    android:layout_height=&quot;match_parent&quot;/&gt;            &lt;/LinearLayout&gt;            &lt;View                android:background=&quot;@color/darker_gray&quot;                android:layout_width=&quot;match_parent&quot;                android:layout_height=&quot;1dp&quot;/&gt;            &lt;LinearLayout                android:background=&quot;@color/white&quot;                android:orientation=&quot;horizontal&quot;                android:layout_width=&quot;match_parent&quot;                android:layout_height=&quot;48dp&quot;&gt;                &lt;TextView                    android:paddingLeft=&quot;20dp&quot;                    android:text=&quot;时间选择&quot;                    android:textColor=&quot;@color/black&quot;                    android:textSize=&quot;14sp&quot;                    android:textStyle=&quot;bold&quot;                    android:layout_width=&quot;0dp&quot;                    android:layout_weight=&quot;1&quot;                    android:gravity=&quot;center_vertical&quot;                    android:layout_height=&quot;match_parent&quot;/&gt;                &lt;TextView                    android:text=&quot;00:00&quot;                    android:paddingRight=&quot;20dp&quot;                    android:textStyle=&quot;bold&quot;                    android:textSize=&quot;14sp&quot;                    android:textColor=&quot;@color/black&quot;                    android:layout_width=&quot;0dp&quot;                    android:id=&quot;@+id/timeContent&quot;                    android:layout_weight=&quot;1&quot;                    android:gravity=&quot;center_vertical|right&quot;                    android:layout_height=&quot;match_parent&quot;/&gt;            &lt;/LinearLayout&gt;            &lt;View                android:background=&quot;@color/darker_gray&quot;                android:layout_width=&quot;match_parent&quot;                android:layout_height=&quot;1dp&quot;/&gt;            &lt;LinearLayout                android:background=&quot;@color/white&quot;                android:orientation=&quot;horizontal&quot;                android:layout_width=&quot;match_parent&quot;                android:layout_height=&quot;48dp&quot;&gt;                &lt;TextView                    android:paddingLeft=&quot;20dp&quot;                    android:text=&quot;乘客姓名&quot;                    android:textColor=&quot;@color/black&quot;                    android:textSize=&quot;14sp&quot;                    android:textStyle=&quot;bold&quot;                    android:layout_width=&quot;0dp&quot;                    android:layout_weight=&quot;1&quot;                    android:gravity=&quot;center_vertical&quot;                    android:layout_height=&quot;match_parent&quot;/&gt;                &lt;EditText                    android:background=&quot;@color/white&quot;                    android:hint=&quot;请输入乘客姓名&quot;                    android:paddingRight=&quot;20dp&quot;                    android:id=&quot;@+id/userName&quot;                    android:textStyle=&quot;bold&quot;                    android:textSize=&quot;14sp&quot;                    android:textColor=&quot;@color/black&quot;                    android:layout_width=&quot;0dp&quot;                    android:layout_weight=&quot;1&quot;                    android:inputType=&quot;text&quot;                    android:lines=&quot;1&quot;                    android:gravity=&quot;center_vertical|right&quot;                    android:layout_height=&quot;match_parent&quot;/&gt;            &lt;/LinearLayout&gt;            &lt;View                android:background=&quot;@color/darker_gray&quot;                android:layout_width=&quot;match_parent&quot;                android:layout_height=&quot;1dp&quot;/&gt;            &lt;LinearLayout                android:background=&quot;@color/white&quot;                android:orientation=&quot;horizontal&quot;                android:layout_width=&quot;match_parent&quot;                android:layout_height=&quot;48dp&quot;&gt;                &lt;TextView                    android:paddingLeft=&quot;20dp&quot;                    android:text=&quot;手机号码&quot;                    android:textColor=&quot;@color/black&quot;                    android:textSize=&quot;14sp&quot;                    android:textStyle=&quot;bold&quot;                    android:layout_width=&quot;0dp&quot;                    android:layout_weight=&quot;1&quot;                    android:gravity=&quot;center_vertical&quot;                    android:layout_height=&quot;match_parent&quot;/&gt;                &lt;EditText                    android:background=&quot;@color/white&quot;                    android:hint=&quot;请输入手机号码&quot;                    android:paddingRight=&quot;20dp&quot;                    android:id=&quot;@+id/phoneNumber&quot;                    android:textStyle=&quot;bold&quot;                    android:textSize=&quot;14sp&quot;                    android:textColor=&quot;@color/black&quot;                    android:layout_width=&quot;0dp&quot;                    android:layout_weight=&quot;1&quot;                    android:inputType=&quot;number&quot;                    android:lines=&quot;1&quot;                    android:gravity=&quot;center_vertical|right&quot;                    android:layout_height=&quot;match_parent&quot;/&gt;            &lt;/LinearLayout&gt;            &lt;View                android:background=&quot;@color/darker_gray&quot;                android:layout_width=&quot;match_parent&quot;                android:layout_height=&quot;1dp&quot;/&gt;            &lt;LinearLayout                android:background=&quot;@color/white&quot;                android:orientation=&quot;horizontal&quot;                android:layout_width=&quot;match_parent&quot;                android:layout_height=&quot;48dp&quot;&gt;                &lt;TextView                    android:paddingLeft=&quot;20dp&quot;                    android:text=&quot;上车地点&quot;                    android:textColor=&quot;@color/black&quot;                    android:textSize=&quot;14sp&quot;                    android:textStyle=&quot;bold&quot;                    android:layout_width=&quot;0dp&quot;                    android:layout_weight=&quot;1&quot;                    android:gravity=&quot;center_vertical&quot;                    android:layout_height=&quot;match_parent&quot;/&gt;                &lt;!--设置android:textAlignment=&quot;viewEnd&quot;使内容右对齐--&gt;                &lt;Spinner                    android:textAlignment=&quot;viewEnd&quot;                    android:textStyle=&quot;bold&quot;                    android:textSize=&quot;14sp&quot;                    android:textColor=&quot;@color/black&quot;                    android:layout_width=&quot;0dp&quot;                    android:id=&quot;@+id/inStation&quot;                    android:layout_weight=&quot;1&quot;                    android:gravity=&quot;center_vertical|right&quot;                    android:layout_height=&quot;match_parent&quot;                    tools:ignore=&quot;RtlCompat&quot; /&gt;            &lt;/LinearLayout&gt;            &lt;View                android:background=&quot;@color/darker_gray&quot;                android:layout_width=&quot;match_parent&quot;                android:layout_height=&quot;1dp&quot;/&gt;            &lt;LinearLayout                android:background=&quot;@color/white&quot;                android:orientation=&quot;horizontal&quot;                android:layout_width=&quot;match_parent&quot;                android:layout_height=&quot;48dp&quot;&gt;                &lt;TextView                    android:paddingLeft=&quot;20dp&quot;                    android:text=&quot;下车地点&quot;                    android:textColor=&quot;@color/black&quot;                    android:textSize=&quot;14sp&quot;                    android:textStyle=&quot;bold&quot;                    android:layout_width=&quot;0dp&quot;                    android:layout_weight=&quot;1&quot;                    android:gravity=&quot;center_vertical&quot;                    android:layout_height=&quot;match_parent&quot;/&gt;                &lt;Spinner                    android:textStyle=&quot;bold&quot;                    android:textSize=&quot;14sp&quot;                    android:textColor=&quot;@color/black&quot;                    android:textAlignment=&quot;viewEnd&quot;                    android:layout_width=&quot;0dp&quot;                    android:layout_weight=&quot;1&quot;                    android:id=&quot;@+id/outStation&quot;                    android:gravity=&quot;center_vertical|right&quot;                    android:layout_height=&quot;match_parent&quot;                    tools:ignore=&quot;RtlCompat&quot; /&gt;            &lt;/LinearLayout&gt;            &lt;Button                android:text=&quot;下一步&quot;                android:textColor=&quot;@color/white&quot;                android:textSize=&quot;16sp&quot;                android:onClick=&quot;nextActivity&quot;                android:textStyle=&quot;bold&quot;                android:layout_marginTop=&quot;10dp&quot;                android:layout_marginLeft=&quot;10dp&quot;                android:layout_marginRight=&quot;10dp&quot;                android:layout_marginBottom=&quot;10dp&quot;                android:background=&quot;@drawable/button_style2&quot;                android:layout_width=&quot;match_parent&quot;                android:layout_height=&quot;wrap_content&quot;/&gt;        &lt;/LinearLayout&gt;    &lt;/ScrollView&gt;&lt;/LinearLayout&gt;
程序设计&ensp;&ensp;&ensp;&ensp;日期时间选择器、spinner动态加载数据&ensp;&ensp;&ensp;&ensp;BusMoreInfoActivity.javapackage com.SmartCity.Bus;import androidx.annotation.NonNull;import androidx.appcompat.app.AppCompatActivity;import androidx.recyclerview.widget.LinearLayoutManager;import androidx.recyclerview.widget.RecyclerView;import android.annotation.SuppressLint;import android.app.DatePickerDialog;import android.app.TimePickerDialog;import android.content.Intent;import android.os.Bundle;import android.os.Handler;import android.os.Looper;import android.os.Message;import android.text.TextUtils;import android.view.View;import android.widget.AdapterView;import android.widget.ArrayAdapter;import android.widget.DatePicker;import android.widget.EditText;import android.widget.Spinner;import android.widget.TextView;import android.widget.TimePicker;import android.widget.Toast;import com.SmartCity.MyHttpRequest;import com.SmartCity.R;import java.util.ArrayList;import java.util.Calendar;import java.util.List;public class BusMoreInfoActivity extends AppCompatActivity implements View.OnClickListener &#123;    private int BusId;//线路的id    private String BusName;//线路名    private LineInfoBean lineInfoBean;//路线详情的json反序列化对象    private LineStationBean lineStationBean;//查询线路所有站点信息的json反序列对象    private Handler handler;//线程通信    private MyHttpRequest myHttpRequest = new MyHttpRequest();//服务器通信模块封装    private List&lt;String&gt; lineStationList = new ArrayList&lt;&gt;();//线路中所有站点的列表    private TextView firstStation,endStation,price,mileage;//起点、终点、票价、里程    private RecyclerView recyclerView;//线路列表    private TextView dateContent,timeContent;//日期选择、时间选择    private EditText userName,phoneNumber;//乘客姓名、乘客联系电话    private Spinner inStation,outStation;//上车地点、下车地点    private String date,time;//日期、时间    private Calendar calendar = Calendar.getInstance();//获取时间日期    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_bus_more_info);        myHandler();//线程通信        init();//初始化界面        submit();//设置监听        getData();//获取数据    &#125;//    线程通信    private void myHandler() &#123;        handler = new Handler(Looper.getMainLooper())&#123;            @Override            public void handleMessage(@NonNull Message msg) &#123;                super.handleMessage(msg);                if (msg.what == 1)&#123;                    setData();//验证数据正确性、预处理数据                &#125;            &#125;        &#125;;    &#125;//    验证数据正确性、预处理数据    private void setData() &#123;        if (lineInfoBean == null || lineStationBean == null)&#123;            Toast.makeText(this,&quot;线路信息获取错误: 未知原因&quot;,Toast.LENGTH_SHORT).show();        &#125;        else if (lineStationBean.getCode() != 200)&#123;            Toast.makeText(this,&quot;线路信息获取错误: &quot; + lineStationBean.getMsg(),Toast.LENGTH_SHORT).show();        &#125;        else if (lineInfoBean.getCode() != 200)&#123;            Toast.makeText(this,&quot;线路信息获取错误: &quot; + lineInfoBean.getMsg(),Toast.LENGTH_SHORT).show();        &#125;        else &#123;            for (int i = 0; i &lt; lineStationBean.getTotal(); i++) &#123;                lineStationList.add(lineStationBean.getRows().get(i).getName());            &#125;            showBusInfo();//显示线路信息        &#125;    &#125;//    显示线路信息    @SuppressLint(&quot;SetTextI18n&quot;)    private void showBusInfo() &#123;        BusName = lineInfoBean.getData().getName();//线路名        firstStation.setText(&quot;起点: &quot; + lineInfoBean.getData().getFirst());        endStation.setText(&quot;终点: &quot; + lineInfoBean.getData().getEnd());        price.setText(&quot;票价: &quot; + lineInfoBean.getData().getPrice());        mileage.setText(&quot;里程: &quot; + lineInfoBean.getData().getMileage() + &quot;km&quot;);//        年月日，并给月和日去零        date = calendar.get(Calendar.YEAR) + &quot;-&quot; +                ((calendar.get(Calendar.MONTH) + 1) &lt; 10 ? &quot;0&quot; + (calendar.get(Calendar.MONTH) + 1) : calendar.get(Calendar.MONTH) + 1) + &quot;-&quot; +                (calendar.get(Calendar.DAY_OF_MONTH) &lt; 10 ? &quot;0&quot; + calendar.get(Calendar.DAY_OF_MONTH) : calendar.get(Calendar.DAY_OF_MONTH));        dateContent.setText(date);//        时分秒，并给分钟去“0”        time = calendar.get(Calendar.HOUR_OF_DAY) + &quot;:&quot; +                (calendar.get(Calendar.MINUTE) &lt; 10 ? &quot;0&quot; + calendar.get(Calendar.MINUTE) : calendar.get(Calendar.MINUTE));        timeContent.setText(time);//        设置第一个下拉列表中的列表项        ArrayAdapter&lt;String&gt; adapter1 =new ArrayAdapter&lt;&gt;(this, android.R.layout.simple_spinner_item,lineStationList);        adapter1.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);        inStation.setAdapter(adapter1);//设置spinner的适配器        setOutStation();//下车点选择        setRecycler();//设置线路列表    &#125;//    当选中上车点的列表项时，动态获得下车点的列表项，防止下车点超过上车点    private void setOutStation() &#123;        inStation.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() &#123;            @Override//            这里的position就是列表项中选中的item的position，根据position得到outStation中的列表数据            public void onItemSelected(AdapterView&lt;?&gt; parent, View view, int position, long id) &#123;                List&lt;String&gt; lineStationList2 = new ArrayList&lt;&gt;();                for (int i = position + 1; i &lt; lineStationList.size(); i++) &#123;                    lineStationList2.add(lineStationList.get(i));                &#125;                ArrayAdapter&lt;String&gt; adapter2 = new ArrayAdapter&lt;&gt;(BusMoreInfoActivity.this,android.R.layout.simple_spinner_item,lineStationList2);                adapter2.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);                outStation.setAdapter(adapter2);            &#125;            @Override            public void onNothingSelected(AdapterView&lt;?&gt; parent) &#123;  &#125;        &#125;);    &#125;//    设置列表    private void setRecycler() &#123;        BusMoreInfoAdapter busMoreInfoAdapter = new BusMoreInfoAdapter(this,lineStationList);        LinearLayoutManager layoutManager = new LinearLayoutManager(this,RecyclerView.HORIZONTAL,false);        recyclerView.setAdapter(busMoreInfoAdapter);        recyclerView.setLayoutManager(layoutManager);    &#125;//    获取线路数据    private void getData() &#123;        lineInfoBean = (LineInfoBean) myHttpRequest.myHttp(&quot;/prod-api/api/bus/line/&quot; + BusId,null,LineInfoBean.class,null,&quot;get&quot;);        lineStationBean = (LineStationBean) myHttpRequest.myHttp(&quot;/prod-api/api/bus/stop/list?linesId=&quot; + BusId,null,LineStationBean.class,null,&quot;get&quot;);        Message message = Message.obtain();        message.what = 1;        handler.sendMessage(message);    &#125;//    初始化界面    private void init() &#123;        BusId = getIntent().getExtras().getInt(&quot;BusId&quot;);//从跳转来的页面中获取到传入的线路id        firstStation = findViewById(R.id.firstStation);        endStation = findViewById(R.id.endStation);        price = findViewById(R.id.price);        mileage = findViewById(R.id.mileage);        recyclerView = findViewById(R.id.recyclerView);        dateContent = findViewById(R.id.dateContent);        timeContent = findViewById(R.id.timeContent);        userName = findViewById(R.id.userName);        phoneNumber = findViewById(R.id.phoneNumber);        inStation = findViewById(R.id.inStation);        outStation = findViewById(R.id.outStation);    &#125;//    设置监听    private void submit() &#123;        dateContent.setOnClickListener(this);//日期选择        timeContent.setOnClickListener(this);//时间选择    &#125;//    “下一步”按钮的OnClick    public void nextActivity(View view) &#123;        String date = dateContent.getText().toString();//日期        String time = timeContent.getText().toString();//时间        String userName = this.userName.getText().toString();//乘客名        String phoneNumber = this.phoneNumber.getText().toString();//手机号        String inStation = this.inStation.getSelectedItem().toString();//上车地点        String outStation = this.outStation.getSelectedItem().toString();//下车地点        if (TextUtils.isEmpty(userName))&#123;            Toast.makeText(this,&quot;乘客姓名不可为空&quot;,Toast.LENGTH_SHORT).show();        &#125;        else if (TextUtils.isEmpty(phoneNumber))&#123;            Toast.makeText(this,&quot;手机号不可为空&quot;,Toast.LENGTH_SHORT).show();        &#125;        else if (phoneNumber.length() != 11)&#123;            Toast.makeText(this,&quot;手机号格式不正确&quot;,Toast.LENGTH_SHORT).show();        &#125;        else &#123;//            跳转到确认订单页            Intent intent = new Intent(this,ConfirmActivity.class);            intent.putExtra(&quot;date&quot;,date);            intent.putExtra(&quot;time&quot;,time);            intent.putExtra(&quot;userName&quot;,userName);            intent.putExtra(&quot;phoneNumber&quot;,phoneNumber);            intent.putExtra(&quot;inStation&quot;,inStation);            intent.putExtra(&quot;outStation&quot;,outStation);            intent.putExtra(&quot;BusName&quot;,BusName);            startActivity(intent);        &#125;    &#125;//    结束页面    public void finishActivity(View view) &#123;  finish();  &#125;//    时间日期选择时    @Override    public void onClick(View v) &#123;        switch (v.getId())&#123;            case R.id.dateContent://日期选择器                DatePickerDialog datePickerDialog = new DatePickerDialog(this, new DatePickerDialog.OnDateSetListener() &#123;                    @Override                    public void onDateSet(DatePicker view, int year, int month, int dayOfMonth) &#123;                        String date = year + &quot;-&quot; +                                ((month + 1) &lt; 10 ? &quot;0&quot; + (month + 1) : month + 1) + &quot;-&quot; +                                (dayOfMonth &lt; 10 ? &quot;0&quot; + dayOfMonth : dayOfMonth);                        dateContent.setText(date);                    &#125;                &#125;,//日期选择监听器                        calendar.get(Calendar.YEAR),//年                        calendar.get(Calendar.MONTH),//月                        calendar.get(Calendar.DAY_OF_MONTH));//日                datePickerDialog.show();//显示                break;            case R.id.timeContent://时间选择器                TimePickerDialog timePickerDialog = new TimePickerDialog(this, new TimePickerDialog.OnTimeSetListener() &#123;                    @Override                    public void onTimeSet(TimePicker view, int hourOfDay, int minute) &#123;                        String time = hourOfDay + &quot;:&quot; +                                (minute &lt; 10 ? &quot;0&quot; + minute : minute);                        timeContent.setText(time);                    &#125;                &#125;,//时间选择监听器                        calendar.get(Calendar.HOUR_OF_DAY),//小时                        calendar.get(Calendar.MINUTE),//分钟                        true);//是否24小时制                timePickerDialog.show();                break;        &#125;    &#125;&#125;
确认订单&ensp;&ensp;&ensp;&ensp;显示订单信息，确认信息无误后点击“提交订单”就可以提交了
订单提交结果的反序列化对象&ensp;&ensp;&ensp;&ensp;提交订单后，返回的json的反序列化对象&ensp;&ensp;&ensp;&ensp;CommitOrderBean.javapackage com.SmartCity.Bus;public class CommitOrderBean &#123;    private String msg;    private int code;    private String orderNum;    public String getMsg() &#123;        return msg;    &#125;    public void setMsg(String msg) &#123;        this.msg = msg;    &#125;    public int getCode() &#123;        return code;    &#125;    public void setCode(int code) &#123;        this.code = code;    &#125;    public String getOrderNum() &#123;        return orderNum;    &#125;    public void setOrderNum(String orderNum) &#123;        this.orderNum = orderNum;    &#125;&#125;
界面布局&ensp;&ensp;&ensp;&ensp;activity_confirm.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout android:layout_height=&quot;match_parent&quot;    android:layout_width=&quot;match_parent&quot;    android:orientation=&quot;vertical&quot;    android:gravity=&quot;center_horizontal&quot;    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;    &lt;!--    Title--&gt;    &lt;LinearLayout        android:background=&quot;@color/blue&quot;        android:orientation=&quot;horizontal&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;58dp&quot;&gt;        &lt;LinearLayout            android:onClick=&quot;finishActivity&quot;            android:gravity=&quot;center&quot;            android:layout_width=&quot;58dp&quot;            android:layout_height=&quot;58dp&quot;&gt;            &lt;ImageView                android:src=&quot;@mipmap/back&quot;                android:layout_width=&quot;20dp&quot;                android:layout_height=&quot;20dp&quot;/&gt;        &lt;/LinearLayout&gt;        &lt;LinearLayout            android:gravity=&quot;center&quot;            android:layout_weight=&quot;1&quot;            android:layout_width=&quot;0dp&quot;            android:layout_height=&quot;match_parent&quot;&gt;            &lt;TextView                android:text=&quot;确认订单&quot;                android:textStyle=&quot;bold&quot;                android:textSize=&quot;18sp&quot;                android:textColor=&quot;@color/white&quot;                android:layout_width=&quot;wrap_content&quot;                android:layout_height=&quot;wrap_content&quot;/&gt;        &lt;/LinearLayout&gt;        &lt;LinearLayout            android:gravity=&quot;center&quot;            android:layout_width=&quot;58dp&quot;            android:layout_height=&quot;58dp&quot;&gt;        &lt;/LinearLayout&gt;    &lt;/LinearLayout&gt;    &lt;!--    Content--&gt;    &lt;ScrollView        android:background=&quot;@color/darker_gray&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;match_parent&quot;&gt;        &lt;LinearLayout            android:orientation=&quot;vertical&quot;            android:background=&quot;@color/white&quot;            android:gravity=&quot;center_horizontal&quot;            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;wrap_content&quot;&gt;            &lt;LinearLayout                android:orientation=&quot;horizontal&quot;                android:layout_width=&quot;match_parent&quot;                android:layout_height=&quot;48dp&quot;&gt;                &lt;TextView                    android:text=&quot;线路名&quot;                    android:textSize=&quot;16sp&quot;                    android:textColor=&quot;@color/black&quot;                    android:textStyle=&quot;bold&quot;                    android:gravity=&quot;center_vertical&quot;                    android:paddingLeft=&quot;20dp&quot;                    android:layout_width=&quot;0dp&quot;                    android:layout_weight=&quot;1&quot;                    android:layout_height=&quot;match_parent&quot;/&gt;                &lt;TextView                    android:text=&quot;lineName&quot;                    android:id=&quot;@+id/lineName&quot;                    android:layout_width=&quot;0dp&quot;                    android:textSize=&quot;16sp&quot;                    android:textColor=&quot;@color/black&quot;                    android:textStyle=&quot;bold&quot;                    android:gravity=&quot;center_vertical|right&quot;                    android:paddingRight=&quot;20dp&quot;                    android:layout_weight=&quot;1&quot;                    android:layout_height=&quot;match_parent&quot;/&gt;            &lt;/LinearLayout&gt;            &lt;View                android:background=&quot;@color/darker_gray&quot;                android:layout_width=&quot;match_parent&quot;                android:layout_height=&quot;1dp&quot;/&gt;            &lt;LinearLayout                android:orientation=&quot;horizontal&quot;                android:layout_width=&quot;match_parent&quot;                android:layout_height=&quot;48dp&quot;&gt;                &lt;TextView                    android:text=&quot;乘客名&quot;                    android:textSize=&quot;16sp&quot;                    android:textColor=&quot;@color/black&quot;                    android:textStyle=&quot;bold&quot;                    android:gravity=&quot;center_vertical&quot;                    android:paddingLeft=&quot;20dp&quot;                    android:layout_width=&quot;0dp&quot;                    android:layout_weight=&quot;1&quot;                    android:layout_height=&quot;match_parent&quot;/&gt;                &lt;TextView                    android:text=&quot;userName&quot;                    android:id=&quot;@+id/userName&quot;                    android:layout_width=&quot;0dp&quot;                    android:textSize=&quot;16sp&quot;                    android:textColor=&quot;@color/black&quot;                    android:textStyle=&quot;bold&quot;                    android:gravity=&quot;center_vertical|right&quot;                    android:paddingRight=&quot;20dp&quot;                    android:layout_weight=&quot;1&quot;                    android:layout_height=&quot;match_parent&quot;/&gt;            &lt;/LinearLayout&gt;            &lt;View                android:background=&quot;@color/darker_gray&quot;                android:layout_width=&quot;match_parent&quot;                android:layout_height=&quot;1dp&quot;/&gt;            &lt;LinearLayout                android:orientation=&quot;horizontal&quot;                android:layout_width=&quot;match_parent&quot;                android:layout_height=&quot;48dp&quot;&gt;                &lt;TextView                    android:text=&quot;手机号&quot;                    android:textSize=&quot;16sp&quot;                    android:textColor=&quot;@color/black&quot;                    android:textStyle=&quot;bold&quot;                    android:gravity=&quot;center_vertical&quot;                    android:paddingLeft=&quot;20dp&quot;                    android:layout_width=&quot;0dp&quot;                    android:layout_weight=&quot;1&quot;                    android:layout_height=&quot;match_parent&quot;/&gt;                &lt;TextView                    android:text=&quot;phoneNumber&quot;                    android:id=&quot;@+id/phoneNumber&quot;                    android:layout_width=&quot;0dp&quot;                    android:textSize=&quot;16sp&quot;                    android:textColor=&quot;@color/black&quot;                    android:textStyle=&quot;bold&quot;                    android:gravity=&quot;center_vertical|right&quot;                    android:paddingRight=&quot;20dp&quot;                    android:layout_weight=&quot;1&quot;                    android:layout_height=&quot;match_parent&quot;/&gt;            &lt;/LinearLayout&gt;            &lt;View                android:background=&quot;@color/darker_gray&quot;                android:layout_width=&quot;match_parent&quot;                android:layout_height=&quot;1dp&quot;/&gt;            &lt;LinearLayout                android:orientation=&quot;horizontal&quot;                android:layout_width=&quot;match_parent&quot;                android:layout_height=&quot;48dp&quot;&gt;                &lt;TextView                    android:text=&quot;日期&quot;                    android:textSize=&quot;16sp&quot;                    android:textColor=&quot;@color/black&quot;                    android:textStyle=&quot;bold&quot;                    android:gravity=&quot;center_vertical&quot;                    android:paddingLeft=&quot;20dp&quot;                    android:layout_width=&quot;0dp&quot;                    android:layout_weight=&quot;1&quot;                    android:layout_height=&quot;match_parent&quot;/&gt;                &lt;TextView                    android:text=&quot;date&quot;                    android:id=&quot;@+id/date&quot;                    android:layout_width=&quot;0dp&quot;                    android:textSize=&quot;16sp&quot;                    android:textColor=&quot;@color/black&quot;                    android:textStyle=&quot;bold&quot;                    android:gravity=&quot;center_vertical|right&quot;                    android:paddingRight=&quot;20dp&quot;                    android:layout_weight=&quot;1&quot;                    android:layout_height=&quot;match_parent&quot;/&gt;            &lt;/LinearLayout&gt;            &lt;View                android:background=&quot;@color/darker_gray&quot;                android:layout_width=&quot;match_parent&quot;                android:layout_height=&quot;1dp&quot;/&gt;            &lt;LinearLayout                android:orientation=&quot;horizontal&quot;                android:layout_width=&quot;match_parent&quot;                android:layout_height=&quot;48dp&quot;&gt;                &lt;TextView                    android:text=&quot;时间&quot;                    android:textSize=&quot;16sp&quot;                    android:textColor=&quot;@color/black&quot;                    android:textStyle=&quot;bold&quot;                    android:gravity=&quot;center_vertical&quot;                    android:paddingLeft=&quot;20dp&quot;                    android:layout_width=&quot;0dp&quot;                    android:layout_weight=&quot;1&quot;                    android:layout_height=&quot;match_parent&quot;/&gt;                &lt;TextView                    android:text=&quot;time&quot;                    android:id=&quot;@+id/time&quot;                    android:layout_width=&quot;0dp&quot;                    android:textSize=&quot;16sp&quot;                    android:textColor=&quot;@color/black&quot;                    android:textStyle=&quot;bold&quot;                    android:gravity=&quot;center_vertical|right&quot;                    android:paddingRight=&quot;20dp&quot;                    android:layout_weight=&quot;1&quot;                    android:layout_height=&quot;match_parent&quot;/&gt;            &lt;/LinearLayout&gt;            &lt;View                android:background=&quot;@color/darker_gray&quot;                android:layout_width=&quot;match_parent&quot;                android:layout_height=&quot;1dp&quot;/&gt;            &lt;LinearLayout                android:orientation=&quot;horizontal&quot;                android:layout_width=&quot;match_parent&quot;                android:layout_height=&quot;48dp&quot;&gt;                &lt;TextView                    android:text=&quot;上车地点&quot;                    android:textSize=&quot;16sp&quot;                    android:textColor=&quot;@color/black&quot;                    android:textStyle=&quot;bold&quot;                    android:gravity=&quot;center_vertical&quot;                    android:paddingLeft=&quot;20dp&quot;                    android:layout_width=&quot;0dp&quot;                    android:layout_weight=&quot;1&quot;                    android:layout_height=&quot;match_parent&quot;/&gt;                &lt;TextView                    android:id=&quot;@+id/inStation&quot;                    android:layout_width=&quot;0dp&quot;                    android:layout_height=&quot;match_parent&quot;                    android:layout_weight=&quot;1&quot;                    android:gravity=&quot;center_vertical|right&quot;                    android:paddingRight=&quot;20dp&quot;                    android:text=&quot;inStation&quot;                    android:textColor=&quot;@color/black&quot;                    android:textSize=&quot;16sp&quot;                    android:textStyle=&quot;bold&quot; /&gt;            &lt;/LinearLayout&gt;            &lt;View                android:background=&quot;@color/darker_gray&quot;                android:layout_width=&quot;match_parent&quot;                android:layout_height=&quot;1dp&quot;/&gt;            &lt;LinearLayout                android:orientation=&quot;horizontal&quot;                android:layout_width=&quot;match_parent&quot;                android:layout_height=&quot;48dp&quot;&gt;                &lt;TextView                    android:text=&quot;下车地点&quot;                    android:textSize=&quot;16sp&quot;                    android:textColor=&quot;@color/black&quot;                    android:textStyle=&quot;bold&quot;                    android:gravity=&quot;center_vertical&quot;                    android:paddingLeft=&quot;20dp&quot;                    android:layout_width=&quot;0dp&quot;                    android:layout_weight=&quot;1&quot;                    android:layout_height=&quot;match_parent&quot;/&gt;                &lt;TextView                    android:text=&quot;outStation&quot;                    android:id=&quot;@+id/outStation&quot;                    android:layout_width=&quot;0dp&quot;                    android:textSize=&quot;16sp&quot;                    android:textColor=&quot;@color/black&quot;                    android:textStyle=&quot;bold&quot;                    android:gravity=&quot;center_vertical|right&quot;                    android:paddingRight=&quot;20dp&quot;                    android:layout_weight=&quot;1&quot;                    android:layout_height=&quot;match_parent&quot;/&gt;            &lt;/LinearLayout&gt;            &lt;View                android:background=&quot;@color/darker_gray&quot;                android:layout_width=&quot;match_parent&quot;                android:layout_height=&quot;1dp&quot;/&gt;            &lt;LinearLayout                android:background=&quot;@color/darker_gray&quot;                android:layout_width=&quot;match_parent&quot;                android:layout_height=&quot;wrap_content&quot;&gt;                &lt;Button                    android:onClick=&quot;commit&quot;                    android:textStyle=&quot;bold&quot;                    android:textColor=&quot;@color/white&quot;                    android:textSize=&quot;16sp&quot;                    android:text=&quot;提交订单&quot;                    android:layout_marginTop=&quot;10dp&quot;                    android:layout_marginBottom=&quot;10dp&quot;                    android:layout_marginRight=&quot;20dp&quot;                    android:layout_marginLeft=&quot;20dp&quot;                    android:background=&quot;@drawable/button_style2&quot;                    android:layout_width=&quot;match_parent&quot;                    android:layout_height=&quot;wrap_content&quot;/&gt;            &lt;/LinearLayout&gt;        &lt;/LinearLayout&gt;    &lt;/ScrollView&gt;&lt;/LinearLayout&gt;
程序设计&ensp;&ensp;&ensp;&ensp;订单提交成功后跳转到全部订单页面&ensp;&ensp;&ensp;&ensp;ConfirmActivity.javapackage com.SmartCity.Bus;import androidx.annotation.NonNull;import androidx.appcompat.app.AppCompatActivity;import android.content.Intent;import android.os.Bundle;import android.os.Handler;import android.os.Looper;import android.os.Message;import android.view.View;import android.widget.TextView;import android.widget.Toast;import com.SmartCity.MyHttpRequest;import com.SmartCity.R;import com.SmartCity.SoftData;import com.SmartCity.UserInfo.OrderActivity;public class ConfirmActivity extends AppCompatActivity &#123;    private Handler handler;//线程通信    private MyHttpRequest myHttpRequest = new MyHttpRequest();//服务器通信模块封装    private TextView lineName,userName,phoneNumber,date,time,inStation,outStation;    private String start,end,price,path;//上车点、下车点、票价、线路名    private int status = 0;//支付状态(0:未支付,1:已支付)    private CommitOrderBean commitOrderBean;//提交订单返回的json的反序列化对象    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_confirm);        myHandler();//线程通信        init();//初始化界面        getData();//获取提交订单的json字符串中的数据        setData();//显示上页填写的数据    &#125;    private void myHandler() &#123;        handler = new Handler(Looper.getMainLooper())&#123;            @Override            public void handleMessage(@NonNull Message msg) &#123;                super.handleMessage(msg);                if (msg.what == 1)&#123;                    if (commitOrderBean == null)&#123;                        Toast.makeText(ConfirmActivity.this,&quot;订单提交失败: 未知原因&quot;,Toast.LENGTH_SHORT).show();                    &#125;                    else if (commitOrderBean.getCode() != 200)&#123;                        Toast.makeText(ConfirmActivity.this,&quot;订单提交失败: &quot; + commitOrderBean.getMsg(),Toast.LENGTH_SHORT).show();                    &#125;                    else &#123;//                        跳转到支付订单页面                        Toast.makeText(ConfirmActivity.this,&quot;订单提交成功&quot;,Toast.LENGTH_SHORT).show();                        Intent intent = new Intent(ConfirmActivity.this, OrderActivity.class);                        startActivity(intent);                        finish();//关闭当前页面                    &#125;                &#125;            &#125;        &#125;;    &#125;//    获取json中要提交的数据    private void getData() &#123;        start = this.getIntent().getExtras().getString(&quot;inStation&quot;);        end = this.getIntent().getExtras().getString(&quot;outStation&quot;);        price = this.getIntent().getExtras().getString(&quot;price&quot;);        path = this.getIntent().getExtras().getString(&quot;BusName&quot;);    &#125;    //    设置上页传入的数据    private void setData() &#123;        lineName.setText(this.getIntent().getExtras().getString(&quot;BusName&quot;));        userName.setText(this.getIntent().getExtras().getString(&quot;userName&quot;));        phoneNumber.setText(this.getIntent().getExtras().getString(&quot;phoneNumber&quot;));        date.setText(this.getIntent().getExtras().getString(&quot;date&quot;));        time.setText(this.getIntent().getExtras().getString(&quot;time&quot;));        inStation.setText(this.getIntent().getExtras().getString(&quot;inStation&quot;));        outStation.setText(this.getIntent().getExtras().getString(&quot;outStation&quot;));    &#125;//    初始化界面    private void init() &#123;        lineName = findViewById(R.id.lineName);        userName = findViewById(R.id.userName);        phoneNumber = findViewById(R.id.phoneNumber);        date = findViewById(R.id.date);        time = findViewById(R.id.time);        inStation = findViewById(R.id.inStation);        outStation = findViewById(R.id.outStation);    &#125;//    提交按钮    public void commit(View view) &#123;        String json = &quot;&#123;\n&quot; +                &quot;\&quot;start\&quot;:\&quot;&quot; + start + &quot;\&quot;,\n&quot; +                &quot;\&quot;end\&quot;:\&quot;&quot; + end + &quot;\&quot;,\n&quot; +                &quot;\&quot;price\&quot;:\&quot;&quot; + price + &quot;\&quot;,\n&quot; +                &quot;\&quot;path\&quot;:\&quot;&quot; + path + &quot;\&quot;,\n&quot; +                &quot;\&quot;status\&quot;:&quot; + status + &quot;\n&quot; +                &quot;&#125;&quot;;        commitOrderBean = (CommitOrderBean) myHttpRequest.myHttp(&quot;/prod-api/api/bus/order&quot;,json,CommitOrderBean.class, SoftData.token,&quot;post&quot;);        Message message = Message.obtain();        message.what = 1;        handler.sendMessage(message);    &#125;    //    关闭页面    public void finishActivity(View view) &#123;  finish();  &#125;&#125;
全部订单&ensp;&ensp;&ensp;&ensp;全部订单页因为之前用不到，好像是直接跳过去了的
顶部按钮的两种状态&ensp;&ensp;&ensp;&ensp;蓝色边框白色背景&ensp;&ensp;&ensp;&ensp;outline_style.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;    &lt;stroke android:width=&quot;2dp&quot;        android:color=&quot;@color/blue&quot;/&gt;    &lt;solid android:color=&quot;@color/white&quot;/&gt;&lt;/shape&gt;&ensp;&ensp;&ensp;&ensp;蓝色背景&ensp;&ensp;&ensp;&ensp;outline_style2.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;    &lt;solid android:color=&quot;@color/blue&quot;/&gt;&lt;/shape&gt;
&ensp;&ensp;&ensp;&ensp;背景选择器&ensp;&ensp;&ensp;&ensp;order_button_style.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;    &lt;item android:state_selected=&quot;true&quot; android:drawable=&quot;@drawable/outline_style2&quot;/&gt;    &lt;item android:state_selected=&quot;false&quot; android:drawable=&quot;@drawable/outline_style&quot;/&gt;&lt;/selector&gt;
订单的反序列化对象&ensp;&ensp;&ensp;&ensp;当前账号下的所有订单及订单信息的反序列化对象&ensp;&ensp;&ensp;&ensp;OrderBean.javapackage com.SmartCity.UserInfo;import java.util.List;public class OrderBean &#123;    private int total;    private List&lt;RowsBean&gt; rows;    private int code;    private String msg;    public int getTotal() &#123;        return total;    &#125;    public void setTotal(int total) &#123;        this.total = total;    &#125;    public List&lt;RowsBean&gt; getRows() &#123;        return rows;    &#125;    public void setRows(List&lt;RowsBean&gt; rows) &#123;        this.rows = rows;    &#125;    public int getCode() &#123;        return code;    &#125;    public void setCode(int code) &#123;        this.code = code;    &#125;    public String getMsg() &#123;        return msg;    &#125;    public void setMsg(String msg) &#123;        this.msg = msg;    &#125;    public static class RowsBean &#123;        private int id;        private String orderNum;        private String path;        private String start;        private String end;        private int price;        private String userName;        private String userTel;        private int userId;        private int status;        private String paymentType;        private String payTime;        public int getId() &#123;            return id;        &#125;        public void setId(int id) &#123;            this.id = id;        &#125;        public String getOrderNum() &#123;            return orderNum;        &#125;        public void setOrderNum(String orderNum) &#123;            this.orderNum = orderNum;        &#125;        public String getPath() &#123;            return path;        &#125;        public void setPath(String path) &#123;            this.path = path;        &#125;        public String getStart() &#123;            return start;        &#125;        public void setStart(String start) &#123;            this.start = start;        &#125;        public String getEnd() &#123;            return end;        &#125;        public void setEnd(String end) &#123;            this.end = end;        &#125;        public int getPrice() &#123;            return price;        &#125;        public void setPrice(int price) &#123;            this.price = price;        &#125;        public String getUserName() &#123;            return userName;        &#125;        public void setUserName(String userName) &#123;            this.userName = userName;        &#125;        public String getUserTel() &#123;            return userTel;        &#125;        public void setUserTel(String userTel) &#123;            this.userTel = userTel;        &#125;        public int getUserId() &#123;            return userId;        &#125;        public void setUserId(int userId) &#123;            this.userId = userId;        &#125;        public int getStatus() &#123;            return status;        &#125;        public void setStatus(int status) &#123;            this.status = status;        &#125;        public String getPaymentType() &#123;            return paymentType;        &#125;        public void setPaymentType(String paymentType) &#123;            this.paymentType = paymentType;        &#125;        public String getPayTime() &#123;            return payTime;        &#125;        public void setPayTime(String payTime) &#123;            this.payTime = payTime;        &#125;    &#125;&#125;
订单列表的item&ensp;&ensp;&ensp;&ensp;使用了一个蓝色背景框的样式&ensp;&ensp;&ensp;&ensp;activity_order_item.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout android:layout_height=&quot;wrap_content&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_marginRight=&quot;20dp&quot;    android:layout_marginLeft=&quot;20dp&quot;    android:layout_marginTop=&quot;10dp&quot;    android:orientation=&quot;vertical&quot;    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;    &lt;LinearLayout        android:orientation=&quot;horizontal&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;48dp&quot;&gt;        &lt;TextView            android:text=&quot;订单编号&quot;            android:textSize=&quot;16sp&quot;            android:textStyle=&quot;bold&quot;            android:paddingLeft=&quot;20dp&quot;            android:textColor=&quot;@color/black&quot;            android:background=&quot;@color/white&quot;            android:gravity=&quot;center_vertical&quot;            android:layout_width=&quot;0dp&quot;            android:layout_weight=&quot;1&quot;            android:layout_height=&quot;match_parent&quot;/&gt;        &lt;TextView            android:text=&quot;订单编号&quot;            android:textSize=&quot;16sp&quot;            android:textStyle=&quot;bold&quot;            android:id=&quot;@+id/orderNumber&quot;            android:textColor=&quot;@color/black&quot;            android:background=&quot;@color/white&quot;            android:gravity=&quot;center_vertical|right&quot;            android:paddingRight=&quot;20dp&quot;            android:layout_width=&quot;0dp&quot;            android:layout_weight=&quot;1&quot;            android:layout_height=&quot;match_parent&quot;/&gt;    &lt;/LinearLayout&gt;    &lt;View        android:background=&quot;@color/darker_gray&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;1dp&quot;/&gt;    &lt;LinearLayout        android:orientation=&quot;horizontal&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;48dp&quot;&gt;        &lt;TextView            android:text=&quot;线路&quot;            android:textSize=&quot;16sp&quot;            android:textStyle=&quot;bold&quot;            android:paddingLeft=&quot;20dp&quot;            android:textColor=&quot;@color/black&quot;            android:background=&quot;@color/white&quot;            android:gravity=&quot;center_vertical&quot;            android:layout_width=&quot;0dp&quot;            android:layout_weight=&quot;1&quot;            android:layout_height=&quot;match_parent&quot;/&gt;        &lt;TextView            android:text=&quot;线路名&quot;            android:textSize=&quot;16sp&quot;            android:textStyle=&quot;bold&quot;            android:id=&quot;@+id/lineName&quot;            android:textColor=&quot;@color/black&quot;            android:background=&quot;@color/white&quot;            android:gravity=&quot;center_vertical|right&quot;            android:paddingRight=&quot;20dp&quot;            android:layout_width=&quot;0dp&quot;            android:layout_weight=&quot;1&quot;            android:layout_height=&quot;match_parent&quot;/&gt;    &lt;/LinearLayout&gt;    &lt;View        android:background=&quot;@color/darker_gray&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;1dp&quot;/&gt;    &lt;LinearLayout        android:orientation=&quot;horizontal&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;48dp&quot;&gt;        &lt;TextView            android:text=&quot;票价&quot;            android:textSize=&quot;16sp&quot;            android:textStyle=&quot;bold&quot;            android:paddingLeft=&quot;20dp&quot;            android:textColor=&quot;@color/black&quot;            android:background=&quot;@color/white&quot;            android:gravity=&quot;center_vertical&quot;            android:layout_width=&quot;0dp&quot;            android:layout_weight=&quot;1&quot;            android:layout_height=&quot;match_parent&quot;/&gt;        &lt;TextView            android:text=&quot;￥8&quot;            android:textSize=&quot;16sp&quot;            android:textStyle=&quot;bold&quot;            android:id=&quot;@+id/price&quot;            android:textColor=&quot;@color/black&quot;            android:background=&quot;@color/white&quot;            android:gravity=&quot;center_vertical|right&quot;            android:paddingRight=&quot;20dp&quot;            android:layout_width=&quot;0dp&quot;            android:layout_weight=&quot;1&quot;            android:layout_height=&quot;match_parent&quot;/&gt;    &lt;/LinearLayout&gt;    &lt;TextView        android:text=&quot;支付订单&quot;        android:gravity=&quot;center&quot;        android:background=&quot;@drawable/order_button_style&quot;        android:textColor=&quot;@color/black&quot;        android:textStyle=&quot;bold&quot;        android:textSize=&quot;16sp&quot;        android:id=&quot;@+id/orderPay&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;48dp&quot;/&gt;&lt;/LinearLayout&gt;
订单列表的适配器&ensp;&ensp;&ensp;&ensp;支付按钮的click供外部调用，如果已经支付过的订单，则不显示支付按钮&ensp;&ensp;&ensp;&ensp;OrderAdapter.javapackage com.SmartCity.UserInfo;import android.content.Context;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import android.widget.TextView;import androidx.annotation.NonNull;import androidx.recyclerview.widget.RecyclerView;import com.SmartCity.R;import java.util.List;public class OrderAdapter extends RecyclerView.Adapter&lt;OrderAdapter.MyViewHolder&gt; &#123;    private List&lt;List&lt;String&gt;&gt; pay;    private Context context;    public OrderAdapter(List&lt;List&lt;String&gt;&gt; pay, Context context) &#123;        this.pay = pay;        this.context = context;    &#125;    @NonNull    @Override    public MyViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) &#123;        View view = LayoutInflater.from(context).inflate(R.layout.activity_order_item,parent,false);        return new MyViewHolder(view);    &#125;    @Override    public void onBindViewHolder(@NonNull MyViewHolder holder, int position) &#123;        holder.orderNumber.setText(pay.get(0).get(position));        holder.lineName.setText(pay.get(1).get(position));        holder.price.setText(&quot;￥&quot; + pay.get(2).get(position));//        如果是已经支付过的，则不显示支付按钮        if (pay.get(3).get(position).equals(&quot;1&quot;))&#123;            holder.orderPay.setVisibility(View.GONE);        &#125;        else &#123;            holder.orderPay.setVisibility(View.VISIBLE);        &#125;    &#125;    @Override    public int getItemCount() &#123;        return pay.get(0).size();    &#125;    public class MyViewHolder extends RecyclerView.ViewHolder &#123;        private TextView orderNumber,lineName,price,orderPay;        public MyViewHolder(@NonNull View itemView) &#123;            super(itemView);            orderNumber = itemView.findViewById(R.id.orderNumber);            lineName = itemView.findViewById(R.id.lineName);            price = itemView.findViewById(R.id.price);            orderPay = itemView.findViewById(R.id.orderPay);//            支付按钮            orderPay.setOnClickListener(new View.OnClickListener() &#123;                @Override                public void onClick(View v) &#123;                    if (onRecyclerListener != null)&#123;                        onRecyclerListener.OnItemClick(pay.get(0).get(getAbsoluteAdapterPosition()));                    &#125;                &#125;            &#125;);        &#125;    &#125;    private OnRecyclerListener onRecyclerListener;    public void setOnRecyclerListener(OnRecyclerListener onRecyclerListener) &#123;        this.onRecyclerListener = onRecyclerListener;    &#125;    public interface OnRecyclerListener&#123;        void OnItemClick(String orderNumber);    &#125;&#125;
界面布局&ensp;&ensp;&ensp;&ensp;注意理解顶部两个按钮的状态改变&ensp;&ensp;&ensp;&ensp;activity_order.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout android:layout_height=&quot;match_parent&quot;    android:layout_width=&quot;match_parent&quot;    android:orientation=&quot;vertical&quot;    android:gravity=&quot;center_horizontal&quot;    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;    &lt;!--    Title--&gt;    &lt;LinearLayout        android:background=&quot;@color/blue&quot;        android:orientation=&quot;horizontal&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;58dp&quot;&gt;        &lt;LinearLayout            android:onClick=&quot;finishActivity&quot;            android:gravity=&quot;center&quot;            android:layout_width=&quot;58dp&quot;            android:layout_height=&quot;58dp&quot;&gt;            &lt;ImageView                android:src=&quot;@mipmap/back&quot;                android:layout_width=&quot;20dp&quot;                android:layout_height=&quot;20dp&quot;/&gt;        &lt;/LinearLayout&gt;        &lt;LinearLayout            android:gravity=&quot;center&quot;            android:layout_weight=&quot;1&quot;            android:layout_width=&quot;0dp&quot;            android:layout_height=&quot;match_parent&quot;&gt;            &lt;TextView                android:text=&quot;我的订单&quot;                android:textStyle=&quot;bold&quot;                android:textSize=&quot;18sp&quot;                android:textColor=&quot;@color/white&quot;                android:layout_width=&quot;wrap_content&quot;                android:layout_height=&quot;wrap_content&quot;/&gt;        &lt;/LinearLayout&gt;        &lt;LinearLayout            android:gravity=&quot;center&quot;            android:layout_width=&quot;58dp&quot;            android:layout_height=&quot;58dp&quot;&gt;        &lt;/LinearLayout&gt;    &lt;/LinearLayout&gt;    &lt;!--    Content--&gt;    &lt;LinearLayout        android:background=&quot;@color/darker_gray&quot;        android:orientation=&quot;vertical&quot;        android:gravity=&quot;center_horizontal&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;match_parent&quot;&gt;        &lt;LinearLayout            android:orientation=&quot;horizontal&quot;            android:layout_marginRight=&quot;60dp&quot;            android:layout_marginLeft=&quot;60dp&quot;            android:layout_marginTop=&quot;10dp&quot;            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;60dp&quot;&gt;            &lt;TextView                android:background=&quot;@drawable/order_button_style&quot;                android:text=&quot;未支付&quot;                android:textSize=&quot;16sp&quot;                android:id=&quot;@+id/button0&quot;                android:textColor=&quot;@color/white&quot;                android:textStyle=&quot;bold&quot;                android:gravity=&quot;center&quot;                android:layout_width=&quot;0dp&quot;                android:layout_weight=&quot;1&quot;                android:layout_height=&quot;match_parent&quot;/&gt;            &lt;TextView                android:text=&quot;已支付&quot;                android:gravity=&quot;center&quot;                android:id=&quot;@+id/button1&quot;                android:textSize=&quot;16sp&quot;                android:textColor=&quot;@color/black&quot;                android:textStyle=&quot;bold&quot;                android:background=&quot;@drawable/order_button_style&quot;                android:layout_width=&quot;0dp&quot;                android:layout_weight=&quot;1&quot;                android:layout_height=&quot;match_parent&quot;/&gt;        &lt;/LinearLayout&gt;        &lt;androidx.recyclerview.widget.RecyclerView            android:id=&quot;@+id/recyclerView&quot;            android:visibility=&quot;visible&quot;            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;wrap_content&quot;/&gt;    &lt;/LinearLayout&gt;&lt;/LinearLayout&gt;
程序设计&ensp;&ensp;&ensp;&ensp;通过一个过渡集合，在“支付”和“未支付”两个集合中来回克隆，使一个RecyclerView刷新数据，达到两个RecyclerView的效果&ensp;&ensp;&ensp;&ensp;OrderActivity.javapackage com.SmartCity.UserInfo;import androidx.annotation.NonNull;import androidx.appcompat.app.AppCompatActivity;import androidx.recyclerview.widget.LinearLayoutManager;import androidx.recyclerview.widget.RecyclerView;import android.os.Bundle;import android.os.Handler;import android.os.Looper;import android.os.Message;import android.view.View;import android.widget.TextView;import android.widget.Toast;import com.SmartCity.Bean;import com.SmartCity.MyHttpRequest;import com.SmartCity.R;import com.SmartCity.SoftData;import java.util.ArrayList;import java.util.List;public class OrderActivity extends AppCompatActivity implements View.OnClickListener &#123;    private MyHttpRequest myHttpRequest = new MyHttpRequest();//服务器通信模块封装    private Handler handler;//线程通信模块    private OrderBean orderBean;//所有订单的json字符串反序列化对象    private List&lt;List&lt;String&gt;&gt; alreadyPay;//已支付订单    private List&lt;List&lt;String&gt;&gt; noPay;//未支付订单    private List&lt;List&lt;String&gt;&gt; pay;//克隆1或2，最终传入adapter    private RecyclerView recyclerView;//订单列表    private OrderAdapter orderAdapter;//适配器    private TextView button0,button1;//顶部的两个按钮    private Bean bean;//默认的反序列化列表    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_order);        myHandler();//线程通信        init();//初始化界面        getData();//获取所有订单数据    &#125;//    获取所有订单数据    private void getData() &#123;        new Thread()&#123;            @Override            public void run() &#123;                super.run();                orderBean = (OrderBean) myHttpRequest.myHttp(&quot;/prod-api/api/bus/order/list&quot;,null,OrderBean.class, SoftData.token,&quot;get&quot;);                Message message = Message.obtain();                message.what = 1;                handler.sendMessage(message);            &#125;        &#125;.start();    &#125;//    线程通信    private void myHandler() &#123;        handler = new Handler(Looper.getMainLooper())&#123;            @Override            public void handleMessage(@NonNull Message msg) &#123;                super.handleMessage(msg);                if (msg.what == 1)&#123;                    setData(0);                &#125;            &#125;        &#125;;    &#125;//    将支付或未支付的订单的集合克隆到最终传入到adapter的集合中    private void setData(int status) &#123;        setList();//创建集合、拿到数据        setButtonStyle(status);//设置按钮样式//        判断显示未支付或者已支付的订单        if (status == 0)&#123;            pay.addAll(noPay);        &#125;        else &#123;            pay.addAll(alreadyPay);        &#125;        setRecycler();//设置列表显示数据    &#125;//    设置按钮样式    private void setButtonStyle(int status) &#123;        if (status == 0)&#123;            button0.setTextColor(getResources().getColor(R.color.white));            button0.setSelected(true);            button1.setTextColor(getResources().getColor(R.color.black));            button1.setSelected(false);        &#125;        else if (status == 1)&#123;            button1.setTextColor(getResources().getColor(R.color.white));            button1.setSelected(true);            button0.setTextColor(getResources().getColor(R.color.black));            button0.setSelected(false);        &#125;    &#125;//    设置列表显示数据    private void setRecycler() &#123;        if (orderAdapter == null)&#123;            orderAdapter = new OrderAdapter(pay,this);            LinearLayoutManager layoutManager = new LinearLayoutManager(this, RecyclerView.VERTICAL,false);            recyclerView.setAdapter(orderAdapter);            recyclerView.setLayoutManager(layoutManager);        &#125;        else &#123;            orderAdapter.notifyDataSetChanged();        &#125;        orderAdapter.setOnRecyclerListener(new OrderAdapter.OnRecyclerListener() &#123;            @Override            public void OnItemClick(String orderNumber) &#123;                payOrder(orderNumber);//支付订单，传入订单号            &#125;        &#125;);    &#125;//    点击支付订单    private void payOrder(String orderNumber) &#123;        String json = &quot;&#123;\n&quot; +                &quot;\&quot;orderNum\&quot;: \&quot;&quot; + orderNumber + &quot;\&quot;,\n&quot; +                &quot;\&quot;paymentType\&quot;: \&quot;电子支付\&quot;\n&quot; +                &quot;&#125;&quot;;        bean = (Bean) myHttpRequest.myHttp(&quot;/prod-api/api/bus/pay&quot;,json,Bean.class,SoftData.token,&quot;post&quot;);        if (bean == null)&#123;            Toast.makeText(this,&quot;支付失败: 未知原因&quot;,Toast.LENGTH_SHORT).show();        &#125;        else if (bean.getCode() != 200)&#123;            Toast.makeText(this,&quot;支付失败: &quot; + bean.getMsg(),Toast.LENGTH_SHORT).show();        &#125;        else &#123;            Toast.makeText(this,&quot;支付成功&quot;,Toast.LENGTH_SHORT).show();            getData();//重新获得数据        &#125;    &#125;    //    得到的集合中的数据    private void setList() &#123;        if (pay == null)&#123;            pay = new ArrayList&lt;&gt;();//只用作克隆            noPay = new ArrayList&lt;&gt;();            alreadyPay = new ArrayList&lt;&gt;();//            创建集合中的集合            for (int i = 0; i &lt; 4; i++) &#123;                noPay.add(new ArrayList&lt;&gt;());                alreadyPay.add(new ArrayList&lt;&gt;());            &#125;        &#125;        else &#123;            pay.clear();//            清空集合中的集合            for (int i = 0; i &lt; 4; i++) &#123;                noPay.get(i).clear();                alreadyPay.get(i).clear();            &#125;        &#125;//        得到集合数据        for (int i = 0; i &lt; orderBean.getTotal(); i++) &#123;            if (orderBean.getRows().get(i).getStatus() == 0)&#123;                noPay.get(0).add(orderBean.getRows().get(i).getOrderNum());                noPay.get(1).add(orderBean.getRows().get(i).getPath());                noPay.get(2).add(String.valueOf(orderBean.getRows().get(i).getPrice()));                noPay.get(3).add(String.valueOf(orderBean.getRows().get(i).getStatus()));            &#125;            else if(orderBean.getRows().get(i).getStatus() == 1)&#123;                alreadyPay.get(0).add(orderBean.getRows().get(i).getOrderNum());                alreadyPay.get(1).add(orderBean.getRows().get(i).getPath());                alreadyPay.get(2).add(String.valueOf(orderBean.getRows().get(i).getPrice()));                alreadyPay.get(3).add(String.valueOf(orderBean.getRows().get(i).getStatus()));            &#125;        &#125;    &#125;//    初始化界面    private void init() &#123;        recyclerView = findViewById(R.id.recyclerView);        button0 = findViewById(R.id.button0);        button1 = findViewById(R.id.button1);        button0.setOnClickListener(this);        button1.setOnClickListener(this);        button0.setSelected(true);    &#125;//    结束页面    public void finishActivity(View view) &#123;  finish();  &#125;//    顶部两个按钮点击时    @Override    public void onClick(View v) &#123;        switch (v.getId())&#123;            case R.id.button0://                为0时加载未支付列表                setData(0);                break;            case R.id.button1://                为1时加载支付列表                setData(1);                break;        &#125;    &#125;&#125;
比赛不让用ViewPager2，其它都能忍，这个忍不了，不写了，操！给开放个阿里云仓，谁想用什么自己找，谁本事大谁赢不就是了?
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android开发手记</tag>
        <tag>智慧城市</tag>
      </tags>
  </entry>
  <entry>
    <title>Configuration类的常量与变量</title>
    <url>/2021/11/17/Configuration%E7%B1%BB%E7%9A%84%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[&ensp;&ensp;&ensp;&ensp;Android中Configuration类专门用于描述手机设备上的配置信息,这些配置信息既包括用户特定的配置项,也包括系统的动态设备配置。
官方文档: https://developer.android.com/reference/android/content/res/Configuration中国地址: https://developer.android.google.cn/reference/android/content/res/Configuration
在AndroidManifest.xml添加：&lt; uses-permission android:name=&quot;android.permission.CHANGE_CONFIGURATION&quot; /&gt;在&lt; activity标签中添加:android:configChanges=&quot;orientation&quot;
Configuration对象&ensp;&ensp;&ensp;&ensp;对象获得Configuration configuration = getResources().getConfiguration();
Configuration变量public int colorMode;             // 屏幕颜色的Bitpublic int densityDpi;            // 得到屏幕的像素密度public float fontScale;           // 获取当前用户设置的字体的缩放因子public int hardKeyboardHidden;    // 判断硬键盘是否可见，有两个可选值：HARDKEYBOARDHIDDEN_NO,HARDKEYBOARDHIDDEN_YES，分别是十六进制的0和1public int keyboard;              // 获取设备当前关联额键盘类型，该属性的返回值：KEYBOARD_12KEY（只有12个键的小键盘）、KEYBOARD_NOKEYS、KEYBOARD_QWERTY（普通键盘）public int keyboardHidden;        /* 该属性会返回一个boolean值用于表示当前的键盘是否可用,该属性不仅                                                                                                                   * 会判断系统的硬件键盘,也会判断系统位于屏幕上的软键盘,如果该系统                                       * 的硬件键盘不可用但软键盘可用该属性会返回KEYBOARDHIDDEN_NO,只                                    * 有当两个键盘都不可用的时候才返回KEYBOARDHIDDEN_YES                                   * *//** @deprecated(弃用) */          @Deprecated                       public Locale locale;             // 获取用户当前的语言环境public int mcc;                   // 得到移动信号的国家码public int mnc;                   // 得到移动信号的网络码public int navigation;            /* 判断系统上方向导航设备的类型。该属性的返回值：                                    * NAVIGATION_NONAV（无导航）、NAVIGATION_DPAD(DPAD导航）、                                    * NAVIGATION_TRACKBALL（轨迹球导航）、NAVIGATION_WHEEL（滚轮导航）                                   * */public int navigationHidden;      /* 全部5个案件或者DPAD(上下左右中按键)导航是否可用，                                   * 返回NAVIGATIONHIDDEN_NO(不可用)，NAVIGATIONHIDDEN_YES(可用)                                   * */public int orientation;           /* 得到系统屏幕的方向,该属性将会返回ORIENTATION_LANDSCAPE(横向                                    * 屏幕),ORIENTATION_PORTRAIT(竖向屏幕),ORIENTATION_SQUARE(方                                    * 形屏幕)三个属性值之一                                   * */public int screenHeightDp;        // 屏幕可用高和宽，用dp表示public int screenLayout;          // 屏幕整体布局的位掩码public int screenWidthDp;         // 当前可用的屏幕空间的宽度，以dp为单位public int smallestScreenWidthDp; // 应用程序在正常操作中看到的最小屏幕大小public int touchscreen;           /* 获取系统触摸屏的触摸方式。该属性的返回值：                                    * TOUCHSCREEN_NOTOUCH（无触摸屏）、TOUCHSCREEN_STYLUS（触摸笔                                    * 式触摸屏）、TOUCHSCREEN_FINGER（接收手指的触摸屏）等属性值                                   * */public int uiMode;                // ui的bit
Configuration常量&ensp;&ensp;&ensp;&ensp;复制别人的，好多都写错了，建议看官方文档

    
        
            常数
        
        
            int
            density_dpi_undefined
            默认值densitydpi这表明没有宽度已被指定。
        
        
            int
            hardkeyboardhidden_no
            常数hardkeyboardhidden的相应值，物理键盘被暴露。
        
        
            int
            hardkeyboardhidden_undefined
            常数hardkeyboardhidden：一个值表示没有值已设置。
        
        
            int
            hardkeyboardhidden_yes
            常数hardkeyboardhidden的相应值，物理键盘被隐藏。
        
        
            int
            keyboardhidden_no
            常数keyboardhidden的相应值， keysexposed资源限定符。
        
        
            int
            keyboardhidden_undefined
            常数keyboardhidden：一个值表示没有值已设置。
        
        
            int
            keyboardhidden_yes
            常数keyboardhidden的相应值， keyshidden资源限定符。
        
        
            int
            keyboard_12key
            常数keyboard的相应值， 12key资源限定符。
        
        
            int
            keyboard_nokeys
            常数keyboard的相应值， nokeys资源限定符。
        
        
            int
            keyboard_qwerty
            常数keyboard的相应值， 键盘资源限定符。
        
        
            int
            keyboard_undefined
            常数keyboard：一个值表示没有值已设置。
        
        
            int
            navigationhidden_no
            常数navigationhidden的相应值， navexposed资源限定符。
        
        
            int
            navigationhidden_undefined
            常数navigationhidden：一个值表示没有值已设置。
        
        
            int
            navigationhidden_yes
            常数navigationhidden的相应值， navhidden资源限定符。
        
        
            int
            navigation_dpad
            常数navigation（导航）的相应值， 东风标致资源限定符。
        
        
            int
            navigation_nonav
            常数navigation（导航）的相应值， nonav资源限定符。
        
        
            int
            navigation_trackball
            常数navigation（导航）的相应值， 轨迹球资源限定符。
        
        
            int
            navigation_undefined
            常数navigation（导航）：一个值表示没有值已设置。
        
        
            int
            navigation_wheel
            常数导航的相应值， 轮资源限定符。
        
        
            int
            orientation_landscape
            常数定位的相应值， 土地资源限定符。
        
        
            int
            orientation_portrait
            常数定位的相应值， 港口资源限定符。
        
        
            int
            orientation_square
            这种不断的被废弃的在API级别16。目前不支持或使用。
        
        
            int
            orientation_undefined
            常数定位：一个值表示没有值已设置。
        
        
            int
            screenlayout_layoutdir_ltr
            
                常数screenlayout：一个screenlayout_layoutdir_mask值表示一个布局目录已被设置为LTR。
        
        
            int
            screenlayout_layoutdir_mask
            常数screenlayout：编码布局方向位。
        
        
            int
            screenlayout_layoutdir_rtl
            
                常数screenlayout：一个screenlayout_layoutdir_mask值表示一个目录被设置为RTL布局。
        
        
            int
            screenlayout_layoutdir_shift
            常数screenlayout：位移到布局方向。
        
        
            int
            screenlayout_layoutdir_undefined
            
                常数screenlayout：一个screenlayout_layoutdir_mask值表示没有布局方向已定。
        
        
            int
            screenlayout_long_mask
            常数screenlayout：编码的纵横比位。
        
        
            int
            screenlayout_long_no
            常数screenlayout：一个screenlayout_long_mask价值相当于
                不久资源限定符。
        
        
            int
            screenlayout_long_undefined
            
                常数screenlayout：一个screenlayout_long_mask值表示没有大小已设置。
        
        
            int
            screenlayout_long_yes
            常数screenlayout：一个screenlayout_long_mask价值相当于
                长资源限定符。
        
        
            int
            screenlayout_size_large
            
                常数screenlayout：一个screenlayout_size_mask值指示屏幕至少约为480x640 dp单位，对应于 大资源限定符。
        
        
            int
            screenlayout_size_mask
            常数screenlayout：编码比特的大小。
        
        
            int
            screenlayout_size_normal
            
                常数screenlayout：一个screenlayout_size_mask值指示屏幕至少约320x470 dp单位，对应于 正常的资源限定符。
        
        
            int
            screenlayout_size_small
            
                常数screenlayout：一个screenlayout_size_mask值指示屏幕至少约320x426 dp单位，对应于 小资源限定符。
        
        
            int
            screenlayout_size_undefined
            
                常数screenlayout：一个screenlayout_size_mask值表示没有大小已设置。
        
        
            int
            screenlayout_size_xlarge
            
                常数screenlayout：一个screenlayout_size_mask值指示屏幕至少约720x960 dp单位，对应于 超大资源限定符。
        
        
            int
            screenlayout_undefined
            常数screenlayout：一个值表示screenlayout是未定义的
        
        
            int
            screen_height_dp_undefined
            默认值screenHeightDp这表明没有宽度已被指定。
        
        
            int
            screen_width_dp_undefined
            默认值screenwidthdp这表明没有宽度已被指定。
        
        
            int
            smallest_screen_width_dp_undefined
            默认值smallestscreenwidthdp这表明没有宽度已被指定。
        
        
            int
            touchscreen_finger
            常数触摸屏的相应值， 手指资源限定符。
        
        
            int
            touchscreen_notouch
            常数触摸屏的相应值， 无接触资源限定符。
        
        
            int
            touchscreen_stylus
            这种不断的被废弃的在API级别16。目前不支持或使用。
        
        
            int
            touchscreen_undefined
            常数触摸屏：一个值表示没有值已设置。
        
        
            int
            ui_mode_night_mask
            常数uimode夜间模式：编码比特。
        
        
            int
            ui_mode_night_no
            常数uimode：一个ui_mode_night_mask价值相当于 日间资源限定符。
            
        
        
            int
            ui_mode_night_undefined
            常数uimode：一个ui_mode_night_mask值表明没有模式已设置。
        
        
            int
            ui_mode_night_yes
            常数uimode：一个ui_mode_night_mask价值相当于 晚上资源限定符。
            
        
        
            int
            ui_mode_type_appliance
            常数uimode：一个ui_mode_type_mask价值相当于 电器资源限定符。
            
        
        
            int
            ui_mode_type_car
            常数uimode：一个ui_mode_type_mask价值相当于 小型车资源限定符。
            
        
        
            int
            ui_mode_type_desk
            常数uimode：一个ui_mode_type_mask价值相当于 书桌资源限定符。
            
        
        
            int
            ui_mode_type_mask
            常数uimode：编码模式位。
        
        
            int
            ui_mode_type_normal
            常数uimode：一个ui_mode_type_mask值对应的
                没有用户界面模式限定符指定的资源。
        
        
            int
            ui_mode_type_television
            常数uimode：一个ui_mode_type_mask价值相当于 电视机资源限定符。
            
        
        
            int
            ui_mode_type_undefined
            常数uimode：一个ui_mode_type_mask值表明没有模式已设置。
        
    



]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android开发手记</tag>
      </tags>
  </entry>
  <entry>
    <title>CountDownLatch线程等待</title>
    <url>/2021/10/21/CountDownLatch%E7%BA%BF%E7%A8%8B%E7%AD%89%E5%BE%85/</url>
    <content><![CDATA[异步请求&ensp;&ensp;创建一个使用okhttp发送get请求的方法，并将请求到的字符串结果return出来，由于使用的请求方式是异步请求，并不能马上得到响应值，所以最后return出去的还是nullpublic class MyHttpRequest &#123;    private String value;	    public String myGet(String url)&#123;        OkHttpClient okHttpClient = new OkHttpClient();        Request request = new Request.Builder().url(url).build();        Call call = okHttpClient.newCall(request);        call.enqueue(new Callback() &#123;            @Override            public void onFailure(@NotNull Call call, @NotNull IOException e) &#123;                value = &quot;noValue&quot;;            &#125;            @Override            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException &#123;                value = response.body().string();\            &#125;        &#125;);        return value;    &#125;&#125;
&ensp;&ensp;调用它，不出意外的话，一定是请求失败的String value = myHttpRequest.myGet(&quot;https://www.baidu.com&quot;);if (value == null || &quot;noValue&quot;.equals(value))&#123;    System.out.println(&quot;请求失败&quot;);&#125; else &#123;    System.out.println(&quot;请求成功\n&quot; + value);&#125;
等待请求结果&ensp;&ensp;如果要使其得请求结束后再return，让主线程等待子线程执行完毕&ensp;&ensp;使用countDownLatch类，使一个线程等待其他线程各自执行完毕后再执行。通过一个计数器来实现，计数器的初始值是线程的数量。每当一个线程执行完毕后，计数器的值就-1，当计数器的值为0时，表示所有线程都执行完毕，然后在闭锁上等待的线程就可以恢复工作了。
&ensp;&ensp;创建同步工具类，设置计数器初始值CountDownLatch countDownLatch = new CountDownLatch(1);
&ensp;&ensp;当请求失败或者请求成功时，计数器减一countDownLatch.countDown();
&ensp;&ensp;请求完毕后，执行await()阻塞线程，只有当计数器的值为0时，退出阻塞结束线程等待try &#123;    countDownLatch.await();&#125; catch (InterruptedException e) &#123;    e.printStackTrace();&#125;
&ensp;&ensp;看一下完整的myGet()方法public String myGet(String url)&#123;    CountDownLatch countDownLatch = new CountDownLatch(1);//创建同步工具类，设置计数器初始值    OkHttpClient okHttpClient = new OkHttpClient();    Request request = new Request.Builder().url(url).build();    Call call = okHttpClient.newCall(request);    call.enqueue(new Callback() &#123;        @Override        public void onFailure(@NotNull Call call, @NotNull IOException e) &#123;            value = &quot;noValue&quot;;            countDownLatch.countDown();//计数器减一        &#125;        @Override        public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException &#123;            value = response.body().string();            countDownLatch.countDown();//计数器减一        &#125;    &#125;);    try &#123;        countDownLatch.await();//阻塞当前线程，直到计数器为0退出    &#125; catch (InterruptedException e) &#123;        e.printStackTrace();    &#125;    return value;&#125;
&ensp;&ensp;再次从测试类中调用，一模一样的代码String value = myHttpRequest.myGet(&quot;https://www.baidu.com&quot;);if (value.equals(&quot;noValue&quot;))&#123;    System.out.println(&quot;请求失败&quot;);&#125;else &#123;    System.out.println(&quot;请求成功\n&quot; + value);&#125;
&ensp;&ensp;可见请求成功，并输出了请求结果
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android开发手记</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言指针</title>
    <url>/2022/11/23/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[虚拟内存&ensp;&ensp;虚拟内存作为一个中间层，避免程序直接与物理内存交互，因而程序中访问的内存地址不再是真实的物理内存地址，而是每个进程独有的虚拟内存地址，虚拟内存地址由操作系统映射到适当的物理内存地址上，至于如何映射与开发者无关。

&ensp;&ensp;在只启动一次的情况下，一个程序只可以拥有一个进程，多个程序的多个进程拥有结构相同的虚拟内存，在典型的32位系统中，虚拟内存空间总大小为4GB（64位系统远大于4G），其中包括用户空间和内核空间

用户空间，占用虚拟内存空间3G，包括
代码段（Code Segment）：也称为文本段，存储程序的机器码指令。通常是只读的，因为程序在运行时不应该修改自己的指令。
数据段（Data Segment）：存储全局变量和静态变量。数据段分为初始化的数据段（Initialized Data Segment）和未初始化的数据段（Uninitialized Data Segment，也称为BSS段）。初始化的数据段包含在程序中明确初始化的全局和静态变量，而未初始化的数据段包含未初始化的全局和静态变量，这些变量会在程序运行时被初始化为零或空。
堆（Heap）：动态内存分配的区域，由程序员进行手动管理。使用malloc()、calloc()、realloc()等函数分配内存，并使用free()函数释放内存。
栈（Stack）：存储局部变量、函数参数和函数调用的返回地址。栈是一种后进先出（LIFO）的数据结构，它在函数调用时分配局部变量的空间，当函数返回时释放这些空间。
常量区（Constant Area）：存储常量字符串，例如字符串字面量。这部分内存通常是只读的。
内存映射区域（Memory-mapped Region）：存储与文件关联的内存映射区域。这包括共享内存等。


内核空间，占用虚拟内存空间1G (0xC000_0000 ~ 0xFFFF_FFFF)

指针概念&ensp;&ensp;在典型的32位系统中，虚拟内存空间总大小为4GB，因为4GB＝4,096MB＝4,194,304KB＝4,294,967,296byte，即虚拟内存空间共有4,294,967,296个字节；&ensp;&ensp;8位16进制从0x0000_0000到0xffff_ffff刚好4,294,967,296个数，每个数对应虚拟内存中的一个字节，将8位16进制中的每个数都作为虚拟内存的字节的内存地址；于是虚拟内存的内存地址范围从0x0000_0000到0xffff_ffff

&ensp;&ensp;对于一个多字节的变量，例如一个占用4字节内存的int变量，假设其第一个字节储存在虚拟内存中的地址为0x7fc5_3001，于是其最后一个字节的地址就为0x7fc5_3004，那么它编号最小的内存地址0x7fc5_3001就代表它本身的地址// int 占用4个字节// 假设第一个字节的内存地址是 0x7fc5_3001// 那么变量 num 的内存地址就是 0x7fc5_3001int num = 1;// 取 num 的指针，也就是内存地址int* pointer = &amp;num// 将会输出 0x7fc5_3001printf(&quot;pointer = %p&quot;, pointer);
指针变量&ensp;&ensp;定义指针变量数据类型* 指针变量名;
&ensp;&ensp;取变量所在的内存地址int num = 100;int* pointer = &amp;num;// 将会输出 num 的内存地址printf(&quot;pointer = %p&quot;,pointer);
&ensp;&ensp;取指针变量所指向的内存地址储存的值int num1 = 100;int* pointer = &amp;num1;// 取指针变量所指向的内存地址储存的值int num2 = *pointer;// 将会输出 100 ，num1 = num2printf(&quot;pointer = %d&quot;,num2);
&ensp;&ensp;不同数据类型的指针只能存储对应类型的内存地址
// 字符指针char ch = &#x27;A&#x27;;char* ch_pointer = &amp;ch;// 短整型指针short int sh = 10;short int* sh_pointer = &amp;sh;// 整形指针int in = 10;int* in_pointer = &amp;in;// 长整型指针long int lo = 10;long int* lo_pointer = &amp;lo;// 浮点型指针float fl = 10.0f;float* fl_pointer = &amp;fl;// 双浮点型指针double dou = 10.0;double* dou_pointer = &amp;dou;
&ensp;&ensp;通用指针，可以储存任何变量类型的指针int num = 100;void* pointer = &amp;num;
指针和数组的关系
数组名代表数组首元素的内存地址，因此数组名可以直接赋值给指针变量，而实际上赋值时传递的是数组的地址

int main() &#123;    int arr[] = &#123; 1,2,3,4,5 &#125;;    // 将数组名直接赋值给指针变量    int* pointer_1 = arr;    // 取数组首元素的内存地址    int* pointer_2 = &amp;arr[0];    // 二者相同    printf(&quot;pointer_1 = %p\n&quot;, pointer_1);    printf(&quot;pointer_2 = %p\n&quot;, pointer_2);    return 0;&#125;

数组名只可作为不可变的左值，因为数组名表示数组的起始地址，而指针声明时是左值，但也可以作为右值


左值（lvalue） 是指表达式结束后依然存在的持久化对象，通常是一个标识符（变量、数组元素、结构体成员等）。左值可以出现在赋值运算符的左边，表示一个可以被赋值的位置。在int x = 42;中，x是左值，因为它是一个标识符，可以出现在赋值运算符的左边，
右值（rvalue） 是指表达式结束后不再存在的临时对象，通常是一个常量、表达式的结果或临时计算得到的值。在int y = 10 + 5;中，10 + 5是右值，因为它是一个临时计算得到的值，不能被直接赋值；

int main() &#123;    int arr1[3] = &#123; 1,2,3 &#125;;    int num = 10;    int* pointer1 = &amp;num;    // 错误，因为数组名只可作为不可变的左值    arr1 = pointer1;    // 错误，因为数组无法接受直接赋予地址值，而arr1也不能作为初始值赋予arr2    int arr2[] = arr1;    // 指针可以作为左值，接受arr1传递的地址值    int* pointer2 = arr1;    // pointer2指针可以作为右值，对pointer1重新赋予地址值    pointer1 = pointer2;    return 0;&#125;

数组名不能进行自增或自减运算，而指针变量可以

&ensp;&ensp;数组首元素的指针自加可以移动到数组第二个元素，此时指针指向第二个元素，两元素地址十六进制值相差为一个数组元素的类型所占用字节的大小，例如int类型数组，那么两元素地址的十六进制值将相差4字节。注意，指针自加或+整数的方式只有在数组元素中才有意义
int main() &#123;    int arr[] = &#123; 1,2,3,4,5,6,7,8 &#125;;    // 将数组名代表的数组首元素地址赋值给指针    int* pointer = arr;    // pointer此时指向数组的首元素地址，将会输出 1 及第一个元素的地址    printf(&quot;num = %d, pointer = %p\n&quot;, *pointer, pointer);    // 指针自加，即向下移动一个元素    pointer++;    // pointer此时指向数组第二个元素的地址，将会输出 2 及第二个元素的地址    printf(&quot;num = %d, pointer = %p\n&quot;, *pointer, pointer);    // 自加2，向下移动两个元素    pointer+=2;    // pointer此时指向数组第四个元素的地址，将会输出 4 及第四个元素的地址    printf(&quot;num = %d, pointer = %p\n&quot;, *pointer, pointer);    // 自减，向上移动一个元素    pointer--;    // pointer此时指向数组第三个元素的地址，将会输出 3 及第三个元素的地址    printf(&quot;num = %d, pointer = %p\n&quot;, *pointer, pointer);    return 0;&#125;
&ensp;&ensp;同一数组两元素的两个指针可以相减，将会得到两个元素之间相差的元素的个数int main() &#123;    int arr[] = &#123; 1,2,3 &#125;;    // 数组第一个元素的指针    int* pointer1 = &amp;arr[0];    // 数组第二个元素的指针    int* pointer2 = &amp;arr[1];    // 数组第三个元素的指针    int* pointer3 = &amp;arr[2];    // 第三个元素和第一个元素下标相差 2 ，将会输出2    int minus_1 = (int)(pointer3 - pointer1);    printf(&quot;minus_1 = %d\n&quot;, minus_1);    // 第二个元素和第一个元素下标相差 1 ，将会输出1    int minus_2 = (int)(pointer2 - pointer1);    printf(&quot;minus_2 = %d\n&quot;, minus_2);        return 0;&#125;

sizeof操作符对指针和数组名使用的结果不同，


对数组名使用sizeof得到的是整个数组的大小，
对指针变量使用sizeof得到的是指针本身的大小；

int main() &#123;    // 数组中有 8 个 int 类型元素，因此数组的大小应该是 32 字节    int arr[] = &#123; 1,2,3,4,5,6,7,8 &#125;;    // 在32位系统 int 类型指针通常占用 4 字节的内存空间。    // 在64位系统 int 类型指针通常占用 8 字节的内存空间。    int* pointer = arr;    // 将会输出 32    printf(&quot;%zu\n&quot;, sizeof(arr));    // 在32位系统中输出 4 ，在64位系统中输出 8    printf(&quot;%zu\n&quot;, sizeof(pointer));    return 0;&#125;

数组元素的指针加下标的方式也能调用数组中的元素

int main() &#123;    int arr[] = &#123; 1,2,3,4,5 &#125;;    // 数组名代表了数组首元素的内存地址    // 将数组首元素的内存地址赋值给指针    int* pointer = arr;    // 使用指针加下标的方式调用数组第二个元素    int num = pointer[1];    // 将会输出 2    printf(&quot;num = %d\n&quot;, num);        return 0;&#125;
&ensp;&ensp;如果取数组中第二个元素arr[1]的指针，并以arr[1]的指针加下标的方式调用数组中的元素，那么调用arr[1]将使用下标0，调用其他元素的下标均在原数组下标基础上-1int main() &#123;    int arr[] = &#123; 1,2,3,4,5 &#125;;    // 数组中第二个元素的内存地址    int* pointer = &amp;arr[1];    // 将会输出 arr[0] 的值 1    printf(&quot;value1 = %d\n&quot;, pointer[-1]);    // 将会输出 arr[1] 的值 2    printf(&quot;value2 = %d\n&quot;, pointer[0]);    // 将会输出 arr[2] 的值 3    printf(&quot;value3 = %d\n&quot;, pointer[1]);    return 0;&#125;
&ensp;&ensp;同理，如果取第三个元素arr[2]的指针，用arr[2]的指针加下标的方式调用数组中的元素，那么调用arr[2]将使用下标0，调用其他元素的下标均在元素组下标基础上-2int main() &#123;    int arr[] = &#123; 1,2,3,4,5 &#125;;    // 数组中第三个元素的内存地址    int* pointer = &amp;arr[2];    // 将会输出 arr[1] 的值 2    printf(&quot;value1 = %d\n&quot;, pointer[-1]);    // 将会输出 arr[2] 的值 3    printf(&quot;value2 = %d\n&quot;, pointer[0]);    // 将会输出 arr[3] 的值 4    printf(&quot;value3 = %d\n&quot;, pointer[1]);        return 0;&#125;
&ensp;&ensp;其实我发现如果指针指向变量，也可以用像数组一样，取指针指向的变量的值int main() &#123;    int num = 10;    int* pointer = &amp;num;    // 将会输出 10    printf(&quot;pointer = %d\n&quot;, pointer[0]);    return 0;&#125;
指针数组&ensp;&ensp;由指针组成的数组，其本质上还是一个数组int main() &#123;    // 指针数组    int* p[5];    int arr[5] = &#123; 1,2,3,4,5 &#125;;    // 循环将int类型数组中元素的地址值存进指针数组    for (size_t i = 0; i &lt; 5; i++) &#123;        p[i] = &amp;arr[i];    &#125;    // 输出指针数组中指针的地址值和地址中的值    for (size_t i = 0; i &lt; 5; i++) &#123;        printf(&quot;pointer = %p\n&quot;, p[i]);        printf(&quot;num = %d\n&quot;, *p[i]);    &#125;        return 0;&#125;
二级指针（多重指针）&ensp;&ensp;指针作为一个占用4字节内存的数据，它也有自己的内存地址，那么指针的内存地址也可以用另一个指针记录，如下代码pointer_pointer指向指针pointer的地址int main() &#123;    int num = 100;    int* pointer = &amp;num;    printf(&quot;pointer = %p\n&quot;, pointer);    // 指针的指针    int** pointer_pointer = &amp;pointer;    printf(&quot;pointer_pointer = %p\n&quot;, pointer_pointer);        return 0;&#125;
字符指针&ensp;&ensp;字符串有下面四种常见写法
int main() &#123;    // char数组以 \0 结尾，构成字符串    char str1[] = &#123; &#x27;h&#x27;,&#x27;e&#x27;,&#x27;l&#x27;,&#x27;l&#x27;,&#x27;o&#x27;,&#x27;\0&#x27; &#125;;    // 直接在大括号中写字符串    char str2[] = &#123;&quot;hello&quot;&#125;;    // 去掉大括号    char str3[] = &quot;hello&quot;;    // 字符串直接赋值给指针，无法修改指定某个元素    char* str4 = &quot;hello&quot;;    // 将输出 4 个 hello    printf(&quot;str1=%s, str2=%s, str3=%s, str4=%s\n&quot;, str1, str2, str3, str4);    // 数组名代表的内存地址无法修改，但是可以修改元素值    str1[0] = &#x27;H&#x27;;    str2[0] = &#x27;H&#x27;;    str3[0] = &#x27;H&#x27;;    // 字符串直接赋值的指针，无法修改指定某个元素    // 但是可以修改指向的内存地址    str4 = &quot;Hello&quot;;    // 将输出 4 个 Hello    printf(&quot;str1=%s, str2=%s, str3=%s, str4=%s\n&quot;, str1, str2, str3, str4);    return 0;&#125;
&ensp;&ensp;字符串指针即便转换成char数组，依然不能够修改指定的某个元素值int main() &#123;    char* str = &quot;hello&quot;;    // 将字符串指针作为参数传递给 test1    // test1 所接收的形参是 char 数组    test1(str);    return 0;&#125;void test1(char arr[]) &#123;    // 字符串指针即便转换成 char 数组    // 依然不能够修改指定的某个元素值    arr[0] = &#x27;H&#x27;;    printf(&quot;arr[0] = %c\n&quot;, arr[0]);&#125;
&ensp;&ensp;给char类型的指针直接赋值字符串，相当于将一个char数组构成的字符串赋值给指针，不同的是这样的指针是可以修改指定元素值的
int main() &#123;    // char数组以 \0 结尾，构成字符串    char str1[] = &#123; &#x27;h&#x27;,&#x27;e&#x27;,&#x27;l&#x27;,&#x27;l&#x27;,&#x27;o&#x27;,&#x27;\0&#x27; &#125;;    // char数组赋值给指针    // 相当于 char* str4 = &quot;hello&quot;    char* str4 = str1;    // 将输出两个 hello    printf(&quot;str1=%s, str2=%s\n&quot;, str1, str4);    // 需要注意的是，如果将char数组构成的字符串赋值给指针变量    // 是可以修改指定的元素值的    str4[0] = &#x27;H&#x27;;        // 将输出两个 Hello    printf(&quot;str1=%s, str2=%s\n&quot;, str1, str4);    return 0;&#125;
数组指针&ensp;&ensp;数组指针不同于指针数组，指针数组是一个数组，其中的每个元素都是指针，数组指针是指向数组的指针，它指向数组的首元素地址
&ensp;&ensp;数组指针通常以下面这种格式定义数据类型(*数组指针变量名)[长度] = &amp;数组名
&ensp;&ensp;由于数组名代表数组首元素的内存地址，所以也可以省略取地址符号&amp;数据类型(*数组指针变量名)[长度] = 数组名

一维数组的指针

&ensp;&ensp;(*pointer)表示pointer是一个指向数组的指针，指向的数组包含4个int类型元素；解引用*pointer将提供整个数组，(*pointer)[0]将给出数组的第一个元素；不过其实一维数组完全没必要用这样的数组指针定义，直接把数组名赋值给一个与数组元素相同类型的指针就行了int main() &#123;    int arr[5] = &#123; 1,2,3,4 &#125;;    // 数组指针，指向一个数组    int(*pointer)[] = &amp;arr;    // 打印下面三个值，输出的内容是一致的    // 1.数组指针指向的内存地址    printf(&quot;pointer     = %p\n&quot;, pointer);    // 2.数组指针指向的内存地址中储存的数组    printf(&quot;*pointer    = %p\n&quot;, *pointer);    // 3.数组指针指向的内存地址中储存的数组的首元素地址    printf(&quot;*pointer[0] = %p\n&quot;, &amp;((*pointer)[0]));    // 将输出 1, 2, 3, 4    printf(&quot;%d, %d, %d, %d\n&quot;, (*pointer)[0], (*pointer)[1], (*pointer)[2], (*pointer)[3]);    return 0;&#125;
&ensp;&ensp;用指针调用数组中的元素int main() &#123;    int arr[5] = &#123; 1,2,3,4 &#125;;    // 数组指针，指向一个数组    int(*pointer)[] = &amp;arr;    // 解引用，得到数组arr的指针，其实等同于将arr代表的地址赋值给arr_p    int* arr_p = *pointer;    // 将输出 1    printf(&quot;%d\n&quot;, *arr_p);    // 指针向下移动    arr_p++;    // 将输出 2    printf(&quot;%d\n&quot;, *arr_p);    return 0;&#125;

二维数组的指针

&ensp;&ensp;当arr是如下的二维数组时，pointer依然是一个指向包含4个int类型元素的数组的指针；解引用*pointer将提供二维数组第一行的数组，(*pointer)[0]将给出第一行数组的第一个元素int main() &#123;    int arr[3][4] = &#123;        &#123;1, 2, 3, 4&#125;,        &#123;5, 6, 7, 8&#125;,        &#123;9, 10, 11, 12&#125;    &#125;;    // 数组指针，指向二维数组中的某一行    int(*pointer)[4] = arr;        // pointer的起始位置在二维数组的第一行    // 所以arr_0将指向 &#123;1, 2, 3, 4&#125; 数组    int* arr_0 = *pointer;    // 将输出 1, 2, 3, 4    printf(&quot;%d, %d, %d, %d\n&quot;, arr_0[0], arr_0[1], arr_0[2], arr_0[3]);    // 指针向下移动    pointer++;    // pointer目前移动到二维数组的第二行    // 所以arr_1将指向 &#123;5, 6, 7, 8&#125; 数组    int* arr_1 = *pointer;    // 将输出 5, 6, 7, 8    printf(&quot;%d, %d, %d, %d\n&quot;, arr_1[0], arr_1[1], arr_1[2], arr_1[3]);    // 指针继续向下移动    pointer++;    // pointer目前移动到二维数组的第三行    // 所以arr_2将指向 &#123;9, 10, 11, 12&#125; 数组    int* arr_2 = *pointer;    // 将输出 9, 10, 11, 12    printf(&quot;%d, %d, %d, %d\n&quot;, arr_2[0], arr_2[1], arr_2[2], arr_2[3]);        return 0;&#125;

&ensp;&ensp;如果不使用移动指针的方式，也可以用指针直接调用二维数组中的元素，通过pointer[i][j]的方式，访问不同数组中的元素int main() &#123;    int arr[3][4] = &#123;        &#123;1, 2, 3, 4&#125;,        &#123;5, 6, 7, 8&#125;,        &#123;9, 10, 11, 12&#125;    &#125;;    // 数组指针，指向二维数组中的某一行    int(*pointer)[4] = arr;        // 指针直接调用二维数组的第一行    int* arr_0 = pointer[0];    // 将输出 1, 2, 3, 4    printf(&quot;%d, %d, %d, %d\n&quot;, arr_0[0], arr_0[1], arr_0[2], arr_0[3]);    // 指针直接调用二维数组的第二行    int* arr_1 = pointer[1];    // 将输出 5, 6, 7, 8    printf(&quot;%d, %d, %d, %d\n&quot;, arr_1[0], arr_1[1], arr_1[2], arr_1[3]);    // 指针直接调用二维数组的第三行    int* arr_2 = pointer[2];    // 将输出 9, 10, 11, 12    printf(&quot;%d, %d, %d, %d\n&quot;, arr_2[0], arr_2[1], arr_2[2], arr_2[3]);        return 0;&#125;

三维数组的指针

&ensp;&ensp;当arr是三维数组时，pointer是一个指向二维数组的指针，指向的二维数组中包含了3个一维数组，每个一维数组又包含4个int类型的元素；通过pointer++可以移动指针到下一个二维数组
int main() &#123;    int arr[2][3][4] = &#123;        &#123;            &#123;1, 2, 3, 4&#125;,            &#123;5, 6, 7, 8&#125;,            &#123;9, 10, 11, 12&#125;        &#125;,        &#123;            &#123;13, 14, 15, 16&#125;,            &#123;17, 18, 19, 20&#125;,            &#123;21, 22, 23, 24&#125;        &#125;    &#125;;    // 数组指针，指向三维数组中的某个二维数组    int(*pointer)[3][4] = arr;    // pointer的起始位置在三维数组的第一个元素    // (*pointer)[0]是第一个元素的第一行    int* arr_0_0 = (*pointer)[0];    // 将输出 1, 2, 3, 4    printf(&quot;%d, %d, %d, %d\n&quot;, arr_0_0[0], arr_0_0[1], arr_0_0[2], arr_0_0[3]);    // (*pointer)[1]是第一个元素的第二行    int* arr_0_1 = (*pointer)[1];    // 将输出 5, 6, 7, 8    printf(&quot;%d, %d, %d, %d\n&quot;, arr_0_1[0], arr_0_1[1], arr_0_1[2], arr_0_1[3]);    // (*pointer)[2]是第一个元素的第三行    int* arr_0_2 = (*pointer)[2];    // 将输出 9, 10, 11, 12    printf(&quot;%d, %d, %d, %d\n&quot;, arr_0_2[0], arr_0_2[1], arr_0_2[2], arr_0_2[3]);    // 指针向下移动    pointer++;    // pointer目前移动到三维数组的第二个元素    // (*pointer)[0]是第二个元素的第一行    int* arr_1_0 = (*pointer)[0];    // 将输出 13, 14, 15, 16    printf(&quot;%d, %d, %d, %d\n&quot;, arr_1_0[0], arr_1_0[1], arr_1_0[2], arr_1_0[3]);    // (*pointer)[1]是第二个元素的第二行    int* arr_1_1 = (*pointer)[1];    // 将输出 17, 18, 19, 20    printf(&quot;%d, %d, %d, %d\n&quot;, arr_1_1[0], arr_1_1[1], arr_1_1[2], arr_1_1[3]);    // (*pointer)[2]是第二个元素的第三行    int* arr_1_2 = (*pointer)[2];    // 将输出 21, 22, 23, 24    printf(&quot;%d, %d, %d, %d\n&quot;, arr_1_2[0], arr_1_2[1], arr_1_2[2], arr_1_2[3]);        return 0;&#125;
&ensp;&ensp;通过pointer[i][j][k]的方式，直接访问不同二维数组中的元素int main() &#123;    int arr[2][3][4] = &#123;        &#123;            &#123;1, 2, 3, 4&#125;,            &#123;5, 6, 7, 8&#125;,            &#123;9, 10, 11, 12&#125;        &#125;,        &#123;            &#123;13, 14, 15, 16&#125;,            &#123;17, 18, 19, 20&#125;,            &#123;21, 22, 23, 24&#125;        &#125;    &#125;;    // 数组指针，指向三维数组中的某个二维数组    int(*pointer)[3][4] = arr;    // 指针直接调用三维数组第一个元素的第一行    int* arr_0_0 = pointer[0][0];    // 将输出 1, 2, 3, 4    printf(&quot;%d, %d, %d, %d\n&quot;, arr_0_0[0], arr_0_0[1], arr_0_0[2], arr_0_0[3]);    // 指针直接调用三维数组第一个元素的第二行    int* arr_0_1 = pointer[0][1];    // 将输出 5, 6, 7, 8    printf(&quot;%d, %d, %d, %d\n&quot;, arr_0_1[0], arr_0_1[1], arr_0_1[2], arr_0_1[3]);    // 指针直接调用三维数组第一个元素的第三行    int* arr_0_2 = pointer[0][2];    // 将输出 9, 10, 11, 12    printf(&quot;%d, %d, %d, %d\n&quot;, arr_0_2[0], arr_0_2[1], arr_0_2[2], arr_0_2[3]);    // 指针直接调用三维数组第二个元素的第一行    int* arr_1_0 = pointer[1][0];    // 将输出 13, 14, 15, 16    printf(&quot;%d, %d, %d, %d\n&quot;, arr_1_0[0], arr_1_0[1], arr_1_0[2], arr_1_0[3]);    // 指针直接调用三维数组第二个元素的第二行    int* arr_1_1 = pointer[1][1];    // 将输出 17, 18, 19, 20    printf(&quot;%d, %d, %d, %d\n&quot;, arr_1_1[0], arr_1_1[1], arr_1_1[2], arr_1_1[3]);    // 指针直接调用三维数组第二个元素的第三行    int* arr_1_2 = pointer[1][2];    // 将输出 21, 22, 23, 24    printf(&quot;%d, %d, %d, %d\n&quot;, arr_1_2[0], arr_1_2[1], arr_1_2[2], arr_1_2[3]);    return 0;&#125;

个人一点小看法

&ensp;&ensp;如果将一维数组视作是一个仅包含一个元素的二维数组，即将int arr[] = &#123; 1,2,3,4,5 &#125;视作int arr[] = &#123; &#123; 1,2,3,4,5 &#125; &#125;，那么二维数组和一维数组的用法以及定义就相互吻合了&ensp;&ensp;而且如果不这样的话，无法解释pointer[i]不能调用其指向的一维数组int arr[5] = &#123; 1,2,3,4 &#125;中的元素的问题int main() &#123;    int arr[1][4] = &#123;        &#123; 1,2,3,4 &#125;    &#125;;    // 数组指针，指向一个二维数组    int(*pointer)[4] = arr;    // pointer的起始位置在二维数组的第一行（arr中只有一行）    // 所以arr_0将指向 &#123; 1,2,3,4 &#125; 数组    int* arr_0 = *pointer;    // 将输出 1, 2, 3, 4    printf(&quot;%d, %d, %d, %d\n&quot;, arr_0[0], arr_0[1], arr_0[2], arr_0[3]);    // 如果再使用 pointer++ 移动指针，将会溢出    // 因为arr中只有一行        return 0;&#125;
&ensp;&ensp;用指针直接调用的方式，使用pointer[i][j]访问一维数组中的元素；即使arr是个一维数组，也要通过这种方式，而不是pointer[i]int main() &#123;    int arr[1][4] = &#123;        &#123; 1,2,3,4&#125;    &#125;;    // 数组指针，指向一个二维数组    int(*pointer)[4] = arr;    // 指针直接调用二维数组的第一行    int* arr_0 = pointer[0];    // 将输出 1, 2, 3, 4    printf(&quot;%d, %d, %d, %d\n&quot;, arr_0[0], arr_0[1], arr_0[2], arr_0[3]);        return 0;&#125;
&ensp;&ensp;同样二维数组也可以视作仅包含一个元素的三维数组，只不过这种情况下二维数组的指针(*pointer)[0]不是一个左值，所以无法通过移动指针位置的方式选择二维数组中的一维数组int main() &#123;    int arr[1][3][4] = &#123;        &#123;            &#123;1, 2, 3, 4&#125;,            &#123;5, 6, 7, 8&#125;,            &#123;9, 10, 11, 12&#125;        &#125;    &#125;;    // 数组指针，指向三维数组中的某个二维数组    int(*pointer)[3][4] = arr;    // pointer的起始位置在三维数组的第一个元素    // (*pointer)[0]是第一个元素的第一行    int* arr_0 = (*pointer)[0];    // 将输出 1, 2, 3, 4    printf(&quot;%d, %d, %d, %d\n&quot;, arr_0[0], arr_0[1], arr_0[2], arr_0[3]);    // (*pointer)[1]是第一个元素的第二行    int* arr_1 = (*pointer)[1];    // 将输出 5, 6, 7, 8    printf(&quot;%d, %d, %d, %d\n&quot;, arr_1[0], arr_1[1], arr_1[2], arr_1[3]);    // (*pointer)[2]是第一个元素的第三行    int* arr_2 = (*pointer)[2];    // 将输出 9, 10, 11, 12    printf(&quot;%d, %d, %d, %d\n&quot;, arr_2[0], arr_2[1], arr_2[2], arr_2[3]);        return 0;&#125;
&ensp;&ensp;通过pointer[i][j][k]的方式，直接访问不同二维数组中的元素int main() &#123;    int arr[1][3][4] = &#123;        &#123;            &#123;1, 2, 3, 4&#125;,            &#123;5, 6, 7, 8&#125;,            &#123;9, 10, 11, 12&#125;        &#125;    &#125;;    // 数组指针，指向三维数组中的某个二维数组    int(*pointer)[3][4] = arr;    // pointer的起始位置在三维数组的第一个元素    // pointer[0][0]是第一个元素的第一行    int* arr_0 = pointer[0][0];    // 将输出 1, 2, 3, 4    printf(&quot;%d, %d, %d, %d\n&quot;, arr_0[0], arr_0[1], arr_0[2], arr_0[3]);    // pointer[0][1]是第一个元素的第二行    int* arr_1 = pointer[0][1];    // 将输出 5, 6, 7, 8    printf(&quot;%d, %d, %d, %d\n&quot;, arr_1[0], arr_1[1], arr_1[2], arr_1[3]);    // pointer[0][2]是第一个元素的第三行    int* arr_2 = pointer[0][2];    // 将输出 9, 10, 11, 12    printf(&quot;%d, %d, %d, %d\n&quot;, arr_2[0], arr_2[1], arr_2[2], arr_2[3]);    return 0;&#125;
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C语言基础</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言关键字</title>
    <url>/2022/11/20/C%E8%AF%AD%E8%A8%80%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[关键字变量类型关键字char val1 = &#x27;a&#x27;;        // 字符型变量short int val2 = 100;   // 短整型int val3 = 100;         // 整形long int val4 = 100000; // 长整型float val5 = 100.1f;    // 单浮点型double val6 = 100.1;    // 双浮点型signed int val7 = -100; // 修饰字符型、短整形、整形和长整形，代表有正负符号，可以保存正负数unsigned int val8 = 100;// 修饰字符型、短整形、整形和长整形，代表无正负符号，只可以保存正数和0// void用于修饰函数的参数类型及返回值// 代表不需要传入参数，没有返回值void test(void) &#123;&#125;
&ensp;&ensp;C99新增定义bool类型关键字_Bool，_Bool只有0和1两个值，如果给他赋非零值，它的值仍然是1_Bool b1 = 1;_Bool b2 = 0;_Bool b3 = 100;_Bool b4 = NULL;// 将输出 1 0 1 0printf(&quot;b1 = %d,b2 = %d,b3 = %d,b4 = %d&quot;, b1, b2, b3, b4);
&ensp;&ensp;在库文件stdbool.h中，有_Bool的宏定义bool，0的宏定义false及1的宏定义true，引入该库文件后，可以以如下形式定义bool类型变量bool b1 = false;bool b2 = true;
&ensp;&ensp;当使用printf输出不同类型的字符时，需要使用以下占位符将对应类型的字符进行格式化
%d   // 十进制有符号整数%u   // 十进制无符号整数%x   // 以十六进制表示的整数%o   // 以八进制表示的整数%ld  // 十进制长整型%hd  // 十进制短整形%f   // float类型浮点数%lf  // double类型浮点数%e   // 指数形式的浮点数%g   // 以 %e 或 %f 中较短的形式输出浮点数%s   // 字符串%ls  // 宽字符串%c   // 单个字符%lc  // 宽字符%p   // 指针%%   // 输出百分号 %%+   // 强制输出带有符号数的正负号%-   // 左对齐输出%Nd  // 输出宽度为 N 位的有符号整数，不足 N 位前面使用空格补齐%.Nf // 输出浮点数，保留 N 位小数%0   // 数字前面用 0 补齐%3d  // 要求宽度为 3 位，如果不足 3 位，前面空格补齐%03d // 要求宽度为 3 位，如果不足 3 位，前面 0 补齐%-3d // 要求宽度为3位，如果不足3位，后面空格补齐%.2f // 小数点后保留两位
储存类型关键字&ensp;&ensp;register修饰的变量称为寄存器变量，系统会尽量（不一定）将其储存空间存放在寄存器中，当变量中的数据被成功存放在寄存器中之后，就没有了内存地址，CPU取寄存器中的数据会快于内存中的数据，但register不能修饰数组，只能修饰字符型、短整形、整形及长整型变量// register声明寄存器变量register int val1 = 100;
&ensp;&ensp;static可以修饰全局变量、局部变量以及函数// static修饰静态变量static int val2 = 100;
&ensp;&ensp;const修饰的变量称为常量，常量值一旦被定义就无法修改，相当于java中的final// const修饰常量const int val3 = 100;
&ensp;&ensp;auto用于声明自动变量，自动变量通常是局部变量（函数的形参也视为局部变量），局部变量在不加任何修饰的情况下默认就是自动变量。所以auto可有可无了，修饰和不修饰一样// 没什么用，加和不加一样auto int val4 = 200;
&ensp;&ensp;extern修饰外部变量或函数、引用外部变量或函数，extern修饰的变量或函数表示可以被外部调用，由于函数和变量默认可被外部调用，所以作为修饰关键字时extern是可以不添加的，但是当引用外部变量或函数时，必须使用extern对其声明extern void test(); // 引用外部函数extern int val1;    // 引用外部变量int main() &#123;    // 引用外部函数    test();    // 引用外部变量    printf(&quot;外部变量 = %d\n&quot;,val1);&#125;
控制语句关键字if else for while do switch case break continue goto default
&ensp;&ensp;其中goto直接跳转到目标标签所在的位置向下执行，如下代码将会输出125；其它的不说了。int main() &#123;    printf(&quot;1&quot;);    printf(&quot;2&quot;);    goto tmp;   // 将会跳转到tmp标签所在的位置向下执行    printf(&quot;3&quot;);    printf(&quot;4&quot;);    tmp:    // tmp标签    printf(&quot;5&quot;);    return 0;&#125;
其他关键字&ensp;&ensp;sizeof，sizeof()函数用于获取括号中的表达式占用储存空间的大小，表达式在这里可以是变量、常量、数组、指针等，sizeof的返回值是size_t类型的无符号整数，单位是字节；size_t虽然在许多情况下被广泛使用，但并不是关键字，而是一个预定义的类型名，其占位符是%zu或%zdint a = 1;printf(&quot;size = %zu&quot;, sizeof(a));
&ensp;&ensp;typedef用于给已有数据类型起别名，使用别名定义的变量与原数据类型定义的变量没有任何类型上的差异typedef int NEW_INT;        // 给int类型定义别名为NEW_INTNEW_INT val1 = 111;         // 使用别名定义变量printf(&quot;val1 = %d\n&quot;, val1);// 输出别名定义的变量typedef short int INT16;    // 给short int类型定义别名为INT16INT16 val2 = 10;            // 使用别名定义变量printf(&quot;val2 = %d\n&quot;, val2);// 输出别名定义的变量typedef int FIVE_INT[5];            // 给固定长度为 5 的 int 类型数组起别名FIVE_INT fiveInt = &#123; 1,2,3,4,5 &#125;;   // 使用别名定义数组typedef int INT_ARR[];              // 给未固定长度的 int 类型数组起别名INT_ARR ints = &#123; 1,2,3,4,5,6,7 &#125;;   // 使用别名定义数组typedef void(*FUNC_POINTER)(int);   // 给返回值为 void 形参为一个 int 的函数指针起别名FUNC_POINTER funcPointer = &amp;func;   // 使用别名定义函数指针typedef int(*ARR_POINTER)[4];       // 给 4 列的 int 型二维数组起别名int arr[3][4] = &#123;        &#123;1, 2, 3, 4&#125;,        &#123;5, 6, 7, 8&#125;,        &#123;9, 10, 11, 12&#125;&#125;;ARR_POINTER arrPointer = arr;       // 使用别名定义二维数组的数组指针
&ensp;&ensp;volatile修饰的变量每次使用时都去内存中取最新的值，而不是寄存器中的备份volatide int val1 = 11;
类型转换自动转换&ensp;&ensp;字节数低的类型转字节数高的类型，会进行自动类型转换
强制转换&ensp;&ensp;字节数高的类型转字节数低的类型，需要进行强制类型转换；如下将float类型强制转换成int类型，输出结果为2float val1 = 2.5f;int val2 = (int)val1;printf(&quot;val2 = %d&quot;, val2);
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C语言基础</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言变量和函数</title>
    <url>/2022/11/22/C%E8%AF%AD%E8%A8%80%E5%8F%98%E9%87%8F%E5%92%8C%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[变量局部变量&ensp;&ensp;在函数或复合语句内部定义的变量叫做局部变量，局部变量只在它定义的函数或复合语句内有效，函数被调用时为局部变量开辟空间并赋值，函数执行完毕后局部变量的空间随即被释放#include &lt;stdio.h&gt;void numPlus();int main() &#123;        numPlus();    numPlus();    numPlus();        return 0;&#125;void numPlus() &#123;    int num = 100;    for (size_t i = 0; i &lt; 10; i++)    &#123;        num++;    &#125;    // 将会输出 110    printf(&quot;num = %d\n&quot;, num);&#125;
&ensp;&ensp;用static修饰的局部变量称为静态局部变量，静态局部变量只在它定义的函数或复合语句内有效，第一次调用函数时为静态局部变量开辟空间并赋值，但是并不会随着函数的执行完毕而释放，并且在后续调用函数时，不再为其开辟空间和赋值。静态局部变量默认值为0#include &lt;stdio.h&gt;void numPlus();int main() &#123;        numPlus();    numPlus();    numPlus();        return 0;&#125;void numPlus() &#123;    static int num = 100;    for (size_t i = 0; i &lt; 10; i++)    &#123;        num++;    &#125;    // 第一次被调用时输出 110    // 后续输出 120, 130, ...    printf(&quot;num = %d\n&quot;, num);&#125;
全局变量&ensp;&ensp;在函数之外定义的变量叫做全局变量，extern修饰的全局变量表示允许被外部调用，但由于普通全局变量默认允许外部调用，所以extern修饰可有可无。注意全局变量在声明时不要进行定义（赋值）。全局变量默认值为0#include&lt;stdio.h&gt;extern int num;int main ()&#123;    num = 100;&#125;
&ensp;&ensp;static修饰的全局变量表示静态全局变量，静态全局变量禁止外部调用，仅供当前C文件调用，因此extern和static有冲突，不能修饰同一个变量。静态全局变量默认值为0#include&lt;stdio.h&gt;static int num;int main ()&#123;    num = 100;&#125;
函数入口函数&ensp;&ensp;入口函数是C语言执行的起点#include&lt;stdio.h&gt;int main() &#123;    printf(&quot;hello world&quot;);    return 0;&#125;
函数调用&ensp;&ensp;C语言从入口函数开始执行，但是编译器从上往下编译，当被调函数在下，主调函数在上时，主调函数并不知道被调函数的存在，所以会出现错误#include&lt;stdio.h&gt;int main() &#123;    // 此时 fun1 函数没有被定义    fun1();    return 0;&#125;void fun1() &#123;    printf(&quot;fun1\n&quot;);&#125;
&ensp;&ensp;可以将被调函数fun1放在主调函数main之上，此时被调函数优先编译，当主调函数调用时，已经知道了被调函数的存在#include&lt;stdio.h&gt;void fun1() &#123;    printf(&quot;fun1\n&quot;);&#125;int main() &#123;    // 此时 fun1 已经被定义    fun1();    return 0;&#125;
&ensp;&ensp;或者先对被调函数进行声明，提前告知被调函数的存在，函数虽然只可以定义一次，但可以被声明无数次#include&lt;stdio.h&gt;void fun1();    // 声明fun1函数的存在int main() &#123;    // 此时 fun1 函数虽然没有被定义，但是main函数已经知道它的存在    fun1();    return 0;&#125;void fun1() &#123;    printf(&quot;fun1\n&quot;);&#125;
&ensp;&ensp;调用其他c文件中的函数时，也需要对其进行声明，例如demo2.c#include&lt;stdio.h&gt;void fun2() &#123;    printf(&quot;fun2\n&quot;);&#125;
&ensp;&ensp;当demo1.c中的主调函数调用demo2.c的被调函数时#include &lt;stdio.h&gt;void fun1();extern void fun2();int main() &#123;    fun1();    fun2();    return 0;&#125;void fun1() &#123;    printf(&quot;fun1\n&quot;);&#125;
函数声明&ensp;&ensp;c文件中的函数较少时，可以通过被调函数放在主调函数之上，或者在c文件中声明被调函数的方式，来解决函数未定义的问题，当c文件中函数过多时，大量函数声明将会使代码变得臃肿，函数的循环调用也使得上下顺序摆放不切实际，所以此时可以创建对应的头文件，在头文件中声明函数，在c文件中只声明头文件，例如demo1.c中的代码#include &lt;stdio.h&gt;void fun1();void fun2();int main() &#123;    fun1();    fun2();    return 0;&#125;void fun1() &#123;    printf(&quot;fun1\n&quot;);&#125;void fun2() &#123;    printf(&quot;fun2\n&quot;);&#125;
&ensp;&ensp;创建对应的头文件demo1.h，并在其中声明fun1、fun2#include &lt;stdio.h&gt;extern void fun1();extern void fun2();
&ensp;&ensp;而在demo1.c中只对demo1.h进行声明#include &quot;demo1.h&quot;int main() &#123;    fun1();    fun2();    return 0;&#125;void fun1() &#123;    printf(&quot;fun1\n&quot;);&#125;void fun2() &#123;    printf(&quot;fun2\n&quot;);&#125;
静态函数&ensp;&ensp;被static修饰的函数称为静态函数，静态函数仅可被当前C文件调用static void test() &#123;    printf(&quot;静态函数&quot;);&#125;
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C语言基础</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言数组</title>
    <url>/2022/11/21/C%E8%AF%AD%E8%A8%80%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[一维数组&ensp;&ensp;注意：“初始化数组”和“给数组赋值”是不同的概念，初始化是在声明数组的同时为其分配内存并赋予初值，给数组赋值是在数组已经声明和分配内存的情况下为数组元素赋予新的值
&ensp;&ensp;声明一个长度为10的数组，系统会给每个元素分配未初始化值（未初始化的值是不确定的），并为其分配连续的内存地址// 声明数组int arr[10];
&ensp;&ensp;声明一个长度为10的数组，并对数组中的部分元素赋予初始值（简称初始化），未初始化的部分系统将会为其赋值为0// 声明数组，对部分元素初始化int arr2[10] = &#123; 1,2 &#125;;// 将会输出 120printf(&quot;arr2 = %d%d%d\n&quot;, arr2[0],arr2[1],arr2[2]);
&ensp;&ensp;声明一个长度为10的数组，并对全部元素初始化// 声明数组，对全部元素初始化int arr3[10] = &#123; 1,2,3,4,5,6,7,8,9,0 &#125;;
&ensp;&ensp;声明数组但不指定长度，数组的长度将由&#123;&#125;中初始值的个数决定// 声明数组，不指定数组长度int arr4[] = &#123; 1,2,3,4 &#125;;
&ensp;&ensp;声明数组，并给指定的部分元素初始化// 只给第一个和第四个元素赋初始值int arr[5] = &#123;[0] = 1, [3] = 4&#125;;// 将会输出 10040printf(&quot;arr = %d%d%d%d%d\n&quot;, arr[0],arr[1],arr[2],arr[3],arr[4]);
&ensp;&ensp;注意，使用大括号给数组赋初始值时，只能在数组声明时赋值，否则会报错，因为声明数组时如果不赋初始值，编译器会自动为数组每个元素赋未初始化值，并分配连续的内存地址，数组名指向的内存地址一旦被分配就不可更改，所以数组声明后无法再使用大括号给数组赋值// 声明数组int arr[3];// 数组被声明却未初始化// 系统给每个元素赋未初始化值并分配内存地址// 所以无法再使用&#123;&#125;对其进行初始化arr = &#123;1,2,3&#125;;
&ensp;&ensp;在C语言中，数组名是一个指向数组首元素的指针常量，并不代表数组的所有元素的集合。如下代码中arr1是指向数组首元素的指针常量，并不等同于&#123;1,2,3,4,5&#125;，所以无法将arr1作为初始值赋值给数组arr2；且因为C语言中的数组变量无法直接被赋值，只能给数组中的元素赋值或初始化赋值，所以数组变量arr1也不能作为地址值赋值给数组变量arr2// 声明数组arr1，并对其赋初始值，正确int arr1[5] = &#123;1,2,3,4,5&#125;;// 给数组arr2赋值，错误int arr2[2] = arr1;
&ensp;&ensp;我说实话在这里边获取数组长度的方式是真他妈的操蛋，不能直接像java那样arr.length，只能通过计算占用储存空间大小的方式获取数组长度// 定义一个长度为3的数组int arr[3];// 数组占用的储存空间大小/元素占用的储存空间大小int arrLength = sizeof(arr) / sizeof(int);printf(&quot;数组arr长度 = %d&quot;, arrLength);
二维数组&ensp;&ensp;创建二维数组但未对数组进行初始化，系统会给每个元素分配默认值// 3行4列二维数组，未初始化int arr[3][4];
&ensp;&ensp;创建二维数组并对数组部分初始化，未初始化的部分系统将会为其赋值为0// 3行4列二维数组，部分初始化int arr2[3][4] = &#123;    &#123;1,2,3&#125;,    &#123;1,2,3,4&#125;&#125;;// 将会输出0，因为第1行第4列的元素未进行初始化printf(&quot;arr = %d\n&quot;,arr2[0][3]);
&ensp;&ensp;创建二维数组并对所有元素赋值，元素的个数不可以超过指定的个数// 3行4列二位数组，全部初始化int arr3[3][4] = &#123;    &#123;1,2,3,4&#125;,    &#123;5,6,7,8&#125;,    &#123;9,10,11,12&#125;&#125;;
&ensp;&ensp;创建二维数组时可以不指定具体行数，行数将在二维数组创建时动态决定，但必须指定列数// 不指定行数，只指定列数int arr4[][4] = &#123;    &#123;1,2,3,4&#125;,    &#123;5,6,7,8&#125;&#125;;
&ensp;&ensp;创建二维数组，并逐个对数组进行初始化，如下面9个元素，只对二维数组中[0][0]到[2][0]进行了初始化// 逐个对数组进行初始化int arr5[3][4] = &#123;    1,2,3,4,5,6,7,8,9&#125;;// 将会输出 9,0，因为[2][1]未进行初始化printf(&quot;arr5 = %d,%d&quot;, arr5[2][0], arr5[2][1]);
&ensp;&ensp;创建二维数组，给指定部分元素初始化int arr[][4] = &#123;[0][1] = 1, [1][2] = 3&#125;;
char数组&ensp;&ensp;char数组的最后一个元素如果为\0，该数组就构成了一个字符串，否则只能是字符数组，无法构成字符串char str[] = &#123; &#x27;t&#x27;,&#x27;e&#x27;,&#x27;s&#x27;,&#x27;t&#x27;,&#x27;\0&#x27; &#125;;// 将会输出 testprintf(&quot;字符串 = %s&quot;, str);
&ensp;&ensp;如果直接给char数组赋值字符串，那么它的最后一位必定是\0，在C语言中\0是空字符（null character），用于表示字符串的结束，如果使用printf输出%c格式的\0，将会输出一个空格，表示有不可见的字符被输出。// 储存长度为4的字符串，则char类型数组的长度至少为5，因为最后一位需要储存\0char str[] = &quot;test&quot;; // 等号右边这样写&#123;&quot;test&quot;&#125;也可以// 将会输出 0，因为最后一个元素是 \0printf(&quot;str = %d\n&quot;, str[4]);// 将会输出空，因为 \0 代表空printf(&quot;str = %c\n&quot;, str[4]);
&ensp;&ensp;\0会被计入数组占用的字节，但不会被计入字符串长度之内，其中strlen()是string.h下的函数，用于计算字符串长度char str[] = &quot;test&quot;;// 字符串占用的字节数为 5 ，因为最后一位是 \0printf(&quot;arr size = %d\n&quot;, sizeof str);// 字符串长度为 4 ，\0不计入其中printf(&quot;arr length = %d\n&quot;, strlen(str));
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C语言基础</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言文件操作</title>
    <url>/2022/12/08/C%E8%AF%AD%E8%A8%80%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[打开文件&ensp;&ensp;使用fopen函数打开文件，第一个参数是文件的路径，第二个参数是文件的打开模式，如只读、写入、追加；如果文件打开成功，将返回一个文件指针，否则返回NULLFILE *fopen(const char *filename, const char *mode);
&ensp;&ensp;如下代码以只写模式打开了E:\temp\文件夹下的test.txt文件String filePath = &quot;E:\\temp\\test.txt&quot;;// 以读取模式打开FILE* file = fopen(filePath, &quot;w&quot;);
&ensp;&ensp;文件的打开模式有以下




文件使用方式
含义
如果指定文件不存在




“r”（只读）
打开一个已有的文本文件，只允许读取
出错


“w”（只写）
打开一个文本文件（清空原有数据），只允许写入
建立一个新的文件


“a”（追加）
打开一个文本文件，用于追加写入
建立一个新的文件


“rb”（只读）
打开一个已有的二进制文件，只允许读取
出错


“wb”（只写）
打开一个二进制文件（清空原有数据），只允许写入
建立一个新的文件


“ab”（追加）
打开一个二进制文件，用于追加写入
建立一个新的文件


“r+”（读写）
打开一个已有文本文件，允许读取和写入
出错


“w+”（读写）
打开一个文本文件（清空原有数据），允许读取和写入
建立一个新的文件


“a+”（读写）
打开一个文本文件，用于读取和追加写入
建立一个新的文件


“rb+”（读写）
打开一个已有二进制文件，允许读取和写入
出错


“wb+”（读写）
打开一个二进制文件（清空原有数据），允许读取和写入
建立一个新的文件


“ab+”（读写）
打开一个二进制文件，用于读取和追加写入
建立一个新的文件




&ensp;&ensp;打开的文件在操作结束后一定要使用fclose函数关闭int fclose(FILE *stream);
写出文件&ensp;&ensp;通过以下函数写出文件到本地




函数
作用




fputc()
向文件中写入一个字符


fputs()
向文件中写入一行字符串


fprintf()
按指定格式向文件中写入数据




fputc&ensp;&ensp;fputc()用于将一个字符写入指定的文件流中；character是要向文件流中写入的字符；stream是指向文件流的FILE类型的指针，它指定了要写入的文件；该函数返回值是写入的字符，如果发生错误，则返回EOF，这是一个表示文件尾或错误的宏，其代表的值为-1int fputc(int character, FILE *stream);
&ensp;&ensp;如下代码使用fputc函数在本地文件中写下了26个字母
typedef char* String;int main() &#123;    // 指定文件路径    String filePath = &quot;E:\\temp\\test.txt&quot;;    // 以只写模式打开文件    FILE* file = fopen(filePath, &quot;w&quot;);    // 检查文件是否成功打开    if (file != NULL) &#123;        // 得到小写字母 a 的 ASCII 码        int a_c = &#x27;a&#x27;;        // 通过 26 次循环，将 26 个字母写入本地        for (int i = 0; i &lt; 26; i++) &#123;            // 当前轮次需要写入的字符            int cc = a_c + i;            // 写入字符到本地，并记录写入结果            int result = fputc(cc, file);            // 判断是否成功写入            if (result != EOF) &#123;                // 输出写入的结果                printf(&quot;result = %c\n&quot;, result);            &#125; else &#123;                // 输出错误消息                perror(&quot;文件写入失败&quot;);                return 1;            &#125;        &#125;        printf(&quot;文件写入完毕\n&quot;);        // 关闭文件流        fclose(file);        file = NULL;    &#125; else &#123;        // 输出错误消息        perror(&quot;文件打开失败&quot;);        return 1;    &#125;    return 0;&#125;
fputs&ensp;&ensp;fputs()用于将一个字符串写入到指定的文件流中；str是向文件流中写入的字符串；stream是指向文件流的FILE类型的指针；如果写入成功，函数返回一个非负整数，发生错误则返回EOFint fputs(const char *str, FILE *stream);
&ensp;&ensp;如下代码使用fputs函数在本地文件中写下了一段字符串#define ARR_LENGTH 4typedef char* String;int main() &#123;    // 准备要写入到文件流中的字符串数组    String str_arr[ARR_LENGTH] = &#123;&quot;悟已往之不谏，\n&quot;,                                  &quot;知来者之可追。\n&quot;,                                  &quot;实迷途其未远，\n&quot;,                                  &quot;觉今是而昨非。&quot;&#125;;    // 指定文件路径    String filePath = &quot;E:\\temp\\test.txt&quot;;    // 以只写模式打开文件    FILE* file = fopen(filePath, &quot;w&quot;);    // 检查文件是否成功打开    if (file != NULL) &#123;        // 使用循环将数组中的字符串依次写入本地        for (int i = 0; i &lt; ARR_LENGTH; i++) &#123;            // 写入字符串到输出流，如果写入发生错误时会返回 EOF            int result = fputs(str_arr[i], file);            // 如果写入失败            if (result == EOF) &#123;                // 输出错误消息                perror(&quot;文件写入失败&quot;);                return 1;            &#125;        &#125;        printf(&quot;文件写入完毕\n&quot;);        // 关闭文件流        fclose(file);        file = NULL;    &#125; else &#123;        // 输出错误消息        perror(&quot;文件打开失败&quot;);        return 1;    &#125;    return 0;&#125;
fprintf&ensp;&ensp;fprintf()函数用于将格式化后的数据写入到指定的文件流中，格式化方式与printf()类似，stream表示指向文件流的指针，format是包含占位符的字符串，...是可变参数，用以填充字符串中的占位符；如果数据成功写入，返回写入的字符数（非负整数），如果发生错误则返回负值int fprintf(FILE *stream, const char *format, ...);
&ensp;&ensp;如下代码使用fprintf函数在本地文件中写下了一段字符串#define ARR_LENGTH 3typedef char* String;// 声明结构体，包含姓名和各科成绩；同时声明结构体数组并初始化struct Scores &#123;    String name;    int chinese;    int math;    int english;&#125; scores_arr[ARR_LENGTH] = &#123;&quot;小红&quot;, 100, 80, 70,                            &quot;小刚&quot;, 80, 98, 100,                            &quot;小明&quot;, 90, 60, 80&#125;;int main() &#123;    // 指定文件路径    String filePath = &quot;E:\\temp\\test.txt&quot;;    // 以只写模式打开文件    FILE* file = fopen(filePath, &quot;w&quot;);    // 该变量用于统计 fprintf 写入的字符总数    int char_sum = 0;    // 检查文件是否成功打开    if (file != NULL) &#123;        // 使用循环将结构体数组中的数据写入本地        for (int i = 0; i &lt; ARR_LENGTH; i++) &#123;            // 写入字符串到输出流，如果成功写入，该方法将返回写入的字符数            int result = fprintf(file, &quot;姓名：%s，数学：%d，英语：%d，语文：%d\n&quot;,                    scores_arr[i].name, scores_arr[i].chinese, scores_arr[i].math, scores_arr[i].english);            // 累加字符数            char_sum += result;            // 判断文件写入情况            if (result &lt; 0) &#123;                perror(&quot;写入文件时发生错误&quot;);                return 1;            &#125;        &#125;        printf(&quot;文件写入完毕，共计字符 %d 个\n&quot;, char_sum);        // 关闭文件流        fclose(file);        file = NULL;    &#125; else &#123;        // 输出错误消息        perror(&quot;文件打开失败&quot;);        return 1;    &#125;    return 0;&#125;
读取文件&ensp;&ensp;通过以下函数读取本地文件




函数
作用




fgetc()
从文件中读取一个字符


fgets()
从文件中读取一行字符串


fscanf()
按指定格式从文件中读取数据




fgetc&ensp;&ensp;fgetc()函数用于从指定的文件流中读取一个字符，只有一个参数是指向文件流的指针，如果读取成功，返回值被读取的字符的ASCII值，如果到达文件末尾或者发生错误，返回EOF；可以使用feof和ferror函数来进一步检查是文件末尾还是发生了错误&ensp;&ensp;文件指针会在每次调用fgetc后移动到下一个字符位置int fgetc(FILE *stream);
&ensp;&ensp;如下代码使用fgetc函数将本地文件中的内容逐个字符读取，并储存至缓冲区输出typedef char* String;int main() &#123;    // 指定文件路径    String filePath = &quot;E:\\temp\\test.txt&quot;;    // 以只读模式打开文件    FILE* file = fopen(filePath, &quot;r&quot;);    // 检查文件是否成功打开    if (file != NULL) &#123;        // 储存字符读取结果        int character;        // 作为缓冲器，储存所有字符读取结果        char buffer[1024] = &#123;0&#125;;        // 使用循环将所有读取成功的字符储存进 buffer        for (int i = 0; (character = fgetc(file)) != EOF; i++) &#123;            buffer[i] = (char)character;        &#125;        if (feof(file)) &#123;   // EOF 发生在文件末尾            // 将 buffer 作为字符串输出            printf(&quot;character = %s&quot;, buffer);        &#125; else if(ferror(file)) &#123; // EOF 发生在读取过程中            perror(&quot;发生了读取错误&quot;);            return 1;        &#125;        // 关闭文件流        fclose(file);        file = NULL;    &#125; else &#123;        // 输出错误消息        perror(&quot;文件打开失败&quot;);        return 1;    &#125;    return 0;&#125;
fgets&ensp;&ensp;fgets()函数用于从文件流中读取一行文本；str存储从文件中读取的文本；size代表要读取的最大字符数，限制fgets函数从文件流中每次最多读取size-1个字符（因为最后一个元素要储存\0），直到遇到换行符\n或文件结束符EOF，并在字符数组的末尾添加一个\0字符形成字符串；stream代表要读取的文件流；该函数的返回值是成功读取的字符串的地址，如果读取到文件末尾或者发生错误，返回NULL&ensp;&ensp;文件指针会在每次调用fgets后移动到读取的字符串的末尾char *fgets(char *str, int size, FILE *stream);
&ensp;&ensp;如下代码展示了fgets函数“每次读取一行”，由于读取的文件中一共有5行内容，而fgets函数换行符\n或文件结束符EOF将会结束本轮的内容读取，并且每行内容的字符没有超出fgets第二个参数限制的字符范围，所以代码中循环语句经过5次循环，把test.txt中的内容读取完毕&ensp;&ensp;如果把fgets第二个参数限制的字符范围设置为8，即每次从文件流中最多读取7个字符，那么循环语句将经过10次循环读取完毕test.txt中的内容，因为文件中的每行内容都在7~14的范围内假设test.txt中的内容如下：First lineSecond lineThird lineFourth lineFifth line
typedef char* String;int main() &#123;    // 指定文件路径    String filePath = &quot;E:\\temp\\test.txt&quot;;    // 以只读模式打开文件    FILE* file = fopen(filePath, &quot;r&quot;);    // 检查文件是否成功打开    if (file != NULL) &#123;        // 存储从文件中读取的文本        char str[1024] = &#123;0&#125;;        // 循环读取文件中的每一行，当 fgets 返回 NULL 时循环会结束        for (int i = 1; fgets(str, sizeof(str), file) ; i++) &#123;            printf(&quot;第 %d 轮读取 = %s\n&quot;, i, str);        &#125;        // 关闭文件流        fclose(file);        file = NULL;    &#125; else &#123;        // 输出错误消息        perror(&quot;文件打开失败&quot;);        return 1;    &#125;    return 0;&#125;
&ensp;&ensp;如下代码使用fgets函数将本地文件中的内容逐行读取，并储存至缓冲区输出typedef char* String;int main() &#123;    // 指定文件路径    String filePath = &quot;E:\\temp\\test.txt&quot;;    // 以只读模式打开文件    FILE* file = fopen(filePath, &quot;r&quot;);    // 检查文件是否成功打开    if (file != NULL) &#123;        // 储存每行读取结果        char str[1024] = &#123;0&#125;;        // 作为缓冲器，储存所有行读取结果        char buffer[1024 * 100] = &#123;0&#125;;        // 循环读取文件中的每一行        while (fgets(str, sizeof(str), file) != NULL) &#123;            // 拼接字符串，把每一行拼接起来            strcat(buffer, str);        &#125;        // 将 buffer 作为字符串输出        printf(&quot;buffer = %s\n&quot;, buffer);        // 关闭文件流        fclose(file);        file = NULL;    &#125; else &#123;        // 输出错误消息        perror(&quot;文件打开失败&quot;);        return 1;    &#125;    return 0;&#125;
fscanf&ensp;&ensp;fscanf()函数用于从文件中读取格式化输入，格式化方式与scanf()类似；stream表示要读取的文件流；format表示格式化字符串；...是可变参数列表，用于接收按照format字符串指定格式读取的数据；该函数返回成功读取和匹配的参数个数，如果到达文件末尾或发生读取错误，则返回EOF&ensp;&ensp;文件指针会在每次调用fscanf后根据成功读取的数据大小移动int fscanf(FILE *stream, const char *format, ...);
&ensp;&ensp;fscanf函数在读取数据时以空白字符（包括空格、制表符和换行符）作为分隔符，如果想要读取多行数据，可以使用循环来多次调用；如下代码从指定文件中读取每一条符合格式要求的数据假设test.txt中的内容如下：姓名：小红，数学：100，英语：80，语文：70姓名：小刚，数学：80，英语：98，语文：100姓名：小明，数学：90，英语：60，语文：80
typedef char* String;int main() &#123;    // 指定文件路径    String filePath = &quot;E:\\temp\\test.txt&quot;;    // 以只写模式打开文件    FILE* file = fopen(filePath, &quot;r&quot;);    // 检查文件是否成功打开    if (file != NULL) &#123;        // 记录学生姓名        char name[1024] = &#123;0&#125;;        // 记录成绩        int chinese = 0, math = 0, english = 0;        // 使用循环读取每一行与格式化字符串中匹配的数据        while (fscanf(file, &quot;姓名：%[^，]，数学：%d，英语：%d，语文：%d\n&quot;, name, &amp;math, &amp;english, &amp;chinese) != EOF) &#123;            printf(&quot;学生姓名：%s，数学成绩：%d，英语成绩：%d，语文成绩：%d\n&quot;, name, math, english, chinese);        &#125;        if (feof(file)) &#123; // EOF 发生在文件末尾            printf(&quot;文件读取完毕&quot;);        &#125; else if (ferror(file)) &#123; // EOF 发生在读取过程中            perror(&quot;发生了读取错误&quot;);            return 1;        &#125;        // 关闭文件流        fclose(file);        file = NULL;    &#125; else &#123;        // 输出错误消息        perror(&quot;文件打开失败&quot;);        return 1;    &#125;    return 0;&#125;
移动指针&ensp;&ensp;fseek函数用于移动文件指针在文件流中的位置；stream是指向FILE结构的指针，它标识了文件流；offset表示偏移量，它用于确定文件指针在文件流中的新位置；whence表示相对位置的基准，可以取以下三个常量值

SEEK_SET：从文件的起始位置开始偏移offset个字节
SEEK_CUR：从当前文件位置开始偏移offset个字节
SEEK_END：从文件末尾位置开始偏移offset个字节

&ensp;&ensp;fseek的返回值是一个整数，通常用于检查是否定位成功，如果成功，返回值为0；否则返回非零值。
int fseek(FILE *stream, long offset, int whence);
&ensp;&ensp;如下代码将文件指针移动到倒数第一个字符之前，那么fgetc将只能读取倒数第一个字符typedef char* String;int main() &#123;    // 指定文件路径    String filePath = &quot;E:\\temp\\test.txt&quot;;    // 以只读模式打开文件    FILE* file = fopen(filePath, &quot;r&quot;);    // 检查文件是否成功打开    if (file != NULL) &#123;        // 将指针移动到倒数第一个字符之前        fseek(file, -1, SEEK_END);        // 储存字符读取结果        int character;        // 作为缓冲器，储存所有字符读取结果        char buffer[1024] = &#123;0&#125;;        // 使用循环将所有读取成功的字符储存进 buffer        for (int i = 0; (character = fgetc(file)) != EOF; i++) &#123;            buffer[i] = (char)character;        &#125;        if (feof(file)) &#123;   // EOF 发生在文件末尾            // 将 buffer 作为字符串输出            printf(&quot;character = %s&quot;, buffer);        &#125; else if(ferror(file)) &#123; // EOF 发生在读取过程中            perror(&quot;发生了读取错误&quot;);            return 1;        &#125;        // 关闭文件流        fclose(file);        file = NULL;    &#125; else &#123;        // 输出错误消息        perror(&quot;文件打开失败&quot;);        return 1;    &#125;    return 0;&#125;
错误处理&ensp;&ensp;在进行文件操作时，需要考虑错误处理。可以使用feof函数检查文件是否已经到达末尾，以及使用ferror函数检查文件操作是否发生了错误if (feof(file)) &#123;    // 到达文件末尾&#125; else if (ferror(file)) &#123;    // 文件操作发生错误&#125;
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C语言基础</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言预处理指令</title>
    <url>/2022/11/22/C%E8%AF%AD%E8%A8%80%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[预定义&ensp;&ensp;include指令是一种常用的预处理指令。通过include指令，可以将其他文件中的代码引入到当前文件中，从而实现代码的复用和模块化开发。&ensp;&ensp;include通常用于包含.h的头文件，尽管可以包含.c文件，但是这是错误的操作。&ensp;&ensp;include包含的文件会在预编译时展开，所以当一个.c文件被包含，将会出现多次展开，从而导致函数重复定义，而.h文件如果被多次包含，也会出现多次声明的情况。
&ensp;&ensp;用尖角号包含头文件，在系统指定的路径下找头文件#include&lt;stdio.h&gt;&ensp;&ensp;用双引号包含头文件，现在当前目录下找头文件，如果当前目录下不存在，再到系统指定的路径下找头文件#include &quot;demo.h&quot;
宏定义&ensp;&ensp;在预编译时预处理器会将替换为对应的值，其格式是如下，其中宏名是一个标识符，值可以是一个常量、关键字、一段表达式或者函数，当某个值被宏名定义后，在代码中就可以直接用宏名来取代值#define 宏名 值

宏定义中的常量替换

#include &lt;stdio.h&gt;// 将__NUMBER_1__替换为12#define __NUMBER_1__ 12int main() &#123;    // __NUMBER_1__的值被替换为12    int num1 = __NUMBER_1__;    // 将会输出12    printf(&quot;num1 = %d\n&quot;, num1);// 终止__NUMBER_1__的替换#undef __NUMBER_1__// 重新将__NUMBER_1__替换为10#define __NUMBER_1__ 10// 将__STRING_1__替换为str1#define __STRING_1__ &quot;str1&quot;    // __NUMBER_1__的值被替换为10    num1 = __NUMBER_1__;    // 将会输出10    printf(&quot;num1 = %d\n&quot;, num1);    // __STRING_1__的值被替换为str1    char* str1 = __STRING_1__;    // 将会输出20    printf(&quot;str1 = %s\n&quot;, str1);        return 0;&#125;// 终止__NUMBER_1__和__STRING_1__的替换#undef __NUMBER_1__#undef __STRING_1__

宏定义中的关键字替换

#include &lt;stdio.h&gt;// 将st替换为static关键字#define st static// 直接用st修饰供外部访问的变量st int num;int main() &#123;    num = 10;    printf(&quot;num = %d\n&quot;, num);        return 0;&#125;// 终止st的替换#undef st

宏定义中的表达式替换

#include &lt;stdio.h&gt;// 将over替换为return 0关键字#define over return 0;int main() &#123;    printf(&quot;hello world&quot;);        // 等同于 return 0;    over&#125;// 终止over的替换#undef over

宏定义中的函数替换

#include &lt;stdio.h&gt;#define ex extern// 将function();方法调用替换为fun#define fun function()ex char* function();int main() &#123;    printf(&quot;%s\n&quot;,fun);    return 0;&#125;char* function() &#123;    return &quot;hello world&quot;;&#125;// 终止fun的替换#undef fun

带参数的宏定义替换

#include &lt;stdio.h&gt;// 将S(a,b)类型替换成a+b#define S(a,b) a+b;int main() &#123;    int sum = S(1, 2);    printf(&quot;sum = %d&quot;, sum);        return 0;&#125;// 终止fun的替换#undef S(a,b)
条件编译&ensp;&ensp;通过条件编译预处理指令，可以根据条件判断是否编译某段代码

#if…#elif…#else…#endif

&ensp;&ensp;首先判断#if后的条件，条件不满足则判断#elif后的条件，均不满足则执行#else，并以#endif结束条件编译&ensp;&ensp;下面代码中defined(宏名)用于判断某个宏名是否被定义过，被定义过返回1，否则返回0#include &lt;stdio.h&gt;// 对DEBUG宏定义，不用添加值#define __DEBUG__char* model;int main() &#123;#if defined(__DEBUG__)      // 当DEBUG被宏定义时    model = &quot;调试模式&quot;;#elif defined(__RELEASE__)  // 当RELEASE被宏定义时    model = &quot;发布模式&quot;;#else                       // 没有进行DEBUG或RELEASE宏定义    model = &quot;错误&quot;;#endif                      // 结束条件编译    // 将会输出“调试模式”，因为DEBUG被宏定义    printf(&quot;%s\n&quot;, model);        return 0;&#125;

#ifdef…#else…#endif

&ensp;&ensp;首先判断#ifdef后的宏名是否被定义，未被定义则执行#else，并以#endif结束条件编译#include &lt;stdio.h&gt;// 对RELEASE宏定义，不用添加值#define __RELEASE__char* model;int main() &#123;#ifdef __RELEASE__  // 判断RELEASE是否被宏定义    model = &quot;发布模式&quot;;#else               // 没有被宏定义    model = &quot;调试模式&quot;;#endif              // 结束条件编译    // 将会输出“发布模式”，因为RELEASE被定义    printf(&quot;%s\n&quot;, model);        return 0;&#125;

#ifndef…#else…#endif

&ensp;&ensp;与#ifdef相对应，首先判断#ifndef后的宏名是否未被定义，被定义则执行#else，并以#endif结束条件编译#include &lt;stdio.h&gt;char* model;int main() &#123;#ifndef __RELEASE__  // 判断__RELEASE__是否未被宏定义    model = &quot;发布模式&quot;;#else               // 被宏定义    model = &quot;调试模式&quot;;#endif              // 结束条件编译    // 将会输出“发布模式”，因为RELEASE未被定义    printf(&quot;%s\n&quot;, model);        return 0;&#125;
防止复引用&ensp;&ensp;当一个.h的头文件被#include多次包含时，头文件中的声明语句将会被多次声明，使用选择编译的方式可以防止这种情况，使头文件在第二次被展开时不编译声明语句
&ensp;&ensp;如下代码，当.h的头文件第一次被引用时，宏名PROJECT_NAME_DEMO_H是未定义状态，代码体将会被展开编译，当头文件被第二次引用时，PROJECT_NAME_DEMO_H已经被定义，代码体不被展开编译#ifndef PROJECT_NAME_DEMO_H // 判断宏名PROJECT_NAME_DEMO_H是否没有被定义过#define PROJECT_NAME_DEMO_H // 定义宏名，无需定义值...//代码体#endif //PROJECT_NAME_DEMO_H// 结束
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C语言基础</tag>
      </tags>
  </entry>
  <entry>
    <title>FileSelector使用手册</title>
    <url>/2024/01/19/FileSelector%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/</url>
    <content><![CDATA[引用方式Gradle 7.0以下，需要在项目级build.gradle文件中加入
allprojects &#123;    repositories &#123;        ...        maven &#123; url &#x27;https://jitpack.io&#x27; &#125;    &#125;&#125;
Gradle 7.0以上，需要在setting.gradle文件中加入
dependencyResolutionManagement &#123;	repositories &#123;		...		maven &#123; url &#x27;https://jitpack.io&#x27; &#125;	&#125;&#125;
远程仓库配置之后，即可在模块的build.gradle中引入FileSelector
dependencies &#123;    implementation &#x27;com.github.xxinPro:FileSelector:1.0&#x27;&#125;
启动方式1、启动Activity
FileSelector.create(this)        .forResult(new OnResultCallbackListener() &#123;            @Override            public void onResult(List&lt;FileBean&gt; result) &#123;                // 文件处理逻辑            &#125;            @Override            public void onCancel() &#123;                // 未选择处理逻辑            &#125;        &#125;);
2、注入frameLayout，其中forResult()的第一个参数代表需要被注入的frameLayout的id
FileSelector.create(this)        .forResult(R.id.frame_layout, new OnResultCallbackListener() &#123;            @Override            public void onResult(List&lt;FileBean&gt; result) &#123;                // 文件处理逻辑            &#125;            @Override            public void onCancel() &#123;                // 未选择处理逻辑            &#125;        &#125;);
操作文件在选择文件后，FileSelector将回调OnResultCallbackListener的onResult()方法，在onResult()方法中通过List&lt;FileBean&gt;集合可对文件进行操作
对于FileBean类，其中仅包含一个可用的File或DocumentFile类型文件对象，因为在Android 11及以上的系统中，data或obb目录中的子文件是DocumentFile类型文件对象
可以通过如下方法判断FileBean中包含的文件类型




方法名
返回结果




public boolean isFileType()
为true时表示FileBean中包含一个File类型文件对象，反之为DocumentFile类型文件对象


public boolean isDocumentFileType()
为true时表示FileBean中包含一个DocumentFile类型文件对象，反之为File类型文件对象




通过如下方法可以获取FileBean中包含的File或DocumentFile文件对象




方法名
返回结果




public File getFile()
获取FileBean中包含的File类型文件对象


public DocumentFile getDocumentFile()
获取FileBean中包含的DocumentFile类型文件对象




通过如下方法可以对FileBean类进行一些快捷操作




方法名
返回结果




public long lastModified()
取FileBean中包含文件的最后修改时间


public long length()
取FileBean中包含文件的大小


public String getName()
取FileBean中包含文件的文件名




基本使用设置起始路径设置FileSelector打开的起始路径，默认起始路径为/storage/emulated/0，可以自定义设置为任何一个存在的路径，包括data(obb)目录及其子目录，若data(obb)目录或其子目录没有访问权限将会自动申请
FileSelector.create(this)        .setInitPath(Environment.getExternalStorageDirectory().getAbsolutePath())   // 设置起始路径        .forResult(new OnResultCallbackListener() &#123;            @Override            public void onResult(List&lt;FileBean&gt; result) &#123;                // 文件处理逻辑            &#125;            @Override            public void onCancel() &#123;                // 未选择处理逻辑            &#125;        &#125;);
设置排序规则设置文件列表的排序规则，默认根据文件名排序
FileSelector.create(this)        .setSortRule(SortRule.Name) // 设置排序规则        .forResult(new OnResultCallbackListener() &#123;            @Override            public void onResult(List&lt;FileBean&gt; result) &#123;                // 文件处理逻辑            &#125;            @Override            public void onCancel() &#123;                // 未选择处理逻辑            &#125;        &#125;);
setSortRule()重载方法的第二个参数用于控制是否逆序，为true时代表逆序
FileSelector.create(this)        .setSortRule(SortRule.Name, true) // 设置排序规则，并进行逆序        .forResult(new OnResultCallbackListener() &#123;            @Override            public void onResult(List&lt;FileBean&gt; result) &#123;                // 文件处理逻辑            &#125;            @Override            public void onCancel() &#123;                // 未选择处理逻辑            &#125;        &#125;);
FileSelector提供了如下三种排序规则
public enum SortRule &#123;    Time,   // 按时间排序    Name,   // 按文件名排序    Size,   // 按大小排序&#125;
若不满足，可以使用自定义的排序规则；需要注意的是，设置自定义排序规则后FileSelector中的排序规则将不生效
FileSelector.create(this)        .selfSortRule(new Comparator&lt;FileItemBean&gt;() &#123;            @Override            public int compare(FileItemBean o1, FileItemBean o2) &#123;                // 自定义排序逻辑                return 0;            &#125;        &#125;)        .forResult(new OnResultCallbackListener() &#123;            @Override            public void onResult(List&lt;FileBean&gt; result) &#123;                // 文件处理逻辑            &#125;            @Override            public void onCancel() &#123;                // 未选择处理逻辑            &#125;        &#125;);
自定义文件图标FileSelector提供了默认的文件图标，若不满足可以对文件图标进行自定义设置
未知文件图标FileSelector通过文件的后缀名来设置对应的图标，所以当文件有一些不明所以的后缀名时，FileSelector将会为其设置一个未知文件图标，通过如下代码可以对该图标进行自定义
FileSelector.create(this)        .setDefaultFileIcon(R.drawable.file_icon) // 设置未知文件的图标        .forResult(new OnResultCallbackListener() &#123;            @Override            public void onResult(List&lt;FileBean&gt; result) &#123;                // 文件处理逻辑            &#125;            @Override            public void onCancel() &#123;                // 未选择处理逻辑            &#125;        &#125;);
文件夹图标自定义文件夹图标
FileSelector.create(this)        .setDefaultFolderIcon(R.drawable.folder_icon) // 设置文件夹的图标        .forResult(new OnResultCallbackListener() &#123;            @Override            public void onResult(List&lt;FileBean&gt; result) &#123;                // 文件处理逻辑            &#125;            @Override            public void onCancel() &#123;                // 未选择处理逻辑            &#125;        &#125;);
给指定类型文件添加图标FileSelector给小部分常见文件添加了图标，例如jpg、png，若对此图标不满足或想添加其他类型文件的图标，可以通过如下方式
FileSelector.create(this)        .addIconBySuffix(&quot;jpg&quot;, R.drawable.img_icon)    // 给指定类型文件添加图标        .addIconBySuffix(&quot;png&quot;, R.drawable.img_icon)    // 给指定类型文件添加图标        .addIconBySuffix(&quot;mp3&quot;, R.drawable.music_icon)  // 给指定类型文件添加图标        .forResult(new OnResultCallbackListener() &#123;            @Override            public void onResult(List&lt;FileBean&gt; result) &#123;                // 文件处理逻辑            &#125;            @Override            public void onCancel() &#123;                // 未选择处理逻辑            &#125;        &#125;);
批量添加公用同一图标的文件类型，如下代码将jpg、png、webp的图标设置为R.drawable.img_icon
FileSelector.create(this)        .addBatchesIconBySuffix(            new String[] &#123;&quot;jpg&quot;, &quot;png&quot;, &quot;webp&quot;&#125;, R.drawable.img_icon)        .forResult(new OnResultCallbackListener() &#123;            @Override            public void onResult(List&lt;FileBean&gt; result) &#123;                // 文件处理逻辑            &#125;            @Override            public void onCancel() &#123;                // 未选择处理逻辑            &#125;        &#125;);
批量添加，注意后缀名和图标的drawable id一一对应
FileSelector.create(this)        .addBatchesIconBySuffix(            new String[] &#123;&quot;jpg&quot;, &quot;png&quot;, &quot;mp3&quot;&#125;,            new int[] &#123;R.drawable.img_icon, R.drawable.img_icon, R.drawable.music_icon&#125;)        .forResult(new OnResultCallbackListener() &#123;            @Override            public void onResult(List&lt;FileBean&gt; result) &#123;                // 文件处理逻辑            &#125;            @Override            public void onCancel() &#123;                // 未选择处理逻辑            &#125;        &#125;);
加载略缩图开启略缩图加载后，图片、GIF图片以及视频的图标将显示一个略缩图，但是加载略缩图需要加载引擎，可以参考下面使用Glide实现的GlideEngine
FileSelector.create(this)        .isDisplayThumbnail(true)   // 开启略缩图加载        .setImageEngine(GlideEngine.createGlideEngine()) // 设置略缩图加载引擎        .forResult(new OnResultCallbackListener() &#123;            @Override            public void onResult(List&lt;FileBean&gt; result) &#123;                // 文件处理逻辑            &#125;            @Override            public void onCancel() &#123;                // 未选择处理逻辑            &#125;        &#125;);
GlideEnginepublic class GlideEngine implements ImageEngine &#123;    private static volatile GlideEngine glideEngine;    private GlideEngine () &#123;&#125;    public static GlideEngine createGlideEngine() &#123;        if (glideEngine == null) &#123;            synchronized (GlideEngine.class) &#123;                if (glideEngine == null) &#123;                    glideEngine = new GlideEngine();                &#125;            &#125;        &#125;        return glideEngine;    &#125;    @Override    public void loadFileImage(Context context, File file, ImageView imageView, int defaultDrawableId) &#123;        RequestOptions options = new RequestOptions()                .centerCrop()                .placeholder(defaultDrawableId);        Glide.with(context)                .load(file)                .apply(options)                .into(imageView);    &#125;    @Override    public void loadDocumentFileImage(Context context, DocumentFile documentFile, ImageView imageView, int defaultDrawableId) &#123;        RequestOptions options = new RequestOptions()                .centerCrop()                .placeholder(defaultDrawableId);        Glide.with(context)                .load(documentFile.getUri())                .apply(options)                .into(imageView);    &#125;&#125;
文件修改时间的格式FileSelector中默认的文件修改时间的显示格式是2024-01-01 12:30:26，可以通过如下方式修改
FileSelector.create(this)        .setLastModifiedPattern(&quot;yyyy年MM月dd日 HH时mm分ss秒&quot;) // 设置文件最后修改时间的显示格式        .forResult(new OnResultCallbackListener() &#123;            @Override            public void onResult(List&lt;FileBean&gt; result) &#123;                // 文件处理逻辑            &#125;            @Override            public void onCancel() &#123;                // 未选择处理逻辑            &#125;        &#125;);
只显示文件夹设置文件列表中只显示文件夹，不显示文件
FileSelector.create(this)        .isOnlyDisplayFolder(true)  // 只显示文件夹        .forResult(new OnResultCallbackListener() &#123;            @Override            public void onResult(List&lt;FileBean&gt; result) &#123;                // 文件处理逻辑            &#125;            @Override            public void onCancel() &#123;                // 未选择处理逻辑            &#125;        &#125;);
只选择文件设置只能选择文件，禁止选择文件夹
FileSelector.create(this)        .isOnlySelectFile(true) // 只能选择文件        .forResult(new OnResultCallbackListener() &#123;            @Override            public void onResult(List&lt;FileBean&gt; result) &#123;                // 文件处理逻辑            &#125;            @Override            public void onCancel() &#123;                // 未选择处理逻辑            &#125;        &#125;);
显示指定类型文件设置仅显示指定类型的文件，如下代码设置后，将仅显示jpg、txt、mp3类型的文件
FileSelector.create(this)        .addDisplayType(&quot;jpg&quot;, &quot;txt&quot;, &quot;mp3&quot;)    // 仅显示指定类型文件        .forResult(new OnResultCallbackListener() &#123;            @Override            public void onResult(List&lt;FileBean&gt; result) &#123;                // 文件处理逻辑            &#125;            @Override            public void onCancel() &#123;                // 未选择处理逻辑            &#125;        &#125;);
设置最大选择数如下代码设置后，在选择文件时最多只能选择5个
FileSelector.create(this)        .setMaxSelectValue(5)    // 设置文件最大选择数        .forResult(new OnResultCallbackListener() &#123;            @Override            public void onResult(List&lt;FileBean&gt; result) &#123;                // 文件处理逻辑            &#125;            @Override            public void onCancel() &#123;                // 未选择处理逻辑            &#125;        &#125;);
设置最大选择数支持添加一个文件选择回调，将会在选择item时调用该回调方法
FileSelector.create(this)        // 设置文件最大选择数，同时设置一个文件选择回调        .setMaxSelectValue(5, new OnSelectCallBackListener() &#123;            @Override            public void onSelectCallBack(int maxSelectCount, int currentSelectCount) &#123;                if (currentSelectCount &gt;= maxSelectCount) &#123;                    Toast.makeText(SelectActivity.this, &quot;最多选择&quot; + maxSelectCount + &quot;个文件~&quot;, Toast.LENGTH_SHORT).show();                &#125;            &#125;        &#125;)        .forResult(new OnResultCallbackListener() &#123;            @Override            public void onResult(List&lt;FileBean&gt; result) &#123;                // 文件处理逻辑            &#125;            @Override            public void onCancel() &#123;                // 未选择处理逻辑            &#125;        &#125;);
设置单选模式在设置单选模式后，将仅能选择一个文件或文件夹；单选模式不同于设置最大选择数为1，具体区别请自行测试
FileSelector.create(this)        .isSingle(true)     // 设置为单选模式        .forResult(new OnResultCallbackListener() &#123;            @Override            public void onResult(List&lt;FileBean&gt; result) &#123;                // 文件处理逻辑            &#125;            @Override            public void onCancel() &#123;                // 未选择处理逻辑            &#125;        &#125;);
开启震动默认为开启状态，选择文件或文件夹时将轻微震动手机
FileSelector.create(this)        .isVibrator(true)   // 开启震动        .forResult(new OnResultCallbackListener() &#123;            @Override            public void onResult(List&lt;FileBean&gt; result) &#123;                // 文件处理逻辑            &#125;            @Override            public void onCancel() &#123;                // 未选择处理逻辑            &#125;        &#125;);
自动打开选择模式开启后，在进入文件选择页面时将自动打开文件选择模式
FileSelector.create(this)        .isAutoOpenSelectMode(true) // 自动打开选择模式        .forResult(new OnResultCallbackListener() &#123;            @Override            public void onResult(List&lt;FileBean&gt; result) &#123;                // 文件处理逻辑            &#125;            @Override            public void onCancel() &#123;                // 未选择处理逻辑            &#125;        &#125;);
设置状态栏颜色设置状态栏的颜色在fragment注入模式下同样生效，所以在选择文件之后可能需要重新设置frameLayout所属Activity的状态栏颜色
FileSelector.create(this)        .setStatusBarColor(R.color.blue)    // 设置状态栏颜色        .forResult(new OnResultCallbackListener() &#123;            @Override            public void onResult(List&lt;FileBean&gt; result) &#123;                // 文件处理逻辑            &#125;            @Override            public void onCancel() &#123;                // 未选择处理逻辑            &#125;        &#125;);
设置状态栏字体颜色状态栏字体颜色只有黑色和白色两种，当为true时状态栏字体颜色将显示黑色
在fragment注入模式下同样生效，所以在选择文件之后可能需要重新设置frameLayout所属Activity的状态栏字体颜色
FileSelector.create(this)        .setStatusBarTextColor(true)  // 设置状态栏字体颜色        .forResult(new OnResultCallbackListener() &#123;            @Override            public void onResult(List&lt;FileBean&gt; result) &#123;                // 文件处理逻辑            &#125;            @Override            public void onCancel() &#123;                // 未选择处理逻辑            &#125;        &#125;);
设置导航栏颜色设置底部虚拟导航栏的颜色在fragment注入模式下同样生效，所以在选择文件之后可能需要重新设置frameLayout所属Activity的导航栏颜色
FileSelector.create(this)        .setNavigationBarColor(R.color.blue)    // 设置导航栏颜色        .forResult(new OnResultCallbackListener() &#123;            @Override            public void onResult(List&lt;FileBean&gt; result) &#123;                // 文件处理逻辑            &#125;            @Override            public void onCancel() &#123;                // 未选择处理逻辑            &#125;        &#125;);
进阶使用1、设置FileSelector最下面一层view的样式
FileSelectorViewStyle fileSelectorViewStyle = new FileSelectorViewStyle();fileSelectorViewStyle.setBackgroundColorId(R.color.white);              // 底层背景色fileSelectorViewStyle.setBackgroundDrawableId(R.drawable.background);   // 底层背景图FileSelector.create(this)        .setFileSelectorViewStyle(fileSelectorViewStyle)        .forResult(new OnResultCallbackListener() &#123;            @Override            public void onResult(List&lt;FileBean&gt; result) &#123;                // 文件处理逻辑            &#125;            @Override            public void onCancel() &#123;                // 未选择处理逻辑            &#125;        &#125;);
2、设置FileSelector顶部栏的样式

FileSelectorTitleBarStyle fileSelectorTitleBarStyle = new FileSelectorTitleBarStyle();// 设置顶部栏高度，以dp为单位fileSelectorTitleBarStyle.setHeight(50);// 设置顶部栏背景色fileSelectorTitleBarStyle.setBackgroundColorId(R.color.blue);// 设置顶部栏左侧返回按钮的图片drawable资源idfileSelectorTitleBarStyle.setOverImageDrawableId(R.drawable.back);// 设置顶部栏中间标题textfileSelectorTitleBarStyle.setTitleText(&quot;请选择文件&quot;);// 设置顶部栏中间标题的字体大小，以sp为单位fileSelectorTitleBarStyle.setTitleTextSize(20);// 设置顶部栏中间标题的字体颜色fileSelectorTitleBarStyle.setTitleTextColorId(R.color.white);// 设置顶部栏右侧的按钮，在进入选择模式之后的textfileSelectorTitleBarStyle.setStartControlText(&quot;取消&quot;);// 设置顶部栏右侧的按钮，在退出选择模式之后的textfileSelectorTitleBarStyle.setEndControlText(&quot;全选&quot;);// 设置顶部栏右侧的按钮的字体大小fileSelectorTitleBarStyle.setControlTextSize(16);// 设置顶部栏右侧的按钮的字体颜色fileSelectorTitleBarStyle.setControlTextColorId(R.color.white);FileSelector.create(this)        .setFileSelectorTitleBarStyle(fileSelectorTitleBarStyle)        .forResult(new OnResultCallbackListener() &#123;            @Override            public void onResult(List&lt;FileBean&gt; result) &#123;                // 文件处理逻辑            &#125;            @Override            public void onCancel() &#123;                // 未选择处理逻辑            &#125;        &#125;);
3、设置FileSelector路径显示栏的样式

FileSelectorPathBarStyle fileSelectorPathBarStyle = new FileSelectorPathBarStyle();// 设置路径栏背景色fileSelectorPathBarStyle.setBackgroundColorId(R.color.white);// 设置路径栏头item的背景色fileSelectorPathBarStyle.setHeadItemBackgroundColorId(R.color.blue);// 设置路径栏头item的字体颜色fileSelectorPathBarStyle.setHeadItemTextColorId(R.color.white);// 设置路径栏其余item的背景色fileSelectorPathBarStyle.setItemBackgroundColorId(R.color.gray);// 设置路径栏其余item的字体颜色fileSelectorPathBarStyle.setItemTextColorId(R.color.black);// 设置路径栏所有item的字体大小fileSelectorPathBarStyle.setItemTextSize(16);// 设置路径栏item之间箭头图片的drawable资源idfileSelectorPathBarStyle.setArrowImageDrawableId(R.drawable.arrow);// 设置文件数量的描述fileSelectorPathBarStyle.setFileCountDescription(&quot;文件数量：&quot;);// 设置文件夹数量的描述fileSelectorPathBarStyle.setFolderCountDescription(&quot;文件夹数量：&quot;);// 设置文件及文件夹数量描述的字体颜色fileSelectorPathBarStyle.setDescriptionColorId(R.color.black);// 设置文件及文件夹数量描述的字体大小fileSelectorPathBarStyle.setDescriptionTextSize(16);FileSelector.create(this)        .setFileSelectorPathBatStyle(fileSelectorPathBarStyle)        .forResult(new OnResultCallbackListener() &#123;            @Override            public void onResult(List&lt;FileBean&gt; result) &#123;                // 文件处理逻辑            &#125;            @Override            public void onCancel() &#123;                // 未选择处理逻辑            &#125;        &#125;);
4、设置FileSelector列表样式
列表item的宽高、内边距、外边距及下划线，可以通过RecyclerView的addItemDecoration()方法设置，ItemDecoration可以参考下面的LineItemDecoration和ImageItemDecoration

FileSelectorListViewStyle fileSelectorListViewStyle = new FileSelectorListViewStyle();// 设置列表背景色fileSelectorListViewStyle.setBackgroundColorId(R.color.white);// 设置当前目录为空时的提示fileSelectorListViewStyle.setEmptyFolderDescription(&quot;当前文件夹为空&quot;);// 设置当前目录为空时提示的字体颜色fileSelectorListViewStyle.setEmptyFolderDescriptionTextColorId(R.color.black);// 设置当前目录为空时提示的字体大小fileSelectorListViewStyle.setEmptyFolderDescriptionTextSize(20);// 设置当前目录为空时页面的背景色fileSelectorListViewStyle.setEmptyFolderBackgroundColorId(R.color.white);// 设置列表加载过程的提示fileSelectorListViewStyle.setLoadProgressDescription(&quot;文件加载中...&quot;);// 设置列表加载过程提示的字体颜色fileSelectorListViewStyle.setLoadProgressDescriptionTextColorId(R.color.black);// 设置列表加载过程提示的字体大小fileSelectorListViewStyle.setLoadProgressDescriptionTextSize(20);// 设置加载时环形进度条的颜色fileSelectorListViewStyle.setLoadProgressBarColorId(R.color.blue);// 设置加载页面的背景色fileSelectorListViewStyle.setLoadProgressBackgroundColorId(R.color.white);// 设置item的装饰fileSelectorListViewStyle.setItemDecoration(new CustomItemDecoration(this));// 以下代码是对item一些样式的设置FileSelectorListViewStyle.FileSelectorListItemStyle fileSelectorListItemStyle = new FileSelectorListViewStyle.FileSelectorListItemStyle();// 设置item背景色fileSelectorListItemStyle.setItemBackgroundColorId(R.color.white);// 设置item被点击时变化的背景色fileSelectorListItemStyle.setItemActionDownBackgroundColorId(R.color.gray);// 设置item中文件名的字体颜色fileSelectorListItemStyle.setFileNameTextColorId(R.color.black);// 设置item中文件名的字体大小fileSelectorListItemStyle.setFileSizeTextSize(16);// 设置item中文件修改时间的字体颜色fileSelectorListItemStyle.setLastModifiedTextColorId(R.color.gray);// 设置item中文件修改时间的字体大小fileSelectorListItemStyle.setLastModifiedTextSize(16);// 设置item中文件大小的字体颜色fileSelectorListItemStyle.setFileSizeTextColorId(R.color.gray);// 设置item中文件大小的字体大小fileSelectorListItemStyle.setFileSizeTextSize(16);// 设置item文件夹右侧箭头图片drawable资源idfileSelectorListItemStyle.setArrowDrawableId(R.drawable.arrow);// 设置item被选中后，checkBox显示的图片drawable资源idfileSelectorListItemStyle.setSelectedDrawableId(R.drawable.selected);// 设置item未被选中时，checkBox显示的图片drawable资源idfileSelectorListItemStyle.setDeselectedDrawableId(R.drawable.deselected);// 设置item的样式fileSelectorListViewStyle.setFileSelectorListItemStyle(fileSelectorListItemStyle);FileSelector.create(this)        .setFileSelectorListViewStyle(fileSelectorListViewStyle)        .forResult(new OnResultCallbackListener() &#123;            @Override            public void onResult(List&lt;FileBean&gt; result) &#123;                // 文件处理逻辑            &#125;            @Override            public void onCancel() &#123;                // 未选择处理逻辑            &#125;        &#125;);
LineItemDecorationpublic class LineItemDecoration extends RecyclerView.ItemDecoration &#123;    private final Context context;    private final int lineStrokeWidth;    public LineItemDecoration(Context context, int lineStrokeWidth) &#123;        this.context = context;        this.lineStrokeWidth = lineStrokeWidth;    &#125;    @Override    public void onDraw(@NonNull Canvas c, @NonNull RecyclerView parent, @NonNull RecyclerView.State state) &#123;        super.onDraw(c, parent, state);        // 在相邻item之间绘制一条分割线        Paint paint = new Paint();        paint.setColor(context.getResources().getColor(R.color.black));        paint.setStrokeWidth(PixelsUtil.dp2px(lineStrokeWidth, context));        int childCount = parent.getChildCount();        for (int i = 0; i &lt; childCount; i++) &#123;            View child = parent.getChildAt(i);            c.drawLine(child.getLeft() + 20, child.getBottom(), child.getRight() - 20, child.getBottom(), paint);        &#125;    &#125;    @Override    public void onDrawOver(@NonNull Canvas c, @NonNull RecyclerView parent, @NonNull RecyclerView.State state) &#123;        super.onDrawOver(c, parent, state);    &#125;    @Override    public void getItemOffsets(@NonNull Rect outRect, @NonNull View view, @NonNull RecyclerView parent, @NonNull RecyclerView.State state) &#123;        super.getItemOffsets(outRect, view, parent, state);        // 相当于设置item的margin，在底部或顶部空出空间，用于显示onDraw中绘制的分割线        outRect.set(0, 0, 0, PixelsUtil.dp2px(lineStrokeWidth, context));        // 设置item的padding，不会影响onDraw中绘制的分割线        view.setPadding(0,0,0,0);        // 设置item宽高        RecyclerView.LayoutParams layoutParams = (RecyclerView.LayoutParams) view.getLayoutParams();        layoutParams.height = RecyclerView.LayoutParams.WRAP_CONTENT;        layoutParams.width = RecyclerView.LayoutParams.MATCH_PARENT;        // layoutParams.setMargins(0,0,0,0); // 也可以通过layoutParams设置item的margin        view.setLayoutParams(layoutParams);    &#125;&#125;
ImageItemDecorationpublic class ImageItemDecoration extends RecyclerView.ItemDecoration &#123;    private final Context context;    private final int imageDrawableId;    public ImageItemDecoration(Context context, int imageDrawableId) &#123;        this.context = context;        this.imageDrawableId = imageDrawableId;    &#125;    @Override    public void getItemOffsets(@NonNull Rect outRect, @NonNull View view, @NonNull RecyclerView parent, @NonNull RecyclerView.State state) &#123;        super.getItemOffsets(outRect, view, parent, state);        int dp10 = PixelsUtil.dp2px(10, context);        outRect.set(0, dp10, 0, dp10);    &#125;    @Override    public void onDraw(@NonNull Canvas c, @NonNull RecyclerView parent, @NonNull RecyclerView.State state) &#123;        super.onDraw(c, parent, state);        Drawable drawable = ResourcesUtil.getDrawableById(context, imageDrawableId);        Paint paint = new Paint();        paint.setAntiAlias(true);        int childCount = parent.getChildCount();        for (int i = 0; i &lt; childCount - 1; i++) &#123;            View child = parent.getChildAt(i);            int dp20 = PixelsUtil.dp2px(20, context);            int left = child.getLeft() + dp20;     // item左边界            int top = child.getBottom();         // item上边界            int right = child.getRight() - dp20;   // item右边界            int bottom = child.getBottom() + dp20; // item下边界            // 设置图片绘制区域            drawable.setBounds(left, top, right, bottom);            // 绘制图片            drawable.draw(c);        &#125;    &#125;&#125;
5、设置FileSelector底部栏样式

FileSelectorFootBarStyle fileSelectorFootBarStyle = new FileSelectorFootBarStyle();// 设置底部栏背景色fileSelectorFootBarStyle.setBackgroundColorId(R.color.gray);// 设置底部栏按钮的背景色fileSelectorFootBarStyle.setBtnBackgroundColorId(R.color.white);// 设置底部栏按钮按下后变化的背景色fileSelectorFootBarStyle.setBtnActionDownBackgroundColorId(R.color.gray);// 设置底部栏左边按钮的textfileSelectorFootBarStyle.setLeftButtonText(&quot;全选&quot;);// 设置item被全选后底部栏左边按钮的textfileSelectorFootBarStyle.setLeftButtonSelectedAllText(&quot;取消全选&quot;);// 设置底部栏右边按钮的textfileSelectorFootBarStyle.setRightButtonText(&quot;确定&quot;);// 设置底部栏按钮的字体颜色fileSelectorFootBarStyle.setButtonTextColorId(R.color.black);// 设置底部栏按钮的字体大小fileSelectorFootBarStyle.setButtonTextSize(16);FileSelector.create(this)        .setFileSelectorFootBarStyle(fileSelectorFootBarStyle)        .forResult(new OnResultCallbackListener() &#123;            @Override            public void onResult(List&lt;FileBean&gt; result) &#123;                // 文件处理逻辑            &#125;            @Override            public void onCancel() &#123;                // 未选择处理逻辑            &#125;        &#125;);
开源地址https://github.com/xxinPro/FileSelector
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android开发手记</tag>
      </tags>
  </entry>
  <entry>
    <title>Git配置多个SSH-Key</title>
    <url>/2022/08/21/Git%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AASSH-Key/</url>
    <content><![CDATA[&nbsp;&nbsp;因工作原因，在github、gitee和自己的服务器之间反复横跳，他妈的&nbsp;&nbsp;因此需要在本地配置多个公钥，免去每次同步项目都要输密码的麻烦
&nbsp;&nbsp;首先生成三个key在本地ssh-keygen -t rsa -C &#x27;x@xxin.xyz&#x27; -f ~/.ssh/mygit_id_rsa #连接个人服务器使用ssh-keygen -t rsa -C &#x27;x@xxin.xyz&#x27; -f ~/.ssh/gitee_id_rsa #连接gitee使用ssh-keygen -t rsa -C &#x27;x@xxin.xyz&#x27; -f ~/.ssh/github_id_rsa #连接github使用&nbsp;&nbsp;默认在目录C:\Users\.ssh可以看到

&nbsp;&nbsp;然后在这个目录下创建名为config的文件，并填入如下# mygitHost 192.168.1.1 #服务器地址或者域名HostName 192.168.1.1PreferredAuthentications publickeyIdentityFile ~/.ssh/mygit_id_rsa #key路径# giteeHost gitee.comHostName gitee.comPreferredAuthentications publickeyIdentityFile ~/.ssh/gitee_id_rsa# githubHost github.comHostName github.comPreferredAuthentications publickeyIdentityFile ~/.ssh/github_id_rsa
&nbsp;&nbsp;然后把对应的.pub文件填入到git服务器，如何添加到到自己的git服务器要因情况而定，故不再展示

&nbsp;&nbsp;测试是否能连通服务器ssh -T git@gitee.comssh -T git@github.com
&nbsp;&nbsp;补充一下我的新电脑在使用git时出现的问题，clone项目时反复提示Could not resolve host: gitee.com，任何域名都ping不通，但是直接pingIP地址又是没问题的，疑似是git bash无法解析域名，在网上查阅了很多文章，大都是说修改host文件，于是抱着试一试的心态给gitee添加了手动解析，果不其然，没有一丁点效果ping gitee # 将会提示Ping request could not find host gitee.com. Please check the name and try again.ping 212.64.63.190# IP地址是没问题的&nbsp;&nbsp;然后我以为是DNS的问题，但是后来发现在cmd命令窗口中可以ping通域名，也就是说DNS是没问题的，最后的最后，在无意间，将git bash的编码由uf8修改为gbk之后就可以ping通域名了

&nbsp;&nbsp;但是后遗症是无法正常读取utf8的中文，总起来说就是说utf8编码无法解析域名，gbk可以解析域名，但是无法正常显示utf8编码的中文，他妈了个蛋的
&nbsp;&nbsp;后来根据网上中文乱码的文章，都无济于事&nbsp;&nbsp;最后解决的方案，在控制面板 → “时钟和区域” → “区域” → “管理” → “更改系统区域设置” → 选中“使用Unicode UTF-8提供全球语言支持”，然后修改git bash的编码格式为utf-8，重启就可以了

]]></content>
      <categories>
        <category>菜鸡手记</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Lambda</title>
    <url>/2021/07/24/Lambda/</url>
    <content><![CDATA[匿名类
package July_2021.demo2;public class 匿名类 &#123;    public static void main(String[] args) &#123;        匿名类 nm = new 匿名类();        nm.test(new price()&#123;            @Override            public String name() &#123;                return &quot;测试&quot;;            &#125;        &#125;);    &#125;    public void test(price name)&#123;        System.out.println(name.name());    &#125;&#125;interface price&#123;    String name();&#125;
lambda修改后
package July_2021.demo2;public class 匿名类 &#123;    public static void main(String[] args) &#123;        匿名类 nm = new 匿名类();        nm.test(() -&gt; &#123;            return &quot;测试&quot;;        &#125;);    &#125;    public void test(price name)&#123;        System.out.println(name.name());    &#125;&#125;interface price&#123;    String name();&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Git仓库添加多个地址</title>
    <url>/2022/08/31/Git%E4%BB%93%E5%BA%93%E6%B7%BB%E5%8A%A0%E5%A4%9A%E4%B8%AA%E5%9C%B0%E5%9D%80/</url>
    <content><![CDATA[&ensp;&ensp;前不久经历了gitee的“仓库丢失”风波，而后又被莫名其妙的注销了账号，虽然后面官方都给解决了，但是还是让我有了把项目同步到多个代码托管平台的想法
方法一&ensp;&ensp;关联多个SSH地址git remote add gitee git@gitee.com/address.git # gitee仓库地址git remote add gitlab git@jihulab.com/address.git # gitlab仓库地址
&ensp;&ensp;列出关联的所有SSH地址git remote -v
&ensp;&ensp;如果之前添加过默认的关联，此时将会列出gitee   git@gitee.com/address.git (fetch)gitee   git@gitee.com/address.git (push)gitlab  git@jihulab.com/address.git (fetch)gitlab  git@jihulab.com/address.git (push)origin  git@gitee.com/address.git (fetch)origin  git@gitee.com/address.git (push)
&ensp;&ensp;如果想移除关联git remote remove origin
&ensp;&ensp;同步项目到服务器git push gitee master # 同步master分支到gitee仓库git push gitlab master # 同步master分支到gitlab仓库
&ensp;&ensp;拉项目到本地git pull gitee master # 将gitee仓库中的master项目拉到本地git pull gitlab master # 将gitlab仓库中的master项目拉到本地
方法二&ensp;&ensp;给origin添加另一个可以同步的地址git remote set-url --add origin git@jihulab.com/address.git
&ensp;&ensp;从origin中删掉一个地址git remote set-url --delete origin git@jihulab.com/address.git
&ensp;&ensp;通过这种方式，可以push一次到两个仓库
]]></content>
      <categories>
        <category>菜鸡手记</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>NDK开发</title>
    <url>/2024/02/11/NDK%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[NDK开发工具下载

在模块级gradle中指定NDK版本
android &#123;    ndkVersion &quot;26.1.10909125&quot;&#125;
cmake下载

在指定模块中创建cmake构建脚本CMakeLists.txt，并在模块级gradle中指定cmake构建脚本位置及cmake版本
android &#123;    externalNativeBuild &#123;        cmake &#123;            // 指定cmake构建脚本位置            path file(&#x27;src/main/cpp/CMakeLists.txt&#x27;)            // 指定cmake构建脚本的版本            version &#x27;3.22.1&#x27;        &#125;    &#125;&#125;
创建一个cpp文件，这个cpp文件用于与java建立连接，引入如下库
#include &lt;jni.h&gt;
在cmake构建脚本CMakeLists.txt中，指定如下内容
# 指定CMake的最低版本要求cmake_minimum_required(VERSION 3.22.1)# 定义本地库名称project(&quot;decoder&quot;)# 添加 decoder.cpp 共享库add_library($&#123;CMAKE_PROJECT_NAME&#125; SHARED    decoder.cpp)# 链接目标库到其他库target_link_libraries($&#123;CMAKE_PROJECT_NAME&#125;    android    log)
在java代码中引入本地库
static &#123;    System.loadLibrary(&quot;decoder&quot;);&#125;
然后可以定义native方法
public static native int test(int num1, int num2);
通过Alt+Enter快捷键，可以在对应的c++文件中创建对应的函数
extern &quot;C&quot;JNIEXPORT jint JNICALLJava_xyz_xxin_silkdecoder_DecoderNative_test(JNIEnv *env, jclass clazz, jint num1, jint num2) &#123;    // TODO: implement test()    return num1 + num2;&#125;
参考：https://developer.android.google.cn/ndk/guides?hl=zh-cn
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android开发手记</tag>
      </tags>
  </entry>
  <entry>
    <title>RecyclerView实现批量选择</title>
    <url>/2022/02/12/RecyclerView%E5%AE%9E%E7%8E%B0%E6%89%B9%E9%87%8F%E9%80%89%E6%8B%A9/</url>
    <content><![CDATA[图中展示了部分效果
所需资源&ensp;&ensp;&ensp;&ensp;只用到了两个小图片
布局主页布局&ensp;&ensp;&ensp;&ensp;这里注意下，底部的操作栏初始状态是隐藏的，当点击右上角编辑按钮时才显示它&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;    android:orientation=&quot;vertical&quot;    tools:context=&quot;.MainActivity&quot;&gt;&lt;!--    顶部框--&gt;    &lt;androidx.constraintlayout.widget.ConstraintLayout        android:background=&quot;@android:color/holo_blue_bright&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;60dp&quot;&gt;        &lt;TextView            android:layout_width=&quot;wrap_content&quot;            android:layout_height=&quot;wrap_content&quot;            android:text=&quot;RecyclerView&quot;            android:textColor=&quot;@color/black&quot;            android:textSize=&quot;16sp&quot;            android:textStyle=&quot;bold&quot;            app:layout_constraintBottom_toBottomOf=&quot;parent&quot;            app:layout_constraintEnd_toEndOf=&quot;parent&quot;            app:layout_constraintStart_toStartOf=&quot;parent&quot;            app:layout_constraintTop_toTopOf=&quot;parent&quot;            tools:ignore=&quot;MissingConstraints&quot; /&gt;        &lt;TextView            android:id=&quot;@+id/editor&quot;            android:layout_width=&quot;wrap_content&quot;            android:layout_height=&quot;wrap_content&quot;            android:text=&quot;编辑&quot;            android:textSize=&quot;16sp&quot;            android:textStyle=&quot;bold&quot;            android:layout_marginRight=&quot;20dp&quot;            app:layout_constraintBottom_toBottomOf=&quot;parent&quot;            app:layout_constraintEnd_toEndOf=&quot;parent&quot;            app:layout_constraintTop_toTopOf=&quot;parent&quot;            tools:ignore=&quot;MissingConstraints&quot;            android:layout_marginEnd=&quot;20dp&quot; /&gt;    &lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;&lt;!--    中间的列表--&gt;    &lt;androidx.recyclerview.widget.RecyclerView        android:id=&quot;@+id/recyclerView&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;0dp&quot;        android:layout_weight=&quot;1&quot;/&gt;    &lt;View        android:background=&quot;@color/black&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;1dp&quot;/&gt;&lt;!--    底部操作框--&gt;    &lt;androidx.constraintlayout.widget.ConstraintLayout        android:visibility=&quot;gone&quot;        android:id=&quot;@+id/footBar&quot;        android:padding=&quot;10dp&quot;        android:orientation=&quot;horizontal&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;wrap_content&quot;&gt;        &lt;TextView            android:id=&quot;@+id/selectSum&quot;            android:layout_width=&quot;wrap_content&quot;            android:layout_height=&quot;wrap_content&quot;            android:text=&quot;当前共选中: &quot;            android:textStyle=&quot;bold&quot;            android:textSize=&quot;16sp&quot;            android:textColor=&quot;@android:color/holo_red_dark&quot;            app:layout_constraintBottom_toBottomOf=&quot;parent&quot;            app:layout_constraintStart_toStartOf=&quot;parent&quot;            app:layout_constraintTop_toTopOf=&quot;parent&quot;            tools:ignore=&quot;MissingConstraints&quot; /&gt;        &lt;Button            android:text=&quot;全选&quot;            android:id=&quot;@+id/selectAll&quot;            android:layout_width=&quot;wrap_content&quot;            android:layout_height=&quot;wrap_content&quot;            app:layout_constraintBottom_toBottomOf=&quot;parent&quot;            app:layout_constraintEnd_toEndOf=&quot;parent&quot;            app:layout_constraintTop_toTopOf=&quot;parent&quot;            tools:ignore=&quot;MissingConstraints&quot; /&gt;        &lt;Button            android:text=&quot;删除&quot;            android:id=&quot;@+id/deleteAll&quot;            android:layout_width=&quot;wrap_content&quot;            android:layout_height=&quot;wrap_content&quot;            app:layout_constraintBottom_toBottomOf=&quot;parent&quot;            app:layout_constraintEnd_toStartOf=&quot;@+id/selectAll&quot;            app:layout_constraintTop_toTopOf=&quot;parent&quot;            tools:ignore=&quot;MissingConstraints&quot; /&gt;    &lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;&lt;/LinearLayout&gt;
item布局&ensp;&ensp;&ensp;&ensp;列表项的布局item.xml，这里注意下，表示选中状态的图片在没有开启编辑状态时是隐藏的&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;    android:layout_width=&quot;match_parent&quot;    android:padding=&quot;10dp&quot;    android:gravity=&quot;center_vertical&quot;    android:layout_height=&quot;wrap_content&quot;    tools:ignore=&quot;UseCompoundDrawables&quot;&gt;&lt;!--    是否选中--&gt;    &lt;ImageView        android:visibility=&quot;gone&quot;        android:id=&quot;@+id/itemSelect&quot;        android:src=&quot;@drawable/select&quot;        android:layout_width=&quot;20dp&quot;        android:layout_height=&quot;20dp&quot;        tools:ignore=&quot;ContentDescription&quot; /&gt;&lt;!--    列表项的标题--&gt;    &lt;TextView        android:layout_marginTop=&quot;10dp&quot;        android:layout_marginBottom=&quot;10dp&quot;        android:id=&quot;@+id/itemTitle&quot;        android:textColor=&quot;@color/black&quot;        android:textSize=&quot;16sp&quot;        android:textStyle=&quot;bold&quot;        android:layout_marginLeft=&quot;20dp&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;/&gt;&lt;/LinearLayout&gt;
程序item属性类&ensp;&ensp;&ensp;&ensp;创建ItemProperty类，用于记录item的属性值/** * item的属性 */public class ItemProperty &#123;    private String title; //item标题    private boolean isSelect; //是否选中    public String getTitle() &#123;        return title;    &#125;    public boolean isSelect() &#123;        return isSelect;    &#125;    public void setTitle(String title) &#123;        this.title = title;    &#125;    public void setSelect(boolean select) &#123;        isSelect = select;    &#125;&#125;
列表构造器&ensp;&ensp;&ensp;&ensp;boolean isEditStatus表示现在是否在编辑状态，通过setEditMode(boolean)方法可以设置，传入true时表示进入编辑状态，反之退出&ensp;&ensp;&ensp;&ensp;List&lt;ItemProperty&gt; itemProperties是item属性的集合，通过notifyList(List&lt;ItemProperty&gt;)方法可以设置，设置时更新数据；通过getItemProperties()可以获取这个变量值&ensp;&ensp;&ensp;&ensp;然后有一个用于实现itemClick的接口等一系列，在onBindViewHolder()中响应了它，并且onBindViewHolder()中根据不同状态对item的属性做不同的设置，其它没啥好解释的public class RecyclerBuilder extends RecyclerView.Adapter&lt;RecyclerBuilder.MyViewHolder&gt; &#123;    private final Context context;    private List&lt;ItemProperty&gt; itemProperties; //item属性集合    public RecyclerBuilder(Context context) &#123;        this.context = context;    &#125;    @NonNull    @Override    public MyViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) &#123;        View view = LayoutInflater.from(context).inflate(R.layout.item, parent, false);        return new MyViewHolder(view);    &#125;    @Override    public void onBindViewHolder(@NonNull MyViewHolder holder, int position) &#123;        holder.itemTitle.setText(itemProperties.get(position).getTitle());//        是否是编辑状态，是的话显示选中按钮，反之隐藏        if (isEditStatus)&#123;            holder.itemSelect.setVisibility(View.VISIBLE);//            按钮是否为选中状态            if (itemProperties.get(position).isSelect())&#123;                holder.itemSelect.setImageResource(R.drawable.selectfill);            &#125;            else &#123;                holder.itemSelect.setImageResource(R.drawable.select);            &#125;        &#125;        else &#123;            holder.itemSelect.setVisibility(View.GONE);        &#125;//        itemClick        holder.itemView.setOnClickListener(view -&gt; &#123;            if (onRecyclerViewItemClick != null)&#123;                onRecyclerViewItemClick.OnItemClick(holder.getAdapterPosition(), itemProperties);            &#125;        &#125;);    &#125;    @Override    public int getItemCount() &#123;        return itemProperties.size();    &#125;    public static class MyViewHolder extends RecyclerView.ViewHolder &#123;        private final TextView itemTitle;        private final ImageView itemSelect;        public MyViewHolder(@NonNull View itemView) &#123;            super(itemView);            itemTitle = itemView.findViewById(R.id.itemTitle);            itemSelect = itemView.findViewById(R.id.itemSelect);        &#125;    &#125;//    获取item属性集合    public List&lt;ItemProperty&gt; getItemProperties() &#123;        return itemProperties;    &#125;    //刷新列表数据    @SuppressLint(&quot;NotifyDataSetChanged&quot;)    public void notifyList(List&lt;ItemProperty&gt; itemProperties)&#123;        this.itemProperties = itemProperties;        notifyDataSetChanged();    &#125;    private boolean isEditStatus; //是否是编辑状态//    设置编辑模式    @SuppressLint(&quot;NotifyDataSetChanged&quot;)    public void setEditMode(boolean isEditStatus)&#123;        this.isEditStatus = isEditStatus;        notifyDataSetChanged();//刷新列表    &#125;//    响应itemClick    public void setOnRecyclerViewItemClick(OnRecyclerViewItemClick onRecyclerViewItemClick)&#123;        this.onRecyclerViewItemClick = onRecyclerViewItemClick;    &#125;    private OnRecyclerViewItemClick onRecyclerViewItemClick; //itemClick    interface OnRecyclerViewItemClick&#123;        void OnItemClick(int position, List&lt;ItemProperty&gt; itemProperties);    &#125;&#125;
主页&ensp;&ensp;&ensp;&ensp;当点击右上角编辑按钮时，进入编辑模式，显示列表item表示选中的图标，此时点击item将会亮起选中图标&ensp;&ensp;&ensp;&ensp;点击全选会根据当前的选中状态，全部选中或者取消全部选中&ensp;&ensp;&ensp;&ensp;点击删除出现弹窗提示，此时确定即删除所有选中的item
public class MainActivity extends AppCompatActivity implements View.OnClickListener, RecyclerBuilder.OnRecyclerViewItemClick &#123;    private TextView editor_et; //右上角编辑按钮    private TextView selectSum_tv; //显示当前选中的数量    private Button deleteAll_btn; //删除按钮    private Button selectAll_btn; //全部选中按钮    private RecyclerView recyclerView; //列表    private ConstraintLayout footBar; //底部的操作栏    private final List&lt;ItemProperty&gt; itemProperties = new ArrayList&lt;&gt;(); //item属性集合    private RecyclerBuilder recyclerBuilder; //列表适配器    private boolean isEditStatus = false; //是否是编辑状态    private boolean isSelectAll = false; //是否是全选状态    private int selectedSum; //已经选中的item的数量    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        initView(); //初始化view        initData(); //初始化数据        initEvent(); //初始化事件    &#125;    /**     * 初始化view     */    private void initView() &#123;        editor_et = findViewById(R.id.editor);        selectSum_tv = findViewById(R.id.selectSum);        deleteAll_btn = findViewById(R.id.deleteAll);        selectAll_btn = findViewById(R.id.selectAll);        recyclerView = findViewById(R.id.recyclerView);        footBar = findViewById(R.id.footBar);    &#125;    /**     * 初始化数据，加载列表     */    private void initData() &#123;        recyclerBuilder = new RecyclerBuilder(MainActivity.this);        LinearLayoutManager linearLayoutManager = new LinearLayoutManager(MainActivity.this);        recyclerView.setAdapter(recyclerBuilder); //设置适配器        recyclerView.setLayoutManager(linearLayoutManager); //设置布局//        添加数据        for (int i = 0; i &lt; 100; i++) &#123;            ItemProperty itemProperty = new ItemProperty();            itemProperty.setTitle(&quot;第&quot; + i + &quot;项&quot;);            itemProperties.add(itemProperty);            recyclerBuilder.notifyList(itemProperties); //逐次刷新列表数据        &#125;        recyclerView.addItemDecoration(new DividerItemDecoration(MainActivity.this, DividerItemDecoration.VERTICAL));    &#125;    /**     * 监听事件     */    private void initEvent() &#123;        recyclerBuilder.setOnRecyclerViewItemClick(this); //item的click        editor_et.setOnClickListener(this); //编辑按钮        selectAll_btn.setOnClickListener(this);        deleteAll_btn.setOnClickListener(this);    &#125;    @SuppressLint(&#123;&quot;SetTextI18n&quot;, &quot;NotifyDataSetChanged&quot;&#125;)    @Override    public void OnItemClick(int position, List&lt;ItemProperty&gt; itemProperties) &#123;//        位于编辑状态下        if (isEditStatus)&#123;            ItemProperty itemProperty = itemProperties.get(position);//            如果item是选中状态            if (itemProperty.isSelect())&#123;                selectedSum--;                itemProperty.setSelect(false);            &#125;//            非选中状态            else &#123;                selectedSum++;                itemProperty.setSelect(true);            &#125;//            判断所有item是否都已经被选中            if (selectedSum == itemProperties.size())&#123;                selectAll_btn.setText(&quot;取消全选&quot;);                isSelectAll = true;            &#125;            else &#123;                selectAll_btn.setText(&quot;全选&quot;);                isSelectAll = false;            &#125;//            设置选中个数显示，刷新列表            selectSum_tv.setText(&quot;当前共选中: &quot; + selectedSum + &quot;个&quot;);            recyclerBuilder.notifyDataSetChanged();        &#125;//        没有位于编辑状态        else &#123;            Toast.makeText(MainActivity.this, &quot;点击了：&quot; + position, Toast.LENGTH_SHORT).show();        &#125;    &#125;    @SuppressLint(&quot;NonConstantResourceId&quot;)    @Override    public void onClick(View view) &#123;        switch (view.getId())&#123;            case R.id.editor:                editorClick();                break;            case R.id.selectAll:                selectAllClick();                break;            case R.id.deleteAll:                deleteAllClick();        &#125;    &#125;    /**     * 点击编辑按钮时，根据表示当前编辑状态的变量，判断进入或退出编辑模式     */    private void editorClick() &#123;        if (isEditStatus)&#123;            editor_et.setText(&quot;编辑&quot;);            footBar.setVisibility(View.GONE); //隐藏底部操作栏            isEditStatus = false;        &#125;        else &#123;            editor_et.setText(&quot;取消&quot;);            footBar.setVisibility(View.VISIBLE); //显示底部操作栏            isEditStatus = true;            clearAllSelected(); //设置所有item为未选中        &#125;//        设置编辑模式        recyclerBuilder.setEditMode(isEditStatus);    &#125;    /**     * 点击全选按钮时，根据当前选中状态，调用全部选中或者取消全部选中     */    @SuppressLint(&quot;NotifyDataSetChanged&quot;)    private void selectAllClick() &#123;//        是否已经在全选状态        if (isSelectAll)&#123;            clearAllSelected();        &#125;        else &#123;            checkAllItem();        &#125;//        刷新列表        recyclerBuilder.notifyDataSetChanged();    &#125;    /**     * 全部选中     */    @SuppressLint(&quot;SetTextI18n&quot;)    private void checkAllItem() &#123;//        从适配器中获取item属性的集合        List&lt;ItemProperty&gt; itemProperties = recyclerBuilder.getItemProperties();        selectedSum = itemProperties.size(); //选中个数        selectSum_tv.setText(&quot;当前选中了: &quot; + selectedSum + &quot;个&quot;); //设置选中个数显示        isSelectAll = true; //进入全选状态        selectAll_btn.setText(&quot;取消全选&quot;); //设置按钮显示//        遍历设置所有item为未选中状态        for (int i = 0; i &lt; itemProperties.size(); i++) &#123;            itemProperties.get(i).setSelect(true);        &#125;    &#125;    /**     * 取消所有选中     */    @SuppressLint(&quot;SetTextI18n&quot;)    private void clearAllSelected() &#123;//        从适配器中获取item属性的集合        List&lt;ItemProperty&gt; itemProperties = recyclerBuilder.getItemProperties();        selectedSum = 0; //选中个数        selectSum_tv.setText(&quot;当前选中了: &quot; + selectedSum + &quot;个&quot;); //设置选中个数显示        isSelectAll = false; //退出全选状态        selectAll_btn.setText(&quot;全选&quot;); //设置按钮显示        for (int i = 0; i &lt; itemProperties.size(); i++) &#123;            itemProperties.get(i).setSelect(false);        &#125;    &#125;    /**     * 删除按钮     */    @SuppressLint(&#123;&quot;SetTextI18n&quot;, &quot;NotifyDataSetChanged&quot;&#125;)    private void deleteAllClick() &#123;        if (selectedSum == 0)&#123;            Toast.makeText(MainActivity.this, &quot;没有选中&quot;, Toast.LENGTH_SHORT).show();            return;        &#125;//        dialog提示        AlertDialog.Builder builder = new AlertDialog.Builder(MainActivity.this);        builder.setTitle(&quot;确定删除吗&quot;)                .setMessage(&quot;将会删除&quot; + selectedSum + &quot;个item&quot;)                .setPositiveButton(&quot;确定&quot;, (dialogInterface, i) -&gt; &#123;                    deleteSelected(); //删除选中                    dialogInterface.dismiss();                &#125;)                .setNeutralButton(&quot;取消&quot;, (dialogInterface, i) -&gt; dialogInterface.dismiss())                .create().show();    &#125;    /**     * 删除选中     */    @SuppressLint(&#123;&quot;SetTextI18n&quot;, &quot;NotifyDataSetChanged&quot;&#125;)    private void deleteSelected() &#123;//        从适配器中获取item属性的集合        List&lt;ItemProperty&gt; itemProperties = recyclerBuilder.getItemProperties();//        循环判断选中状态的item属性类，并从item属性集合中删除        for (int i = itemProperties.size()-1, j = 0; i &gt;= j; i--)&#123;            ItemProperty itemProperty = itemProperties.get(i);            if (itemProperty.isSelect())&#123;                itemProperties.remove(itemProperty);                selectedSum--;            &#125;        &#125;        selectSum_tv.setText(&quot;当前选中了: &quot; + selectedSum + &quot;个&quot;); //设置选中个数显示        recyclerBuilder.notifyDataSetChanged(); //刷新数据    &#125;&#125;
源代码：https://github.com/xxinPro/RecyclerCheck
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android开发手记</tag>
      </tags>
  </entry>
  <entry>
    <title>RecyclerView滚动到指定item</title>
    <url>/2021/10/27/RecyclerView%E6%BB%9A%E5%8A%A8%E5%88%B0%E6%8C%87%E5%AE%9Aitem/</url>
    <content><![CDATA[添加数据&ensp;&ensp;&ensp;&ensp;一组平平无奇的数据，从0-999共一千条，Adapter类就不外放了，没意思public class MainActivity extends AppCompatActivity&#123;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        RecyclerView recyclerView = findViewById(R.id.recyclerView);        setData(recyclerView);    &#125;    private void setData(RecyclerView recyclerView) &#123;        List&lt;String&gt; strings = new ArrayList&lt;&gt;();//        一千条数据        for (int i = 0; i &lt; 1000; i++) &#123;            strings.add(&quot;数据&quot; + i);        &#125;        MyRecyclerViewAdapter myRecyclerViewAdapter = new MyRecyclerViewAdapter(this,strings);        LinearLayoutManager linearLayoutManager = new LinearLayoutManager(this,RecyclerView.VERTICAL,false);        recyclerView.setAdapter(myRecyclerViewAdapter);        recyclerView.setLayoutManager(linearLayoutManager);//        添加一条分割线        recyclerView.addItemDecoration(new DividerItemDecoration(this,DividerItemDecoration.VERTICAL));    &#125;&#125;&ensp;&ensp;&ensp;&ensp;看下效果吧
item滚动&ensp;&ensp;&ensp;&ensp;当RecyclerView的item全部加载完毕后，毫无疑问，第一条也就是item0一定是位于顶部的，那如何指定任意一个item，使得RecyclerView滑动到这个item置顶
&ensp;&ensp;&ensp;&ensp;妈的，经过研究，根本就没有那么麻烦，我他妈又是视图树观察又是布局加载监听的，其实一个scrollToPosition()就搞定了，破防了妈的//    直接调用这个方法就是了    private void setItemTo(RecyclerView recyclerView, final int position)&#123;        recyclerView.scrollToPosition(position);//滚动到指定item！！！    &#125;	//    如果不想使用RecyclerView，用它的布局管理器也可以    private void setItemTo(LinearLayoutManager linearLayoutManager, int position)&#123;        linearLayoutManager.scrollToPosition(position);    &#125;

]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android开发手记</tag>
      </tags>
  </entry>
  <entry>
    <title>SHA加密</title>
    <url>/2022/03/03/SHA%E5%8A%A0%E5%AF%86/</url>
    <content><![CDATA[&ensp;&ensp;&ensp;&ensp;加密的方法/** * 字符串SHA加密 * @param text 要加密的字符串 * @param type 加密类型 * @return 加密结果 */private static String SHA(String text, String type)&#123;    String result = null;    if (text != null &amp;&amp; text.length() &gt; 0)&#123;        try &#123;            MessageDigest messageDigest = MessageDigest.getInstance(type);            messageDigest.update(text.getBytes(StandardCharsets.UTF_8));            byte[] bytes = messageDigest.digest();            StringBuilder stringBuilder = new StringBuilder();            for (int i = 0; i &lt; bytes.length; i++) &#123;                String hex = Integer.toHexString(0xff &amp; bytes[i]);                if (hex.length() == 1)&#123;                    stringBuilder.append(&quot;0&quot;);                &#125;                stringBuilder.append(hex);            &#125;            result = stringBuilder.toString();        &#125; catch (NoSuchAlgorithmException e) &#123;            e.printStackTrace();        &#125;    &#125;    return  result;&#125;
&ensp;&ensp;&ensp;&ensp;SHA256加密/** * sha-256加密 * @param text 要加密的字符串 * @return 加密结果 */public static String SHA256(String text)&#123;    return SHA(text, &quot;SHA-256&quot;);&#125;
&ensp;&ensp;&ensp;&ensp;SHA512加密/** * sha-512加密 * @param text 要加密的字符串 * @return 加密结果 */public static String SHA512(String text)&#123;    return SHA(text, &quot;SHA-512&quot;);&#125;
&ensp;&ensp;&ensp;&ensp;MD5加密/** * md5加密 * @param text 要加密的字符串 * @return 加密结果 */public static String SHAMD5(String text)&#123;    return SHA(text, &quot;MD5&quot;);&#125;
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java开发手记</tag>
      </tags>
  </entry>
  <entry>
    <title>SILK API文档翻译</title>
    <url>/2024/02/16/SILK-API%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91/</url>
    <content><![CDATA[下载SILK开发包下载地址：https://lxx6.lanzouq.com/itL0C1oesnab
中文文档应用程序编程接口（API）在interface文件夹中的四个头文件中定义：

SKP_Silk_SDK_API.h – SILK编码器和解码器的函数声明。
SKP_Silk_control.h – 控制编码器和从解码器获取状态信息的结构声明。
SKP_API_typedef.h  – 类型定义。
SKP_Silk_errors.h  – SILK SDK的错误代码描述。

高级设置通常只应根据特殊需求进行更改，可以在src文件夹中的头文件中进行设置：

SKP_Silk_define.h – 用于控制SILK SDK的各种定义。

编码器控制结构描述（SKP_Silk_control.h）编码器结构（SKP_SILK_SDK_EncControlStruct）具有以下成员：

SKP_int32 API_sampleRate;  （输入）编码器的API采样频率（以为赫兹单位）。有效值为：8000、12000、16000、24000、32000、44100和48000。这个采样频率表示输入信号到编码器的采样频率。
SKP_int32 maxInternalSampleRate;  （输入）编码器的最大内部采样频率（以为赫兹单位）。有效值为：8000、12000、16000和24000。这个采样频率表示编码信号的采样频率。请注意，编码器可能会自动适应采样频率为较低的值。maxInternalSampleRate在呼叫设置期间不得超过RTP时间戳时钟速率。
SKP_int packetSize;  （输入）每个包的样本数。在上述列出的任何API采样频率下，都支持对应于20、40、60、80或100毫秒的样本数，例如，在24000 Hz API采样频率下，20毫秒包的样本数为480。
SKP_int32 bitRate;  （输入）激活语音的目标比特率，范围为5000-100000比特每秒（bps）。如果输入值不在支持的范围内，则在内部限制该值。
SKP_int packetLossPercentage;  （输入）上行方向的估计数据包丢失百分比（0-100）。在数据包丢失的情况下，这控制错误传播。如果使用带内前向错误更正，则此信息还确定编码器将添加多少保护。
SKP_int complexity;  （输入）复杂性设置。支持的值为0、1和2，其中0是最低复杂性，2是最高复杂性。
SKP_int useInBandFEC;  （输入）启用/禁用带内前向错误更正（0禁用，1启用）。
SKP_int useDTX;  （输入）启用/禁用不连续传输（0禁用，1启用）。

解码器控制结构描述（SKP_Silk_control.h）解码器结构（SKP_SILK_SDK_DecControlStruct）具有以下成员：

SKP_int32 API_sampleRate;  （输入）解码器输出信号的采样频率（以为赫兹单位）。这个采样频率与接收信号的内部采样频率无关。为了保留所有传输的信息，它至少应该是最大内部采样频率，即编码器的maxInternalSampleRate。有效值为：8000、12000、16000、24000、32000、44100和48000。
SKP_int frameSize;  （输出）样本中的帧大小；始终对应于以API_sampleRate采样的20毫秒数据，即160、240、320、480、640、882或960。
SKP_int framesPerPacket;  （输出）最后解码的包中的20毫秒帧数。可能的输出值为1、2、3、4或5。
SKP_int moreInternalDecoderFrames;  （输出）当设置时，表示从已在解码器中缓冲的多帧有效负载中可用更多输出帧的标志（0或1）。
SKP_int inBandFECOffset;  （输出）主有效负载和冗余有效负载之间的数据包距离（0、1或2）。

注释：SILK解码器将始终解码每个函数调用的20毫秒帧。如果接收的数据包包含多帧，则必须多次调用解码器才能完全解码该数据包。为了指示数据包的解码何时完成，使用moreInternalDecoderFrames标志。如果moreInternalDecoderFrames为0，则最后一个数据包已完全解码，解码器准备好接收下一个数据包。当moreInternalDecoderFrames为1时，解码器尚未完成解码上一个数据包中包含的所有帧，应继续调用解码器，直到moreInternalDecoderFrames更改为0。此外，当moreInternalDecoderFrames为1时，SKP_Silk_SDK_Decode的输入inData将被忽略，因为在这种情况下，最后接收到的数据包的剩余部分将从内部缓冲区中读取。
函数（SKP_Silk_SDK_API.h）所有函数都返回错误代码，如果在函数执行过程中没有遇到错误，则返回0。返回负值表示错误。错误代码的列表可以在SKP_Silk_errors.h中找到。
SKP_Silk_SDK_Get_Encoder_Size将SILK编码器状态的大小（以字节为单位）写入*encSizeBytes。使用此函数可以为编码器状态分配适当的内存空间。
SKP_int SKP_Silk_SDK_Get_Encoder_Size(    SKP_int32 *encSizeBytes);

*encSizeBytes：（输出）编码器状态的大小（以字节为单位）。

SKP_Silk_SDK_InitEncoder初始化编码器状态encState，并返回默认编码器状态encStatus。该函数必须在对编码器的第一次调用之前调用，并且可以被调用以重置内部编码器状态，例如在发起新的语音调用时。
SKP_int SKP_Silk_SDK_InitEncoder(    void                            *encState,    SKP_SILK_SDK_EncControlStruct   *encStatus);

*encState： （输入/输出）编码器状态。
*encStatus：（输出）编码器状态结构。返回默认编码器设置。

SKP_Silk_SDK_QueryEncoderSKP_int SKP_Silk_SDK_QueryEncoder(    const void                      *encState,    SKP_SILK_SDK_EncControlStruct   *encStatus);

*encState：（输入）编码器状态。
*encStatus：（输出）编码器状态结构体。返回当前编码器设置。

描述：返回当前编码器设置encStatus。可以调用此函数来检查编码器的设置。结构成员是静态的，因为它们将保存作为输入传递给编码器的值，除非在超出预期范围的情况下受到内部限制。
SKP_Silk_SDK_Encode这是主要的编码器函数。从samplesIn中读取nSamplesIn个输入样本，并在内部进行缓冲，直到至少有encControl-&gt;packetSize个样本可用时，将编码一个有效载荷并写入outData。参数指针nBytesOut同时用作输入和输出。作为输入，nBytesOut指定有效载荷可能包含的最大字节数；这是（最多）您的应用程序在outData数组中分配的字节数。作为输出，nBytesOut返回outData中有效载荷的实际大小。必须将encControl结构的所有成员设置为有效值（请参阅SKP_SILK_SDK_EncControlStruct的描述），否则将报告错误。输入向量samplesIn的采样频率必须选择为等于或高于encControl-&gt;API_sampleRate中存储的值。输入采样频率应选择等于或高于最大内部采样频率maxInternalSampleRate，并且可以根据最好支持集成应用程序的情况从有效的选择中选择。
SKP_int SKP_Silk_SDK_Encode(    void                                *encState,    const SKP_SILK_SDK_EncControlStruct *encControl,    const SKP_int16                     *samplesIn,    SKP_int                             nSamplesIn,    SKP_uint8                           *outData,    SKP_int16                           *nBytesOut);

*encState：（输入/输出）编码器状态。
*encControl：（输入）保持编码器控制的结构。
*samplesIn：（输入）具有音频样本的nSamplesIn的输入向量。
nSamplesIn:（输入）输入样本数。必须对应10毫秒的倍数，并且不高于encControl-&gt;packetSize。
*outData：（输出）输出有效载荷。
*nBytesOut：（输入/输出）输入：有效负载中允许的最大字节数。输出：有效负载中的输出字节数。

SKP_Silk_SDK_Get_Decoder_Size将SILK解码器状态的大小（以字节为单位）写入decSizeBytes。使用此函数可为解码器状态分配适当的内存空间。
SKP_int SKP_Silk_SDK_Get_Decoder_Size(    SKP_int32 *decSizeBytes);

decSizeBytes：（输出）解码器状态的大小（以字节为单位）。

SKP_Silk_SDK_InitDecoder初始化解码器状态decState。该函数必须在第一次调用解码器之前调用，并且可以被调用以重置内部解码器状态，例如在发起新的语音呼叫时。
SKP_int SKP_Silk_SDK_InitDecoder(    void *decState);
*decState：（输入/输出）编码器状态。
SKP_Silk_SDK_Decode这是解码器的主要功能。当有效负载在传输过程中丢失时，输入lostFlag应设置为1，否则应设置为0。nByteIn输入参数必须与有效负载中用于检测损坏数据包的字节数完全匹配。输出信号的采样率（以赫兹为单位）通过decStatus-&gt;API_sampleRate进行设置。应当确保解码器采样率匹配或超过编码信号的内部采样率。这可以通过将解码器采样率设置为至少24000或者通过在呼叫建立期间向远端发送器指示较低的最大采样率来实现。解码器更新解码器状态decStatus，该状态应用于处理多个帧数据包。请参阅解码器状态结构体的描述。
SKP_int SKP_Silk_SDK_Decode(    void                            *decState,    SKP_SILK_SDK_DecControlStruct   *decStatus,    SKP_int                         lostFlag,    const SKP_uint8                 *inData,    const SKP_int                   nBytesIn,    SKP_int16                       *samplesOut,    SKP_int16                       *nSamplesOut);

*decState：（输入/输出）解码器状态。
*decStatus：（输入/输出）解码器状态结构体。
lostFlag：（输入）用于激活数据包丢失隐藏的标志。0未丢失1已丢失。
*inData：（输入）要解码的分组有效载荷。
nBytesIn：（输入）有效载荷中的字节数（inData）。
*samplesOut:（输出）解码的样本。
*nSamplesOut:（输出）解码的采样数。

SKP_Silk_SDK_search_for_LBRR提取低比特率冗余（LBRR）数据。如果在传输过程中丢失了一个数据包，并且在解码器端有未来的数据包可用，此函数可用于提取任何可用的带内错误校正数据。如果数据包n丢失，并且数据包n + 1或数据包n + 2在解码器端可用，则应执行以下操作：首先，应将数据包n + 1的有效负载输入到SKP_Silk_SDK_search_for_LBRR中，并提供一个lost_offset值为1，即相对于丢失的数据包的相对距离，即(n + 1) - n。如果在调用之后*nLBRRBytes大于零，则意味着数据包中存在LBRR数据，应调用解码器，将LBRRData作为输入有效负载（inData），nLBRRBytes作为有效负载长度（nBytesIn）。如果nLBRRBytes为零，则应搜索数据包n + 2，但这次将lost_offset设置为2，即(n + 2) - n。如果对于数据包n + 2，nLBRRBytes也为零，则应调用解码器，并将lostFlag设置为1以激活正常的数据包丢失遮挡。对于nLBRRBytes大于零的情况，应调用解码器，将LBRRData作为输入有效负载（inData），nLBRRBytes作为有效负载长度（nBytesIn）。
void SKP_Silk_SDK_search_for_LBRR(    const SKP_uint8     *inData,     const SKP_int       nBytesIn,    SKP_int             lost_offset,    SKP_uint8           *LBRRData,    SKP_int16           *nLBRRBytes);

*inData：（输入）未来的数据包有效载荷。
nBytesIn：（输入）数据包有效载荷中的字节数。
lost_offset：（输入）丢失数据包和未来数据包之间的数据包距离（1或2）。
*LBRRData：（输出）提取的冗余LBRR有效载荷。
*nLBRRBytes:（输出）LBRR有效负载的字节数。

SKP_Silk_SDK_get_TOC返回数据包的目录（TOC）结构。
void SKP_Silk_SDK_get_TOC(    const SKP_uint8         *inData,     const SKP_int           nBytesIn,     SKP_Silk_TOC_struct     *Silk_TOC);

*inData：（输入）数据包有效载荷。
nBytesIn：（输入）数据包中的字节数。
*Silk_TOC:（输出）提取的有关数据包的目录信息。

SKP_Silk_SDK_get_version返回一个包含Silk SDK版本号的字符串。
SKP_INLINE const char *SKP_Silk_SDK_get_version();
定义（SKP_Silk_define.h）该文件包含许多控制SILK操作的定义。为了确保正确的操作，大多数都应该单独处理。但是，如果需要与默认操作不同的操作，则可以更改一些。这些是：
// 允许的值为0和1，其中0表示不受限制地使用内部复杂度模式。// 如果设置为1，则仅允许在最低复杂度设置下运行SILK，并减少内存使用。#define LOW_COMPLEXITY_ONLY 0// 允许的值为0和1，如果设置为0，SILK模式之间的内部切换会立即发生，导致音频带宽从一帧变到下一帧。// 如果设置为0，则计算复杂度略低。// 如果设置为1，则应用自适应低通滤波器来平滑开关，以获得更悦耳的输出。#define SWITCH_TRANSITION_FILTERING 1
关于采样率的说明在单向SILK语音呼叫中涉及四种类型的采样频率：

RTP时间戳时钟速率。这确定RTP时间戳的更新速率。它在呼叫设置期间进行协商，并在呼叫的持续时间内保持不变。
内部采样率。这确定核心SILK编解码器运行的采样率。它可以通过maxInternalSampleRate编码器参数进行限制，该参数不得超过RTP时间戳时钟速率。这样做的原因是，SILK的早期版本无法解码具有比解码器API采样率更高的内部采样率的信号。
编码器API采样率。这确定传递到SILK编码器的音频信号的采样率。虽然可以在对编码器的函数调用之间的任何时候更改，但在切换的时候可能会发生小的音频故障。
解码器API采样率。这确定由SILK解码器提供的音频信号的采样率。虽然可以在对解码器的函数调用之间的任何时候更改，但在切换的时候可能会发生小的音频故障。

参考测试程序该软件开发工具包（SDK）包含有关SILK编码器（test/Encoder.c）和解码器（test/Decoder.c）的测试程序的源代码实现。该代码作为API的参考实现，提供了一种快速编译、运行和分析SILK在不同模式下在任何比特率下的性能的方式。
在Mac或Linux上，可以使用提供的Makefile来编译和生成SDK的测试程序。用于生成编码器和解码器测试程序的目标分别是Encoder和Decoder。类似地，在Windows上，可以通过提供的Visual Studio 2005或2010解决方案和项目来生成测试程序。运行任何可执行文件都可以。
]]></content>
      <categories>
        <category>便笺</category>
      </categories>
      <tags>
        <tag>频繁查阅</tag>
      </tags>
  </entry>
  <entry>
    <title>ScrollView+RecyclerView实现悬停导航栏</title>
    <url>/2021/10/15/ScrollView-RecyclerView%E5%AE%9E%E7%8E%B0%E6%82%AC%E5%81%9C%E5%AF%BC%E8%88%AA%E6%A0%8F/</url>
    <content><![CDATA[效果预览
设计思路
主页布局&ensp;&ensp;&ensp;&ensp;个人喜欢用LinearLayout做最外层布局，任何情况下。。。&ensp;&ensp;&ensp;&ensp;这里需要先用到ScrollView，等下再使用重写的ScrollView类来取代它
activity_main.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout android:layout_height=&quot;match_parent&quot;    android:layout_width=&quot;match_parent&quot;    android:orientation=&quot;vertical&quot;    android:gravity=&quot;center&quot;    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;    &lt;ScrollView        android:id=&quot;@+id/myScrollView&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;match_parent&quot;&gt;        &lt;LinearLayout            android:orientation=&quot;vertical&quot;            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;match_parent&quot;&gt;&lt;!--            顶部--&gt;            &lt;LinearLayout                android:gravity=&quot;center&quot;                android:orientation=&quot;vertical&quot;                android:background=&quot;#0000FF&quot;                android:layout_width=&quot;match_parent&quot;                android:layout_height=&quot;200dp&quot;&gt;                &lt;TextView                    android:text=&quot;顶部&quot;                    android:textColor=&quot;@color/white&quot;                    android:textStyle=&quot;bold&quot;                    android:textSize=&quot;18sp&quot;                    android:layout_width=&quot;wrap_content&quot;                    android:layout_height=&quot;wrap_content&quot;/&gt;            &lt;/LinearLayout&gt;&lt;!--            导航栏--&gt;&lt;!--            这里给导航栏加了tag标签，方便找到它--&gt;            &lt;LinearLayout                android:gravity=&quot;center&quot;                android:background=&quot;#FFFFE0&quot;                android:layout_width=&quot;match_parent&quot;                android:tag=&quot;NavBar&quot;                android:layout_height=&quot;60dp&quot;&gt;                &lt;TextView                    android:text=&quot;顶部&quot;                    android:textColor=&quot;@color/black&quot;                    android:textStyle=&quot;bold&quot;                    android:textSize=&quot;18sp&quot;                    android:layout_width=&quot;wrap_content&quot;                    android:layout_height=&quot;wrap_content&quot;/&gt;            &lt;/LinearLayout&gt;&lt;!--            列表--&gt;            &lt;androidx.recyclerview.widget.RecyclerView                android:id=&quot;@+id/recyclerView&quot;                android:layout_width=&quot;match_parent&quot;                android:layout_height=&quot;wrap_content&quot;/&gt;        &lt;/LinearLayout&gt;    &lt;/ScrollView&gt;&lt;/LinearLayout&gt;
重写ScrollView&ensp;&ensp;&ensp;&ensp;创建MyScrollView类并继承ScrollView，重写ScrollView的前三个构造器，重写onLayout()方法，重写dispatchDraw()方法，在类中创建接口供外部继承调用
MyScrollView.javapackage com.xin.FixBar;import android.content.Context;import android.graphics.Canvas;import android.util.AttributeSet;import android.view.View;import android.widget.LinearLayout;import android.widget.ScrollView;import android.widget.Toast;public class MyScrollView extends ScrollView &#123;    public MyScrollView(Context context) &#123;        super(context);    &#125;    public MyScrollView(Context context, AttributeSet attrs) &#123;        super(context, attrs);    &#125;    public MyScrollView(Context context, AttributeSet attrs, int defStyleAttr) &#123;        super(context, attrs, defStyleAttr);    &#125;    private View view;//用作储存状态栏的View    @Override    protected void onLayout(boolean changed, int l, int t, int r, int b) &#123;        super.onLayout(changed, l, t, r, b);        if (changed)&#123;//            得到滚动布局中的LinearLayout            LinearLayout linearLayout = (LinearLayout) getChildAt(0);            if (linearLayout != null)&#123;//                遍历滚动布局子View LinearLayout的所有子View                for (int i = 0; i &lt; linearLayout.getChildCount(); i++)&#123;//                    将标签为NavBar的View赋值给实例变量view                    if (linearLayout.getChildAt(i).getTag() != null &amp;&amp; linearLayout.getChildAt(i).getTag().toString().equals(&quot;NavBar&quot;))&#123;                        view = linearLayout.getChildAt(i);                        break;                    &#125;                &#125;            &#125;            else &#123;                Toast.makeText(getContext(),&quot;至少有一个LinearLayout作为ScrollView的子View&quot;,Toast.LENGTH_SHORT).show();            &#125;        &#125;    &#125;    @Override    protected void dispatchDraw(Canvas canvas) &#123;        super.dispatchDraw(canvas);//        当getScrollY()与view.getTop()相等时，说明状态栏滑动到了顶部        if (getScrollY() &gt;= view.getTop())&#123;            if (onNavBarListener != null)&#123;                onNavBarListener.OnFix();//固定状态栏            &#125;            canvas.save();            canvas.translate(0,getScrollY());            canvas.clipRect(0,0,view.getMeasuredWidth(),view.getMeasuredHeight());//设置画布的显示范围            view.draw(canvas);//绘制设置的canvas            canvas.restore();//恢复到canvas.save()保存时的状态        &#125;//        状态栏未接触到顶部，则不设置为其固定        else &#123;            if (onNavBarListener != null)&#123;                onNavBarListener.OnReset();//取消固定状态栏            &#125;        &#125;    &#125;//    使在Activity中可以继承或直接调用接口对悬浮状态栏进行设置    private OnNavBarListener onNavBarListener;    public void setOnNavBarListener(OnNavBarListener onNavBarListener)&#123;        this.onNavBarListener = onNavBarListener;    &#125;    public interface OnNavBarListener&#123;        void OnFix();//固定状态栏        void OnReset();//取消固定状态栏    &#125;&#125;
&ensp;&ensp;&ensp;&ensp;然后把activity_main.xml中的ScrollView控件替换为我们重写后的MyScrollView，注意使用完整的类名&lt;com.xin.FixBar.MyScrollView        android:id=&quot;@+id/myScrollView&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;match_parent&quot;&gt;&lt;/com.xin.FixBar.MyScrollView&gt;
创建item的布局item.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout android:layout_height=&quot;60dp&quot;    android:layout_width=&quot;match_parent&quot;    android:gravity=&quot;center_vertical&quot;    android:orientation=&quot;horizontal&quot;    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;    &lt;TextView        android:text=&quot;文本&quot;        android:id=&quot;@+id/item_text&quot;        android:layout_marginLeft=&quot;20dp&quot;        android:textSize=&quot;16sp&quot;        android:textColor=&quot;@color/black&quot;        android:textStyle=&quot;bold&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;/&gt;&lt;/LinearLayout&gt;
创建MyAdapter&ensp;&ensp;&ensp;&ensp;创建MyAdapter类，继承Recycler.Adapter给RecylcerView创建适配器
MyAdapter.javapackage com.xin.FixBar;import android.content.Context;import android.view.View;import android.view.ViewGroup;import android.widget.TextView;import androidx.annotation.NonNull;import androidx.recyclerview.widget.RecyclerView;public class MyAdapter extends RecyclerView.Adapter&lt;MyAdapter.MyViewHolder&gt; &#123;    private Context context;    private String[] data;    public MyAdapter(Context context,String[] data)&#123;        this.context = context;        this.data = data;    &#125;    @NonNull    @Override    public MyViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) &#123;        View view = View.inflate(context,R.layout.item,null);        return new MyViewHolder(view);    &#125;    @Override    public void onBindViewHolder(@NonNull MyViewHolder holder, int position) &#123;        holder.item_view.setText(data[position]);    &#125;    @Override    public int getItemCount() &#123;        return data.length;    &#125;    public class MyViewHolder extends RecyclerView.ViewHolder &#123;        private TextView item_view;        public MyViewHolder(@NonNull View itemView) &#123;            super(itemView);            item_view =itemView.findViewById(R.id.item_text);        &#125;    &#125;&#125;
在MainActivity中调用都在注释里了，啥也不想写。。。package com.xin.FixBar;import androidx.annotation.NonNull;import androidx.appcompat.app.AppCompatActivity;import androidx.recyclerview.widget.LinearLayoutManager;import androidx.recyclerview.widget.RecyclerView;import android.os.Bundle;import android.util.Log;public class MainActivity extends AppCompatActivity &#123;    private MyScrollView myScrollView;    private RecyclerView recyclerView;    private String[] data;    private boolean navBar = false;//navbar的悬浮状态    private MyAdapter myAdapter;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        init();//初始化        setRecycler();//设置列表        setScroll();//设置滚动    &#125;//    设置滚动    private void setScroll() &#123;        myScrollView.setOnNavBarListener(new MyScrollView.OnNavBarListener() &#123;            @Override//            设置为悬浮状态            public void OnFix() &#123;                if (!navBar)&#123;                    navBar = true;                    recyclerView.setNestedScrollingEnabled(true);//允许recyclerView滑动                    Log.d(&quot;setScroll&quot;, &quot;OnReset: recyclerView已允许&quot;);                &#125;            &#125;            @Override//            取消悬浮状态            public void OnReset() &#123;                if (navBar)&#123;                    navBar = false;                    recyclerView.setNestedScrollingEnabled(false);//禁止recyclerView滑动                    Log.d(&quot;setScroll&quot;, &quot;OnReset: recyclerView已禁止&quot;);                &#125;            &#125;        &#125;);    &#125;//    设置列表    private void setRecycler() &#123;        LinearLayoutManager layoutManager = new LinearLayoutManager(this);//实例化一个布局管理器        layoutManager.setOrientation(LinearLayoutManager.VERTICAL);//设置布局方向        recyclerView.setLayoutManager(layoutManager);//给Recycler添加布局//        设置RecyclerView的高度        int pxHeight = this.getResources().getDisplayMetrics().heightPixels;//获取屏幕高度的px        int StatusBarHeight = (int) (60 * this.getResources().getDisplayMetrics().density + 0.5f);//状态栏的px高度        recyclerView.getLayoutParams().height = pxHeight - StatusBarHeight;//得到RecyclerView的高度并设置        myAdapter = new MyAdapter(this,data);//实例化适配器        recyclerView.setAdapter(myAdapter);//设置适配器        recyclerView.setNestedScrollingEnabled(false);//设置recycler为不可滑动，解决滑动冲突//        给RecyclerView添加滑动监听，当滑动至顶部时，禁用RecyclerView滑动        recyclerView.addOnScrollListener(new RecyclerView.OnScrollListener() &#123;            @Override//            滑动停止时调用            public void onScrolled(@NonNull RecyclerView recyclerView, int dx, int dy) &#123;                super.onScrolled(recyclerView, dx, dy);//                当recyclerView滑动到顶部时，canScrollVertically(-1)返回false，禁用它的滑动                if (!recyclerView.canScrollVertically(-1))&#123;                    recyclerView.setNestedScrollingEnabled(false);                &#125;            &#125;        &#125;);    &#125;//    初始化    private void init() &#123;        myScrollView = findViewById(R.id.myScrollView);        recyclerView = findViewById(R.id.recyclerView);        data = new String[]&#123;                &quot;测试1&quot;,&quot;测试2&quot;,&quot;测试3&quot;,&quot;测试4&quot;,&quot;测试5&quot;,&quot;测试6&quot;,&quot;测试7&quot;,&quot;测试8&quot;,&quot;测试9&quot;,&quot;测试10&quot;,&quot;测试11&quot;,&quot;测试12&quot;,&quot;测试13&quot;,&quot;测试14&quot;,                &quot;测试1&quot;,&quot;测试2&quot;,&quot;测试3&quot;,&quot;测试4&quot;,&quot;测试5&quot;,&quot;测试6&quot;,&quot;测试7&quot;,&quot;测试8&quot;,&quot;测试9&quot;,&quot;测试10&quot;,&quot;测试11&quot;,&quot;测试12&quot;,&quot;测试13&quot;,&quot;测试14&quot;,                &quot;测试1&quot;,&quot;测试2&quot;,&quot;测试3&quot;,&quot;测试4&quot;,&quot;测试5&quot;,&quot;测试6&quot;,&quot;测试7&quot;,&quot;测试8&quot;,&quot;测试9&quot;,&quot;测试10&quot;,&quot;测试11&quot;,&quot;测试12&quot;,&quot;测试13&quot;,&quot;测试14&quot;,                &quot;测试1&quot;,&quot;测试2&quot;,&quot;测试3&quot;,&quot;测试4&quot;,&quot;测试5&quot;,&quot;测试6&quot;,&quot;测试7&quot;,&quot;测试8&quot;,&quot;测试9&quot;,&quot;测试10&quot;,&quot;测试11&quot;,&quot;测试12&quot;,&quot;测试13&quot;,&quot;测试14&quot;,                &quot;测试1&quot;,&quot;测试2&quot;,&quot;测试3&quot;,&quot;测试4&quot;,&quot;测试5&quot;,&quot;测试6&quot;,&quot;测试7&quot;,&quot;测试8&quot;,&quot;测试9&quot;,&quot;测试10&quot;,&quot;测试11&quot;,&quot;测试12&quot;,&quot;测试13&quot;,&quot;测试14&quot;        &#125;;    &#125;&#125;
到这里就搞定了
源代码的话，github地址：https://github.com/xxinPro/fixNavBar
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android开发手记</tag>
      </tags>
  </entry>
  <entry>
    <title>Shizuku开发</title>
    <url>/2024/04/28/Shizuku%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[Shizuku开源地址：https://github.com/RikkaApps/ShizukuShizuku开发指南：https://github.com/RikkaApps/Shizuku-API
示例项目开源地址：https://github.com/xxinPro/AdbShellUtils
安装Shizuku该方案通过Shizuku给自己的软件授予adb shell权限，但前提是Shizuku必须拥有adb shell权限，具体可以参考
Shizuku用户手册：https://shizuku.rikka.app/zh-hans/guide/setup/
引入依赖可以选择引入maven central中的远程依赖
def shizuku_version = &quot;13.1.5&quot;implementation &quot;dev.rikka.shizuku:api:$shizuku_version&quot;// implementation &quot;dev.rikka.shizuku:aidl:$shizuku_version&quot;     // 不需要在app gradle中引入// implementation &quot;dev.rikka.shizuku:shared:$shizuku_version&quot;   // 不需要在app gradle中引入implementation &quot;dev.rikka.shizuku:provider:$shizuku_version&quot;
亦或者引入Shizuku-API中对应的模块
implementation project(&#x27;:api&#x27;)// implementation project(&#x27;:shared&#x27;)    // 不需要在app gradle中引入// implementation project(&#x27;:aidl&#x27;)      // 不需要在app gradle中引入implementation project(&#x27;:provider&#x27;)
添加支持在清单文件中加入如下代码
&lt;provider    android:name=&quot;rikka.shizuku.ShizukuProvider&quot;    android:authorities=&quot;$&#123;applicationId&#125;.shizuku&quot;    android:multiprocess=&quot;false&quot;    android:enabled=&quot;true&quot;    android:exported=&quot;true&quot;    android:permission=&quot;android.permission.INTERACT_ACROSS_USERS_FULL&quot; /&gt;
进行完这一步，已经可以发现在Shizuku的应用管理中出现了目标app
判断权限判断当前app是否拥有shizuku中的adb shell权限
/** * 判断是否拥有shizuku adb shell权限 */private boolean checkPermission() &#123;    return Shizuku.checkSelfPermission() == PackageManager.PERMISSION_GRANTED;&#125;
动态申请权限动态申请Shizuku adb shell权限
private void requestShizukuPermission() &#123;    boolean checked = checkPermission();    if (checked) &#123;        Toast.makeText(this, &quot;已拥有权限&quot;, Toast.LENGTH_SHORT).show();        return;    &#125;    if (Shizuku.isPreV11()) &#123;        Toast.makeText(this, &quot;当前shizuku版本不支持动态申请&quot;, Toast.LENGTH_SHORT).show();        return;    &#125;    // 动态申请权限    Shizuku.requestPermission(MainActivity.PERMISSION_CODE);&#125;
Shizuku授权监听
private final Shizuku.OnRequestPermissionResultListener onRequestPermissionResultListener = new Shizuku.OnRequestPermissionResultListener() &#123;    @Override    public void onRequestPermissionResult(int requestCode, int grantResult) &#123;        boolean granted = grantResult == PackageManager.PERMISSION_GRANTED;        if (granted) &#123;            Toast.makeText(MainActivity.this, &quot;授权成功&quot;, Toast.LENGTH_SHORT).show();        &#125; else &#123;            Toast.makeText(MainActivity.this, &quot;授权失败&quot;, Toast.LENGTH_SHORT).show();        &#125;    &#125;&#125;;
授权监听需要手动添加
// 添加权限申请监听Shizuku.addRequestPermissionResultListener(onRequestPermissionResultListener);
在Activity销毁时移除授权监听
// 移除权限申请监听Shizuku.removeRequestPermissionResultListener(onRequestPermissionResultListener);
Shizuku状态监听Shiziku服务被启动时会调用该监听，例如app运行期间，通过电脑abd命令启动Shizuku服务，将会立即调用该监听；此外，在app启动时倘若Shiziku服务处于启动状态，也会调用该监听
// Shiziku服务启动时调用该监听Shizuku.addBinderReceivedListenerSticky(onBinderReceivedListener);private final Shizuku.OnBinderReceivedListener onBinderReceivedListener = new Shizuku.OnBinderReceivedListener() &#123;    @Override    public void onBinderReceived() &#123;        Toast.makeText(MainActivity.this, &quot;Shizuku服务启动&quot;, Toast.LENGTH_SHORT).show();    &#125;&#125;;
Shiziku服务被终止时调用该监听，若app运行期间，Shizuku服务异常终止或手动停止，将会立即调用该监听
// Shiziku服务终止时调用该监听Shizuku.addBinderDeadListener(onBinderDeadListener);private final Shizuku.OnBinderDeadListener onBinderDeadListener = new Shizuku.OnBinderDeadListener() &#123;    @Override    public void onBinderDead() &#123;        Toast.makeText(MainActivity.this, &quot;Shizuku服务终止&quot;, Toast.LENGTH_SHORT).show();    &#125;&#125;;
在Activity销毁时移除监听
Shizuku.removeBinderReceivedListener(onBinderReceivedListener);Shizuku.removeBinderDeadListener(onBinderDeadListener);
执行命令在app级gradle文件中添加如下配置
android &#123;    buildFeatures &#123;        buildConfig true    // 开启BuildConfig类的生成        aidl true           // 启用aidl    &#125;&#125;
在main包下添加aidl目录，其与java、src目录同级，在aidl目录的指定包下创建IUserService.aidl
package xyz.xxin.adbshellutils;interface IUserService &#123;    /**     * Shizuku服务端定义的销毁方法     */    void destroy() = 16777114;    /**     * 自定义的退出方法     */    void exit() = 1;    /**     * 执行命令     */    String exec(String command) = 2;&#125;
在java目录的指定包下创建UserService.java，该服务继承IUserService.Stub，无需在app清单文件中注册
public class UserService extends IUserService.Stub &#123;    @Override    public void destroy() throws RemoteException &#123;    &#125;    @Override    public void exit() throws RemoteException &#123;    &#125;    @Override    public String exec(String command) throws RemoteException &#123;    &#125;&#125;
在UserService.java中实现IUserService.aidl中的方法
public class UserService extends IUserService.Stub &#123;    @Override    public void destroy() throws RemoteException &#123;        System.exit(0);    &#125;    @Override    public void exit() throws RemoteException &#123;        destroy();    &#125;    @Override    public String exec(String command) throws RemoteException &#123;        StringBuilder stringBuilder = new StringBuilder();        try &#123;            // 执行shell命令            Process process = Runtime.getRuntime().exec(command);            // 读取执行结果            InputStreamReader inputStreamReader = new InputStreamReader(process.getInputStream());            BufferedReader bufferedReader = new BufferedReader(inputStreamReader);            String line;            while ((line = bufferedReader.readLine()) != null) &#123;                stringBuilder.append(line).append(&quot;\n&quot;);            &#125;        &#125; catch (IOException e) &#123;            throw new RuntimeException(e);        &#125;        return stringBuilder.toString();    &#125;&#125;
绑定服务
Shizuku.bindUserService(userServiceArgs, serviceConnection);// 指定服务的各项参数private final Shizuku.UserServiceArgs userServiceArgs =        new Shizuku.UserServiceArgs(new ComponentName(BuildConfig.APPLICATION_ID, UserService.class.getName()))                .daemon(false)                .processNameSuffix(&quot;adb_service&quot;)                .debuggable(BuildConfig.DEBUG)                .version(BuildConfig.VERSION_CODE);// 建立服务连接通道private final ServiceConnection serviceConnection = new ServiceConnection() &#123;    @Override    public void onServiceConnected(ComponentName componentName, IBinder iBinder) &#123;        Toast.makeText(MainActivity.this, &quot;服务连接成功&quot;, Toast.LENGTH_SHORT).show();        if (iBinder != null &amp;&amp; iBinder.pingBinder()) &#123;            IUserService iUserService = IUserService.Stub.asInterface(iBinder);            try &#123;                // 执行shell命令                iUserService.exec(&quot;ls&quot;);            &#125; catch (RemoteException e) &#123;                throw new RuntimeException(e);            &#125;        &#125;    &#125;    @Override    public void onServiceDisconnected(ComponentName componentName) &#123;        Toast.makeText(MainActivity.this, &quot;服务连接断开&quot;, Toast.LENGTH_SHORT).show();    &#125;&#125;;
解绑服务
Shizuku.unbindUserService(userServiceArgs, serviceConnection, true);
aidl参考：Android 接口定义语言 (AIDL)，跟着例子，来整一遍AIDL吧
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android开发手记</tag>
      </tags>
  </entry>
  <entry>
    <title>SilkDecoder使用手册</title>
    <url>/2024/02/22/SilkDecoder%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/</url>
    <content><![CDATA[引用方式Gradle 7.0以下，需要在项目级build.gradle文件中加入
allprojects &#123;    repositories &#123;        ...        maven &#123; url &#x27;https://jitpack.io&#x27; &#125;    &#125;&#125;
Gradle 7.0以上，需要在setting.gradle文件中加入
dependencyResolutionManagement &#123;	repositories &#123;		...		maven &#123; url &#x27;https://jitpack.io&#x27; &#125;	&#125;&#125;
远程仓库配置之后，即可在模块的build.gradle中引入SilkDecoder
dependencies &#123;    implementation &#x27;com.github.xxinPro:SilkDecoder:1.0&#x27;&#125;
使用方式解码为mp3将silk解码为mp3
SilkDecoder.decodeToMp3(silkFilePath, mp3FilePath);
将silk解码为mp3并自定义采样率和比特率

采样率：有效值：8000、12000、16000、24000、32000、44100、48000
比特率：通常取：64、128、192

SilkDecoder.decodeToMp3(silkFilePath, mp3FilePath, sampleRate, bitrate);
解码为wav将silk解码为wav
SilkDecoder.decodeToWav(silkFilePath, wavFilePath);
将silk解码为wav并自定义采样率

采样率：有效值：8000、12000、16000、24000、32000、44100、48000

SilkDecoder.decodeToWav(silkFilePath, wavFilePath, sampleRate);
解码为pcm将silk解码为pcm
SilkDecoder.decodeToPcm(silkFilePath, pcmFilePath);
将silk解码为pcm并自定义采样率

采样率：有效值：8000、12000、16000、24000、32000、44100、48000

SilkDecoder.decodeToPcm(silkFilePath, pcmFilePath, sampleRate);
开源地址https://github.com/xxinPro/SilkDecoder
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android开发手记</tag>
      </tags>
  </entry>
  <entry>
    <title>System和RunTime</title>
    <url>/2022/12/26/System%E5%92%8CRunTime/</url>
    <content><![CDATA[System



System





public static void exit(int status)
终止当前运行的虚拟机


public static void gc()
回收虚拟机无用资源


public static native long currentTimeMillis()
返回系统当前时间的毫秒值


public static native void arraycopy()
数组拷贝





System.exit(int status)&ensp;&ensp;调用该方法可以马上终止虚拟机运行，那么由此向下的程序就无法被执行，他需要传入一个状态码作为参数，当状态码为0时代表正常结束虚拟机运行，其他值代表异常结束虚拟机运行public static void main(String[] args) &#123;    System.exit(0);&#125;
System.gc()&ensp;&ensp;主动调用java虚拟机回收垃圾，将会回收没有意义的对象等public static void main(String[] args) &#123;    System.gc();&#125;
System.currentTimeMillis();&ensp;&ensp;返回当前时间的毫秒值，也就是常说的时间戳了，它是一个long类型的值public static void main(String[] args) &#123;    long timeStamp = System.currentTimeMillis();    System.out.println(&quot;时间戳 = &quot; + timeStamp);&#125;
System.arraycopy()&ensp;&ensp;使用该方法可以对数组进行拷贝，方法需要5个参数，分别代表：原数组，原数组被拷贝的起始元素下标，目标数组，拷贝到目标数组的起始元素下标，拷贝长度public static void main(String[] args) &#123;    int[] arr1 = new int[]&#123;1,2,3,4,5,6,7,8,9&#125;;    int[] arr2 = new int[5];        // 如下，代表将arr1数组从下标0开始的连续3个元素拷贝到arr2，拷贝到arr2中从元素下标1开始的3个连续元素    System.arraycopy(arr1, 0, arr2, 1, 3);    for (int i : arr2) &#123;        // 将会输出：0，1，2，3，0        System.out.println(i);    &#125;&#125;
RunTime&ensp;&ensp;RunTime对象无法创建，但是可以通过getRuntime()方法获取




RunTime





public void exit(int status)
终止当前运行的虚拟机


public native int availableProcessors()
获得CPU线程数


public native long maxMemory()
虚拟机能从系统中获取总内存大小


public native long totalMemory()
虚拟机已经从系统中获取的内存大小


public native long freeMemory()
系统剩余内存大小


public Process exec()
执行cmd命令




Runtime.getRuntime().exit()&ensp;&ensp;其实这个方法和System.exit(0)是一模一样的public static void main(String[] args) &#123;    Runtime.getRuntime().exit(0);&#125;
Runtime.getRuntime().availableProcessors()&ensp;&ensp;电脑CPU的线程数，例如4核8线程，那获取到的就是8，8核16线程获取到的就是16
public static void main(String[] args) &#123;    int progressNum = Runtime.getRuntime().availableProcessors();    System.out.println(&quot;CPU线程数 = &quot; + progressNum);&#125;
Runtime.getRuntime().maxMemory()&ensp;&ensp;表示虚拟机能从系统中获取到的内存大小public static void main(String[] args) &#123;    long maxMemory = Runtime.getRuntime().maxMemory();    System.out.println(&quot;虚拟机能获取到的最大内存大小 = &quot; + (maxMemory / 1024 / 1024) + &quot;M&quot;);&#125;
Runtime.getRuntime().totalMemory()&ensp;&ensp;表示虚拟机已经从系统中获取到的内存大小public static void main(String[] args) &#123;    long totalMemory = Runtime.getRuntime().totalMemory();    System.out.println(&quot;虚拟机已经获取到的最大内存大小 = &quot; + (totalMemory / 1024 / 1024) + &quot;M&quot;);&#125;
Runtime.getRuntime().freeMemory()&ensp;&ensp;表示虚拟机获取到的内存中，并未使用的内存的大小public static void main(String[] args) &#123;    long freeMemory = Runtime.getRuntime().freeMemory();    System.out.println(&quot;虚拟机空闲内存大小 = &quot; + (freeMemory / 1024 / 1024) + &quot;M&quot;);&#125;
&ensp;&ensp;那么已经获取到的内存大小减去空闲内存大小就等于已经使用的内存大小了public static void main(String[] args) &#123;    long totalMemory = Runtime.getRuntime().totalMemory();    long freeMemory = Runtime.getRuntime().freeMemory();    System.out.println(&quot;已经使用的内存大小 = &quot; + ((totalMemory - freeMemory) / 1024 / 1024) + &quot;M&quot;);&#125;
Runtime.getRuntime().exec()&ensp;&ensp;执行cmd命令，该方法需要捕获异常
public static void main(String[] args) &#123;    try &#123;        Runtime.getRuntime().exec(&quot;notepad&quot;);    &#125; catch (IOException e) &#123;        e.printStackTrace();    &#125;&#125;
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Tampermonkey的安装和使用</title>
    <url>/2021/09/16/Tampermonkey%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[&ensp;&ensp;Tampermonkey，又叫油猴脚本&ensp;&ensp;油猴脚本是增强浏览器网页功能的扩展程序，我们通常使用的支持油猴脚本的浏览器：谷歌浏览器、QQ浏览器、360浏览器&ensp;&ensp;教程中使用Chrome谷歌浏览器做演示

下载扩展程序首先下载扩展程序，解压后得到后缀为.crx的程序源Tampermonkey.rar下载
安装扩展程序1.打开谷歌浏览器，依次点击右上角三个小点→更多工具→扩展程序
2.打开右上角开发者模式
3.将第一步下载解压的crx源程序拖动至谷歌浏览器扩展程序页面
4.弹窗提示“要添加Tampermonkey吗”，选择添加扩展程序
5.出现了这个，就是安装成功了
安装用户脚本1.从新启动谷歌浏览器，打开网页https://greasyfork.org/zh-CN/scripts查找脚本
2.可以通过搜索找到你想要的脚本，点击它
3.点击安装脚本
4.再次点击安装，安装成功后会自动关闭并返回上一页，所以不要紧张
管理安装的脚本1.点击右上角的拼图小图标，然后点击Tampermonkey
2.点击管理面板
3.在这里可以管理你的每一个脚本，开启、关闭和删除
运行脚本打开某某通，你会发现它已经开始自动学习，并且进度条可以自由拖动，答题和考试会自动作答
其它脚本如vip解析，一样的操作
]]></content>
      <categories>
        <category>菜鸡手记</category>
      </categories>
      <tags>
        <tag>软件与工具</tag>
      </tags>
  </entry>
  <entry>
    <title>TextView实现图文混排</title>
    <url>/2021/10/22/TextView%E5%AE%9E%E7%8E%B0%E5%9B%BE%E6%96%87%E6%B7%B7%E6%8E%92/</url>
    <content><![CDATA[使用Html.fromHtml方法，解析html页面，并在Android TextView显示，实现图文混排
数据源，可以看到是html格式：
注意：从API level 24开始，fromHtml(String)被废弃，使用fromHtml(String source, int flags) 代替
flags:&ensp;&ensp;&ensp;&ensp;FROM_HTML_MODE_COMPACT：html块元素之间使用一个换行符分隔&ensp;&ensp;&ensp;&ensp;FROM_HTML_MODE_LEGACY：html块元素之间使用两个换行符分隔/*  * source: html内容 * flags: 标记 */  Html.fromHtml(String source, int flags);
&ensp;&ensp;&ensp;&ensp;如果只使用以上两个参数，对应的方法只会实现html中的文字，图片会被绿色的小方块取代
所以我们要使用四个参数的Html.fromHtml()方法/*  * source: html内容 * flags: 标记 * imageGetter: 加载图片 * tagHandler: 识别其它很多标签 */  Html.fromHtml(String source, int flags, ImageGetter imageGetter, TagHandler tagHandler)
页面布局&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;    android:gravity=&quot;center&quot;    android:orientation=&quot;vertical&quot;    android:background=&quot;#ededed&quot;    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;    &lt;androidx.cardview.widget.CardView        android:layout_margin=&quot;10dp&quot;        app:cardCornerRadius=&quot;5dp&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;match_parent&quot;&gt;        &lt;LinearLayout            android:background=&quot;@color/white&quot;            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;match_parent&quot;&gt;            &lt;TextView                android:text=&quot;内容&quot;                android:layout_margin=&quot;10dp&quot;                android:id=&quot;@+id/textView&quot;                android:textStyle=&quot;bold&quot;                android:textColor=&quot;@color/black&quot;                android:textSize=&quot;15sp&quot;                android:layout_width=&quot;match_parent&quot;                android:layout_height=&quot;match_parent&quot;/&gt;        &lt;/LinearLayout&gt;    &lt;/androidx.cardview.widget.CardView&gt;&lt;/LinearLayout&gt;
重写ImageGetter类创建MyImageGetter继承自Html.fromHtml()的第三个参数类，Html.ImageGetter，并重写了它的getDrawable方法
import android.content.Context;import android.graphics.drawable.Drawable;import android.graphics.drawable.LevelListDrawable;import android.text.Html;import android.widget.TextView;import androidx.annotation.NonNull;import androidx.annotation.Nullable;import com.bumptech.glide.Glide;import com.bumptech.glide.request.target.CustomTarget;import com.bumptech.glide.request.transition.Transition;public class MyImageGetter implements Html.ImageGetter &#123;    private Context context;    private TextView textView;    public MyImageGetter(Context context,TextView textView)&#123;        this.context = context;        this.textView = textView;    &#125;    @Override//    source就是img中src的路径    public Drawable getDrawable(String source) &#123;//        实例化LevelListDrawable类，LevelListDrawable可以通过改变Level值来切换相应的图片        LevelListDrawable levelListDrawable = new LevelListDrawable();//        使用Glide动态加载图片，通过asDrawable()指定返回类型为Drawable        Glide.with(context).asDrawable().load(source).into(new CustomTarget&lt;Drawable&gt;() &#123;            @Override//            图片加载回调            public void onResourceReady(@NonNull Drawable resource, @Nullable Transition&lt;? super Drawable&gt; transition) &#123;//                把一个Drawable资源添加到LevelListDrawable                levelListDrawable.addLevel(1,1,resource);                levelListDrawable.setBounds(0,0,resource.getIntrinsicWidth(),resource.getMinimumHeight());//设置Drawable长宽                levelListDrawable.setLevel(1);//设置对象的级别值                textView.invalidate();//调用invalidate()重新绘制TextView界面                textView.setText(textView.getText());//设置重绘的TextView内容            &#125;            @Override            public void onLoadCleared(@Nullable Drawable placeholder) &#123;            &#125;        &#125;);        return levelListDrawable;    &#125;&#125;
getDrawable方法也可以这样写    @Override//    source就是img中src的路径    public Drawable getDrawable(String source) &#123;//        实例化LevelListDrawable类，LevelListDrawable可以通过改变Level值来切换相应的图片        LevelListDrawable levelListDrawable = new LevelListDrawable();//        使用Glide动态加载图片，通过asDrawable()指定返回类型为Drawable        Glide.with(context).asBitmap().load(source).into(new CustomTarget&lt;Bitmap&gt;() &#123;            @Override            public void onResourceReady(@NonNull Bitmap resource, @Nullable Transition&lt;? super Bitmap&gt; transition) &#123;                if (resource != null)&#123;                    BitmapDrawable bitmapDrawable = new BitmapDrawable(null,resource);//                    把一个Drawable资源添加到LevelListDrawable                    levelListDrawable.addLevel(1,1,bitmapDrawable);                    levelListDrawable.setBounds(0,0,resource.getWidth(),resource.getHeight());//设置Drawable长宽                    levelListDrawable.setLevel(1);//设置对象的级别值                    textView.invalidate();//调用invalidate()重新绘制TextView界面                    textView.setText(textView.getText());//设置重绘的TextView内容                &#125;            &#125;            @Override            public void onLoadCleared(@Nullable Drawable placeholder) &#123;            &#125;        &#125;);        return levelListDrawable;    &#125;
设置TextViewpackage com.xin.SmartCity;import androidx.appcompat.app.AppCompatActivity;import android.os.Build;import android.os.Bundle;import android.text.Html;import android.widget.TextView;import com.xin.SmartCity.home.MyImageGetter;public class TestActivity extends AppCompatActivity &#123;    private TextView textView;    private String content;    private MyImageGetter myImageGetter;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_test);        init();        setContent();    &#125;    private void setContent() &#123;//        从api 24开始，原Html.fromHtml被废弃        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N) &#123;//            传入对应参数，因为没有其他标签设置，对后一个参数直接填null            textView.setText(Html.fromHtml(content,Html.FROM_HTML_MODE_COMPACT,myImageGetter,null));        &#125;    &#125;    private void init() &#123;        textView = findViewById(R.id.textView);        myImageGetter = new MyImageGetter(this,textView);//实例化重写的ImageGetter类//        内容        content = &quot;&lt;p&gt;测试文本1&lt;/p&gt;\n&quot; +                &quot;&lt;p&gt;测试文本2&lt;/p&gt;\n&quot; +                &quot;&lt;img src=\&quot;https://www.baidu.com/img/flexible/logo/pc/result.png\&quot; /&gt;\n&quot; +                &quot;&lt;p&gt;测试文本1&lt;/p&gt;\n&quot; +                &quot;&lt;p&gt;测试文本2&lt;/p&gt;\n&quot; +                &quot;&lt;img src=\&quot;https://www.baidu.com/img/flexible/logo/pc/result.png\&quot; /&gt;\n&quot; +                &quot;&lt;p&gt;测试文本1&lt;/p&gt;\n&quot; +                &quot;&lt;p&gt;测试文本2&lt;/p&gt;\n&quot; +                &quot;&lt;img src=\&quot;https://www.baidu.com/img/flexible/logo/pc/result.png\&quot; /&gt;\n&quot; +                &quot;&lt;p&gt;测试文本1&lt;/p&gt;\n&quot; +                &quot;&lt;p&gt;测试文本2&lt;/p&gt;\n&quot; +                &quot;&lt;img src=\&quot;https://www.baidu.com/img/flexible/logo/pc/result.png\&quot; /&gt;&quot;;    &#125;&#125;
效果展示
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android开发手记</tag>
      </tags>
  </entry>
  <entry>
    <title>VMware安装Hackintosh</title>
    <url>/2023/11/28/VMware%E5%AE%89%E8%A3%85Hackintosh/</url>
    <content><![CDATA[黑苹果版本：macOS Monterey 12.5 (21G72)VMware版本：VMware Workstation 16 Pro (16.2.4)
添加macos引导&ensp;&ensp;VMware是没有macos引导的，没有macos引导就无法创建macos系统的虚拟机&ensp;&ensp;以管理员身份运行Hackintosh中的Unlocker.exe，为VMware添加macos引导
&ensp;&ensp;一般情况下它会自动读取VMware的路径，并自动选择工具下载位置，也可以手动选择，确定路径后点击Patch
&ensp;&ensp;进度条结束之后，选定工具下载的路径下多了两个文件夹，VMware新建虚拟机也已经支持macos
添加虚拟机&ensp;&ensp;在VMware中创建新虚拟机，选择典型→稍后选择操作系统→macOS 12，然后下一步
&ensp;&ensp;选择虚拟机位置没啥好说的，然后指定磁盘容量，并选择将虚拟磁盘储存为单个文件，然后下一步
&ensp;&ensp;选择自定义硬件→新 CD/DVD (SATA)→使用ISO镜像文件，选择黑苹果镜像文件的位置，之后点击完成就好了
启动虚拟机&ensp;&ensp;启动macos虚拟机
&ensp;&ensp;这说明安装成功了，然后就是选择语言
&ensp;&ensp;选中磁盘工具，点击继续
&ensp;&ensp;选中虚拟机分配的磁盘并抹掉
&ensp;&ensp;名称可以随便改，其它的不要动，然后点击抹掉，结束之后左上角会出现“🔴”，点击它关闭这个页面
&ensp;&ensp;选中安装macOS Monterey，并点击继续
&ensp;&ensp;之后选择磁盘，继续
&ensp;&ensp;这个过程很长，等待安装结束后会出现选择国家地区，辅助功能，输入法等，都是无所谓的东西，能跳过就跳过
&ensp;&ensp;创建一个本地账户，然后是定位服务，虚拟机要个🐦定位服务，然后选择时区，都是不重要的
&ensp;&ensp;成功进入系统
安装VMwareTools&ensp;&ensp;VMwareTools安装后可以和电脑之间传送文件，共享粘贴板等&ensp;&ensp;鼠标右击桌面的Install macOS Monterey，点击推出Install macOS Monterey
&ensp;&ensp;点击菜单栏中的虚拟机→安装VMware Tools
&ensp;&ensp;接着双击安装，就可以开始安装了
&ensp;&ensp;输入刚刚创建账户的密码，就可以开始安装了
&ensp;&ensp;安装完成之后重启一下虚拟机，就可以使用了
]]></content>
      <categories>
        <category>菜鸡手记</category>
      </categories>
      <tags>
        <tag>VWware</tag>
      </tags>
  </entry>
  <entry>
    <title>VM虚拟机联网问题</title>
    <url>/2022/05/22/VM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%81%94%E7%BD%91%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[&ensp;&ensp;每次在切换或者重连WIFI后IP网段都会改变，然后虚拟机就连接不到网络，因为不常用VM，所以每次都忘记上次是怎么操作的，都要重新再琢磨一遍，烦死人了
&ensp;&ensp;在虚拟机设置，网络适配器中的网络连接选中桥接模式，并勾选复制物理网络链接状态


&ensp;&ensp;现在虚拟机是没有网络的



&ensp;&ensp;点击编辑 -&gt; 虚拟机网络编辑器


&ensp;&ensp;点击更改设置，并赋予其管理员权限


&ensp;&ensp;进入之后如果对当前的配置不熟悉，可以先“还原默认设置”，然后桥接模式这里，选择一个可以正常访问网络的网卡



&ensp;&ensp;然后检查仅主机模式的子网IP是否与网络适配器中的VMnet1的IP在同一网段，如果不在，将其修改至同一网段



&ensp;&ensp;再修改NET模式，将它的子网IP修改至与当前可以访问网络的网卡同一网段


&ensp;&ensp;现在进入到虚拟机中，把他的网络配置修改的与主机可以联网的网卡网络配置处IP地址外完全相同，IP地址一定要在同一网段


&ensp;&ensp;搞定了










]]></content>
      <categories>
        <category>菜鸡手记</category>
      </categories>
      <tags>
        <tag>VWware</tag>
      </tags>
  </entry>
  <entry>
    <title>arr引入AndroidStudio</title>
    <url>/2021/10/14/arr%E5%BC%95%E5%85%A5AndroidStudio/</url>
    <content><![CDATA[&ensp;&ensp;&ensp;&ensp;aar是一个类似于jar的文件格式。但是他们之间是有区别的。jar：仅仅包含class和清单文件，没有资源文件。aar：包含了class文件和资源文件。说白了就是Android的专属“jar”

方法一、手动添加依赖1.在项目的build.gradle文件中加入如下配置，代表添加一个本地仓库，并把libs目录作为仓库的地址repositories &#123;    flatDir &#123;        dirs &#x27;libs&#x27;    &#125;&#125;
2.把arr文件复制进项目的lib目录中
3.在dependencies中加入aar引用implementation(name: &#x27;glide-4.10.0&#x27;, ext: &#x27;aar&#x27;)
4.Sync Now，搞定
方法二、从New Module添加1.File -&gt; New -&gt; New Module
2.选择“Import .JAR/ARR Package”
3.选择arr文件位置finish即可
]]></content>
      <categories>
        <category>菜鸡手记</category>
      </categories>
      <tags>
        <tag>软件与工具</tag>
      </tags>
  </entry>
  <entry>
    <title>ViewPager+Fragment</title>
    <url>/2021/09/20/ViewPager-Fragment/</url>
    <content><![CDATA[①导包在项目的gradle文件中引入ViewPager2的依赖包implementation &#x27;androidx.viewpager2:viewpager2:1.0.0&#x27;
②创建布局在activity_main.xml布局中添加ViewPager2控件&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:layout_height=&quot;match_parent&quot;    android:layout_width=&quot;match_parent&quot;    android:orientation=&quot;vertical&quot;    android:gravity=&quot;center_horizontal&quot;&gt;    &lt;androidx.viewpager2.widget.ViewPager2        android:layout_width=&quot;match_parent&quot;        android:id=&quot;@+id/viewPager2&quot;        android:layout_height=&quot;0dp&quot;        android:layout_weight=&quot;1&quot;/&gt;&lt;/LinearLayout&gt;
③创建Fragment新建一个空白的Fragment，并在BlankFragment.java中对代码进行优化
BlankFragment.java优化下面代码，调用BlankFragment类的newInstance创建Fragment对象时，必会用Bundle传输数据import android.os.Bundle;import androidx.fragment.app.Fragment;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import android.widget.TextView;public class BlankFragment extends Fragment &#123;    private TextView blanFragment_text1;    private View viewRoot;//    接收Bandle消息所用的key    private static final String ARG_PARAM1 = &quot;param1&quot;;    private static final String ARG_PARAM2 = &quot;param2&quot;;//    接收Bandle后储存值mParam1和mParam2    private String mParam1;    private int mParam2;//    无参构造器    public BlankFragment() &#123;        // Required empty public constructor    &#125;//    调用该方法newInstance时会创建一个新的BlankFragment并返回，传入的两个值既是Bundle要发送的数据    public static BlankFragment newInstance(String param1, int param2) &#123;//        创建BlankFragment对象        BlankFragment fragment = new BlankFragment();//        Bundle数据传输        Bundle args = new Bundle();//        设置两个传输值和key        args.putString(ARG_PARAM1, param1);        args.putInt(ARG_PARAM2, param2);//        附加给BlankFragment对象        fragment.setArguments(args);        return fragment;    &#125;    @Override    public void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);//        如果传入了Bundle值，则取出        if (getArguments() != null) &#123;            mParam1 = getArguments().getString(ARG_PARAM1);            mParam2 = getArguments().getInt(ARG_PARAM2);        &#125;    &#125;    @Override    public View onCreateView(LayoutInflater inflater, ViewGroup container,                             Bundle savedInstanceState) &#123;        if (viewRoot == null)&#123;            viewRoot = inflater.inflate(R.layout.fragment_blank, container, false);        &#125;//        对页面上的TextView作出修改        blanFragment_text1 = viewRoot.findViewById(R.id.blanFragment_text1);        blanFragment_text1.setText(mParam1+&quot;;页码:&quot; + mParam2);                return viewRoot;    &#125;&#125;
fragment_blank.xml修改&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout android:layout_height=&quot;match_parent&quot;    android:layout_width=&quot;match_parent&quot;    android:orientation=&quot;vertical&quot;    android:gravity=&quot;center&quot;    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;    &lt;TextView        android:text=&quot;文本&quot;        android:textSize=&quot;20sp&quot;        android:textStyle=&quot;bold&quot;        android:textColor=&quot;@color/black&quot;        android:id=&quot;@+id/blanFragment_text1&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;/&gt;&lt;/LinearLayout&gt;
④创建适配器注意1：ViewPager中的FragmentPagerAdapter和FragmentStatePagerAdapter的区别
注意2：Jetpack和它的Lifecycle组件
MyAdapter继承自FragmentStateAdapter(不是FragmentPagerAdapter或FragmentStatePagerAdapter)import androidx.annotation.NonNull;import androidx.fragment.app.Fragment;import androidx.fragment.app.FragmentManager;import androidx.lifecycle.Lifecycle;import androidx.viewpager2.adapter.FragmentStateAdapter;import java.util.ArrayList;public class MyAdapter extends FragmentStateAdapter &#123;//    接收Fragment集合    private ArrayList&lt;Fragment&gt; fragments;//    需要三个参数：getSupportFragmentManager()管理、Lifecycle是Jetpack中提供的一个用于感知生命周期的组件、fragment集合    public MyAdapter(@NonNull FragmentManager fragmentManager, @NonNull Lifecycle lifecycle,ArrayList&lt;Fragment&gt; fragments) &#123;        super(fragmentManager, lifecycle);        this.fragments = fragments;    &#125;    @NonNull    @Override//    创建Fragment    public Fragment createFragment(int position) &#123;        return fragments.get(position);    &#125;    @Override//    获取页面总数    public int getItemCount() &#123;        return fragments.size();    &#125;&#125;
⑤调用适配器在MainActivity中调用适配器
import androidx.appcompat.app.AppCompatActivity;import androidx.fragment.app.Fragment;import androidx.viewpager2.widget.ViewPager2;import android.os.Bundle;import java.util.ArrayList;public class MainActivity extends AppCompatActivity &#123;    private ViewPager2 viewPager2;    private ArrayList&lt;Fragment&gt; fragments;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        viewPager2 = findViewById(R.id.viewPager2);        fragments = new ArrayList&lt;&gt;();//        添加Fragment        fragments.add(BlankFragment.newInstance(&quot;微信&quot;,0));        fragments.add(BlankFragment.newInstance(&quot;通讯录&quot;,1));        fragments.add(BlankFragment.newInstance(&quot;发现&quot;,2));        fragments.add(BlankFragment.newInstance(&quot;我&quot;,3));//        传入三个参数：getSupportFragmentManager()管理、Lifecycle是Jetpack中提供的一个用于感知生命周期的组件、fragment集合        MyAdapter myAdapter = new MyAdapter(getSupportFragmentManager(),getLifecycle(),fragments);        viewPager2.setAdapter(myAdapter);    &#125;&#125;
⑥当前效果
⑦创建首页的顶部导航和底部按钮创建selected布局&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;&lt;!--    未被选中时--&gt;    &lt;item android:drawable=&quot;@drawable/main_weixin&quot; android:state_selected=&quot;false&quot;/&gt;&lt;!--    被选中时--&gt;    &lt;item android:drawable=&quot;@drawable/main_weixin_true&quot; android:state_selected=&quot;true&quot;/&gt;&lt;/selector&gt;
main_top.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;RelativeLayout android:layout_height=&quot;60dp&quot;    android:layout_width=&quot;match_parent&quot;    android:background=&quot;#FFEDEDED&quot;    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;    &lt;LinearLayout        android:layout_width=&quot;match_parent&quot;        android:orientation=&quot;vertical&quot;        android:gravity=&quot;center&quot;        android:layout_height=&quot;match_parent&quot;&gt;        &lt;TextView            android:text=&quot;page name&quot;            android:id=&quot;@+id/main_top_text1&quot;            android:textStyle=&quot;bold&quot;            android:textColor=&quot;@color/black&quot;            android:textSize=&quot;20sp&quot;            android:layout_width=&quot;wrap_content&quot;            android:layout_height=&quot;wrap_content&quot;/&gt;    &lt;/LinearLayout&gt;    &lt;LinearLayout        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;match_parent&quot;        android:layout_alignParentRight=&quot;true&quot;        android:gravity=&quot;center&quot;        android:orientation=&quot;horizontal&quot;&gt;        &lt;ImageView            android:layout_width=&quot;30dp&quot;            android:layout_height=&quot;30dp&quot;            android:src=&quot;@mipmap/ic_launcher&quot;/&gt;        &lt;ImageView            android:layout_marginRight=&quot;10dp&quot;            android:layout_marginLeft=&quot;10dp&quot;            android:layout_width=&quot;30dp&quot;            android:layout_height=&quot;30dp&quot;            android:src=&quot;@mipmap/ic_launcher&quot;/&gt;    &lt;/LinearLayout&gt;&lt;/RelativeLayout&gt;
main_bottom.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout android:layout_height=&quot;60dp&quot;    android:layout_width=&quot;match_parent&quot;    android:orientation=&quot;horizontal&quot;    android:background=&quot;#FFEDEDED&quot;    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;&lt;!--    微信--&gt;    &lt;LinearLayout        android:layout_width=&quot;0dp&quot;        android:layout_weight=&quot;1&quot;        android:orientation=&quot;vertical&quot;        android:gravity=&quot;center&quot;        android:id=&quot;@+id/main_bottom_button0&quot;        android:layout_height=&quot;match_parent&quot;&gt;        &lt;ImageView            android:id=&quot;@+id/main_bottom_img0&quot;            android:layout_width=&quot;30dp&quot;            android:layout_height=&quot;30dp&quot;            android:src=&quot;@drawable/main_weixin_selected&quot;/&gt;        &lt;TextView            android:text=&quot;name&quot;            android:textColor=&quot;@color/black&quot;            android:layout_width=&quot;wrap_content&quot;            android:layout_height=&quot;wrap_content&quot;/&gt;    &lt;/LinearLayout&gt;&lt;!--    联系人--&gt;    &lt;LinearLayout        android:layout_width=&quot;0dp&quot;        android:layout_weight=&quot;1&quot;        android:orientation=&quot;vertical&quot;        android:gravity=&quot;center&quot;        android:id=&quot;@+id/main_bottom_button1&quot;        android:layout_height=&quot;match_parent&quot;&gt;        &lt;ImageView            android:layout_width=&quot;30dp&quot;            android:layout_height=&quot;30dp&quot;            android:id=&quot;@+id/main_bottom_img1&quot;            android:src=&quot;@drawable/main_lianxiren_selected&quot;/&gt;        &lt;TextView            android:text=&quot;name&quot;            android:textColor=&quot;@color/black&quot;            android:layout_width=&quot;wrap_content&quot;            android:layout_height=&quot;wrap_content&quot;/&gt;    &lt;/LinearLayout&gt;&lt;!--    发现--&gt;    &lt;LinearLayout        android:layout_width=&quot;0dp&quot;        android:layout_weight=&quot;1&quot;        android:orientation=&quot;vertical&quot;        android:gravity=&quot;center&quot;        android:id=&quot;@+id/main_bottom_button2&quot;        android:layout_height=&quot;match_parent&quot;&gt;        &lt;ImageView            android:layout_width=&quot;30dp&quot;            android:layout_height=&quot;30dp&quot;            android:id=&quot;@+id/main_bottom_img2&quot;            android:src=&quot;@drawable/main_faxian_selected&quot;/&gt;        &lt;TextView            android:text=&quot;name&quot;            android:textColor=&quot;@color/black&quot;            android:layout_width=&quot;wrap_content&quot;            android:layout_height=&quot;wrap_content&quot;/&gt;    &lt;/LinearLayout&gt;&lt;!--    我--&gt;    &lt;LinearLayout        android:layout_width=&quot;0dp&quot;        android:layout_weight=&quot;1&quot;        android:orientation=&quot;vertical&quot;        android:gravity=&quot;center&quot;        android:id=&quot;@+id/main_bottom_button3&quot;        android:layout_height=&quot;match_parent&quot;&gt;        &lt;ImageView            android:layout_width=&quot;30dp&quot;            android:layout_height=&quot;30dp&quot;            android:id=&quot;@+id/main_bottom_img3&quot;            android:src=&quot;@drawable/main_wo_selected&quot;/&gt;        &lt;TextView            android:text=&quot;name&quot;            android:textColor=&quot;@color/black&quot;            android:layout_width=&quot;wrap_content&quot;            android:layout_height=&quot;wrap_content&quot;/&gt;    &lt;/LinearLayout&gt;&lt;/LinearLayout&gt;
以组件的方式将main_top.xml和main_bottom.xml添加至activity_main.xml中&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:layout_height=&quot;match_parent&quot;    android:layout_width=&quot;match_parent&quot;    android:orientation=&quot;vertical&quot;    android:gravity=&quot;center_horizontal&quot;&gt;&lt;!--    顶部--&gt;    &lt;include layout=&quot;@layout/main_top&quot;/&gt;    &lt;androidx.viewpager2.widget.ViewPager2        android:layout_width=&quot;match_parent&quot;        android:id=&quot;@+id/viewPager2&quot;        android:layout_height=&quot;0dp&quot;        android:layout_weight=&quot;1&quot;/&gt;&lt;!--    底部--&gt;    &lt;include layout=&quot;@layout/main_bottom&quot;/&gt;&lt;/LinearLayout&gt;
页面切换监听给ViewPager2添加registerOnPageChangeCallback页面切换监听事件//        页面切换监听        viewPager2.registerOnPageChangeCallback(new ViewPager2.OnPageChangeCallback() &#123;            @Override//            翻新页和ViewPager首次加载时调用//            当position=当前页码-1时，说明向前翻页，当前偏移的像素位置(屏幕大小决定)positionOffsetPixels从max-0，当前页面偏移比例positionOffset从100%-0%//            当position等于当前页码时，说明向后翻页，当前偏移的像素位置(屏幕大小决定)positionOffsetPixels从0-max，当前页面偏移比例positionOffset从0%-100%            public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) &#123;                super.onPageScrolled(position, positionOffset, positionOffsetPixels);//                Log.d(&quot;xin&quot;, &quot;onPageScrolled: 页码,&quot; + position + &quot;;偏移像素,&quot; + positionOffsetPixels + &quot;;偏移比例,&quot; + positionOffset);            &#125;            @Override//            翻新页和ViewPager首次加载时调用//            position=当前页码            public void onPageSelected(int position) &#123;                super.onPageSelected(position);//                Log.d(&quot;xin&quot;, &quot;onPageSelected: &quot; + position);                main_top_text1.setText(pageName[position]);//设置首页page name                pageSlide(position);//设置不同页面时底部按钮的展示状态            &#125;            @Override//            手指触碰屏幕时调用//            state=1时手指触碰屏幕，state=2时手指离开屏幕，state=0时滑动结束            public void onPageScrollStateChanged(int state) &#123;                super.onPageScrollStateChanged(state);//                Log.d(&quot;xin&quot;, &quot;onPageScrollStateChanged: &quot; + state);            &#125;        &#125;);
该方法响应页面切换监听事件private void pageSlide(int position)&#123;        if (main_bottom_temp == null)&#123;            main_bottom_img0.setSelected(true);            main_bottom_temp = main_bottom_img0;        &#125;        else&#123;            main_bottom_temp.setSelected(false);            switch (position)&#123;                case 0:                    main_bottom_img0.setSelected(true);                    main_bottom_temp = main_bottom_img0;                    break;                case 1:                    main_bottom_img1.setSelected(true);                    main_bottom_temp = main_bottom_img1;                    break;                case 2:                    main_bottom_img2.setSelected(true);                    main_bottom_temp = main_bottom_img2;                    break;                case 3:                    main_bottom_img3.setSelected(true);                    main_bottom_temp = main_bottom_img3;                    break;            &#125;        &#125;    &#125;
单击底部按钮时切换页面    @Override//    ViewPager2切换页面    public void onClick(View v) &#123;        switch (v.getId())&#123;            case R.id.main_bottom_button0:                viewPager2.setCurrentItem(0);                break;            case R.id.main_bottom_button1:                viewPager2.setCurrentItem(1);                break;            case R.id.main_bottom_button2:                viewPager2.setCurrentItem(2);                break;            case R.id.main_bottom_button3:                viewPager2.setCurrentItem(3);                break;        &#125;    &#125;
MainActivity.java全部代码import androidx.appcompat.app.AppCompatActivity;import androidx.fragment.app.Fragment;import androidx.viewpager2.widget.ViewPager2;import android.os.Bundle;import android.util.Log;import android.view.View;import android.widget.ImageView;import android.widget.LinearLayout;import android.widget.TextView;import java.util.ArrayList;public class MainActivity extends AppCompatActivity implements View.OnClickListener &#123;    private String[] pageName = new String[]&#123;&quot;微信&quot;,&quot;通讯录&quot;,&quot;发现&quot;,&quot;我&quot;&#125;;    private ViewPager2 viewPager2;//ViewPager2    private TextView main_top_text1;//首页顶部的page name//    底部所有按钮的图片    private ImageView main_bottom_img0,main_bottom_img1,main_bottom_img2,main_bottom_img3,main_bottom_temp;//    底部按钮    private LinearLayout main_bottom_button0,main_bottom_button1,main_bottom_button2,main_bottom_button3;    private ArrayList&lt;Fragment&gt; fragments;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        viewPager2 = findViewById(R.id.viewPager2);        fragments = new ArrayList&lt;&gt;();//        添加Fragment        fragments.add(BlankFragment.newInstance(pageName[0],0));        fragments.add(BlankFragment.newInstance(pageName[1],1));        fragments.add(BlankFragment.newInstance(pageName[2],2));        fragments.add(BlankFragment.newInstance(pageName[3],3));//        获取底部所有按钮图        main_bottom_img0 = findViewById(R.id.main_bottom_img0);        main_bottom_img1 = findViewById(R.id.main_bottom_img1);        main_bottom_img2 = findViewById(R.id.main_bottom_img2);        main_bottom_img3 = findViewById(R.id.main_bottom_img3);//        获取底部四个子LinearLayout作为按钮        main_bottom_button0 = findViewById(R.id.main_bottom_button0);        main_bottom_button1 = findViewById(R.id.main_bottom_button1);        main_bottom_button2 = findViewById(R.id.main_bottom_button2);        main_bottom_button3 = findViewById(R.id.main_bottom_button3);//        设置click事件，点击时ViewPager2切换页面        main_bottom_button0.setOnClickListener(this);        main_bottom_button1.setOnClickListener(this);        main_bottom_button2.setOnClickListener(this);        main_bottom_button3.setOnClickListener(this);        main_top_text1 = findViewById(R.id.main_top_text1);//首页顶部的page name//        传入三个参数：getSupportFragmentManager()管理、Lifecycle是Jetpack中提供的一个用于感知生命周期的组件、fragment集合        MyAdapter myAdapter = new MyAdapter(getSupportFragmentManager(),getLifecycle(),fragments);        viewPager2.setAdapter(myAdapter);//        页面切换监听        viewPager2.registerOnPageChangeCallback(new ViewPager2.OnPageChangeCallback() &#123;            @Override//            翻新页和ViewPager首次加载时调用//            当position=当前页码-1时，说明向前翻页，当前偏移的像素位置(屏幕大小决定)positionOffsetPixels从max-0，当前页面偏移比例positionOffset从100%-0%//            当position等于当前页码时，说明向后翻页，当前偏移的像素位置(屏幕大小决定)positionOffsetPixels从0-max，当前页面偏移比例positionOffset从0%-100%            public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) &#123;                super.onPageScrolled(position, positionOffset, positionOffsetPixels);//                Log.d(&quot;xin&quot;, &quot;onPageScrolled: 页码,&quot; + position + &quot;;偏移像素,&quot; + positionOffsetPixels + &quot;;偏移比例,&quot; + positionOffset);            &#125;            @Override//            翻新页和ViewPager首次加载时调用//            position=当前页码            public void onPageSelected(int position) &#123;                super.onPageSelected(position);//                Log.d(&quot;xin&quot;, &quot;onPageSelected: &quot; + position);                main_top_text1.setText(pageName[position]);//设置首页page name                pageSlide(position);//设置不同页面时底部按钮的展示状态            &#125;            @Override//            手指触碰屏幕时调用//            state=1时手指触碰屏幕，state=2时手指离开屏幕，state=0时滑动结束            public void onPageScrollStateChanged(int state) &#123;                super.onPageScrollStateChanged(state);//                Log.d(&quot;xin&quot;, &quot;onPageScrollStateChanged: &quot; + state);            &#125;        &#125;);    &#125;    private void pageSlide(int position)&#123;        if (main_bottom_temp == null)&#123;            main_bottom_img0.setSelected(true);            main_bottom_temp = main_bottom_img0;        &#125;        else&#123;            main_bottom_temp.setSelected(false);            switch (position)&#123;                case 0:                    main_bottom_img0.setSelected(true);                    main_bottom_temp = main_bottom_img0;                    break;                case 1:                    main_bottom_img1.setSelected(true);                    main_bottom_temp = main_bottom_img1;                    break;                case 2:                    main_bottom_img2.setSelected(true);                    main_bottom_temp = main_bottom_img2;                    break;                case 3:                    main_bottom_img3.setSelected(true);                    main_bottom_temp = main_bottom_img3;                    break;            &#125;        &#125;    &#125;    @Override//    ViewPager2切换页面    public void onClick(View v) &#123;        switch (v.getId())&#123;            case R.id.main_bottom_button0:                viewPager2.setCurrentItem(0);                break;            case R.id.main_bottom_button1:                viewPager2.setCurrentItem(1);                break;            case R.id.main_bottom_button2:                viewPager2.setCurrentItem(2);                break;            case R.id.main_bottom_button3:                viewPager2.setCurrentItem(3);                break;        &#125;    &#125;&#125;
当前效果
累死了，就到这儿吧，源代码下载（不包含.gradle和.idea文件夹）
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android开发手记</tag>
      </tags>
  </entry>
  <entry>
    <title>dex分包</title>
    <url>/2023/03/21/dex%E5%88%86%E5%8C%85/</url>
    <content><![CDATA[添加依赖&ensp;&ensp;添加multidex依赖dependencies &#123;    ...    implementation &#x27;com.android.support:multidex:1.0.3&#x27;    ...&#125;
配置multidex启用多dex配置defaultConfig &#123;    ...    multiDexEnabled true    ...&#125;
指定类&ensp;&ensp;如果需要将某些类放置在主dex，可以在gradle中配置multiDexKeepFile参数
&ensp;&ensp;创建一个文本文件，例如multidex-keep.txt，并将需要保留在主DEX文件中的类名添加到该文件中，每行一个类名。
com.example.app.MainActivitycom.example.app.SomeImportantClass
&ensp;&ensp;在app模块的build.gradle文件中，使用multiDexKeepFile参数来指定上面创建的文件路径
defaultConfig &#123;    ...    multiDexEnabled true    multiDexKeepFile file(&#x27;multidex-keep.txt&#x27;)    ...&#125;
重写Application&ensp;&ensp;在应用的Application 类重写方法@Overrideprotected void attachBaseContext(Context base) &#123;    super.attachBaseContext(base);    MultiDex.install(this);&#125;
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android开发手记</tag>
      </tags>
  </entry>
  <entry>
    <title>eclipse搭建Android环境</title>
    <url>/2022/10/17/eclipse%E6%90%AD%E5%BB%BAAndroid%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[下载eclipse&ensp;&ensp;刚一开始我下载的是最新版的eclipse，但是不支持java1.8，所以后面下载了最后一个支持java1.8的版本
&ensp;&ensp;eclipse 2020-06版本

安装ADT&ensp;&ensp;这里我使用在线安装的方式（需要科学上网），在线安装地址：https://dl-ssl.google.com/android/eclipse
&ensp;&ensp;点击安装新软件
&ensp;&ensp;点击add
&ensp;&ensp;然后在线安装，如果是本地安装则添加jar:file:/绝对路径!/
&ensp;&ensp;下一步
&ensp;&ensp;继续下一步
&ensp;&ensp;完成
&ensp;&ensp;接着右下角会有下载进度，这是一个极其缓慢的过程，期间需要保持科学上网
&ensp;&ensp;过程中会弹出这个弹窗，点击仍要安装
SDK安装&ensp;&ensp;待ADT安装完毕后重启eclipse，然后安装SDK Tools、SDK Platform-Tools和一个android SDK
&ensp;&ensp;点击安装
&ensp;&ensp;安装完毕后，打开SDK Manager
&ensp;&ensp;在SDK管理器中可以管理各个版本的SDK
&ensp;&ensp;安装想要的SDK版本，system image是模拟器的镜像文件，占用内存空间较多，可以不下载
显示SDK Manager&ensp;&ensp;如果在window中不显示sdk manager选项，那么就需要手动添加它


手动安装SDK Tools&ensp;&ensp;我下载的android sdk tools好像都是阉割的，其android.bat根本无法启动sdk manager
&ensp;&ensp;而后发现了一个安装版(点击下载)，安装之后的SDK Tools是完整版
ADT下载https://dl.google.com/android/ADT-23.0.6.ziphttp://dl.google.com/android/ADT-23.0.4.ziphttp://dl.google.com/android/ADT-23.0.3.ziphttp://dl.google.com/android/ADT-23.0.2.ziphttp://dl.google.com/android/ADT-23.0.0.ziphttp://dl.google.com/android/ADT-22.6.3.ziphttp://dl.google.com/android/ADT-22.6.2.ziphttp://dl.google.com/android/ADT-22.6.1.ziphttp://dl.google.com/android/ADT-22.6.0.ziphttp://dl.google.com/android/ADT-22.3.0.ziphttp://dl.google.com/android/ADT-22.2.1.ziphttp://dl.google.com/android/ADT-22.2.0.ziphttp://dl.google.com/android/ADT-22.0.5.ziphttp://dl.google.com/android/ADT-22.0.4.ziphttp://dl.google.com/android/ADT-22.0.1.ziphttp://dl.google.com/android/ADT-22.0.0.ziphttp://dl.google.com/android/ADT-21.1.0.ziphttp://dl.google.com/android/ADT-21.0.1.ziphttp://dl.google.com/android/ADT-21.0.0.ziphttp://dl.google.com/android/ADT-20.0.3.ziphttp://dl.google.com/android/ADT-20.0.2.ziphttp://dl.google.com/android/ADT-20.0.1.ziphttp://dl.google.com/android/ADT-20.0.0.ziphttp://dl.google.com/android/ADT-18.0.0.ziphttp://dl.google.com/android/ADT-17.0.0.ziphttp://dl.google.com/android/ADT-16.0.1.ziphttp://dl.google.com/android/ADT-16.0.0.ziphttp://dl.google.com/android/ADT-15.0.1.ziphttp://dl.google.com/android/ADT-15.0.0.ziphttp://dl.google.com/android/ADT-14.0.0.ziphttp://dl.google.com/android/ADT-12.0.0.ziphttp://dl.google.com/android/ADT-11.0.0.ziphttp://dl.google.com/android/ADT-10.0.1.ziphttp://dl.google.com/android/ADT-10.0.0.ziphttp://dl.google.com/android/ADT-8.0.1.ziphttp://dl.google.com/android/ADT-8.0.0.ziphttp://dl.google.com/android/ADT-0.9.9.ziphttp://dl.google.com/android/ADT-0.9.8.ziphttp://dl.google.com/android/ADT-0.9.7.ziphttp://dl.google.com/android/ADT-0.9.6.ziphttp://dl.google.com/android/ADT-0.9.5.ziphttp://dl.google.com/android/ADT-0.9.4.zip
]]></content>
      <categories>
        <category>菜鸡手记</category>
      </categories>
      <tags>
        <tag>软件与工具</tag>
      </tags>
  </entry>
  <entry>
    <title>final修饰符</title>
    <url>/2021/07/22/final%E4%BF%AE%E9%A5%B0%E7%AC%A6/</url>
    <content><![CDATA[final修饰的变量final修饰的成员变量一定由程序员指定初始值，并且一经赋值后，变量值将无法被修改
实例成员变量//  实例成员变量有3种方式为其赋初始值final class test3&#123;	//直接赋值	final int height = 180;	    //    实例成员变量    final String name;    final int age;        &#123;//        实例代码块中为final修饰的实例变量赋予初始值        name = &quot;默认&quot;;    &#125;    public test3()&#123;//        构造器中为final修饰的实例变量赋予初始值        age = 20;    &#125;&#125;//  其实三者本质上还是同一种赋值方式，因为他们编译后都会被还原到构造器中
类成员变量//类成员变量有两种方式为其赋初始值final class test4&#123;//    直接赋值	final static age = 20;    //    类成员变量    final static String name;    static &#123;//        静态代码块中为final修饰的实例变量赋予初始值        name = &quot;默认&quot;;    &#125;&#125;//  二者本质上也是同一种赋值方式，类成员变量在编译后会被还原到类代码块中
局部变量final class test5&#123;    public static void methods1()&#123;	    final int a = 10;		final String b = &quot;默认值&quot;;	&#125;		public void methods2()&#123;	    final int a = 10;		final String b = &quot;默认值&quot;;	&#125;//    局部变量本来就需要显式赋予初始值，因此没有太大变动&#125;
引用类型final修饰引用类型的变量时，只保证这个引用类型变量引用的地址不会发生改变，但对象可以被改变
public class finalTest &#123;    public static void main(String[] args)&#123;//        此时obj.getName会返回小红        final finalObj obj = new finalObj(&quot;小红&quot;);//        通过set方法修改name值为小刚        obj.setName(&quot;小刚&quot;);        System.out.println(obj.getName()); //  输出小刚    &#125;&#125;final class finalObj&#123;    private String name;//    set    public void setName(String name)&#123;        this.name = name;    &#125;//    get    public String getName()&#123;        return this.name;    &#125;//    构造器    public finalObj(String name)&#123;        this.name = name;    &#125;&#125;
对于final变量来说，不管是类变量、实例变量、局部变量，只要满足下面三个条件，就不是变量，而相当于一个直接量

使用final修饰符修饰
在定义该变量时指定了初始值
该初始值可以在编译时就被确定下来

final修饰的方法final修饰的方法不可被重写
public class finalTest &#123;    final public void 铠甲勇士()&#123;        System.out.println(&quot;铠甲勇士&quot;);    &#125;&#125;class final方法重写 extends finalTest&#123;    @Override    public void 铠甲勇士()&#123;//      final修饰的方法无法被重写，将会报错    &#125;&#125;
final修饰的类final修饰的类不可被继承
完~
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>fragment监听返回键</title>
    <url>/2024/01/17/fragment%E7%9B%91%E5%90%AC%E8%BF%94%E5%9B%9E%E9%94%AE/</url>
    <content><![CDATA[setOnKeyListener&ensp;&ensp;通过给fragment的根view添加按键按下监听，此方法接收的按键监听用法类似于Activity中的onKeyDown(int, KeyEvent)
// 设置view在触摸模式下可获得焦点，从而能够接收按键事件view.setFocusableInTouchMode(true);// 请求将焦点移动到viewview.requestFocus();// 设置按键事件监听view.setOnKeyListener(new View.OnKeyListener() &#123;    @Override    public boolean onKey(View v, int keyCode, KeyEvent event) &#123;        // ...        return false;    &#125;&#125;);
&ensp;&ensp;例如监听返回键按下view.setFocusableInTouchMode(true);view.requestFocus();view.setOnKeyListener(new View.OnKeyListener() &#123;    @Override    public boolean onKey(View v, int keyCode, KeyEvent event) &#123;        if (keyCode == KeyEvent.KEYCODE_BACK &amp;&amp; event.getAction() == KeyEvent.ACTION_DOWN) &#123;            Log.d(TAG, &quot;handleOnBackPressed: 按下返回键&quot;);        &#125;        return true;    &#125;&#125;);
&ensp;&ensp;这其中：&ensp;&ensp;setFocusableInTouchMode(boolean)是用于设置view在触摸模式下是否可获取焦点，从而能够接收按键事件&ensp;&ensp;requestFocus()用于请求将焦点设置到指定的view，当调用这个方法时，系统会尝试将焦点移到指定的view上，使得该view能够响应用户的输入事件，比如按键事件。通常requestFocus()会与setFocusableInTouchMode(true)一起使用，以确保在触摸模式下能够接收焦点&ensp;&ensp;setOnKeyListener是用于设置按键事件监听器的方法
OnBackPressedCallback&ensp;&ensp;该方法用于处理用户按下返回按钮的情况，类似于Activity中的onBackPressed()OnBackPressedCallback onBackPressedCallback = new OnBackPressedCallback(true) &#123;    @Override    public void handleOnBackPressed() &#123;        Log.d(TAG, &quot;handleOnBackPressed: 按下返回键&quot;);    &#125;&#125;;getActivity().getOnBackPressedDispatcher().addCallback(getViewLifecycleOwner(), onBackPressedCallback);
&ensp;&ensp;这其中：&ensp;&ensp;OnBackPressedCallback是AndroidX Lifecycle库中的类，创建一个回调对象，用于处理返回按钮按下的事件，true代表启用该回调，默认为启用；当用户按下返回按钮时执行handleOnBackPressed中的逻辑&ensp;&ensp;getOnBackPressedDispatcher()用于获取一个OnBackPressedDispatcher对象，通过该对象注册回调以处理返回按钮的事件&ensp;&ensp;addCallback()用于添加处理返回按钮按下的事件，接收一个getViewLifecycleOwner()参数和onBackPressedCallback回调
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android开发手记</tag>
      </tags>
  </entry>
  <entry>
    <title>gitee+hexo博客</title>
    <url>/2021/07/15/gitee-hexo%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[gitee等代码托管平台搭建hexo博客
hexo官方文档：https://hexo.io/zh-cn/
1.工具安装安装node.js，下载安装git工具，下载
# 查看node是否安装成功node -vnpm -v
2.安装hexo&ensp;&ensp;创建一个文件夹作为博客目录，右键 → Git Bsah Here打开# 在新打开的命令窗口中执行npm install hexo-cli -g
3.初始化环境# 进入博客目录下hexo init
4.启动本地服务hexo server # 或简写hexo s# 提示Start processing后，浏览器打开http://localhost:4000
5.gitee项目仓库地址&ensp;&ensp;得到gitee中项目仓库的地址https://gitee.com/xxinin/blog
6.打开博客目录下的_config.yml文件# 修改以下配置：deploy:  type: git  repo: https://gitee.com/xxinin/blog    #将地址换成自己的地址  branch: master
7.同步至gitee仓库# 首次要安装一个部署插件npm install hexo-deployer-git --savehexo clean     # 清空旧缓存hexo generate  # 生成静态文件，可以用简写hexo ghexo deploy    # 推送到gitee，可以用简写hexo d# 输入gitee的用户名和密码（本人在这边出现问题用户名登录好像只能使用邮箱，用户名登录不上去）
8.登录首次同步会要求登录gitee的账户，正常输入即可，通常情况下登陆一次就会有在本地保存凭据
若hexo d同步时报错unable to access &#x27;https://gitee.com/xxinin/blog/&#x27;: The requested URL returned error: 403说明本地存在其他账户的凭据，打开控制面板→用户账户→管理windows凭据→删除和gitee相关的凭据即可
9.开启gitee pages服务
开启后得到域名https://xxinin.gitee.io/blog填入_config.yml中url
10.其它配置不作详细描述hexo 官方中文文档
11.hexo基本操作命令hexo new post &quot;post-name&quot; # 新建文章，新建的文章在&quot;根目录\source\_posts\&quot;目录下hexo new page &quot;page-name&quot; # 新建页面，新建的页面在&quot;根目录\source\page-name\&quot;目录下hexo version # 显示hexo版本hexo generate # 生成静态页面至public目录hexo deploy # 将静态页面部署到Git服务器hexo server # 开启预览访问端口，默认浏览地址为http://localhost:4000/，&quot;ctrl + c&quot;关闭serverhexo clean # 清理public目录下静态页面缓存文件hexo help # 查看帮助hexo version #查看Hexo的版本# 对应命令可缩写为# hexo n == hexo new# hexo g == hexo generate# hexo s == hexo server# hexo d == hexo deploy
]]></content>
      <categories>
        <category>菜鸡手记</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>github SSH令牌解决</title>
    <url>/2021/10/17/github-SSH%E4%BB%A4%E7%89%8C%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[&ensp;&ensp;&ensp;&ensp;登录到github，进入账户设置
&ensp;&ensp;&ensp;&ensp;往下拉，找到开发者设置(Developer Setting)
&ensp;&ensp;&ensp;&ensp;创建一个token
&ensp;&ensp;&ensp;&ensp;Note随便填，Expiration表示设置到期日期，repo表示对仓库的完全控制，delete_repo表示删除仓库，填写完数据点击Generate token创建token了
&ensp;&ensp;&ensp;&ensp;创建完成后，马上将token复制并记下来，它只显示这一次
&ensp;&ensp;&ensp;&ensp;然后用git工具在本地打开对应项目，输入git remote set-url origin  https://[你的token]@github.com/[你的用户名]/[仓库名].git//例如git remote set-url origin  https://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@github.com/xxinPro/fixNavBar.git
&ensp;&ensp;&ensp;&ensp;一个回车，之后就可以git push origin main了
]]></content>
      <categories>
        <category>菜鸡手记</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>git删除指定某次commit</title>
    <url>/2022/11/18/git%E5%88%A0%E9%99%A4%E6%8C%87%E5%AE%9A%E6%9F%90%E6%AC%A1commit/</url>
    <content><![CDATA[&ensp;&ensp;首先git log查看commit历史，确定自己要删除的commit
&ensp;&ensp;找到一个commit，需要确保它在要移除的commit之前，然后复制他的id
&ensp;&ensp;输入git rebase -i commitIdgit rebase -i e4ea721aac48eaa348ecc1f98a4e9ea8751a04d8&ensp;&ensp;按 i 进入编辑模式，将要删除的commit的pick改成drop
&ensp;&ensp;修改完毕后，按下alt + shift + insert退出编辑模式，然后:wq保存，再次git log，发现删除的两条commit已经没有了&ensp;&ensp;注：在idea中，esc只会退出Terminal输入，alt + shift + insert才能退出vim编辑模式
]]></content>
      <categories>
        <category>菜鸡手记</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo+next中数学公式的引用</title>
    <url>/2021/08/08/hexo-next%E4%B8%AD%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E7%9A%84%E5%BC%95%E7%94%A8/</url>
    <content><![CDATA[简单方程代码$ $ \begin &#123;equation&#125; \label &#123;eq1&#125; e=mc ^ 2 \end &#123;equation&#125; $ $
效果$ $ \begin {equation} \label {eq1}e=mc ^ 2\end {equation} $ $
调用爱因斯坦提出的著名的物质-能量方程$ \eqref &#123;eq1&#125; $ ...
爱因斯坦提出的著名的物质-能量方程$ \eqref {eq1} $ …
多线方程代码$ $ \begin &#123;equation&#125; \label &#123;eq2&#125; \begin &#123;aligned&#125; a &amp; = b + c \\ &amp; = d + e + f + g \\ &amp; = h + i \end &#123;aligned&#125; \end &#123;equation &#125; $ $
效果$ $ \begin {equation} \label {eq2}\begin {aligned}a &amp; = b + c \\ &amp; = d + e + f + g \\ &amp; = h + i\end {aligned}\end {equation} $ $
调用方程$ \eqref &#123;eq2&#125; $是一个多线方程。
方程$ \eqref {eq2} $是一个多线方程。
多重对齐方程代码$ $ \begin &#123;align&#125; a &amp; = b + c \label &#123;eq3&#125; \\ x &amp; = yz \label &#123;eq4&#125; \\ l &amp; = m - n \label &#123;eq5&#125; \end &#123;align&#125; $ $
效果$ $ \begin {align}a &amp; = b + c \label {eq3} \\ x &amp; = yz \label {eq4} \\ l &amp; = m - n \label {eq5}\end {align} $ $
调用有三个对齐的方程：方程$ \eqref &#123;eq3&#125; $，方程$ \eqref &#123;eq4&#125; $和方程$ \eqref &#123;eq5&#125; $。
有三个对齐的方程：方程$ \eqref {eq3} $，方程$ \eqref {eq4} $和方程$ \eqref {eq5} $。
行间公式行间公式$O(f(n))=log_2^&#123;n&#125;$测试
行间公式$O(f(n))=log_2^{n}$测试
参考
官方配置教程https://theme-next.js.org/docs/third-party-services/math-equations
参考一https://blog.csdn.net/ordinary_brony/article/details/108025799
参考二https://www.cnblogs.com/iHeling/p/14095986.html
LaTex在线编辑器https://www.latexlive.com/

]]></content>
      <categories>
        <category>菜鸡手记</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo文章加密</title>
    <url>/2021/11/19/hexo%E6%96%87%E7%AB%A0%E5%8A%A0%E5%AF%86/</url>
    <content><![CDATA[安装加密插件npm install hexo-blog-encrypt
修改配置文件&ensp;&ensp;打开hexo的配置文件，添加encrypt:  enable: true  silent: true  abstract: &lt;center&gt;该篇文章暂不公开，请输入密码后查看&lt;/center&gt;  message: 请输入正确密码后查看  tags:  - &#123;name: tag1, password: passwordA&#125;  - &#123;name: tag2, password: passwordB&#125;  theme: default  wrong_pass_message: 密码错误，请重新输入  wrong_hash_message: 文章校验失败
&ensp;&ensp;不同属性代表的意思enable:   # 布尔值；是否开启插件 true:开 false:关silent:   # 布尔值；是否禁用Log true:禁用 false:不禁用abstract: # 字符串；文章中不添加description值时，防止自动选取文章内容作为文章描述message:  # 字符串：密码输入框中提示的内容tags:     # json：对一个或多个标签中的所有文章内容进行加密，填入固定格式的json串  - &#123;name: tag1, password: passwordA&#125; # name: 字符串；需要被加密的标签名。 password: 字符串；加密密码theme:    # 固定内容：密码输入框的主题风格，有default、blink、shrink、flip、up、surge、wave、xraywrong_pass_message: # 密码输入错误后的提示wrong_hash_message: # 文章校验失败后的提示
文章加密&ensp;&ensp;属性优先级：文章信息头中的属性 &gt; 配置文件中的属性
加密一篇文章&ensp;&ensp;在需要加密的文件信息头中添加相关属性，可以做到只对某一篇文章加密
password: admin  # 密码message: 输入密码查看全部内容 # 密码输入框中提示的内容abstract: 该文章不开放  # 防止自动选取文章内容作为文章描述
取消加密一篇文章&ensp;&ensp;若对某个标签中的所有文章进行加密后，想对谋篇文章开放，在需要开放的文件信息头中添加相关属性
password: &quot;&quot; # 只填一对双引号即可
插件开源地址：https://github.com/D0n9X1n/hexo-blog-encrypt/参考：https://github.com/D0n9X1n/hexo-blog-encrypt/blob/master/ReadMe.zh.md
]]></content>
      <categories>
        <category>菜鸡手记</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>idea创建Servlet</title>
    <url>/2022/03/02/idea%E5%88%9B%E5%BB%BAServlet/</url>
    <content><![CDATA[所使用的idea版本
创建一个新项目&ensp;&ensp;&ensp;&ensp;创建一个java enterprise项目，然后下一步
选择依赖&ensp;&ensp;&ensp;&ensp;选择要添加的依赖，然后finish完成
创建lib和classes&ensp;&ensp;&ensp;&ensp;在webapp的WEB-INF目录下创建lib目录和classes目录
修改编译输出路径&ensp;&ensp;&ensp;&ensp;在左上角File中打开Project Structure -&gt; 点击左边栏中的Modules -&gt; 在中间栏中选中项目 -&gt; 在右边栏中切换到Path选项卡 -&gt; 勾选Use module compile output path -&gt; 将Output path和Test output path的路径修改为刚刚创建的classes的路径
修改存放jar包的路径&ensp;&ensp;&ensp;&ensp;在右边栏中切换到Dependencies选项卡 -&gt; 点击“+”号 -&gt; 点击“JARs or Directories…” -&gt; 选中刚刚创建的lib目录&ensp;&ensp;&ensp;&ensp;然后会弹出这个，选择Jar Directory
Tomcat配置&ensp;&ensp;&ensp;&ensp;点击Run -&gt; Edit Configurations，在这里可以修改程序运行时使用浏览器打开的地址
&ensp;&ensp;&ensp;&ensp;Application context指定本工程的根目录
&ensp;&ensp;&ensp;&ensp;如果是新建的Tomcat，没有这一项的话，可以新建一个
运行&ensp;&ensp;&ensp;&ensp;修改index.jsp中的内容，然后点击右上角运行一把
Servlet实现&ensp;&ensp;&ensp;&ensp;创建MyServlet类，并继承HttpServlet，然后通过@WebServlet()注解的方式配置servletpackage com.lxx6.software;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;//指定Servlet类的名称为myServlet，访问路径为myServlet@WebServlet(name = &quot;myServlet&quot;, value = &quot;/myServlet&quot;)public class MyServlet extends HttpServlet &#123;    &#125;
&ensp;&ensp;&ensp;&ensp;也可以在web.xml中配置&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;         version=&quot;4.0&quot;&gt;&lt;!--    指定这个Servlet类的名称为myServlet--&gt;    &lt;servlet&gt;        &lt;servlet-name&gt;myServlet&lt;/servlet-name&gt;        &lt;servlet-class&gt;com.lxx6.software.MyServlet&lt;/servlet-class&gt;    &lt;/servlet&gt;&lt;!--    指定myServlet这个名称的Servlet类的访问路径为myServlet--&gt;    &lt;servlet-mapping&gt;        &lt;servlet-name&gt;myServlet&lt;/servlet-name&gt;        &lt;url-pattern&gt;/myServlet&lt;/url-pattern&gt;    &lt;/servlet-mapping&gt;&lt;/web-app&gt;
&ensp;&ensp;&ensp;&ensp;然后实现doGet和doPost方法package com.lxx6.software;import javax.servlet.ServletException;import javax.servlet.ServletInputStream;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.PrintWriter;//指定Servlet类的名称为myServlet，访问路径为myServlet@WebServlet(name = &quot;myServlet&quot;, value = &quot;/myServlet&quot;)public class MyServlet extends HttpServlet &#123;//    响应get请求    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;//        响应内容的类型        resp.setContentType(&quot;text/html&quot;);//        响应        PrintWriter out = resp.getWriter();        out.println(&quot;&lt;html&gt;&lt;body&gt;&quot;);        out.println(&quot;&lt;h1&gt;Hello World!&lt;/h1&gt;&quot;);        out.println(&quot;&lt;/body&gt;&lt;/html&gt;&quot;);    &#125;//    响应post请求    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;//        设置编码        req.setCharacterEncoding(&quot;utf8&quot;);        resp.setCharacterEncoding(&quot;utf8&quot;);//        获取body中的内容        ServletInputStream inputStream = req.getInputStream();        InputStreamReader inputStreamReader = new InputStreamReader(inputStream, &quot;utf8&quot;);        BufferedReader bufferedReader = new BufferedReader(inputStreamReader);        StringBuilder stringBuilder = new StringBuilder();        String len;        while ((len = bufferedReader.readLine()) != null)&#123;            stringBuilder.append(new String(len.getBytes()));        &#125;//        获取请求头中的name        String name = req.getHeader(&quot;name&quot;);//        响应        PrintWriter writer = resp.getWriter();        writer.println(name + &quot;发送了: &quot; + stringBuilder);    &#125;&#125;
发送请求测试&ensp;&ensp;&ensp;&ensp;运行，使用postman测试一下，get请求&ensp;&ensp;&ensp;&ensp;post请求
打包&ensp;&ensp;&ensp;&ensp;点击Build -&gt; Build Artifacts -&gt; 选中war -&gt; 选则Build
&ensp;&ensp;&ensp;&ensp;war和war exploded的区别war模式：将WEB工程以包的形式上传到服务器 ；war exploded模式：将WEB工程以当前文件夹的位置关系上传到服务器；（1）war模式这种可以称之为是发布模式，看名字也知道，这是先打成war包，再发布；（2）war exploded模式是直接把文件夹、jsp页面 、classes等等移到Tomcat 部署文件夹里面，进行加载部署。因此这种方式支持热部署，一般在开发的时候也是用这种方式。（3）在平时开发的时候，使用热部署的话，应该对Tomcat进行相应的设置，这样的话修改的jsp界面什么的东西才可以及时的显示出来。
&ensp;&ensp;&ensp;&ensp;打包完成后，项目根路径的target文件夹下的war文件就是了，解压至部署好的环境下即可
参考：https://blog.csdn.net/xlgen157387/article/details/56498938
]]></content>
      <categories>
        <category>菜鸡手记</category>
      </categories>
      <tags>
        <tag>软件与工具</tag>
      </tags>
  </entry>
  <entry>
    <title>mime type列表</title>
    <url>/2022/10/14/mime-type%E5%88%97%E8%A1%A8/</url>
    <content><![CDATA[



后缀名
mime type




.3dm
x-world/x-3dmf


.3dmf
x-world/x-3dmf


.a
application/octet-stream


.aab
application/x-authorware-bin


.aam
application/x-authorware-map


.aas
application/x-authorware-seg


.abc
text/vnd.abc


.acgi
text/html


.afl
video/animaflex


.ai
application/postscript


.aif
audio/aiff


.aif
audio/x-aiff


.aifc
audio/aiff


.aifc
audio/x-aiff


.aiff
audio/aiff


.aiff
audio/x-aiff


.aim
application/x-aim


.aip
text/x-audiosoft-intra


.ani
application/x-navi-animation


.aos
application/x-nokia-9000-communicator-add-on-software


.aps
application/mime


.arc
application/octet-stream


.arj
application/arj


.arj
application/octet-stream


.art
image/x-jg


.asf
video/x-ms-asf


.asm
text/x-asm


.asp
text/asp


.asx
application/x-mplayer2


.asx
video/x-ms-asf


.asx
video/x-ms-asf-plugin


.au
audio/basic


.au
audio/x-au


.avi
application/x-troff-msvideo


.avi
video/avi


.avi
video/msvideo


.avi
video/x-msvideo


.avs
video/avs-video


.bcpio
application/x-bcpio


.bin
application/mac-binary


.bin
application/macbinary


.bin
application/octet-stream


.bin
application/x-binary


.bin
application/x-macbinary


.bm
image/bmp


.bmp
image/bmp


.bmp
image/x-windows-bmp


.boo
application/book


.book
application/book


.boz
application/x-bzip2


.bsh
application/x-bsh


.bz
application/x-bzip


.bz2
application/x-bzip2


.c
text/plain


.c
text/x-c


.c++
text/plain


.cat
application/vnd.ms-pki.seccat


.cc
text/plain


.cc
text/x-c


.ccad
application/clariscad


.cco
application/x-cocoa


.cdf
application/cdf


.cdf
application/x-cdf


.cdf
application/x-netcdf


.cer
application/pkix-cert


.cer
application/x-x509-ca-cert


.cha
application/x-chat


.chat
application/x-chat


.class
application/java


.class
application/java-byte-code


.class
application/x-java-class


.com
application/octet-stream


.com
text/plain


.conf
text/plain


.cpio
application/x-cpio


.cpp
text/x-c


.cpt
application/mac-compactpro


.cpt
application/x-compactpro


.cpt
application/x-cpt


.crl
application/pkcs-crl


.crl
application/pkix-crl


.crt
application/pkix-cert


.crt
application/x-x509-ca-cert


.crt
application/x-x509-user-cert


.csh
application/x-csh


.csh
text/x-script.csh


.css
application/x-pointplus


.css
text/css


.cxx
text/plain


.dcr
application/x-director


.deepv
application/x-deepv


.def
text/plain


.der
application/x-x509-ca-cert


.dif
video/x-dv


.dir
application/x-director


.dl
video/dl


.dl
video/x-dl


.doc
application/msword


.dot
application/msword


.dp
application/commonground


.drw
application/drafting


.dump
application/octet-stream


.dv
video/x-dv


.dvi
application/x-dvi


.dwf
drawing/x-dwf (old)


.dwf
model/vnd.dwf


.dwg
application/acad


.dwg
image/vnd.dwg


.dwg
image/x-dwg


.dxf
application/dxf


.dxf
image/vnd.dwg


.dxf
image/x-dwg


.dxr
application/x-director


.el
text/x-script.elisp


.elc
application/x-bytecode.elisp (compiled elisp)


.elc
application/x-elc


.env
application/x-envoy


.eps
application/postscript


.es
application/x-esrehber


.etx
text/x-setext


.evy
application/envoy


.evy
application/x-envoy


.exe
application/octet-stream


.f
text/plain


.f
text/x-fortran


.f77
text/x-fortran


.f90
text/plain


.f90
text/x-fortran


.fdf
application/vnd.fdf


.fif
application/fractals


.fif
image/fif


.fli
video/fli


.fli
video/x-fli


.flo
image/florian


.flx
text/vnd.fmi.flexstor


.fmf
video/x-atomic3d-feature


.for
text/plain


.for
text/x-fortran


.fpx
image/vnd.fpx


.fpx
image/vnd.net-fpx


.frl
application/freeloader


.funk
audio/make


.g
text/plain


.g3
image/g3fax


.gif
image/gif


.gl
video/gl


.gl
video/x-gl


.gsd
audio/x-gsm


.gsm
audio/x-gsm


.gsp
application/x-gsp


.gss
application/x-gss


.gtar
application/x-gtar


.gz
application/x-compressed


.gz
application/x-gzip


.gzip
application/x-gzip


.gzip
multipart/x-gzip


.h
text/plain


.h
text/x-h


.hdf
application/x-hdf


.help
application/x-helpfile


.hgl
application/vnd.hp-hpgl


.hh
text/plain


.hh
text/x-h


.hlb
text/x-script


.hlp
application/hlp


.hlp
application/x-helpfile


.hlp
application/x-winhelp


.hpg
application/vnd.hp-hpgl


.hpgl
application/vnd.hp-hpgl


.hqx
application/binhex


.hqx
application/binhex4


.hqx
application/mac-binhex


.hqx
application/mac-binhex40


.hqx
application/x-binhex40


.hqx
application/x-mac-binhex40


.hta
application/hta


.htc
text/x-component


.htm
text/html


.html
text/html


.htmls
text/html


.htt
text/webviewhtml


.htx
text/html


.ice
x-conference/x-cooltalk


.ico
image/x-icon


.idc
text/plain


.ief
image/ief


.iefs
image/ief


.iges
application/iges


.iges
model/iges


.igs
application/iges


.igs
model/iges


.ima
application/x-ima


.imap
application/x-httpd-imap


.inf
application/inf


.ins
application/x-internett-signup


.ip
application/x-ip2


.isu
video/x-isvideo


.it
audio/it


.iv
application/x-inventor


.ivr
i-world/i-vrml


.ivy
application/x-livescreen


.jam
audio/x-jam


.jav
text/plain


.jav
text/x-java-source


.java
text/plain


.java
text/x-java-source


.jcm
application/x-java-commerce


.jfif
image/jpeg


.jfif
image/pjpeg


.jfif-tbnl
image/jpeg


.jpe
image/jpeg


.jpe
image/pjpeg


.jpeg
image/jpeg


.jpeg
image/pjpeg


.jpg
image/jpeg


.jpg
image/pjpeg


.jps
image/x-jps


.js
application/x-javascript


.js
application/javascript


.js
application/ecmascript


.js
text/javascript


.js
text/ecmascript


.jut
image/jutvision


.kar
audio/midi


.kar
music/x-karaoke


.ksh
application/x-ksh


.ksh
text/x-script.ksh


.la
audio/nspaudio


.la
audio/x-nspaudio


.lam
audio/x-liveaudio


.latex
application/x-latex


.lha
application/lha


.lha
application/octet-stream


.lha
application/x-lha


.lhx
application/octet-stream


.list
text/plain


.lma
audio/nspaudio


.lma
audio/x-nspaudio


.log
text/plain


.lsp
application/x-lisp


.lsp
text/x-script.lisp


.lst
text/plain


.lsx
text/x-la-asf


.ltx
application/x-latex


.lzh
application/octet-stream


.lzh
application/x-lzh


.lzx
application/lzx


.lzx
application/octet-stream


.lzx
application/x-lzx


.m
text/plain


.m
text/x-m


.m1v
video/mpeg


.m2a
audio/mpeg


.m2v
video/mpeg


.m3u
audio/x-mpequrl


.man
application/x-troff-man


.map
application/x-navimap


.mar
text/plain


.mbd
application/mbedlet


.mc$
application/x-magic-cap-package-1.0


.mcd
application/mcad


.mcd
application/x-mathcad


.mcf
image/vasa


.mcf
text/mcf


.mcp
application/netmc


.me
application/x-troff-me


.mht
message/rfc822


.mhtml
message/rfc822


.mid
application/x-midi


.mid
audio/midi


.mid
audio/x-mid


.mid
audio/x-midi


.mid
music/crescendo


.mid
x-music/x-midi


.midi
application/x-midi


.midi
audio/midi


.midi
audio/x-mid


.midi
audio/x-midi


.midi
music/crescendo


.midi
x-music/x-midi


.mif
application/x-frame


.mif
application/x-mif


.mime
message/rfc822


.mime
www/mime


.mjf
audio/x-vnd.audioexplosion.mjuicemediafile


.mjpg
video/x-motion-jpeg


.mm
application/base64


.mm
application/x-meme


.mme
application/base64


.mod
audio/mod


.mod
audio/x-mod


.moov
video/quicktime


.mov
video/quicktime


.movie
video/x-sgi-movie


.mp2
audio/mpeg


.mp2
audio/x-mpeg


.mp2
video/mpeg


.mp2
video/x-mpeg


.mp2
video/x-mpeq2a


.mp3
audio/mpeg3


.mp3
audio/x-mpeg-3


.mp3
video/mpeg


.mp3
video/x-mpeg


.mpa
audio/mpeg


.mpa
video/mpeg


.mpc
application/x-project


.mpe
video/mpeg


.mpeg
video/mpeg


.mpg
audio/mpeg


.mpg
video/mpeg


.mpga
audio/mpeg


.mpp
application/vnd.ms-project


.mpt
application/x-project


.mpv
application/x-project


.mpx
application/x-project


.mrc
application/marc


.ms
application/x-troff-ms


.mv
video/x-sgi-movie


.my
audio/make


.mzz
application/x-vnd.audioexplosion.mzz


.nap
image/naplps


.naplps
image/naplps


.nc
application/x-netcdf


.ncm
application/vnd.nokia.configuration-message


.nif
image/x-niff


.niff
image/x-niff


.nix
application/x-mix-transfer


.nsc
application/x-conference


.nvd
application/x-navidoc


.o
application/octet-stream


.oda
application/oda


.omc
application/x-omc


.omcd
application/x-omcdatamaker


.omcr
application/x-omcregerator


.p
text/x-pascal


.p10
application/pkcs10


.p10
application/x-pkcs10


.p12
application/pkcs-12


.p12
application/x-pkcs12


.p7a
application/x-pkcs7-signature


.p7c
application/pkcs7-mime


.p7c
application/x-pkcs7-mime


.p7m
application/pkcs7-mime


.p7m
application/x-pkcs7-mime


.p7r
application/x-pkcs7-certreqresp


.p7s
application/pkcs7-signature


.part
application/pro_eng


.pas
text/pascal


.pbm
image/x-portable-bitmap


.pcl
application/vnd.hp-pcl


.pcl
application/x-pcl


.pct
image/x-pict


.pcx
image/x-pcx


.pdb
chemical/x-pdb


.pdf
application/pdf


.pfunk
audio/make


.pfunk
audio/make.my.funk


.pgm
image/x-portable-graymap


.pgm
image/x-portable-greymap


.pic
image/pict


.pict
image/pict


.pkg
application/x-newton-compatible-pkg


.pko
application/vnd.ms-pki.pko


.pl
text/plain


.pl
text/x-script.perl


.plx
application/x-pixclscript


.pm
image/x-xpixmap


.pm
text/x-script.perl-module


.pm4
application/x-pagemaker


.pm5
application/x-pagemaker


.png
image/png


.pnm
application/x-portable-anymap


.pnm
image/x-portable-anymap


.pot
application/mspowerpoint


.pot
application/vnd.ms-powerpoint


.pov
model/x-pov


.ppa
application/vnd.ms-powerpoint


.ppm
image/x-portable-pixmap


.pps
application/mspowerpoint


.pps
application/vnd.ms-powerpoint


.ppt
application/mspowerpoint


.ppt
application/powerpoint


.ppt
application/vnd.ms-powerpoint


.ppt
application/x-mspowerpoint


.ppz
application/mspowerpoint


.pre
application/x-freelance


.prt
application/pro_eng


.ps
application/postscript


.psd
application/octet-stream


.pvu
paleovu/x-pv


.pwz
application/vnd.ms-powerpoint


.py
text/x-script.phyton


.pyc
application/x-bytecode.python


.qcp
audio/vnd.qcelp


.qd3
x-world/x-3dmf


.qd3d
x-world/x-3dmf


.qif
image/x-quicktime


.qt
video/quicktime


.qtc
video/x-qtc


.qti
image/x-quicktime


.qtif
image/x-quicktime


.ra
audio/x-pn-realaudio


.ra
audio/x-pn-realaudio-plugin


.ra
audio/x-realaudio


.ram
audio/x-pn-realaudio


.ras
application/x-cmu-raster


.ras
image/cmu-raster


.ras
image/x-cmu-raster


.rast
image/cmu-raster


.rexx
text/x-script.rexx


.rf
image/vnd.rn-realflash


.rgb
image/x-rgb


.rm
application/vnd.rn-realmedia


.rm
audio/x-pn-realaudio


.rmi
audio/mid


.rmm
audio/x-pn-realaudio


.rmp
audio/x-pn-realaudio


.rmp
audio/x-pn-realaudio-plugin


.rng
application/ringing-tones


.rng
application/vnd.nokia.ringing-tone


.rnx
application/vnd.rn-realplayer


.roff
application/x-troff


.rp
image/vnd.rn-realpix


.rpm
audio/x-pn-realaudio-plugin


.rt
text/richtext


.rt
text/vnd.rn-realtext


.rtf
application/rtf


.rtf
application/x-rtf


.rtf
text/richtext


.rtx
application/rtf


.rtx
text/richtext


.rv
video/vnd.rn-realvideo


.s
text/x-asm


.s3m
audio/s3m


.saveme
application/octet-stream


.sbk
application/x-tbook


.scm
application/x-lotusscreencam


.scm
text/x-script.guile


.scm
text/x-script.scheme


.scm
video/x-scm


.sdml
text/plain


.sdp
application/sdp


.sdp
application/x-sdp


.sdr
application/sounder


.sea
application/sea


.sea
application/x-sea


.set
application/set


.sgm
text/sgml


.sgm
text/x-sgml


.sgml
text/sgml


.sgml
text/x-sgml


.sh
application/x-bsh


.sh
application/x-sh


.sh
application/x-shar


.sh
text/x-script.sh


.shar
application/x-bsh


.shar
application/x-shar


.shtml
text/html


.shtml
text/x-server-parsed-html


.sid
audio/x-psid


.sit
application/x-sit


.sit
application/x-stuffit


.skd
application/x-koan


.skm
application/x-koan


.skp
application/x-koan


.skt
application/x-koan


.sl
application/x-seelogo


.smi
application/smil


.smil
application/smil


.snd
audio/basic


.snd
audio/x-adpcm


.sol
application/solids


.spc
application/x-pkcs7-certificates


.spc
text/x-speech


.spl
application/futuresplash


.spr
application/x-sprite


.sprite
application/x-sprite


.src
application/x-wais-source


.ssi
text/x-server-parsed-html


.ssm
application/streamingmedia


.sst
application/vnd.ms-pki.certstore


.step
application/step


.stl
application/sla


.stl
application/vnd.ms-pki.stl


.stl
application/x-navistyle


.stp
application/step


.sv4cpio
application/x-sv4cpio


.sv4crc
application/x-sv4crc


.svf
image/vnd.dwg


.svf
image/x-dwg


.svr
application/x-world


.svr
x-world/x-svr


.swf
application/x-shockwave-flash


.t
application/x-troff


.talk
text/x-speech


.tar
application/x-tar


.tbk
application/toolbook


.tbk
application/x-tbook


.tcl
application/x-tcl


.tcl
text/x-script.tcl


.tcsh
text/x-script.tcsh


.tex
application/x-tex


.texi
application/x-texinfo


.texinfo
application/x-texinfo


.text
application/plain


.text
text/plain


.tgz
application/gnutar


.tgz
application/x-compressed


.tif
image/tiff


.tif
image/x-tiff


.tiff
image/tiff


.tiff
image/x-tiff


.tr
application/x-troff


.tsi
audio/tsp-audio


.tsp
application/dsptype


.tsp
audio/tsplayer


.tsv
text/tab-separated-values


.turbot
image/florian


.txt
text/plain


.uil
text/x-uil


.uni
text/uri-list


.unis
text/uri-list


.unv
application/i-deas


.uri
text/uri-list


.uris
text/uri-list


.ustar
application/x-ustar


.ustar
multipart/x-ustar


.uu
application/octet-stream


.uu
text/x-uuencode


.uue
text/x-uuencode


.vcd
application/x-cdlink


.vcs
text/x-vcalendar


.vda
application/vda


.vdo
video/vdo


.vew
application/groupwise


.viv
video/vivo


.viv
video/vnd.vivo


.vivo
video/vivo


.vivo
video/vnd.vivo


.vmd
application/vocaltec-media-desc


.vmf
application/vocaltec-media-file


.voc
audio/voc


.voc
audio/x-voc


.vos
video/vosaic


.vox
audio/voxware


.vqe
audio/x-twinvq-plugin


.vqf
audio/x-twinvq


.vql
audio/x-twinvq-plugin


.vrml
application/x-vrml


.vrml
model/vrml


.vrml
x-world/x-vrml


.vrt
x-world/x-vrt


.vsd
application/x-visio


.vst
application/x-visio


.vsw
application/x-visio


.w60
application/wordperfect6.0


.w61
application/wordperfect6.1


.w6w
application/msword


.wav
audio/wav


.wav
audio/x-wav


.wb1
application/x-qpro


.wbmp
image/vnd.wap.wbmp


.web
application/vnd.xara


.wiz
application/msword


.wk1
application/x-123


.wmf
windows/metafile


.wml
text/vnd.wap.wml


.wmlc
application/vnd.wap.wmlc


.wmls
text/vnd.wap.wmlscript


.wmlsc
application/vnd.wap.wmlscriptc


.word
application/msword


.wp
application/wordperfect


.wp5
application/wordperfect


.wp5
application/wordperfect6.0


.wp6
application/wordperfect


.wpd
application/wordperfect


.wpd
application/x-wpwin


.wq1
application/x-lotus


.wri
application/mswrite


.wri
application/x-wri


.wrl
application/x-world


.wrl
model/vrml


.wrl
x-world/x-vrml


.wrz
model/vrml


.wrz
x-world/x-vrml


.wsc
text/scriplet


.wsrc
application/x-wais-source


.wtk
application/x-wintalk


.xbm
image/x-xbitmap


.xbm
image/x-xbm


.xbm
image/xbm


.xdr
video/x-amt-demorun


.xgz
xgl/drawing


.xif
image/vnd.xiff


.xl
application/excel


.xla
application/excel


.xla
application/x-excel


.xla
application/x-msexcel


.xlb
application/excel


.xlb
application/vnd.ms-excel


.xlb
application/x-excel


.xlc
application/excel


.xlc
application/vnd.ms-excel


.xlc
application/x-excel


.xld
application/excel


.xld
application/x-excel


.xlk
application/excel


.xlk
application/x-excel


.xll
application/excel


.xll
application/vnd.ms-excel


.xll
application/x-excel


.xlm
application/excel


.xlm
application/vnd.ms-excel


.xlm
application/x-excel


.xls
application/excel


.xls
application/vnd.ms-excel


.xls
application/x-excel


.xls
application/x-msexcel


.xlt
application/excel


.xlt
application/x-excel


.xlv
application/excel


.xlv
application/x-excel


.xlw
application/excel


.xlw
application/vnd.ms-excel


.xlw
application/x-excel


.xlw
application/x-msexcel


.xm
audio/xm


.xml
application/xml


.xml
text/xml


.xmz
xgl/movie


.xpix
application/x-vnd.ls-xpix


.xpm
image/x-xpixmap


.xpm
image/xpm


.x-png
image/png


.xsr
video/x-amt-showrun


.xwd
image/x-xwd


.xwd
image/x-xwindowdump


.xyz
chemical/x-pdb


.z
application/x-compress


.z
application/x-compressed


.zip
application/x-compressed


.zip
application/x-zip-compressed


.zip
application/zip


.zip
multipart/x-zip


.zoo
application/octet-stream


.zsh
text/x-script.zsh




]]></content>
      <categories>
        <category>便笺</category>
      </categories>
      <tags>
        <tag>频繁查阅</tag>
      </tags>
  </entry>
  <entry>
    <title>main()与exit()</title>
    <url>/2022/12/03/main-%E4%B8%8Eexit/</url>
    <content><![CDATA[main函数函数返回值&ensp;&ensp;c语言约定，main函数的返回值为0时表示函数运行成功，正常情况下，如果省略return 0，编译器会自动添加int main() &#123;    printf(&quot;hello&quot;);    // 编译运行未报错    // 编译器会自动添加    // return 0;&#125;
main函数形参&ensp;&ensp;main函数可以添加形参，其中argc全称是argument count，代表argv中元素的个数，argv的全称是argument value，代表参数值，它是一个指向字符串的指针数组
int main(int argc, char* argv[]) &#123;    printf(&quot;hello&quot;);    return 0;&#125;
&ensp;&ensp;将如下代码写入到demo1.c中int main(int argc, char* argv[]) &#123;    printf(&quot;argc = %d\n&quot;, argc);    for (int i = 0; i &lt; argc; ++i) &#123;        printf(&quot;argv[%d] = %s\n&quot;, i, argv[i]);    &#125;    return 0;&#125;
&ensp;&ensp;使用gcc编译gcc demo1.c -o demo1
&ensp;&ensp;运行编译好的程序demo1 val1 val2 val3
&ensp;&ensp;控制台中输出；可以看到会多传入一个文件名作为默认的参数argc = 4argv[0] = demo1 # 系统自己传入的参数argv[1] = val1argv[2] = val2argv[3] = val3
&ensp;&ensp;在intellij Clion中可以配置main方法接收的参数，运行时将自动传入
exit函数结束程序执行&ensp;&ensp;main函数结束时也会隐式调用exit函数，在main函数中，exit函数等价于return
&ensp;&ensp;exit属于stdlib.h库，用于结束函数的执行并向外部返回一个值，该返回值就是它的参数，通常使用两个常量EXIT_SUCCESS和EXIT_FAILURE作为参数，相当于0和1，分别代表正常结束和异常终止int main() &#123;    test1();    // test2不会被执行    test2();    return 0;&#125;void test1() &#123;    printf(&quot;hello\n&quot;);    // 将不会执行exit之后的代码    exit(EXIT_SUCCESS);&#125;void test2() &#123;    printf(&quot;hi\n&quot;);&#125;
结束时调用方法&ensp;&ensp;在exit执行前执行atexit，函数，并传入一个函数指针，指针指向的函数将在exit结束前被调用int main() &#123;    test1();    test2();    return 0;&#125;void test1() &#123;    printf(&quot;hello\n&quot;);    // 结束前调用test3    atexit(test3);    exit(0);&#125;void test2() &#123;    printf(&quot;hi\n&quot;);&#125;void test3() &#123;    printf(&quot;bye&quot;);&#125;
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C语言基础</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql基础命令</title>
    <url>/2022/01/09/mysql%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[创建数据库CREATE DATABASE xxin;
显示全部数据库SHOW DATABASES;
选择数据库USE xxin;
显示数据表SHOW TABLES;
创建数据表CREATE TABLE soft(  softName VARCHAR(20),  softLink VARCHAR(100),  softSize FLOAT,  softInform VARCHAR(200),  softTime DATETIME);
删除数据表DROP TABLE soft;
查看数据表结构DESCRIBE soft;
查询数据标中的数据记录SELECT * FROM soft;
条件查询(查询soft表中所有softName为test.apk的行)SELECT * FROM soft WHERE softName = &#x27;test.apk&#x27;;
向数据表中插入数据记录INSERT INTO soft VALUES (    &#x27;test.apk&#x27;,    &#x27;https://www.baidu.com&#x27;,    &#x27;5.12&#x27;,    &#x27;测试测试测试测试&#x27;,    &#x27;2021-2-5 23:59:59&#x27;);
删除数据(删除soft表中所有softName为test.apk的行)DELETE FROM soft WHERE softName = &#x27;test.apk&#x27;;
修改数据(将soft表中所有softName为test2.apk的行的softName修改为test.apk)UPDATE soft SET softName = &#x27;test.apk&#x27; WHERE softName = &#x27;test2.apk&#x27;;
主键约束，能够唯一确定一张表中的一条记录某个字段添加主键约束后，该字段不重复且不为空CREATE TABLE lxx(  id INT PRIMARY KEY,  username VARCHAR(20));
联合主键，由多个字段组合的主键使id和username联合起来的联合值不重复且id和username不为空CREATE TABLE lxx(  id INT,  username VARCHAR(20),  PRIMARY KEY(id,username));
自增约束CREATE TABLE lxx (  id INT PRIMARY KEY AUTO_INCREMENT,  username VARCHAR(20),  PASSWORD VARCHAR(20));
向指定字段中插入数据INSERT INTO lxx (username,PASSWORD) VALUE(  &#x27;xxin&#x27;,  &#x27;123456&#x27;);
]]></content>
      <categories>
        <category>菜鸡手记</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>next主题优化</title>
    <url>/2021/07/15/next%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[hexo博客next主题主要优化修改方案
基于hexo5.x和next8.x


next官方文档https://theme-next.js.org/docs/
一、安装和升级安装next主题从github下载next$ cd hexo/myblog#直接下载到themes文件夹$ git clone https://github.com/next-theme/hexo-theme-next themes/next在hexo的_config.yum配置文件中搜索theme，并将其修改为next
2.更新next主题$ cd hexo/myblog$ npm install hexo-theme-next@latest
NexT 建议通过下面这种方式从版本 5 或 7 升级到版本 8：

复制一些旧的 NexT 文件：1.1. _config.yml或next.yml（如果您使用了Alternate Theme Config）。1.2. 放置在next/source/css/_custom/和next/source/css/_variables/目录中的自定义 CSS 文件。1.3. 自定义布局文件放置在next/layout/_custom/*.1.4. 可以通过存储库之间的比较工具找到的任何其他可能的自定义添加。
然后重命名旧的 NexT 文件夹，例如重命名next为next-old.
按照本文提供的方法安装新版本：安装说明。运行hexo clean并hexo s检查站点是否正常工作。
更新 Hexo 和 Hexo 插件如果在完成上述步骤后，执行hexo s或时出现错误hexo g，则表示可能是旧版本的 Hexo/Hexo 插件与新版本的主题 NexT 之间存在冲突。我们建议将 Hexo 升级到 5.0 或更高版本，并将 Hexo 插件升级到最新版本。您可以运行npm outdated以查看所有可升级的插件。
如果您发现任何错误或您只是不喜欢此版本，您可以随时切换回旧版本。

二、美化1.主题选择next的配置文件中搜索Scheme Settings提供了四种主题:scheme: Musescheme: Mistscheme: Piscesscheme: Gemini本博客使用第三种
2.网页icon设置next配置文件搜索faviconfavicon:  small: /images/favicon-16x16-next.png  medium: /images/favicon-32x32-next.png  apple_touch_icon: /images/apple-touch-icon-next.png  safari_pinned_tab: /images/logo.svg  #android_manifest: /manifest.json制作favicon.ico图标，并放置在themes/next/sources/images即可
3.博客底部的标签样式修改后效果↓打开hexo\myblog\themes\next-old\layout\_macro\post.swig搜索rel=&quot;tag&quot;，将后面的&#123;&#123; tag_indicate &#125;&#125;修改为&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;
4.侧边栏头像next配置文件搜索Sidebar Avataravatar:  # Replace the default image and set the url here.  url: http://q1.qlogo.cn/g?b=qq&amp;nk=3033528136&amp;s=640 #头像的网络位置或相对路径(blog/themes/next/source/images)  # If true, the avatar will be dispalyed in circle.  rounded: true #鼠标放在头像上时是否旋转  # If true, the avatar will be rotated with the cursor.  rotated: true #头像是否设为圆形，否则为矩形  opacity: 2 #头像放缩指数
5.侧边栏社交信息next配置文件搜索Social Linkssite_state: true # 是否在侧边栏加入日志、分类、标签等跳转链接social:  #GitHub: https://github.com/yourname || fab fa-github  E-Mail: mailto:x@xxin.xyz || fa fa-envelope  QQ: https://wpa.qq.com/msgrd?v=3&amp;uin=3033528136&amp;site=qq&amp;menu=yes || fab fa-qq  #Weibo: https://weibo.com/yourname || fab fa-weibo  #Google: https://plus.google.com/yourname || fab fa-google  #Twitter: https://twitter.com/yourname || fab fa-twitter  #FB Page: https://www.facebook.com/yourname || fab fa-facebook  #StackOverflow: https://stackoverflow.com/yourname || fab fa-stack-overflow  #YouTube: https://youtube.com/yourname || fab fa-youtube  #Instagram: https://instagram.com/yourname || fab fa-instagram  #Skype: skype:yourname?call|chat || fab fa-skype  social_icons:  enable: true #是否显示社交图标  icons_only: false #是否仅显示社交图标  transition: true
6.侧边栏设置next配置文件搜索Sidebar Settings
sidebar:  # Sidebar Position.  position: left #侧边栏位置  #position: right  # Manual define the sidebar width. If commented, will be default for:  # Muse | Mist: 320  # Pisces | Gemini: 240  #width: 300  # Sidebar Display (only for Muse | Mist), available values:  #  - post    expand on posts automatically. Default.  #  - always  expand for all pages automatically.  #  - hide    expand only when click on the sidebar toggle icon.  #  - remove  totally remove sidebar including sidebar toggle.  display: post  # Sidebar padding in pixels.  padding: 18 #侧边栏相对主菜单像素距离  # Sidebar offset from top menubar in pixels (only for Pisces | Gemini).  offset: 12 #侧边栏相对主菜单像素距离  onmobile: true #手机上是否显示侧边栏
7.版权信息next配置文件搜索creative_commonscreative_commons: #版权配置  # Available values: by | by-nc | by-nc-nd | by-nc-sa | by-nd | by-sa | cc-zero  license: by-nc-sa  # Available values: big | small  size: small  sidebar: true #侧边栏显示版权信息  post: true #文章底部显示版权信息  # You can set a language value if you prefer a translated version of CC license, e.g. deed.zh  # CC licenses are available in 39 languages, you can find the specific and correct abbreviation you need on https://creativecommons.org  language: 
三、配置建议1.浏览器缓存next配置文件中搜索cacheenable: false#默认关闭，开启后打开浏览器缓存建议调试博客时关闭，平时打开
2.菜单标签与标签路径next配置文件中搜索Menu Settings#设置菜单项开启关闭、图标及其相对路径menu:  home: / || fa fa-home  about: /about/ || fa fa-user  tags: /tags/ || fa fa-tags  categories: /categories/ || fa fa-th  archives: /archives/ || fa fa-archive  #schedule: /schedule/ || fa fa-calendar  #sitemap: /sitemap.xml || fa fa-sitemap  #commonweal: /404/ || fa fa-heartbeat只需去除”#”号即打开对应配置，同时需创建对应页面#创建新页面hexo new page tags并将新页面中index.md的内容修改为---title: 标签date: 2021-07-12 11:42:29type: &quot;tags&quot; #对应的标签类型---
3.页面图标设置menu_settings:  icons: true # 是否显示各个页面的图标  badges: true # 标签、分类、归档内的文章数量显示
4.摘要显示next配置文件搜索Read more buttonread_more_btn: true #显示阅读全文按钮会自动截取文章\前的内容作为摘要
]]></content>
      <categories>
        <category>菜鸡手记</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>okhttp断点下载</title>
    <url>/2022/09/15/okhttp%E6%96%AD%E7%82%B9%E4%B8%8B%E8%BD%BD/</url>
    <content><![CDATA[&ensp;&ensp;创建一个DownloadUtils类继承AsyncTask，并实现doInBackground()、onProgressUpdate()、onPostExecute()方法public class DownloadUtils extends AsyncTask&lt;String, Integer, Integer&gt; &#123;    @Override    protected Integer doInBackground(String... strings) &#123;    &#125;    @Override    protected void onProgressUpdate(Integer... values) &#123;    &#125;    @Override    protected void onPostExecute(Integer integer) &#123;    &#125;&#125;
&ensp;&ensp;添加一个接口类，用于下载回调public class DownloadUtils extends AsyncTask&lt;String, Integer, Integer&gt; &#123;    public interface DownloadListener &#123;        // 下载进度        void onProgress(int progress);        // 下载成功        void onSuccess(File downloadCacheFile);        // 下载失败        void onFailed();        // 下载暂停        void onPaused();        // 下载取消        void onCanceled();    &#125;&#125;
&ensp;&ensp;使用该类创建对象时，要求传入下载回调接口public class DownloadUtils extends AsyncTask&lt;String, Integer, Integer&gt; &#123;    private final DownloadListener downloadListener;    // 下载监听    public DownloadUtils(DownloadListener downloadListener) &#123;        this.downloadListener = downloadListener;    &#125;&#125;
&ensp;&ensp;注意执行下载任务时一定要在传入的数组中添加三个顺序固定的参数，方法中发起请求时，在请求头中添加了RANGE参数，该参数用作指定下载区间，重启断点续传；使用RandomAccessFile类写入数据，可以指定从目标文件的哪个位置开始插入数据public class DownloadUtils extends AsyncTask&lt;String, Integer, Integer&gt; &#123;    /**     * 通过execute执行时，需要在传入的数组中添加三个参数，且顺序固定     * 1. 文件下载链接     * 2. 存放下载文件的目录的路径     * 3. 文件名     */    @Override    protected Integer doInBackground(String... strings) &#123;        // 下载链接        String downloadUrl = strings[0];        // 文件所在目录的路径        String folderPath = strings[1];        // 文件名        String fileName = strings[2];        // 如果下载链接为空，直接return出去        if (downloadUrl == null || TextUtils.isEmpty(downloadUrl))            return null;        // 如果所在目录的路径不正确        if (folderPath == null || TextUtils.isEmpty(folderPath))            folderPath = Environment.getExternalStorageDirectory().getAbsolutePath();        // 如果文件名不正确        if (fileName == null || TextUtils.isEmpty(fileName))            fileName = getDownloadFileName(downloadUrl);        // 下载到本地的文件路径        String downloadFilePath = folderPath + &quot;/&quot; + fileName;        // 下载到本地的文件        downloadFile = new File(downloadFilePath);        // 下载到本地的缓存文件路径        String downloadCacheFilePath = folderPath + &quot;/&quot; + fileName + &quot;_cache&quot;;        // 下载到本地的缓存文件        downloadCacheFile = new File(downloadCacheFilePath);        // 已经下载的缓存文件大小        long downloadCacheFileLength = 0;        // 获取已经下载的缓存文件大小        if (downloadCacheFile.exists() &amp;&amp; downloadCacheFile.isFile()) &#123;            downloadCacheFileLength = downloadCacheFile.length();        &#125;        // 要下载的文件的大小        long downloadFileLength = getDownloadFileLength(downloadUrl);        if (downloadFileLength == 0) &#123;            return TYPE_FAILED; // 下载失败        &#125; else if (downloadFileLength == downloadCacheFileLength) &#123;            return TYPE_SUCCESS; // 下载成功        &#125;        OkHttpClient okHttpClient = new OkHttpClient();        Request request = new Request.Builder()                .addHeader(&quot;RANGE&quot;, &quot;bytes=&quot; + downloadCacheFileLength + &quot;-&quot;) // 指定下载区间                .url(downloadUrl)                .build();        try &#123;            Response execute = okHttpClient.newCall(request).execute();            ResponseBody body = execute.body();            if (execute.isSuccessful() &amp;&amp; body != null) &#123;                InputStream inputStream = body.byteStream();                RandomAccessFile randomAccessFile = new RandomAccessFile(downloadCacheFile, &quot;rw&quot;);                randomAccessFile.seek(downloadCacheFileLength); // 跳过已经下载的字节                byte[] bytes = new byte[1024];                int total = 0;                int len;                while ((len = inputStream.read(bytes)) != -1) &#123;                    if (isCanceled) &#123;                        return TYPE_CANCELED;                    &#125; else if (isPaused) &#123;                        return TYPE_PAUSED;                    &#125; else &#123;                        total += len;                        randomAccessFile.write(bytes, 0, len);                        int progressValue = (int) ((total + downloadCacheFileLength) * 100 / downloadFileLength);                        publishProgress(progressValue);                    &#125;                &#125;                body.close();                return TYPE_SUCCESS;            &#125;        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;        return TYPE_FAILED;    &#125;    /**     * 获取下载的文件的大小     * @param url 下载链接     * @return 文件大小     */    private long getDownloadFileLength(String url)&#123;        OkHttpClient okHttpClient = new OkHttpClient();        Request request = new Request.Builder().url(url).build();        long length = 0;        try &#123;            Response execute = okHttpClient.newCall(request).execute();            ResponseBody body = execute.body();            if (execute.isSuccessful() &amp;&amp; body != null)&#123;                length = body.contentLength();                body.close();            &#125;        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;        return length;    &#125;    /**     * 获取下载链接中的文件名     * @param url 下载链接     * @return 文件名     */    private String getDownloadFileName(String url)&#123;        int lastIndexOf = url.lastIndexOf(&quot;/&quot;);        return url.substring(lastIndexOf);    &#125;&#125;
&ensp;&ensp;更新下载进度/** * 当在后台任务中调用了publishProgress(Progress...)方法之后，onProgressUpdate()方法 * 就会很快被调用，该方法中携带的参数就是在后台任务中传递过来的。在这个方法中可以对UI进行操作，利用参数中的数值就可以 * 对界面进行相应的更新。 */@Overrideprotected void onProgressUpdate(Integer... values) &#123;    super.onProgressUpdate(values);    int progress = values[0];    if (progress &gt; lastProgress) &#123;        downloadListener.onProgress(progress);        lastProgress = progress;    &#125;&#125;
&ensp;&ensp;回调传入的接口/** * 当后台任务执行完毕并通过Return语句进行返回时，这个方法就很快被调用。返回的数据会作为参数 * 传递到此方法中，可以利用返回的数据来进行一些UI操作。 */@Overrideprotected void onPostExecute(Integer integer) &#123;    super.onPostExecute(integer);    switch (integer) &#123;        case TYPE_SUCCESS:            removeFile();            downloadListener.onSuccess(downloadFile);            break;        case TYPE_FAILED:            downloadListener.onFailed();            break;        case TYPE_PAUSED:            downloadListener.onPaused();            break;        case TYPE_CANCELED:            deleteCache();            downloadListener.onCanceled();            break;        default:            break;    &#125;&#125;/** * 删除下载缓存 */private void deleteCache() &#123;    downloadCacheFile.delete();&#125;/** * 将缓存文件重命名为目标文件 */private void removeFile() &#123;    if (downloadFile.exists() &amp;&amp; downloadFile.isFile()) &#123;        downloadFile.delete();    &#125;    downloadCacheFile.renameTo(downloadFile);&#125;
&ensp;&ensp;调用时new DownloadUtils(new DownloadUtils.DownloadListener() &#123;    @Override    public void onProgress(int progress) &#123;        // 下载进度    &#125;    @Override    public void onSuccess(File downloadCacheFile) &#123;        // 下载成功后回调    &#125;    @Override    public void onFailed() &#123;        // 下载失败时回调    &#125;    @Override    public void onPaused() &#123;        // 下载暂停    &#125;    @Override    public void onCanceled() &#123;        // 下载取消    &#125;&#125;).execute(url, folderPath, fileName);
&ensp;&ensp;整体来看一下/** * OkHttp断点下载 */public class DownloadUtils extends AsyncTask&lt;String, Integer, Integer&gt; &#123;    private static final int TYPE_SUCCESS = 0;  // 下载成功    private static final int TYPE_FAILED = 1;   // 下载失败    private static final int TYPE_PAUSED = 2;   // 下载暂停    private static final int TYPE_CANCELED = 3; // 下载取消    private boolean isPaused = false;           // 是否暂停    private boolean isCanceled = false;         // 是否取消    private int lastProgress;                   // 记录进度值    private File downloadCacheFile;             // 下载到本地的缓存文件    private File downloadFile;                  // 下载到本地的文件    private final DownloadListener downloadListener;    // 下载监听    public DownloadUtils(DownloadListener downloadListener) &#123;        this.downloadListener = downloadListener;    &#125;    /**     * 通过execute执行时，需要在传入的数组中添加三个参数，且顺序固定     * 1. 文件下载链接     * 2. 存放下载文件的目录的路径     * 3. 文件名     */    @Override    protected Integer doInBackground(String... strings) &#123;        // 下载链接        String downloadUrl = strings[0];        // 文件所在目录的路径        String folderPath = strings[1];        // 文件名        String fileName = strings[2];        // 如果下载链接为空，直接return出去        if (downloadUrl == null || TextUtils.isEmpty(downloadUrl))            return null;        // 如果所在目录的路径不正确        if (folderPath == null || TextUtils.isEmpty(folderPath))            folderPath = Environment.getExternalStorageDirectory().getAbsolutePath();        // 如果文件名不正确        if (fileName == null || TextUtils.isEmpty(fileName))            fileName = getDownloadFileName(downloadUrl);        // 下载到本地的文件路径        String downloadFilePath = folderPath + &quot;/&quot; + fileName;        // 下载到本地的文件        downloadFile = new File(downloadFilePath);        // 下载到本地的缓存文件路径        String downloadCacheFilePath = folderPath + &quot;/&quot; + fileName + &quot;_cache&quot;;        // 下载到本地的缓存文件        downloadCacheFile = new File(downloadCacheFilePath);        // 已经下载的缓存文件大小        long downloadCacheFileLength = 0;        // 获取已经下载的缓存文件大小        if (downloadCacheFile.exists() &amp;&amp; downloadCacheFile.isFile()) &#123;            downloadCacheFileLength = downloadCacheFile.length();        &#125;        // 要下载的文件的大小        long downloadFileLength = getDownloadFileLength(downloadUrl);        if (downloadFileLength == 0) &#123;            return TYPE_FAILED; // 下载失败        &#125; else if (downloadFileLength == downloadCacheFileLength) &#123;            return TYPE_SUCCESS; // 下载成功        &#125;        OkHttpClient okHttpClient = new OkHttpClient();        Request request = new Request.Builder()                .addHeader(&quot;RANGE&quot;, &quot;bytes=&quot; + downloadCacheFileLength + &quot;-&quot;) // 指定下载区间                .url(downloadUrl)                .build();        try &#123;            Response execute = okHttpClient.newCall(request).execute();            ResponseBody body = execute.body();            if (execute.isSuccessful() &amp;&amp; body != null) &#123;                InputStream inputStream = body.byteStream();                RandomAccessFile randomAccessFile = new RandomAccessFile(downloadCacheFile, &quot;rw&quot;);                randomAccessFile.seek(downloadCacheFileLength); // 跳过已经下载的字节                byte[] bytes = new byte[1024];                int total = 0;                int len;                while ((len = inputStream.read(bytes)) != -1) &#123;                    if (isCanceled) &#123;                        return TYPE_CANCELED;                    &#125; else if (isPaused) &#123;                        return TYPE_PAUSED;                    &#125; else &#123;                        total += len;                        randomAccessFile.write(bytes, 0, len);                        int progressValue = (int) ((total + downloadCacheFileLength) * 100 / downloadFileLength);                        publishProgress(progressValue);                    &#125;                &#125;                body.close();                return TYPE_SUCCESS;            &#125;        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;        return TYPE_FAILED;    &#125;    /**     * 获取下载的文件的大小     * @param url 下载链接     * @return 文件大小     */    private long getDownloadFileLength(String url)&#123;        OkHttpClient okHttpClient = new OkHttpClient();        Request request = new Request.Builder().url(url).build();        long length = 0;        try &#123;            Response execute = okHttpClient.newCall(request).execute();            ResponseBody body = execute.body();            if (execute.isSuccessful() &amp;&amp; body != null)&#123;                length = body.contentLength();                body.close();            &#125;        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;        return length;    &#125;    /**     * 获取下载链接中的文件名     * @param url 下载链接     * @return 文件名     */    private String getDownloadFileName(String url)&#123;        int lastIndexOf = url.lastIndexOf(&quot;/&quot;);        return url.substring(lastIndexOf);    &#125;    @Override    protected void onProgressUpdate(Integer... values) &#123;        super.onProgressUpdate(values);        int progress = values[0];        if (progress &gt; lastProgress) &#123;            downloadListener.onProgress(progress);            lastProgress = progress;        &#125;    &#125;    @Override    protected void onPostExecute(Integer integer) &#123;        super.onPostExecute(integer);        switch (integer) &#123;            case TYPE_SUCCESS:                removeFile();                downloadListener.onSuccess(downloadFile);                break;            case TYPE_FAILED:                downloadListener.onFailed();                break;            case TYPE_PAUSED:                downloadListener.onPaused();                break;            case TYPE_CANCELED:                deleteCache();                downloadListener.onCanceled();                break;            default:                break;        &#125;    &#125;    /**     * 删除下载缓存     */    private void deleteCache() &#123;        downloadCacheFile.delete();    &#125;    /**     * 将缓存文件重命名为目标文件     */    private void removeFile() &#123;        if (downloadFile.exists() &amp;&amp; downloadFile.isFile()) &#123;            downloadFile.delete();        &#125;        downloadCacheFile.renameTo(downloadFile);    &#125;    /**     * 调用该方法暂停下载     */    public void pauseDownload() &#123;        this.isPaused = true;    &#125;    /**     * 调用该方法取消下载     */    public void cancelDownload() &#123;        this.isCanceled = true;    &#125;    public interface DownloadListener &#123;        // 下载进度        void onProgress(int progress);        // 下载成功        void onSuccess(File downloadCacheFile);        // 下载失败        void onFailed();        // 下载暂停        void onPaused();        // 下载取消        void onCanceled();    &#125;&#125;
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android开发手记</tag>
      </tags>
  </entry>
  <entry>
    <title>recyclerView瀑布流</title>
    <url>/2022/07/03/recyclerView%E7%80%91%E5%B8%83%E6%B5%81/</url>
    <content><![CDATA[&ensp;&ensp;最近在开发一个小软件，在需要用到图片列表的时候，突然觉得，我好像从来都没有用过recyclerView的瀑布流，于是记下了这篇使用方法
布局主布局&ensp;&ensp;activity_main.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;    tools:context=&quot;.MainActivity&quot;&gt;    &lt;androidx.recyclerview.widget.RecyclerView        android:id=&quot;@+id/recyclerView&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;match_parent&quot; /&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;
item布局&ensp;&ensp;item.xml，在item布局中，设置RelativeLayout完全适应ImageView的布局大小，而ImageView的布局大小，将会在显示的过程中动态的计算出来&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;    android:layout_width=&quot;wrap_content&quot;    android:layout_height=&quot;wrap_content&quot;    android:background=&quot;@color/transparent&quot;&gt;    &lt;ImageView        android:id=&quot;@+id/imageView&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;/&gt;&lt;/RelativeLayout&gt;
创建图片实体类&ensp;&ensp;file用来储存本地图片的文件对象，不用多说；&ensp;&ensp;imgWidth和imgHeight用来储存这个图片的px宽度和高度，在后面适配器中需要结合这两个值去计算图片显示在屏幕上的px高度；&ensp;&ensp;showHeight用来储存图片显示在屏幕上的高度，由屏幕宽度、图片真实高度、图片真实宽度计算得出，当它的值为-1时，说明该对象的显示高度已经计算过了（如果我们的列表是纵向的，那么它显示的宽度是直接通过屏幕宽度计算的，所以不需要在实体类中再对它的显示宽度做记录）；public class ImgEntity &#123;    private File file; //文件对象    private int imgWidth; //图片宽度    private int imgHeight; //图片高度    private int showHeight = -1; //显示的高度    public void setFile(File file) &#123;        this.file = file;    &#125;    public void setImgWidth(int imgWidth) &#123;        this.imgWidth = imgWidth;    &#125;    public void setImgHeight(int imgHeight) &#123;        this.imgHeight = imgHeight;    &#125;    public void setShowHeight(int showHeight) &#123;        this.showHeight = showHeight;    &#125;    public File getFile() &#123;        return file;    &#125;    public int getImgWidth() &#123;        return imgWidth;    &#125;    public int getImgHeight() &#123;        return imgHeight;    &#125;    public int getShowHeight() &#123;        return showHeight;    &#125;&#125;
适配器&ensp;&ensp;图片显示在屏幕的宽度和高度都是在适配器中动态计算的，由于例子中是垂直方向的瀑布流，所以宽度应该是一个固定值，故没有在图片实体中对其属性定义public class RecyclerAdapter extends RecyclerView.Adapter&lt;RecyclerAdapter.ViewHolder&gt; &#123;    private Context context;    private List&lt;ImgEntity&gt; photoList; //图片实体对象    private int spanCount; //列数    private int itemRound; //item的圆角度    private int marginLeft; //item左边的外边距    private int marginTop; //item顶部的外边距    private int marginRight; //item右边的外边距    private int marginBottom; //item底部的外边距    private int showWidth; //图片显示在屏幕时的宽度    public RecyclerAdapter(Context context, List&lt;ImgEntity&gt; photoList, int spanCount, int itemRound, int marginLeft, int marginTop, int marginRight, int marginBottom) &#123;        this.context = context;        this.photoList = photoList;        this.spanCount = spanCount;        this.itemRound = itemRound;        this.marginLeft = marginLeft;        this.marginTop = marginTop;        this.marginRight = marginRight;        this.marginBottom = marginBottom;        //屏幕宽度px值        int screenWidthPx = context.getResources().getDisplayMetrics().widthPixels;        //屏幕宽度 减去 （左右两边的宽度乘item列数），再除以列数就得到了图片显示在屏幕时的宽度        showWidth = (screenWidthPx - (marginLeft + marginRight) * spanCount) / spanCount;    &#125;    @NonNull    @Override    public ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) &#123;        View view = LayoutInflater.from(context).inflate(R.layout.item, parent, false);        return new ViewHolder(view);    &#125;    @Override    public void onBindViewHolder(@NonNull ViewHolder holder, int position) &#123;        ImgEntity imgEntity = photoList.get(position);        if (imgEntity.getShowHeight() == -1)&#123; //如果等于-1说明是第一次加载，计算它的显示在屏幕时的高度            int showHeight = (int) (imgEntity.getImgHeight() * (1.0f * showWidth / imgEntity.getImgWidth()));            imgEntity.setShowHeight(showHeight);        &#125;        holder.imageView.getLayoutParams().height = imgEntity.getShowHeight(); //设置imageView高度        //使imageView圆角        RoundedCorners roundedCorners = new RoundedCorners(itemRound);        RequestOptions override = RequestOptions.bitmapTransform(roundedCorners).override(300, 300);        Glide.with(context).load(photoList.get(position).getFile()).apply(override).into(holder.imageView);    &#125;    @Override    public int getItemCount() &#123;        return photoList.size();    &#125;    public class ViewHolder extends RecyclerView.ViewHolder &#123;        private final ImageView imageView;        public ViewHolder(@NonNull View itemView) &#123;            super(itemView);            imageView = itemView.findViewById(R.id.imageView);        &#125;    &#125;&#125;
使用时&ensp;&ensp;代码中用到的FileUtils.getPathBitmap(path)是封装的一个方法，具体使用为通过图片文件的地址，获取图片的bitmappublic class FileUtils&#123;    public static Bitmap getPathBitmap(String filePath)&#123;        File file = new File(filePath);        try &#123;            FileInputStream fileInputStream = new FileInputStream(file);            return BitmapFactory.decodeStream(fileInputStream);        &#125; catch (FileNotFoundException e) &#123;            e.printStackTrace();        &#125;        return null;    &#125;&#125;
&ensp;&ensp;实战开发中图片的长宽大都由服务器提供public class MainActivity extends AppCompatActivity &#123;    private int spanCount = 2; //列数    private int itemRound = 6; //item的圆角度    private int marginLeft = 10; //item左边的外边距    private int marginTop = 10; //item顶部的外边距    private int marginRight = 10; //item右边的外边距    private int marginBottom = 10; //item底部的外边距	    private RecyclerView recyclerView;    private List&lt;ImgEntity&gt; photoList = new ArrarList&lt;&gt;();	    @Override    protect void onCreate(Bundle bundle) &#123;        super.onCreate(bundle);        recyclerView = findViewById(R.id.recyclerView);		        File folder = new File(&quot;图片文件所在的文件夹地址&quot;);        File[] files = folder.listFiles();        if (files != null &amp;&amp; files.length &gt; 0)&#123;            for (File file : files)&#123;                // 仅添加PNG图片                if (FileUtils.getFileType(file).equals(&quot;png&quot;))&#123;                    ImgEntity imgEntity = new ImgEntity(); // 闪照实体					                    imgEntity.setFile(file); //设置文件对象                    Bitmap pathBitmap = FileUtils.getPathBitmap(file.getPath());                    int imgWidth = pathBitmap == null ? 0 : pathBitmap.getWidth();                    int imgHeight = pathBitmap == null ? 0 : pathBitmap.getHeight();                    imgEntity.setImgWidth(imgWidth); //设置图片文件宽度                    imgEntity.setImgHeight(imgHeight); //设置图片高度                    photoList.add(imgEntity);                &#125;            &#125;        &#125;		        // 瀑布流布局，第一个参数控制行数/列数，第二个参数控制布局方向        StaggeredGridLayoutManager layoutManager = new StaggeredGridLayoutManager(spanCount, StaggeredGridLayoutManager.VERTICAL);        // 创建适配器        FlashRecyclerAdapter flashRecyclerAdapter = new FlashRecyclerAdapter(                this,                photoList,                spanCount,                itemRound,                marginLeft, marginTop, marginRight, marginBottom        );		        // 给item添加边距        recyclerView.addItemDecoration(new RecyclerView.ItemDecoration() &#123;            @Override            public void getItemOffsets(@NonNull Rect outRect, @NonNull View view, @NonNull RecyclerView parent, @NonNull RecyclerView.State state) &#123;                super.getItemOffsets(outRect, view, parent, state);                outRect.set(marginLeft, marginTop, marginRight, marginBottom); //给item添加左上右下外边距            &#125;        &#125;);		        recyclerView.setLayoutManager(layoutManager);        recyclerView.setAdapter(flashRecyclerAdapter);    &#125;&#125;
效果&ensp;&ensp;不要在意其它细节，实现完成后大概就是这个样子了

]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android开发手记</tag>
      </tags>
  </entry>
  <entry>
    <title>synchronized</title>
    <url>/2023/06/07/synchronized/</url>
    <content><![CDATA[同步代码块&ensp;&ensp;使用synchronized关键字给代码块加锁，synchronized后的括号内可以填入任意对象，被填入的对象将作为同步监视器；线程在执行同步代码块之前，必须先获得对同步监视器的锁定，当同步代码执行完成后，线程会释放对同步监视器的锁定；如果同步监视器已经被其他线程锁定，则当前线程进入阻塞队列，等待同步监视器的锁定被释放，这种方式可以确保同一时刻只有一个线程访问加锁的代码块（）。
&ensp;&ensp;如下代码，lock对象充当同步监视器，当一个线程调用test方法并进入同步代码块之前，必须先获得lock对象的锁定，如果已经有其他线程持有了该锁定，当前线程将进入阻塞状态。public class Main &#123;    private final Object lock = new Object();    public void test() &#123;        synchronized (lock) &#123;            // 执行需要同步的代码            // ...        &#125; // 在代码块执行完成后，会自动释放对同步监视器的锁定    &#125;&#125;
&ensp;&ensp;如果多个线程调用了同一个Main对象的test方法，它们将竞争同一个lock对象的锁定，那么只有一个线程能够获得该对象的锁定，并执行同步代码块中的代码，其他线程将被阻塞，直到获得了锁定的线程释放锁。&ensp;&ensp;但如果多个线程调用不同Main对象的test方法，那么每个线程都有不同的lock对象作为同步监视器，获得不同的同步监视器的锁定，所以test方法中的同步代码是独立的，不会发生阻塞。&ensp;&ensp;若要使多个线程能够同步调用不同Main对象的test方法，可以将lock设为静态，此时多个线程将竞争同一个静态锁，只有一个线程能够获得静态锁并执行同步代码块中的代码，其他线程将被阻塞，直到获得锁的线程释放锁。public class Main &#123;    // 设为静态    private static final Object lock = new Object();    public void test() &#123;        synchronized (lock) &#123;            // 执行需要同步的代码            // ...        &#125; // 在代码块执行完成后，会自动释放对同步监视器的锁定    &#125;&#125;
同步方法普通同步方法&ensp;&ensp;普通同步方法，以当前实例对象作为同步监视器
// 同步方法public synchronized void test() &#123;    // 执行需要同步的代码&#125;// 等同于public void test() &#123;    synchronized (this) &#123;        // 执行需要同步的代码    &#125;&#125;
&ensp;&ensp;如下代码执行时，多个线程同时执行syncTest，操作value值递减，由于运行中的线程时间片用完时会进入阻塞状态，假设当前线程在即将操作value值时进入阻塞状态，阻塞期间其他得到时间片的线程继续对value值操作，当阻塞的线程重新获得时间片并执行时，进入阻塞状态之前所操作过的value可能已经被其他线程改变，所以当输出value时会出现相同的值，甚至出现负数public class SyncTest implements Runnable &#123;    private int value = 100;    public static void main(String[] args) &#123;        SyncTest syncTest = new SyncTest();        Thread thread1 = new Thread(syncTest);        Thread thread2 = new Thread(syncTest);        Thread thread3 = new Thread(syncTest);        thread1.start();        thread2.start();        thread3.start();    &#125;    @Override    public void run() &#123;        for (int i = 0; i &lt; 100; i++) &#123;            try &#123;                // sleep会使线程主动放弃执行权，模拟被调度器将时间片分配给其他线程                Thread.sleep(1);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            if (value &gt; 0) &#123;                System.out.println(&quot;value=&quot; + (--value));            &#125;        &#125;    &#125;&#125;
&ensp;&ensp;对value值修改部分加锁@Overridepublic void run() &#123;    for (int i = 0; i &lt; 100; i++) &#123;        try &#123;            // sleep会使线程主动放弃执行权，模拟被调度器将时间片分配给其他线程            Thread.sleep(1);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;        synchronized (this) &#123;            if (value &gt; 0) &#123;                System.out.println(&quot;value=&quot; + (--value));            &#125;        &#125;    &#125;&#125;
&ensp;&ensp;或者将修改value值的部分提取到一个方法，并将方法设为同步方法@Overridepublic void run() &#123;    for (int i = 0; i &lt; 100; i++) &#123;        try &#123;            // sleep会使线程主动放弃执行权，模拟被调度器将时间片分配给其他线程            Thread.sleep(1);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;        sub();    &#125;&#125;private synchronized void sub() &#123;    if (value &gt; 0) &#123;        System.out.println(&quot;value=&quot; + (--value));    &#125;&#125;
静态同步方法&ensp;&ensp;静态同步方法，以当前类的class对象作为同步监视器
// 静态同步方法public synchronized static void test() &#123;    // 执行需要同步的代码&#125;// 等同于public static void test() &#123;    synchronized (Main.class) &#123;        // 执行需要同步的代码    &#125;&#125;
&ensp;&ensp;如下synchronized的用法并不能起到代码同步的作用，因为synchronized后的括号中填入了this，代表以当前对象作为代码块的同步监视器，而三个线程使用了不同的对象，所以synchronized中的代码是独立运行的public class TestThread extends Thread&#123;    private static int value = 100;    public static void main(String[] args) &#123;        new TestThread().start();        new TestThread().start();        new TestThread().start();    &#125;    @Override    public void run() &#123;        super.run();        for (int i = 0; i &lt; 100; i++) &#123;            try &#123;                Thread.sleep(1);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            synchronized (this) &#123;                if (value &gt; 0) &#123;                    System.out.println(&quot;value=&quot; + (--value));                &#125;            &#125;        &#125;    &#125;&#125;
&ensp;&ensp;要使代码在多个线程中同步，需要确定同步监视器的唯一，可以用当前类的class对象作为同步监视器@Overridepublic void run() &#123;    super.run();    for (int i = 0; i &lt; 100; i++) &#123;        try &#123;            Thread.sleep(1);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;        synchronized (TestThread.class) &#123;            if (value &gt; 0) &#123;                System.out.println(&quot;value=&quot; + (--value));            &#125;        &#125;    &#125;&#125;
&ensp;&ensp;或则创建一个静态对象，作为同步监视器private final static Object lock = new Object();@Overridepublic void run() &#123;    super.run();    for (int i = 0; i &lt; 100; i++) &#123;        try &#123;            Thread.sleep(1);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;        synchronized (lock) &#123;            if (value &gt; 0) &#123;                System.out.println(&quot;value=&quot; + (--value));            &#125;        &#125;    &#125;&#125;
&ensp;&ensp;又或者使用静态同步方法@Overridepublic void run() &#123;    super.run();    for (int i = 0; i &lt; 100; i++) &#123;        try &#123;            Thread.sleep(1);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;        sub();    &#125;&#125;private synchronized static void sub() &#123;    if (value &gt; 0) &#123;        System.out.println(&quot;value=&quot; + (--value));    &#125;&#125;
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>tencent bugly接入</title>
    <url>/2023/07/30/tencent-bugly%E6%8E%A5%E5%85%A5/</url>
    <content><![CDATA[
bugly地址：http://bugly.qq.com/

添加依赖&ensp;&ensp;在build.gradle中添加依赖dependencies &#123;    //其中latest.release指代最新Bugly SDK版本号，也可以指定明确的版本号，例如4.0.3    implementation &#x27;com.tencent.bugly:crashreport:latest.release&#x27; &#125;
参数配置&ensp;&ensp;在AndroidManifest.xml中添加权限&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot; /&gt;
&ensp;&ensp;如果开启了混淆，需要在混淆文件中添加如下配置-dontwarn com.tencent.bugly.**-keep public class com.tencent.bugly.**&#123;*;&#125;
初始化bugly&ensp;&ensp;第三个参数为SDK调试模式开关，调试模式的行为特性如下：

输出详细的Bugly SDK的Log；
每一条Crash都会被立即上报；
自定义日志将会在Logcat中输出。

CrashReport.initCrashReport(getApplicationContext(), &quot;注册时申请的APPID&quot;, false);
&ensp;&ensp;Bugly2.0及以上版本支持通过“AndroidManifest.xml”配置APP信息&lt;application    &lt;!-- 配置APP ID --&gt;    &lt;meta-data            android:name=&quot;BUGLY_APPID&quot;            android:value=&quot;&lt;APP_ID&gt;&quot; /&gt;    &lt;!-- 配置APP版本号 --&gt;    &lt;meta-data            android:name=&quot;BUGLY_APP_VERSION&quot;            android:value=&quot;&lt;APP_Version&gt;&quot; /&gt;    &lt;!-- 配置APP渠道号 --&gt;    &lt;meta-data            android:name=&quot;BUGLY_APP_CHANNEL&quot;            android:value=&quot;&lt;APP_Channel&gt;&quot; /&gt;    &lt;!-- 配置Bugly调试模式（true或者false）--&gt;    &lt;meta-data            android:name=&quot;BUGLY_ENABLE_DEBUG&quot;            android:value=&quot;&lt;isDebug&gt;&quot; /&gt;&lt;/application&gt;
&ensp;&ensp;通过“AndroidManifest.xml”配置后的初始化方法如下：
CrashReport.initCrashReport(getApplicationContext());
dex分包配置&ensp;&ensp;如果使用了MultiDex，建议通过Gradle的multiDexKeepFile配置等方式把Bugly的类放到主Dex，另外建议在Application类的attachBaseContext方法中主动加载非主dex
&ensp;&ensp;multidex-keep.txt中配置
com.tencent.bugly.crashreport.CrashReport
&ensp;&ensp;gradle中配置
defaultConfig &#123;    ...    multiDexEnabled true //dex分包    multiDexKeepFile file(&#x27;multidex-keep.txt&#x27;)  // 指定某些类存放于主dex    ...&#125;
测试&ensp;&ensp;执行如下代码，可以进行崩溃测试
CrashReport.testJavaCrash();
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android开发手记</tag>
      </tags>
  </entry>
  <entry>
    <title>toString、equals和clone</title>
    <url>/2021/07/17/toString%E3%80%81equals%E5%92%8Cclone/</url>
    <content><![CDATA[重写toString&ensp;&ensp;调用对象的toString()方法默认会返回对象在堆内存中的地址值Object object = new Object();// 默认输出 类名+@+十六进制哈希值System.out.println(object.toString());
&ensp;&ensp;重写toString()，即可自定义返回值public class StringTest &#123;    public static void main(String[] args)&#123;        Test test = new Test(&quot;测试&quot;);        // 将会输出 str: 测试        System.out.println(test);    &#125;&#125;class Test&#123;    private String str;    @Override    public String toString() &#123;        return &quot;str：&quot; + this.str;    &#125;    public Test(String str)&#123;        this.str = str;    &#125;&#125;
重写equals&ensp;&ensp;equals()用于比较两个对象，Object中默认的equal()方法只会比较两个对象的地址值是否相同，所以当我们使用该方法时需要对其进行拓展，比如两个Student对象中如果姓名和学号相同，即认为二者相同
public class Student &#123;    private String name;    private int age;    private String sex;    private int id;    @Override    public boolean equals(Object obj) &#123;        // 如果地址值相同，直接返回true        if (this == obj) return true;                Student stu = (Student)obj;       if (name.equals(stu.name) &amp;&amp; (id == stu.id)) &#123;           return true;       &#125;       return false;    &#125;&#125;
重写clone浅克隆&ensp;&ensp;浅克隆只需要实现Cloneable接口，并重写clone方法即可public class Student implements Cloneable &#123;    private String name;    private int age;    private String sex;    private int id;    public Student(String name, int age, String sex, int id) &#123;        this.name = name;        this.age = age;        this.sex = sex;        this.id = id;    &#125;    public String getName() &#123;        return name;    &#125;    public int getAge() &#123;        return age;    &#125;    public String getSex() &#123;        return sex;    &#125;    public int getId() &#123;        return id;    &#125;    @Override    protected Student clone() throws CloneNotSupportedException &#123;        return (Student) super.clone();    &#125;&#125;&ensp;&ensp;在其他方法中调用clone()即可实现对象克隆Student clone = student.clone();// 注意此时已经重写了toString()System.out.println(clone);
深克隆&ensp;&ensp;通过将对象序列化和反序列化实现深克隆@Overrideprotected Student clone() throws CloneNotSupportedException &#123;    try &#123;        // 序列化        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();        ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream);        objectOutputStream.writeObject(this);        // 反序列化        ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(byteArrayOutputStream.toByteArray());        ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream);        return (Student) objectInputStream.readObject();    &#125; catch (IOException | ClassNotFoundException e) &#123;        e.printStackTrace();    &#125;    return null;&#125;;
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>三角函数</title>
    <url>/2024/03/05/%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[三角函数基本关系
正弦：$\sin A = \frac{a}{c} $&ensp;&ensp;余弦：$\cos A = \frac{b}{c} $
正切：$\tan A = \frac{a}{b} $&ensp;&ensp;余切：$\cot A = \frac{b}{a} $
余割：$\csc A = \frac{c}{a} $&ensp;&ensp;正割：$\sec A = \frac{c}{b} $

恒等式
$ \sec A = \frac{1}{\cos A} $
$ \csc A = \frac{1}{\sin A} $
$ \cot A = \frac{1}{\tan A} $
$ \sin ^{2}A + \cos ^{2}A = 1 $
$ \tan ^{2}A + 1 = \sec ^{2}A $
$ \tan A = \frac{\sin A}{\cos A} $
$ \cos 2A = \cos ^{2} A - \sin ^{2} A = 1 - 2\sin ^{2} A = 2\cos ^{2} A - 1 $
$ \sin 2A = 2\sin A \times \cos A $
$ \csc ^{2} A = \frac{1}{\sin ^{2} A}  = \frac{\cos ^{2} A + \sin ^{2} A}{\sin ^{2} A} = \frac{\cos ^{2} A}{\sin ^{2} A} + 1 = \cot ^{2}A + 1 $
$ \cos (\alpha \pm  \beta ) = \cos \alpha \cos \beta \mp \sin \alpha \sin \beta  $
$ \sin (\alpha \pm \beta ) = \sin \alpha \cos \beta \pm \cos \alpha \sin \beta  $

正弦余弦




正弦函数
余弦函数




数学表达式
$y=\sin x$
$y=\cos x$


定义域
$(-\infty,+\infty)$
$(-\infty,+\infty)$


值域
$[-1,1]$
$[-1,1]$


奇偶性
奇函数
偶函数


单调性
非单调函数
非单调函数


周期
$2\pi$
$2\pi$


函数图像






正切余切




正切函数
余切函数




数学表达式
$y=\tan x$
$y=\cot x$


定义域
$x \ne k\pi + \frac{\pi}{2}$
$x \ne k\pi$


值域
$(-\infty,+\infty)$
$(-\infty,+\infty)$


奇偶性
奇函数
奇函数


单调性
单调递增
单调递减


周期
$\pi$
$\pi$


函数图像






正割余割




正割函数
余割函数




表达式
$y=\sec x$
$y=\csc x$


定义域
$x \ne k\pi + \frac{\pi}{2}$
$x \ne k\pi$


值域
$(-\infty,-1]\cup[1,+\infty)$
$(-\infty,-1]\cup[1,+\infty)$


奇偶性
偶函数
奇函数


单调性
非单调函数
非单调函数


周期
$2\pi$
$2\pi$


函数图像






反三角函数反正弦反余弦




反正弦函数
反余弦函数




数学表达式
$y=\arcsin x$
$y=\arccos x$


定义域
$[-1,1]$
$[-1,1]$


值域
$[-\frac{\pi}{2},\frac{\pi}{2}]$
$[0,\pi]$


奇偶性
奇函数
非奇非偶


单调性
单调递增
单调递增


函数图像






反正切反余切




反正切函数
反余切函数




数学表达式
$y=\arctan x$
$y=\operatorname{arccot} x$


定义域
$(-\infty,+\infty)$
$(-\infty,+\infty)$


值域
$(-\frac{\pi}{2},\frac{\pi}{2})$
$(0,\pi)$


奇偶性
奇函数
非奇非偶


单调性
单调递增
单调递减


函数图像






]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>上传项目至github</title>
    <url>/2021/10/17/%E4%B8%8A%E4%BC%A0%E9%A1%B9%E7%9B%AE%E8%87%B3github/</url>
    <content><![CDATA[&ensp;&ensp;&ensp;&ensp;创建仓库
&ensp;&ensp;&ensp;&ensp;复制仓库的ssh链接
&ensp;&ensp;&ensp;&ensp;在本地，把预备上传至github的项目文件夹存放在一个文件夹中，例如现在我将fix文件夹放在myProject文件夹中，fix文件夹内就是我想上传的文件
&ensp;&ensp;&ensp;&ensp;鼠标右键myProject文件夹，并选择Git Bash Here，然后在出现的窗口中输入“git clone 复制的ssh链接”从github下载项目
&ensp;&ensp;&ensp;&ensp;在myProject文件夹下，会发现多了一个与github仓库名一样的文件夹(比如我的多了一个fixNavbBar文件夹)
&ensp;&ensp;&ensp;&ensp;接着手动把fix文件夹下的所有文件复制粘贴至fixNavBar
&ensp;&ensp;&ensp;&ensp;然后在命令窗口中“输入cd 文件夹名”进入新文件夹
&ensp;&ensp;&ensp;&ensp;输入git add .(注意有个小点)，会把fixNavbBar文件夹下面新的文件或修改过的文件添加进来，如果之前已经添加了，它会自动省略
&ensp;&ensp;&ensp;&ensp;输入 git commit -m “logs”提交项目说明
&ensp;&ensp;&ensp;&ensp;输入 git push -u origin main，上传项目&ensp;&ensp;&ensp;&ensp;注意：在2021年8月13号之后，github不允许用账号密码上传项目，必须使用token，如果没有token&ensp;点击这里
&ensp;&ensp;&ensp;&ensp;上传完成后到github查看项目即可
]]></content>
      <categories>
        <category>菜鸡手记</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>修改Android项目sdk版本</title>
    <url>/2021/11/13/%E4%BF%AE%E6%94%B9Android%E9%A1%B9%E7%9B%AEsdk%E7%89%88%E6%9C%AC/</url>
    <content><![CDATA[&ensp;&ensp;&ensp;&ensp;一、先来看一下我的Android Studio版本
&ensp;&ensp;&ensp;&ensp;二、创建一个新项目
&ensp;&ensp;&ensp;&ensp;三、在app的gradle文件中，看一下我现在的sdk版本是29，对应Android 10&ensp;&ensp;&ensp;&ensp;这里我有一个疑惑点，先说一下我知道的：Android Studio创建的新项目会根据当前环境下本地最新的sdk版本创建，因为我现在最新的就是sdk api就是29，所以创建的项目对应sdk api29。&ensp;&ensp;&ensp;&ensp;我疑惑的：当我删除掉sdk 29的所有与相关信息的时候，再创建项目，他竟然会自己下载sdk 29的一小部分信息，虽然不是整个sdk，但是足以影响到我创建新项目！！！
&ensp;&ensp;&ensp;&ensp;四、在app的gradle文件中直接修改，或者在左上角File -&gt; Project Structure中修改对应版本信息&ensp;&ensp;&ensp;&ensp;1、Android Gradle Plugin Version和Gradle Version
&ensp;&ensp;&ensp;&ensp;2、这里我把Compile Sdk Version(SDK版本)从29修改到了26，也就是把对应的安卓版本修改到了Android 8，build Tools Version至少要使用29.0.2
&ensp;&ensp;&ensp;&ensp;3、这边默认配置(default config)中的Target SDK Version也修改成了26
&ensp;&ensp;&ensp;&ensp;4、然后点OK，回到app的gradle文件中看一下，已经根据刚刚的配置发生改变了
&ensp;&ensp;&ensp;&ensp;五、编译，发生错误
&ensp;&ensp;&ensp;&ensp;1、说一个什么什么样式找不到，真恶心C:\Users\30335\.gradle\caches\transforms-2\files-2.1\c2c5fa787d66aaf40578b3071f4d283f\appcompat-1.1.0\res\values-v28\values-v28.xml:5:5-8:13: AAPT: error: resource android:attr/dialogCornerRadius not found.
&ensp;&ensp;&ensp;&ensp;点击蓝色log，跳转过去看一下，代码中有一行注释中提到，sdk api 需要28+，这样错误的原因就很明了了，我们的sdk版本是26&lt;!-- We can use the platform styles on API 28+ --&gt;
&ensp;&ensp;&ensp;&ensp;六、打开项目的gradle文件&ensp;&ensp;&ensp;&ensp;在allprojects中插入，然后sync now一下subprojects &#123;    afterEvaluate &#123;        project -&gt;            if (project.hasProperty(&quot;android&quot;)) &#123;                android &#123;                    compileSdkVersion = 29                    buildToolsVersion = &quot;29.0.2&quot;                &#125;            &#125;    &#125;&#125;

&ensp;&ensp;&ensp;&ensp;七、编译运行，好了😊
&ensp;&ensp;&ensp;&ensp;为什么好了？我也不知道
]]></content>
      <categories>
        <category>菜鸡手记</category>
      </categories>
      <tags>
        <tag>软件与工具</tag>
      </tags>
  </entry>
  <entry>
    <title>储存类别</title>
    <url>/2022/12/04/%E5%82%A8%E5%AD%98%E7%B1%BB%E5%88%AB/</url>
    <content><![CDATA[自动储存区&ensp;&ensp;自动储存区中只储存自动变量，自动变量通常是局部变量，函数的形参也视为局部变量；auto用于修饰自动变量，局部变量在不加任何修饰的情况下默认就是自动变量（形参无法被修饰），所以没有任何修饰的局部变量默认就是自动变量，和函数形参一起储存在自动储存区
&ensp;&ensp;自动存储区中的变量在它的作用域（函数或者代码块）被执行时创建、分配内存，在创建时如果没有初始化，变量的值将是未定义的，自动存储区中的变量只在作用域内可见和可用，作用域结束时销毁
&ensp;&ensp;如下代码中，test函数的形参num和函数中的num2都储存在自动储存区，函数test就是它们的作用域，当作用域结束时，num和num2都被销毁int main() &#123;    // 这里 num2 已经被销毁，目前 num2_pointer 是空指针    int* num2_pointer = test(10);    // num2_pointer 此时为空指针，将会进入 if    if (num2_pointer == NULL) &#123;        printf(&quot;num2已被销毁&quot;);    &#125; else &#123;        printf(&quot;num2 = %d\n&quot;, *num2_pointer);    &#125;        return 0;&#125;int* test(int num) &#123;    printf(&quot;num = %d\n&quot;, num);    // num2 在 test 函数运行结束后会被销毁    int num2 = 10;    // num2 被销毁后它的指针就成了空指针    return (&amp;num2);&#125;
静态储存区&ensp;&ensp;静态储存区中存放所有全局变量、静态变量（局部静态变量和全局静态变量）及const修饰的常量（普通常量和静态常量）；静态储存区中的数据在程序启动时就被分配空间，并在程序结束时才被释放，静态存储区的数据是在程序运行期间一直存在的，与函数的调用和返回无关
&ensp;&ensp;静态局部变量的空间分配和赋初始值是在程序第一次进入声明这个变量的函数时，所以后续调用函数时不再为其分配空间和赋初始值。静态局部变量的生命周期贯穿整个程序运行期间，而不是只在函数调用时存在。
&ensp;&ensp;如下代码说明了static修饰的静态局部变量不会在函数执行结束后被销毁，并且说明了只有程序第一次进入声明这个静态局部变量的函数时才会为其分配空间和赋初始值int main() &#123;    // 第一次调用 test 函数    int* num_pointer = test();    // 将会输出 11，说明 num_pointer 不是空指针，函数中的 num 变量没有被销毁    printf(&quot;num = %d\n&quot;, *num_pointer);    // 第二次调用 test 函数    num_pointer = test();    // 将会输出 12，num 不会再被分配空间和赋初始值，只执行了自加    printf(&quot;num = %d\n&quot;, *num_pointer);    return 0;&#125;int* test() &#123;    // 只在第一次进入 test 函数时为 num 分配空间，赋初始值    static int num = 10;    // 自加    num++;    // 将 num 的内存地址 return 出去    // test 执行完毕后如果 num 被销毁，那么内存地址将会为空    return (&amp;num);&#125;
动态储存区&ensp;&ensp;在C语言中，动态存储区主要负责存储程序运行时动态分配的内存，这部分内存的生命周期不是由编译器决定的，而是由程序员在运行时显式地管理。动态存储区包括堆（heap）和栈（stack）两个部分
&ensp;&ensp;堆（Heap）：堆是用于存储动态分配的内存的区域。在堆上分配的内存需要手动释放，否则可能导致内存泄漏。C语言中，通过malloc、calloc、realloc等函数来在堆上分配内存，通过free函数来释放堆上的内存&ensp;&ensp;栈（Stack）：栈是用于存储函数参数和局部变量的内存的区域。栈上的内存由系统自动管理，它在函数调用时被分配，函数结束时自动释放。栈上的内存生命周期短暂，通常与函数的执行周期相关
int main() &#123;    // 在堆上分配一个包含5个整数的数组    int *arr = (int *)malloc(5 * sizeof(int));    // 释放在堆上分配的内存    free(arr);    return 0;&#125;
寄存器储存区&ensp;&ensp;寄存器储存区用于指示编译器将变量存储在寄存器中，而不是存储在内存中。寄存器是CPU内部的高速存储器，访问速度比内存快。需要注意的是虽然C语言提供了register关键字，允许程序员建议编译器将某个变量存储在寄存器中，但实际上编译器并不一定会遵循这个建议。
&ensp;&ensp;寄存器储存区主要用于频繁访问的变量，以提高程序的执行速度。由于寄存器数量有限，不是所有变量都能存储在寄存器中。编译器会根据程序的需求和架构的特性来决定是否将变量存储在寄存器中。寄存器储存区中的变量用于临时存储，程序员不能直接对寄存器进行地址操作，因为寄存器没有地址。
&ensp;&ensp;随着编译器优化的发展，现代编译器能够自动分配寄存器
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C语言基础</tag>
      </tags>
  </entry>
  <entry>
    <title>公众号接口文档</title>
    <url>/2022/01/09/%E5%85%AC%E4%BC%97%E5%8F%B7%E5%90%8E%E5%8F%B0%E6%8E%A5%E5%8F%A3%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[
  ff1e32adbf55caa91082832c5ba17bbf7726dcb8abe111e8e95e4bc84bb182cbb1b456c99e100af325c174da70e9dda164b17c9ad45de943a6713bbc08da0fbd1d22f29654ef29e0e03468f84b5351b5081a04fb8aebf53e8e89eb0afde5dbb986599a35c32bb530b1e227630532420f36d85ce95bfc9f944de96bb54aca81dd25aedbff01cb28586f7bac0a5ec7879e180048880a0a704fdba170375d93bfa44558fd0fd0dfda726e716c5fb808f8759132afb08070cda57397adbae1cc55d2bf7873b10e39dc17b11313993c839c007979a39c6da961ba671a61801be84d18bfde81568e497b74eb3bc0f928364e8f50de8fdaafb40e4f02d13a05bce018350cf9f42d762b3c7cd42d7ad51ab45c475684d83589769adf4602e300ecda8c2c4abaa172ea6c706415eea7b93787fb04dbc442b6e045bf6bd18faa086be2ed48dc0e19b9ee7edfa50d21aa9ae835aa05dec21abd8e32a18a6a9ace158cca0d0c399705d91dad83a6866cd4d6637252f4a20dd5f28cd67d0d2c1b37512bae7030b61aea5e325be706e70aab1192c4a9a5a6efb626f12ca5cf62bcc86c8895080a019e9da43a724a9feeec2cb6663abc5598552d3d895d5b633a197d00a3f35e1989685b232805d44b7578cba973d92aa85656c993a1351e1a47ea8732860200a8d362c10e3009809168890895ee2ecf393b129bc8551969a69439d3a0676818fe5a84893c83d712447b1454c9de3db128f5cad089cf7d1cef4bd7fd83c27732825c077c311b012832d88a2b2ee4acb233010a2af6236b9b2d6ff5a89c4e0915e405bc7a2e5a7667346b387a890b3cec48822980ddb29700cceefcb2747ecf972fd33416f15dca9cdb3103b8cda0b8d5281160e0770f09e9c295748debc1e2a4048dfed6370ff4da380c414ba2c7721df23eb826127b70f6f5b3cc3228a1f033ae94f66a96feb6da1c51184ff718c8e3aac1f099928a2ccc43eb27a403a60ec68b7486e0bbc7963b4769941c9cb44f80a5191f79f69ad2c50400d820286e9e56d51ea6c9a653d8fb19e823006aba3544a7c9c0a17729fab56dbe92b61af753b959cb26d5f926c6a6fd7edb5985bc8163d068390e3a8288a0cf06d3d219e7351853f552ea6b284303a0b860d26d006a5a2220ae9760daf947182515892fb9df558e475ae4448d7c7f32ebd9a4d164f597fe8a694221de29d59127c5d3baf790ab0276675cf20ab45272885de8588d9c53f8c5059301b7c4dcf2c5dcf50df24c56869c42b60c426740bd6e0738b9f2942b2760a26626fab66ff36fdd907a5c20a4d1863728736db7d8fb04618bb612b3dba43805810dc3696b260b8375b469139603b62dfe5b0649bb180a15e1984f65cbb77ae4e810abaf72c0cf163327725ec4da3e1bfa0fbb0e38fd6432e23b6adec1debb36189d53326a8064d2764e532e53b759af560829c8269901acfc58abcc225a94f184acf4b1974740377cf472535076a5db542defaac1b4038eb80efd9911648d1c242fca8af12b12d09161e19caf718383ea81a5d601f7cff96d64e6af41977c53c08f7e6dd23d0f70311ad83c90393cf1460d5ad76b84537158fb1a4368d4c3256bb2299cdfcae27665bc5c80279ece9034eb6131498f3e9a1a3fbc2d7f3c709a166f914c241e4f01fda06ef21bdb3831e9efcb325fbc1f4c1e97ee454810b368b224ba9afc0afe21905e801e1e72b209ec709a1ce64f683b2fcccf2b226d9cdc5c55cba2621a2079e6f36e3ffb77255367c0e6fccae12d0523fccd9916965460ab680ee1c9101ad1f7cb28fb73e4a9c6fbc2ee23306915c61b08b114394e17a7ce09349e5224b6a2dda4aae5b3a66a852359b9b6e7cdad017e37fa9a1b09b6edd2b0da0f8c9d36573d6fde71b7bae31a5ec239c0c2e7cfc8d9f7c68095a96061c402a328ef7cb20ce21d16cfb3fba65440e405bffc2f84f4a86216f51f58df14b44d3dd2d9c8b3ebbdc74bf231be0255aa2dc6e3088d8e22220d5a72266e08a8b56ec3d747934cd37c2eff31406583197fcf0d0bfb34dcad1b4e38075f7b6c73959223725e916722cdfa3c10fd45059b284048e3ddc8d971390f9fd964189917e2c02f03c0c223d9242508ecfb2acbb17967ac6c1dcb796f3c06b4e938d19912a1520a88f585257517644a71446cdc912495922cafefaee4e557d36f2561b46028e0abd018dad0d2bbd0b5eed73dd19a4186cfa58231ccf2005a6b8ac1908be486e2f73509c86ed84a752e37bddee157c1295a227169aa7bf73e0d39fa7ce4cc18f709c95c6e00301f6cba4dda6cb1eecbdadb634337c56f59e44002de3572fca20f7326f369ed9ce4ebcf8d98b798c3524c2fae9c633f60a52d5de5df7691cd724cb78989a4f5caba17bdea744ed62358885b2cee947ee530eaaadf8699e2b3dfd6619a84b1d282c76938d482315339b5760f0776f1294c795fbd99f0a61721e1684315e5718eb2a764b8a8747e6a21d22090697871aad17288aa3a09e5d92d5e98bb0dc52eb9f06358b810c746bb40827d2ef62a8a19eb33f9a271884fe3f89e44d8fceec240502921f75b18496c5d75afc32edf85868ff0efb691c2d9b133524c33c8df23b932761edd8a225e3eadf0f4399b7a5ea702c5eedf55f743b67048e7d2203b77de41a5b5ec7a41c63b15db96c1a63a4664a341e9330c67227785d8027085878fec5d652bb9749c073c7e69f048f711e7b84abe3d013236c542b122217ab01d33379d1cb58e8eb45e2c15070d4341482d44ec38c809c8e9d6941be5ccc4a6c75f26b145a76df234b2abeb94e4a21963e5b6a9c4380fb11931331f6f7d0a4d184c91ba1b4885b4a5f93b6b115f54b0d3561090b7033537966aa43a50edd82c430edb9fec2a0919c80ad145ab0d126205ce2f3e1eacb278a8f5d941b17b574953b72a764af3c02456a06f33323588c29f3c298e416c7f5bbcaa5563059b2643f92db8c492fc08d494c40e661ffbab03aec6b322dbd4f9f49a5e980dee32fe3cf0c66da95cf3f72b6fc89e2f13e8179b8a878b72704738ff2bddb9e202f0c1e62c255b97b3500606be1a3fa9242a9a64f8e9fef79316cd3d6503f34620eda5d57e679096afc140874922216f72a9d92b378bacf4d13afa85a8af7b98bbf52cd7660bc10c66a0ac3d020f00993a1df3a55c418d04aead29986a811e34c79fdb8902401617afef1443073c28636129125bddb25df27f3ff841e76237224c2cbe3671a9f4770bb25f5f82b3786913f22614f38744a2bf51f83f69e517600437b71a0821417dc0dc1d8f96ed16544614168f67b059b3f7820755ba37eaf1cd0f889651b00c3e769e5df62f8d5e33934a13b5d70b1c24e5f151e6adedd65397e783a41d6ed70bf8fb7d66e5d52f21a618129f33e00e8167f67a5443cac7ba5f4c70c50840ccd4b01d20991e16a200ded40c89f5e1f2f54f6d1bc23f31506187539f7cc29e61bc794d4ceb510f7c885a733a704f202816eaf94a7d8c288f54ac0cd5659db7cd2fcc210ebdb503f66beae775b14e2c7bbff7d2c00d8b7f5fe7715fcf19a07ff43be3dedc6cb41204b0e452ba75372d76b1caae28c866eb81c9c522dcb7ef115a9168d5973be972751f1d840445a301e537f8a81f6cb250fb440fc37ba3e94ad4ca794cf869f6fe9ae465dbacc5bded1f9b16eeea3c7869a96097e58c2a4f34aa9df59398341659f441abb64496f4e148673fb1beb9e7c6b397fabd00b9c5eb05f37f8301cf4f428997273975bd232d0cb51e957763616cb6f5af67c9c5537993a1dd4c779e1fe4392ce239948b2298ce92b0cc7efd097000394499fc51f0ee1b200bb926f6eda35ee021b097c1c648d41fdcdbb465329d9a52d8caabd4463dedeb54b9883c468b71b2d4ab32e7492d4f0b191c0f0d6c369280e906cea040047ee4e61ea26663d25e3c2ab6c65521bed241f7644578c00c0df6a43e1504e0090318731b622b066bd7dc28aba44f9994eca94e1bbf76c135e8fe8fe7ed9e6cdc85fd51ce42727160e392d69f17ff29cf109d9f9eadce0cef13f669bc8232047bd29f0b3c6ee47a0ba83558feb1bf0b04996c2d16083f38893d66db9572f2e959f39c3507084dc59ba9c0c31a18375e84926e05a26989c440dd21e111f3fbb98edfd938fd9f76bac246bebe4f82b92ef486fc87415b8238ae8c3326801eb5158d6f9a0615bf4c3873fa4310af7bab629c79743776c8947a40b4272ec8586397eeb82b3ca1b99e5a4c21d6e699fc71cd60d922b8af44164a05981577fdd6df3ca6edba2e39cc80d4ce33e26597dbb3886996357d62915bc5c1eb8fb434724335c6f6f5212c4adeec2b1cc1dd65fcd46ddcaceebb907fa6a2d9e50074ef741660d737cf121f4cb6b4c10cf8d8e61e7b2e7faa2a989902848ef12892265e26b88fa8cb6f531da0c181c630e86dcd478679e57b7962256f7eb214aef46016605ec6a182656db085449f2abd0920683d53a32000c51e2e06b21699d7ff273128c2eb32c092c6d59e00a4777faddb8debbc6e31ca35983aaef5675f4ba100eb67bac674e81f14a67de16b4b0231943122c6bafff075bac9fefc2893df79881373f031689d05082f57313ff3db87628a9473f67599eb7acff27acb5871018bda2f66fe4844f9a3ec55ac49d77ce7d7bcb0dfad50743a88c21add1d2ea99a201a720f24a0e1dc7ec5bc15a4799c41c046f6b34b8e5cdc77f3ace55ba86d3bc0f0f1e453a9c772afeceee52cb8db8d64b0cc7068f1e94f38e8f40613ff7d5ee5b41cff8d139a35c68ebcaf05d4547a21b517270e49bc1e9ee695fefdf78d6a4dd93bc62503d23e8c4ed6dd34639129efa88392e252b6977b318bf2894ac2a305f29d1ec80a647e8104266580cfb6f7be7026505a60648d9b5f002d6396bbb73c3706834da5dcbe2d5beaae591a8e40c8f2e843ede0b85cdf91d7c004efd73619e0d3cb86eddb1ede9cf78b67c44c8e2447137f8c5637599275c10b9ef5c10bddfeb57fb867a84c406af646e90800ec0f0c6f3a1aa2532edf629065cd3ad8294880b38a5f64da0eacd5263d664f6c22d31c8a916db0a7512d6c057dc67c19f0de5ec9d293a5f35679eaaef173495fd6a6adf20848f64b235bb18b9ad827e378b66a60fe5d3f3c135b1cfe7efa39ddaa6b998a93228a73eb23d1ead60771d1ad19ee690582707bc3339d67b016293fe7e08c8879a65685fcb95229c52dbb6a93cb8e323a5bbde3d0789c0661ba082114046c6f5652201b9c54ee234efe8341d3ffdb905eb2c290679ce0d38d6ff3a2aad63726c0bab2600ab5331e3c8664ff33bd3cf3c648330c252d405055184966f6749df8b924b851c814587231930cdb66d9fd4b2e9c1962a63071a4309f7205b08ed237d378182ed8475d6a7bd80f26463b817df565e87544ff534e45e40b2cee4bbfe7efc88914fd617dc6a6786807845ec03c45d69745a8fe4972e3a9c9df92ab5798f2d298402e6745419a293ddb4babdbe4a035b4f69c87fc6da69ad2ff8501da0fce93024e5280a4afca5a09de3f0c4ed9bfa193854603d6b8f3c3248880d2830e64887a57ef65f08380028ed460482f0a83ebdea587b87addc23bd59b4bac00fa0c3574d86eb030ad8d9182fa202b01dcce924bf08fe191869bb4c1eb0bbc66ac6d8d294843a32298952e508b691426756b571379d7d1157f43faa41b401f894be19cf3dcc65291a3ead4b8b84da664fbe475f8ec4fa3241cca778250e0a3feb764e21468cf77f0bec96e35eab53e600b09b75ffbbef7d9cdeac12afd271807d949eccf6d4a9f4c12fb9e80b1a9f30e94689e98c9c355804be42a80286b37d52aeca6bc922848aea42b0834175156d3b78795e89db88f4f8f9d5f2df21e82aff4dd6f305bd5e0e8169b0692ddc8b0d13df2750c61e5268e9738bcb33be5c1f26fbc999e3d4715756b1e14723d2bfe3050bf203f2f809c8620016d22230a5d082847c115280f0d1bef143fe043acdf5180ac24e0a2b6b4c8f8db3b3df02b8aaa23b2648f3d93ee5dbd17108e1b976e521dfe40a473d6e8c251e566d22b16c0e330c077a5241e372f23a4126e7772aa76d671584e682e64e94d569699e33e6150067692fbe8f406d9015cc235f1d06825c91a1de6be74bccd0d1f8a1bfbe5d625dbeb46087b59a8d6802b573260c5889d6171139f7163a038e88c8f6e006e4ba005890e5eed6ade3d5c0c3ae99d9940b5f3347951c38f43704fc88b0d637c278c90bc30d2a23dd46107cac94fc24aae51e21af3d24fc93d8879398f3fca42a70848684774ed35449476ebdcdc39a1db38590d194f23964c5b4117dcb6126374634cea35622ef0ad3be02ad7ce8254f4938b7ec72f9adcfe4110aaeb2c75e12a82b0532c8b8dc40f33cc08316faf9fb13fba8bbd5a59f0836cb6bbad0bdffa1cc0029a01bd1c1cc094368cbf997e03e633b081eb3ecc59645e3f3a286915fa4737d552fd2f38cf78482b84b5c44fd3170845c3f60c29ce79138db4d2b114bfc609b60c0be375d0c79df3a6189de3f773975345dc1bcb19297ca567ea5f61c3400d32334767100b18c7c8dad91ba4b14a027c20a712218063559d484048304591cc58874983595970326aaa3d12adadb06252e8d181d38955dd0961326729db63f7af45611e27c979757a4f9104b35a414e3a1c783400938b12902f4964266f5bdbd451dc353f2b3a2e4175afd307fdd2431813f9a03e6e3e1e584713860f5ac7ce5049dc9c15691a4f9666427aa2d59a84d813cbd2b5e5501c3baa76d593d3834a260337fe378c5475a9128dc1ca111f6cc0013024de43a49fa7450c686e8ef499576f088c1464b20752168f3e5a6df4e77502a98efe6b0ed9ec7279970a95f0763fadd0e5ef28eb4f4e942f1732e379cd2fdf0e9d8d533866274001f2d6d9d5bf1d7179806ebd1bd2bc3414f25b1d1bfe573b134b645e255b04e2df4153ca0ef5ee3f139be045f55284578510d580bb09ae355b091b2f421e2c04a680e3fcc78e762b435937b6a7628a04860dbdbe85fa489840d71da9f6df2f339d20eec1243c7dacc40adac4f9c3abee946f719a87c3a41a35fb3cdc7b560a2af0d1fdaa89477a5488901887adafe01f50307cc1e2343a261cd3d32da4a85bc30b947707351782ca467c92845f5e33951c4cb650042f5c09028db96cbffde27f645e5599a054d7319d8b6fad35285774c37b19b7db2dd03ca798edc6e0a10152ffbc884afe9333bdfaf5de6a7f46f14d99ecfaecf82c514f018008662fd9aa50b612f6de73ea04ef853e3209e6cdba3e65893e1103055b32ed5215d404b1d3cfefeeb4fc5458ae265ff4cf13110aed942262b9c857a583d7531225d8cc538fb5b4c4f7037ff45f1c50b352796e90a3babe01eabe35718f78eb6d04dbeba9d59a6b5202a62a84a9980e46ec2eca00da51484886ab5fd3454b51ac91ad9ac4164cb7d72ee45ddc46284fbe8b477b58562547ce02ae449f27269e82840fba3e3d96952f464abc5bb77e00d452d3e720d20e586489fd57fd508f16c4415a7db9ddd5151720eeec0b78ce73bb892fa4a0006939df231589434f1b6b85cb745a7f9362572a4fb9b7093eae4ae492ea1d5ead7f15dc66f9bca9a8320fd6a6193f013e4281ea1c0e815c6fb4d355cbc0dac6e34814f423dd137ee2e5fe17189ba1718dabb64e8ccd17ce86a18b080ad287b4324c4d057dbe6b2ccebc7d379e6443247170b47c0e122dea0a8f20927db99c36ae39cc81cf1ad773593c9a1e71dba44d68879ff81985c899657a7f53605f443dd625c65f504c33aa004d89f55b8614c1efef46bd97c12e04784db74f21dc50ce96f3f5015813cc6845718465c8e4567026450481ddd725e9d26cb6020bf238deb1f8dbb3c22575299dd18bede098f97d8877a2f1cdfaf4ecfa056888dc8666f1d3542bbd4ebc113980e2d6fb2f0b9221a227eab6c7df1d7e85f3b207e34f16aec36f6bc2f948f65af0f2e34e20b70c2f2798bf87004a083de78f7fce7d07d00013d3ea9eef866cfc6475432fcee5bc354016a05a29221533773c22e5fc4fa5983c50c8600667bf26f095988ac6ee930392d2092f090c3768ab281b2af902cfad26d1b38c2a87d1454d22ee0192916fe3fb13e9adf062182ef1275d649e4c1628f807e8fe2f5ce95b44158d333f9e1cc32d0bf0207da9e4ac7b139133870338a78f82ac3d44a91658f31f156422e2168215cd5e1d8a9c4af06e06324ba9a47fd15445cf2e80bff338575f83bd6392c3bb10ea6682fdbf57cddf49b597d13e72043e847cb1167685a923afed5abfcbcf11108d455d98afea76b066224f570281ef8e6bd8e543809f129a4c81f20a4d6520b8f4552c8ecbf7260380b85cda7ed5cd32e0e4550e23eeb51a95e05f110c27148e6845df04989c967f73b6f87da66ab1122caf455543f5401d827e2e3482fe8e05dd06446da9b72fb541600602d87566560a7da4f49ce6e9a097a8bc8b36a5ed634a11cc3041162b8da0231e587d171e9a69e7f10ccb5e109c3ba4126c43c57d097340f3db3f5474c118c30d84a4b8b640ba484181d966ae7aaea6efa53b86231aec7d458569e5b1d7b3acb47276edbb2c4b50fa9d6603f29f8e28a8354e7ebc46751943de7355d1b076c4aa5fcea70995f307bed5aa7678cfb74f791945b8350ae47b7bacf93de19eada240132df7f5f65be7de3d19ded7e8281f6776b8e034b5ba4e2cc9d7bd69f0b156f4cf52bf4698a3e020fd19ea976f00a05c158f062ffc83dd37f9b853dd31bfe45e375c96f25e6191fea872e7c3e37a5fd12e6f563b124e1f1d37f2eb1c8e1308815c89ab9a67dcafe903744b157e7a3a9fd28cf2a3514b3b7178cb5822a6b1303891677afc3e16457a8f6124da6635cc3dcbe68f59c29b20d7fac86dd24ebec485f81e1936bef129db03b994cf6eea12f30670d6030df16fcedfa18eb8f982f43758eba14eb09a9819f27612717fa7f050dd55e925dbab7f8fd0b01bf115280c75031c129895880a63184c0129deeaf7f0301dbea2c03e34220e349856b95d4d156f3afc5bfe7930cfd1a888c9d7429805de5d8d78c46a3c504e6140d4596d38e06d7677af8fd5c58483b4273d2107a2bda656f432874faf4275866f575b2c0803cbd3cf2bb2fb46168477faa2b24a2de591e084d5ce320fec9df897da3e5902111ae44ef7319e5eefdf69d21b5d815dc736a88abe29105c3dd3bed276f1f9b7139e52be4fb92469b70df0877f4b20e6c4ab79ba86a46dc58674a7f5199318ac08fdbe0cb575e3fc851580afa2f46b887aabde9dbd19ea8b69bc7c018ceff0b21141558731d9ff20daa5feda7190e4121ca53ad2fe4e939de72166d862e1f4212d9638e57e56217a5986244e5b7d02bab5b379181900bb61d74bea307fa5a9f32e4c478d9a3aa8f7ebeb5860c8a3fa7687098adc8bb9cde26375c2d5532b25b3cace86d417c4ee6b9d7406df71b137ce470d27d104a5eab91d78a54319b62762b55afb4c86f16361123709daf5e308a510812b3e0d1bd0f63656c9b8669d4a2bd74b616637b6c07cb15c4de0432a734a5479cde2008a8f0d7e34524eb78da9970ef29d6388cc061b5a46b29204e9dd64bbd47afcc19b12a3636bd2561be45a988ac6e59b55baf4b1a72013fa4ce74bd5ffc444092aa0c33632ce6d9a987d62af0ca48f8e02c11036fd7637c91ebd5dd3f4e527fa4be02af4d969bc6cf33990fde1e4b4ed47e1c5b3ad2a9bf36271753a21db5c7274890e1a02f4ec3d3a79e790115064f6d38c07bcf4c03a9cef4ec2f86530024478d268e771177061bf013a66d22e5e7bb60e7b6bcb7f6dca2b172cd9c79bfb96c4b6e45d5e9ffe32dd4e5abf9a051af064563c1ae0457b78a2ffb73b3f30b343d63862af9e0c7e07c00eeb43dfc1f4990c29bef61418239f0a83db4515e33a385d25c0ff195c2e5aec60b699d55043785471edfdf5c316514618001c48bf5d912f690fbbc0b0db003f4ec4409d67307d8e88bf5df5e76107d7bc97f649cf06ab84ccff3141b92b8f344a548614a76aba6f5040906d22962f80112a520a23fdd7c22a2faa27c38d5afb0e77a6e3f6be67883abf8039b20f31d7fd18e787b6823051f200e01624bfb80125687561f39a79a1dfd6f640d487f2524f3a53d19bbdd6c0572372b6d12fcd3f0877e1d765e7466569357d1040c5c4d5e86e9cf71c697a9fe243de4c94247551d2310bb164a19c431a11ba97358b551fa394bae2682ce8dc491ad653ba4421b4699520cb15b76845450217b6428f6b7dc47144c3104e00dbef684c04e3930eb9893f615f53d48ec7b4e7e1b5e69ff196e69fb937ef4750aa5feca0f721780e4f8d33280f34e24503b724718eb9b1ee17147b8d638743996d70db934c526f3346df07e551eb410c774d80b64a7834e02a045b434663ad4a52e09837b200994c5a8244c5e05b994414bf259952d6162d3be106e1c08a4c3b212323e56106d3b10687ffb6bf9fe4d343e4bdc3b1572e9133e05f55513fb82cfcabc5762e8baf221c490f956da9441b9e30f452bd6a0c424e7e6bf31676a570f9f94966e8415b1b189dc82b9eb928150f80832df756ecda69c09e63573cf456f66be5ae2f7c9680a09c4cbbc078a12513e890828c3d90bb0e5bd98f5952df7d1b1fbbed7243408b68527e0e52994607419293faa5eee5a1f66cefc46db7bf66556f3f16e78b0040c3f2c30eba73ac7580efd1dc14c60c530688fab73a2dd59083cadef9859bf1f2617bb893c5e87f56093203bcf338c55f81db77ddbbde284e4d34e9c336c950e999853d3ad867514e4680d17672e4c7c2d65ad6222eb17f6016b6f70d5848409ec41c41b8065eb46963ef1a75f783d4e835422750db6d41052e8fbd9b465236994f45bd8cab36c6ec388c213223a3880dcb04038641c494d8f9dea76323f079b7fd330e92c1e9d3480e69de9d01442cecdab93785c525d7aba81b5b09d7097dea8dbb7729c5da363061da08ef6d7852af1d7cc8969183853bda0171d5187f4b766796e9c87768048652964258ad01a2bc9cc8088275b6314a95e39bec91318ff2b0c19e476d5123bb6bc9c39f7d1571c0490556e850fc013227c9c9c3cae78d327fd36935bc88677057d880e0904bd0b1e844802ddd77d8bdcfb0802945a2eacc8e14ea3132dab6a414aae22d32f622796b5504058d9e6c53df7c354f22b9cb89d5fa196f899e976349874c27c25ab7d7bbb35a2a036417ca295c6d1a0b009979e8c101ae84bb9606e06e193dc316cb2de8cafd87dc4dec293239c6349aad4dfedecf93040f3630470b479ca7c035f609e1221d77a71a05947f68bc1fefc66ef08140a567345e473b8679bb745b2b0009196ccacb4bfa270223bcd6be42da56e7c5fe00c7fa53a80bae2abf915ef24afcc1358d01c72fdce81d114484f333b16d60957b3d6ed8ecda31e7aa16cc913bec67ee2877612d18ceffcd0dd180a0e2d6caec0d9e12a044890e9e5d35798671ffdb2e90abd4df6aec10bb34da2068be8b7e1bafd9d8f50caf1742eb6690d947193b088da0ccee1e26b6fd7fff159286d9160f020528c55ce27b2ad7de367b091e03eb291c82b44609816719f7ac670c00643aeb5d346f347fc6be6320871310d544ec2015247a2a7756cb831d8cde4e11c70ddd1041f99dc83cdeaa1200f826a3f8f6415877c6269cf9fccd422f963952d3824596e6172f6d19ed38e20fc3626aeb7cd0f105af33cb5497dd8ca88e18e7e85e67d8248aa254abf9485b98ac1f939c1a1f77b58af72c9ad3103de5e53f159676a4326a8ca5cf0cc3aafba1dbef327d9c192c0d6277cf76dc9ada14aeeb0c6b4c74a973249f182697b20bd63191bd6ea6b65be45ed042fba1c40fb120e0e86d4b7167e12569bfc389fa64bbd51bc2afc661aedfacc4f7cbe46b1d8912d9210567ccbee57b07993567bf9c6c128e2908b368093136d686c5d99bfb0bb072d348b2b649f42909f6d204cb6ec6f3cfc85bb53fb6e56b83768a6a5d46aece43e6a180320d430450669f397cfe5867e4fee988eadcc3a85d0b1baeef5cf44adef9dfb32a69cd025bb9ee4ec9c4c79cd471a99a7e1c3c6545bf1ba9417d2a958060525a9d05533346207c8f7b5b5e4175621c7a7ca144bcf6e17d346835af510c973742dd256b27fa1047a39cd4e7a11904e6f8977eaf7d752132c7e3fe7b5e5bdf902cf53ab4dc127c1578867546b9f1ab583748161abd82258c386c22fb3d582011d42e93ecf8341e0f7ff5982cdb5467b74dbd5d3f0b6cf954b8772078a8b37b8e93d5433e9fc26942c43ca4969a306a380c054c011cf02fa689cf0a97087cfd10b2fc9fada72f32c8d115fd33a3942ade3f2386718548abdc562ffdbdf867aab350e662c9169dcef928003430360fd2b6da980ca2619f7cc15391aad73ae1cccafae7336c55dd79181d06f207359d0a91c75a6311806b252dc9c3d9fca85d0733161a9c8886c34dea29dafcb43f9f84ffdbbcd7a9b392810763b5b662524e9e3d90fdf23a62cb7192d9c74e3eb1ad947fb9c0545392064ef7bd7711666a90a5403b0ac614039e41859999fbb3f530b7aaf28bd0dcd3719b67a3b99d3d315519f793abeba2bbef4802edf2c8e024baafc41037bc9b0ee5797e91394b4ee1cf022cd10c5708fff576961f9331d24a22318b23ab04d2757a766e942be66629bc5689edf572a375a57be432e76db1
  
    
      
      
        请输入正确密码后查看
      
    
  

]]></content>
      <categories>
        <category>便笺</category>
      </categories>
      <tags>
        <tag>频繁查阅</tag>
      </tags>
  </entry>
  <entry>
    <title>内部类*</title>
    <url>/2021/07/23/%E5%86%85%E9%83%A8%E7%B1%BB/</url>
    <content><![CDATA[成员内部类
内部类可以使用public private protected default static修饰
java源文件中仅包含一个外部类和一个内部类时，编译会生成两个class文件:外部类.class、外部类$内部类.class
外部类的静态方法不能访问非静态内部类；静态内部类无法访问外部类非静态成员


非静态内部类&ensp;&ensp;无static修饰符修饰的非静态内部类，只能包含非静态成员
public class 外部类 &#123;    public 外部类()&#123;//        外部类的构造器，在构造器中调用内部类的methods方法        内部类 内部类对象 = new 内部类();        内部类对象.methods();    &#125;    public static void main(String[] args) &#123;//        外部类的main方法    &#125;//    非静态内部类内无法创建静态成员    public class 内部类&#123;        public void methods()&#123;//            非静态内部类的实例方法        &#125;        public 内部类()&#123;//            内部类的构造器        &#125;    &#125;&#125;
&ensp;&ensp;当非静态内部类的方法中访问某个变量时，系统优先寻找局部变量，不存在则寻找内部类中的成员变量，依然不存在继续寻找类中的成员变量&ensp;&ensp;如果内部类的局部变量、内部类成员变量和成员变量同名，可以通过this、外部类类名.this来区分内部类成员变量和外部类成员变量public class 外部类&#123;    private String prop = &quot;成员变量&quot;;    public class 内部类&#123;        private String prop = &quot;内部类成员变量&quot;;        public void test()&#123;            String prop = &quot;局部变量&quot;;            System.out,println(prop); // 局部变量            System.out,println(this.prop); // 内部类成员变量            System.out,println(外部类.this.prop); // 外部类成员变量        &#125;    &#125;&#125;&ensp;&ensp;在外部类内使用非静态内部类的实例方法public class 外部类 &#123;    public static void main(String[] args) &#123;//        外部类的main方法    &#125;		public void test()&#123;	    内部类 内部类对象 = new 内部类(); // 通过对象调用		内部类对象.methods();	&#125;    public class 内部类&#123;        public void methods()&#123;		        &#125;    &#125;&#125;&ensp;&ensp;在外部类外使用非静态内部类的实例方法public class 外部类 &#123;    public static void main(String[] args) &#123;    &#125;    public class 内部类&#123;        public void methods()&#123;            System.out.println(&quot;调用了&quot;);        &#125;    &#125;&#125;class 调用外部类的内部类&#123;    public static void main(String[] args) &#123;//        外部类名.内部类名 变量名 = new 外部类名().new 内部类名();        外部类.内部类 内部类对象 = new 外部类().new 内部类();         内部类对象.methods();    &#125;&#125;
静态内部类&ensp;&ensp;用static修饰的类叫内部类；内部类可以包含静态和非静态成员&ensp;&ensp;因为可以包含静态成员，所以静态内部类可以执行public class 外部类2 &#123;    private String prop = &quot;成员变量&quot;;    public 外部类2()&#123;//        外部类的构造器    &#125;    public static void main(String[] args) &#123;        内部类.main(new String[]&#123;&#125;); // 调用静态内部类的静态方法        new 内部类().test(); // 调用静态内部类的实例方法    &#125;    public static class 内部类&#123;        public static void mian(String[] args)&#123;//            内部类的静态方法        &#125;        public void test()&#123;//            内部类的实例方法        &#125;        public 内部类()&#123;//            内部类的构造器        &#125;    &#125;&#125;
&ensp;&ensp;在外部类内使用静态内部类中的方法
public class 外部类2 &#123;    public static void main(String[] args) &#123;        内部类.main(new String[]&#123;&#125;); // 调用静态内部类的静态方法        new 内部类().test(); // 调用静态内部类的实例方法    &#125;    public static class 内部类&#123;        public static void main(String[] args)&#123;//            内部类的静态方法            System.out.println(&quot;静态方法&quot;);        &#125;        public void test()&#123;//            内部类的实例方法            System.out.println(&quot;实例方法&quot;);        &#125;    &#125;&#125;
&ensp;&ensp;在外部类外使用静态内部类中的方法
public class 外部类2 &#123;    public static void main(String[] args) &#123;    &#125;    public static class 内部类&#123;        public static void main(String[] args)&#123;//            内部类的静态方法            System.out.println(&quot;静态方法&quot;);        &#125;        public void test()&#123;//            内部类的实例方法            System.out.println(&quot;实例方法&quot;);        &#125;    &#125;&#125;class 外部类外&#123;    public static void main(String[] args) &#123;        外部类2.内部类.main(new String[]&#123;&#125;); // 在外部类外调用静态内部类的静态方法        new 外部类2.内部类().test(); // 在外部类外调用静态内部类的实例方法    &#125;&#125;
局部内部类
局部内部类不能使用访问控制符和修饰符
所有的局部内部类成员都不能使用访问控制修饰符
java源文件中仅包含一个外部类和一个局部内部类时，编译会生成两个class文件:外部类.class、外部类$1内部类.class

public class public_test &#123;    public static void main(String[] args) &#123;        class 局部内部类 &#123;            public void main() &#123;                System.out.println(&quot;main&quot;);            &#125;        &#125;        局部内部类 局部内部类对象 = new 局部内部类();        局部内部类对象.main();    &#125;&#125;
&ensp;&ensp;局部内部类，食之无味，弃之可惜，就是个垃圾，没吊用
匿名内部类
匿名内部类不能是抽象类
匿名内部类必须继承一个父类，或实现一个接口，但最多只能继承或实现一个
匿名内部类不能定义构造器，但可以定义初始化块，通过实例初始化块完成构造器的任务

public class public_test &#123;    public void test(接口 j)&#123;        System.out.println(j.getName());    &#125;    public static void main(String[] args) &#123;        public_test pt = new public_test();//        继承了“接口”        pt.test(new 接口()&#123;            @Override // 重写接口内的getName方法            public String getName()&#123;                return &quot;测试&quot;;            &#125;        &#125;);    &#125;&#125;interface 接口&#123;    String getName();&#125;
可改写为
public class public_test &#123;    public void test(接口 j)&#123;        System.out.println(j.getName());    &#125;    public static void main(String[] args) &#123;        public_test pt = new public_test();        class 类 implements 接口&#123;            @Override            public String getName()&#123;                return &quot;测试&quot;;            &#125;        &#125;        pt.test(new 类());    &#125;&#125;interface 接口&#123;    String getName();&#125;
还可改写为
public class public_test &#123;    public void test(抽象类 j)&#123;        System.out.println(j.getName());    &#125;    public static void main(String[] args) &#123;        public_test pt = new public_test();        pt.test(new 抽象类()&#123;            @Override            public String getName()&#123;                return &quot;测试&quot;;            &#125;        &#125;);    &#125;&#125;abstract class 抽象类&#123;    public abstract String getName();&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>函数指针</title>
    <url>/2022/12/04/%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[函数的指针&ensp;&ensp;函数指针的声明方式函数返回值类型(*指针变量名)(函数形参);
&ensp;&ensp;函数指针的声明及调用，如下代码将会输出num1 + num2 = 3int main() &#123;    // 声明函数指针    void(*pointer)(int,int);    // 取函数储存地址，赋值给函数指针    pointer = &amp;plus;    // 调用指针指向的函数    (*pointer)(1,2);    return 0;&#125;void plus(int num1, int num2) &#123;    printf(&quot;num1 + num2 = %d\n&quot;, num1+num2);&#125;
&ensp;&ensp;函数指针可以被重新赋值，但是需要注意函数的形参，如下代码将会输出num1 - num2 = -1int main() &#123;    // 声明函数指针    void(*pointer)(int,int);    // 取函数储存地址，赋值给函数指针    pointer = &amp;plus;    // 重新对函数指针赋值，    // sub函数与plus函数形参是一样的    pointer = &amp;sub;    // 调用指针指向的函数    (*pointer)(1,2);    return 0;&#125;void plus(int num1, int num2) &#123;    printf(&quot;num1 + num2 = %d\n&quot;, num1+num2);&#125;void sub(int num1, int num2) &#123;    printf(&quot;num1 - num2 = %d\n&quot;, num1-num2);&#125;
&ensp;&ensp;C语言规定，函数名本身就是指向函数的指针，因此不添加取地址符号&amp;也可取函数指针，如下int main() &#123;    // 取函数 test1 的地址值，赋值给函数指针    int(*pointer)(int) = test1;    // 调用 test1 函数    int result =  (*pointer)(10);    // 输出返回值    printf(&quot;result = %d\n&quot;, result);    return 0;&#125;int test1(int num) &#123;    return num * num;&#125;
回调函数&ensp;&ensp;跟java里的回调方法不一样，所谓回调就是把函数指针作为实参传递给被调函数，在被调函数中调用形参中的函数指针main() &#123;    // 将函数指针作为可变参数传入 test    test(2, plus, sub);    return 0;&#125;/** * @param count 参数个数 * @param ...   可变参数 */void test(int count, ...) &#123;    // 存储可变参数    va_list vaList;    // 初始化 va_list    va_start(vaList, count);    // 从参数列表中取两个函数指针    int(*plus_pointer)(int,int) = va_arg(vaList, int(*)(int,int));    int(*sub_pointer)(int,int) = va_arg(vaList, int(*)(int,int));    // 调用函数指针    int plus_result = (*plus_pointer)(1,2);    int sub_result = (*sub_pointer)(1,2);    // 清理 va_list    printf(&quot;plus_result = %d\n&quot;, plus_result);    printf(&quot;sub_result = %d\n&quot;, sub_result);    va_end(vaList);&#125;int plus(int num1, int num2) &#123;    return num1 + num2;&#125;int sub(int num1, int num2) &#123;    return num1 - num2;&#125;
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C语言基础</tag>
      </tags>
  </entry>
  <entry>
    <title>动态内存分配</title>
    <url>/2022/12/07/%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/</url>
    <content><![CDATA[&ensp;&ensp;调用动态内存分配的函数前需要先引入malloc.h库#include &lt;malloc.h&gt;
malloc&ensp;&ensp;全称是memory allocation，malloc函数可以在动态储存区的堆内存中分配一块指定大小的连续内存空间，调用该函数时传入需要分配的字节数，如果分配成功将返回一个指向新分配内存的指针，如果分配失败返回NULLvoid* malloc(size_t size);
&ensp;&ensp;如下代码在堆空间中分配了一块内存，并通过内存指针给该内存空间赋值；malloc在某些情况下会发生内存分配失败的情况，如内存大小不足、内存碎片化严重，所以通过int_pointer != NULL判断是否分配成功；在动态分配的内存使用完毕后，通过free函数释放内存，动态分配的内存如果不释放会发生内存泄漏，释放后再把指向被释放的内存地址的指针置空，避免该指针再次被程序调用，出现悬空指针问题// 动态分配内存一个 int 类型变量大小的内存空间// 然后将 void* 类型指针强制转换为 int* 型int* int_pointer = (int*)malloc(sizeof(int));// 判断内存空间是否分配成功if (int_pointer != NULL) &#123;    // 给指针指向的内存空间赋值    (*int_pointer) = 10;    // 将会输出 10    printf(&quot;value = %d\n&quot;, (*int_pointer));    // 释放动态分配的内存，避免内存泄露    free(int_pointer);    // 置空指针    int_pointer = NULL;&#125; else &#123;    printf(&quot;内存空间分配失败&quot;);&#125;
&ensp;&ensp;通过malloc在堆空间中创建了一个int类型数组，该程序将输出连续的5个堆空间中的内存地址#define ARR_LENGTH 5// 动态分配内存，并强制转换为 int 类型指针int* arr_int_pointer = (int*)malloc(ARR_LENGTH * sizeof(int));// 判断内存是否分配成功if (arr_int_pointer != NULL) &#123;    // 将指针作为 int 类型数组，输出每个元素的内存地址    for (int i = 0; i &lt; ARR_LENGTH; i++) &#123;        printf(&quot;*arr_int_pointer[%d] = %p\n&quot;, i, &amp;arr_int_pointer[i]);    &#125;    // 释放内存空间    free(arr_int_pointer);    // 置空指针    arr_int_pointer = NULL;&#125; else &#123;    printf(&quot;内存分配失败&quot;);&#125;
&ensp;&ensp;通过malloc同样也能创建一个结构体指针// 声明结构体struct Data&#123;    int int_data;    float float_data;&#125;;// 动态分配内存，并强制转换为结构体类型指针struct Data* data_pointer = (struct Data*)malloc(sizeof(struct Data));// 判断内存是否分配成功if (data_pointer != NULL) &#123;    // 通过结构体指针修改结构体成员的值    data_pointer-&gt;int_data = 10;    data_pointer-&gt;float_data = 22.2f;    // 输出结构体成员的值    printf(&quot;int_data = %d, float_data = %.2f\n&quot;, data_pointer-&gt;int_data, data_pointer-&gt;float_data);    // 释放内存空间    free(data_pointer);    // 置空指针    data_pointer = NULL;&#125; else &#123;    printf(&quot;内存分配失败&quot;);&#125;
calloc&ensp;&ensp;全称是contiguous alloc，calloc函数可以在动态储存区的堆内存中分配一块连续的内存空间，空间的大小由函数的两个参数决定，分别可以理解为：代表元素数量和代表单个元素占用内存大小，调用该函数时传入这两个参数，如果分配成功将返回一个指向新分配内存的指针，并将该内存空间的每个字节初始化为零，如果分配失败返回NULLvoid *calloc(size_t num_elements, size_t element_size);
&ensp;&ensp;其实这个函数满操蛋的，因为完全可以用malloc来替代，如下，没有什么本质上的区别，只不过calloc分配的内存空间把每个字节都初始化为零int* arr_int_pointer1 = (int*)calloc(ARR_LENGTH, sizeof(int));int* arr_int_pointer2 = (int*)malloc(ARR_LENGTH * sizeof(int));
realloc&ensp;&ensp;用于更改由malloc或calloc分配的内存块的大小，该函数需要两个参数，其中第一个代表需要修改的内存块的指针，第二个代表新的内存块大小；如果重新分配成功，则释放原内存块，并返回一个指向重新分配内存块的指针，重新分配失败则返回NULL，原内存块仍然有效。void *realloc(void *ptr, size_t new_size);
&ensp;&ensp;如果新的内存块大小，小于或等于原内存块的大小，那么原内存块可能被截断或保持不变，返回的指针可能与原地址相同，也可能是一个新的地址；如果新内存块的大小，大于原内存块的大小，那么原内存块的内容可能会被复制到新内存块中，并返回新的内存块的指针#define ARR_LENGTH 5// 原内存块大小 20int* pointer1 = (int*)malloc(ARR_LENGTH * sizeof(int));// 新内存块大小 20int* pointer2 = (int*)realloc(pointer1, ARR_LENGTH * sizeof(int));// pointer1 和 pointer2 有可能相同printf(&quot;pointer1 = %p, pointer2 = %p\n&quot;, pointer1, pointer2);
#define ARR_LENGTH 5// 原内存块大小 20int* pointer1 = (int*)malloc(ARR_LENGTH * sizeof(int));// 新内存块大小 24int* pointer2 = (int*)realloc(pointer1, (ARR_LENGTH + 1) * sizeof(int));// pointer1 和 pointer2 不相同printf(&quot;pointer1 = %p, pointer2 = %p\n&quot;, pointer1, pointer2);
&ensp;&ensp;如果第一个参数指定的指针是NULL，那么realloc将分配一个新的内存块，类似于malloc#define ARR_LENGTH 5// 声明一个空指针int* null_pointer = NULL;// 将空指针传入 realloc 将返回一个新的指定大小的内存块int* new_arr_pointer = realloc(null_pointer, ARR_LENGTH * sizeof(int));for (int i = 0; i &lt; ARR_LENGTH; ++i) &#123;    new_arr_pointer[i] = i;    printf(&quot;pointer = %p\n&quot;, &amp;new_arr_pointer[i]);&#125;
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C语言基础</tag>
      </tags>
  </entry>
  <entry>
    <title>单例模式</title>
    <url>/2021/07/20/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[解决某些场景下只需要创建该类的一个实例
class test&#123;//    定义类成员变量    private static test obj;	//    隐藏构造器，避免实例被调用    private test()&#123; &#125;	//   暴露一个static方法用于创建实例    public static test setName()&#123;//        判断是否已经创建过了实例        if (obj == null)&#123;            test obj = new test();        &#125;//        将实例返回        return obj;    &#125;&#125;

调用时
public class 单例模式 &#123;    public static void main(String[] args)&#123;//        不管怎么创建都是错的//        test a = new test();        test a = test.setName();        test b = test.setName();        System.out.println(a == b);//        若返回true，说明两个实例引用同一个地址    &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>可变参数</title>
    <url>/2022/12/04/%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0/</url>
    <content><![CDATA[&ensp;&ensp;可变参数是指参数数量是可变的函数，调用该函数时可以传入任意多个实参；创建接收可变参数的函数时，强制要求至少有一个形参在形参列表第一个，可以是任意类型，形参列表最后一个必须是...，代码如下/** * @param count 代表可变参数的个数 * @param ...   可变参数 */void func(int count, ...) &#123;&#125;
&ensp;&ensp;使用可变参数，需要先引入stdarg.h头文件，可变参数有如下常用的变量类型和方法




Variable
Description




va_list
用于存储可变参数的信息，是一个指向可变参数列表的指针，可以按顺序获取参数的值；相当于可变参数的容器








Function
Description




va_start(va_list, int)
用于初始化va_list，使其指向可变参数列表的开始位置，该函数需要两个参数：可变参数容器，可变参数个数


va_arg(va_list, type)
用于获取va_list指向的当前参数的值，该函数需要两个参数：可变参数的容器，可变参数的变量类型；该函数有返回值，返回值的类型由传入的可变参数的变量类型决定；每调用一次，va_list的指针移动到下一个参数


va_end(va_list)
用于清理va_list，确保在函数退出时没有未处理的参数


va_copy(va_list dest, va_list src)
该函数接受两个参数，dest是要复制到的va_list，src是要复制的源va_list。调用va_copy后，dest将指向与src相同的参数列表，并且可以独立地访问和处理这个复制后的参数列表




&ensp;&ensp;具体使用时，先申明一个va_list变量，用于存储可变参数的信息void func(int count, ...) &#123;    // 用于储存可变参数的信息    va_list vaList;&#125;
&ensp;&ensp;初始化va_list，传入va_list和代表可变参数个数的变量void func(int count, ...) &#123;    // 用于储存可变参数的信息    va_list vaList;    // 初始化 va_list    va_start(vaList, count);&#125;
&ensp;&ensp;取可变参数的值，va_arg每调用一次，va_list便指向下一个参数，这里使用for将每个参数取数并输出void func(int count, ...) &#123;    // 用于储存可变参数的信息    va_list vaList;    // 初始化 va_list    va_start(vaList, count);    for (int i = 0; i &lt; count; ++i) &#123;        // 取参数        int num = va_arg(vaList, int);        // 输出参数        printf(&quot;num = %d\n&quot;, num);    &#125;&#125;
&ensp;&ensp;清理va_list，确保在函数退出时没有未处理的参数void func(int count, ...) &#123;    // 用于储存可变参数的信息    va_list vaList;    // 初始化 va_list    va_start(vaList, count);    for (int i = 0; i &lt; count; ++i) &#123;        // 取参数        int num = va_arg(vaList, int);        // 输出参数        printf(&quot;num = %d\n&quot;, num);    &#125;    // 清理 va_list    va_end(vaList);&#125;
&ensp;&ensp;调用func// 调用 func ，并传入相应参数func(5,1,2,3,4,5);// 将输出// num = 1// num = 2// num = 3// num = 4// num = 5
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C语言基础</tag>
      </tags>
  </entry>
  <entry>
    <title>向Android外置TF卡中写入数据</title>
    <url>/2022/10/26/%E5%90%91Android%E5%A4%96%E7%BD%AETF%E5%8D%A1%E4%B8%AD%E5%86%99%E5%85%A5%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[判断是否存在外置TF卡&ensp;&ensp;文中为了防止手机机身储存与外接储存卡的名称混淆，将手机机身储存称为：内置SD卡；将外接储存卡称为：外置TF卡
获取设备的所有存储卷路径&ensp;&ensp;使用反射的方式获取到getVolumePaths()方法，该方法可以获取设备上所有可用存储卷的路径，获取之后将所有存储卷的路径放置在数组中public static String[] getAllExternal(Context context) &#123;    StorageManager storageManager = (StorageManager) context.getSystemService(Context.STORAGE_SERVICE);    try &#123;        Method getVolumePaths = storageManager.getClass().getMethod(&quot;getVolumePaths&quot;);        return (String[]) getVolumePaths.invoke(storageManager);    &#125; catch (Exception e) &#123;        e.printStackTrace();    &#125;    return null;&#125;
获取外置TF卡储存路径&ensp;&ensp;就一般情况而言，如果打包后的apk运行在手机上，那么代码数组中第一个储存卷路径是内置SD卡路径，第二个储存卷路径是外置TF卡路径(如果有)&ensp;&ensp;当然也存在特殊情况，例如手机没有接入外置TF卡，但是通过数据接口接入了U盘，那么第二个储存卷路径就是该U盘的路径public static String getTFCardPath(Context context) &#123;    // 获取设备的所有存储卷路径    String[] allExternal = getAllExternal(context);    // 所有储存卷路径的个数至少要存在两个    if (allExternal != null &amp;&amp; allExternal.length &gt;= 2) &#123;        return allExternal[1];    &#125;    return null;&#125;
获取外置TF卡挂载状态&ensp;&ensp;方法中使用反射的方式获取到getVolumeState()方法，该方法用于获取指定存储卷的状态，储存卷的状态包括以下几种

mounted：已挂载
unmounted：已卸载
mounted_ro：以只读方式挂载public static String getTFCardState(Context context) &#123;    // ### 获取外置TF卡储存路径    String tfCardPath = getTFCardPath(context);    if (tfCardPath != null) &#123;        StorageManager storageManager = (StorageManager) context.getSystemService(Context.STORAGE_SERVICE);        try &#123;            Method getVolumeState = storageManager.getClass().getMethod(&quot;getVolumeState&quot;, String.class);            return (String) getVolumeState.invoke(storageManager, tfCardPath);        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;    return null;&#125;


使用方式&ensp;&ensp;例如获取外置TF卡可用储存空间public static long getTFAvailableSize(Context context) &#123;    String tfCardState = getTFCardState(context);    // 外置TF卡是否已经挂载    if (tfCardState != null &amp;&amp; tfCardState.equals(Environment.MEDIA_MOUNTED))&#123;        StatFs statFs = new StatFs(getTFCardPath(context));        int blockSize = statFs.getBlockSize();        int availableBlocks = statFs.getAvailableBlocks();        return (long) blockSize * availableBlocks;    &#125;    return -1;&#125;
读写外置TF卡文件&ensp;&ensp;在Android 4.4之后的版本中，读写外置TF卡数据要通过SAF框架，使用DocumentFile来对文件或文件夹进行操作。&ensp;&ensp;下文中操作外置TF卡中的文件基于一个封装的DocumentFileUtils类，DocumentFileUtils工具类封装的可以查看封装DocumentFile
请求权限&ensp;&ensp;创建工具类对象需要传入一个文件目录，一定要将外置TF卡根目录传入，因为传入的目录就是申请权限的目录，一个目录拥有权限后，该目录下的所有文件及文件夹都将拥有读写权限public void requestPermission(Activity activity) &#123;    // 获取外置TF卡路径    String tfCardPath = getTFCardPath(activity);    // 创建DocumentFileUtils对象，一定要传入外置TF卡根路径    DocumentFileUtils documentFileUtils = new DocumentFileUtils(activity, tfCardPath);    // 申请权限    documentFileUtils.requestPermission(activity, 10001);&#125;
&ensp;&ensp;跳转到文件夹权限并授权后，在回调阿onActivityResult()方法中判断申请结果，如果权限申请成功需要保存权限@Overrideprotected void onActivityResult(int requestCode, int resultCode, Intent data) &#123;    super.onActivityResult(requestCode, resultCode, data);    if (requestCode == 10001 &amp;&amp; documentFileUtils != null) &#123;        // 保存权限        documentFileUtils.savePermission(requestCode, data);    &#125;&#125;
获取文件夹或文件对象&ensp;&ensp;获取文件的DocumentFile对象，如果该文件不存在，将会自动创建，创建后的新文件大小为0DocumentFile documentFile = documentFileUtils.getDocumentFile(filePath, true);
&ensp;&ensp;获取文件夹的DocumentFile对象，如果文件夹不存在，将会自动创建DocumentFile documentFile = documentFileUtils.getDocumentFile(filePath, false);
更多使用方式请参照：谷歌官方文档：https://developer.android.google.cn/reference/androidx/documentfile/provider/DocumentFile?hl=en封装DocumentFile：https://blog.xxin.xyz/2022/10/23/%E5%B0%81%E8%A3%85DocumentFile/
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android开发手记</tag>
      </tags>
  </entry>
  <entry>
    <title>在Android项目中使用阿里云maven</title>
    <url>/2021/10/30/%E5%9C%A8Android%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8%E9%98%BF%E9%87%8C%E4%BA%91maven/</url>
    <content><![CDATA[阿里云云效maven地址
官方的gradle配置指南在 build.gradle 文件中加入以下代码:allprojects &#123;  repositories &#123;    maven &#123;      url &#x27;https://maven.aliyun.com/repository/public/&#x27;    &#125;    mavenLocal()    mavenCentral()  &#125;&#125;
如果想使用其它代理仓，以使用spring仓为例，代码如下:allProjects &#123;  repositories &#123;    maven &#123;      url &#x27;https://maven.aliyun.com/repository/public/&#x27;    &#125;    maven &#123;      url &#x27;https://maven.aliyun.com/repository/spring/&#x27;    &#125;    mavenLocal()    mavenCentral()  &#125;&#125;
加入你要引用的文件信息:dependencies &#123;  compile &#x27;[GROUP_ID]:[ARTIFACT_ID]:[VERSION]&#x27;&#125;
执行命令gradle dependencies 或 ./gradlew dependencies 安装依赖
手动配置两个build.gradle文件的区别build.gradle(Project)：用来配置整个工程的build.gradle(app)：用来配置app的
引入仓库&ensp;&ensp;&ensp;&ensp;根据官方配置说明，我们在工程build.gradle文件指定位置添加代码，然后sync Now
添加依赖查找依赖包&ensp;&ensp;&ensp;&ensp;在阿里云maven仓库服务→文件搜索→gav模式，可以搜索我们想添加的依赖包，三个搜索框和引入依赖的代码呈对应关系
&ensp;&ensp;&ensp;&ensp;以okhttp4.9.0为例，在搜索框中输入，com.squareup.okhttp3、okhttp、4.9.0，可以看到
按照格式写入&ensp;&ensp;&ensp;&ensp;按照官方给定的格式，在App的build.gradle文件的dependencies中加入//  官方的格式//  compile &#x27;[GROUP_ID]:[ARTIFACT_ID]:[VERSION]&#x27;dependencies &#123;    implementation &#x27;com.squareup.okhttp3:okhttp:4.9.0&#x27;&#125;
implementation与compile的区别&ensp;&ensp;&ensp;&ensp;至于我们为什么使用implementation而不是compile引入

implementation: 对于使用了该命令编译的依赖，对该项目有依赖的项目将无法访问到使用该命令编译的依赖中的任何程序，也就是将该依赖隐藏在内部，而不对外部公开。
api: 完全等同于compile指令。
compile: 这种是我们最常用的方式，使用该方式依赖的库将会参与编译和打包。
testCompile: 只在单元测试代码的编译以及最终打包测试apk时有效。
debugCompile: 只在debug模式的编译和最终的debug apk打包时有效。
releaseCompile: 仅仅针对Release模式的编译和最终的Release apk打包，比如我们使用的leakcanary。

使用添加的依赖&ensp;&ensp;&ensp;&ensp;编写几行代码测试一下okhttpOkHttpClient okHttpClient = new OkHttpClient();Request request = new Request.Builder().url(&quot;https://www.baidu.com&quot;).build();Call call = okHttpClient.newCall(request);call.enqueue(new Callback() &#123;    @Override    public void onFailure(@NotNull Call call, @NotNull IOException e) &#123;    &#125;    @Override    public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException &#123;        Log.d(&quot;TAG&quot;, &quot;onResponse: &quot; + response.body().string());    &#125;&#125;);
&ensp;&ensp;&ensp;&ensp;添加网络权限&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt;
&ensp;&ensp;&ensp;&ensp;看下log，成功
常用的第三方库implementation &#x27;com.squareup.okhttp3:okhttp:4.9.0&#x27;//okhttpimplementation &#x27;com.github.bumptech.glide:glide:4.12.0&#x27;//glide库annotationProcessor &#x27;com.github.bumptech.glide:compiler:4.12.0&#x27;//glide注解库implementation &#x27;com.google.code.gson:gson:2.8.4&#x27;//Gsonimplementation &#x27;com.youth.banner:banner:2.1.0&#x27;//bannerimplementation &#x27;androidx.recyclerview:recyclerview:1.2.1&#x27;//RecyclerViewimplementation &#x27;androidx.viewpager2:viewpager2:1.1.0-beta01&#x27;//ViewPager2
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android开发手记</tag>
      </tags>
  </entry>
  <entry>
    <title>在服务器中搭建hexo博客</title>
    <url>/2021/07/15/%E5%9C%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%AD%E6%90%AD%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[优点：相对于github或gitee，速度快，自定义程度高
缺点：自己花钱
一、环境安装1.站点创建在宝塔中创建新的站点，该站点即为博客地址
2.nginx配置从宝塔的软件商店即可快捷安装nginx环境
3.git工具下载通过ssh连接服务器，并下载安装git工具yum -y install git #yum安装git相关命令git --version #查看git安装版本yum remove git #卸载git工具
二、git仓库搭建和之前github的仓库一样，服务器也需要创建一个仓库用来实现静态文件储存
1.创建用户在服务器端创建一个新用户gitadduser git #创建git用户chmod 740 /etc/sudoers #改变sudoers文件的权限为文件所有者可写vim /etc/sudoers #读取i #表示insert，从仅读取切换到编辑(插入)#在root ALL=(ALL) ALL 下方添加一行git ALL=(ALL) ALL:wq! #强制保存退出 :q! 强制不保存退出chmod 400 /etc/sudoers #改变sudoers文件的权限为文件所有者可读
2.给git用户添加ssh密钥建立主机与服务器连接，添连接后不需要密码也能登录服务器，方便我们日后的博客文件上传
#本地打开Git Bash并进入到C:\Users\admin\.ssh目录ssh-keygen -t rsa -C &quot;blog.xxin.xyz&quot;# -t 指定密钥类型，默认是 rsa ，可以省略# -C 用于识别这个密钥的注释，可以输入任何内容# -f 指定密钥文件存储文件名，默认id\_rsa#服务器端打开终端命令行su git #切换到git用户mkdir -p ~/.ssh #在git用户(/home/git)下创建.ssh文件夹，用于储存ssh密钥文件touch ~/.ssh/authorized\_keys #创建authorized_keys文件chmod 600 ~/.ssh/authorized\_keys  #为authorized_keys文件赋予文件所有者可读可写的权限chmod 700 ~/.ssh  #为.ssh文件夹赋予文件夹所有者可读可写可执行的权限#复制C:\Users\admin\.ssh目录下，公匙id_rsa.pub内容到服务器/home/git/.ssh/authorized_keys，关闭终端#使用ssh git@server重新登录服务器，测试是否能不要密码登录到git用户
3.创建git仓库sudo mkdir /home/git/repos #在git用户目录下创建repos文件夹作为仓库位置cd /home/git/repossudo git init --bare blog.git #初始化一个名叫blog.git的仓库
4.配置钩子实现自动部署找到 /home/git/repos/taiblog.git/hooks/post-update.sample 改名post-update，内容改为#!/bin/bashgit --work-tree=/www/wwwroot/blog.xxin.xyz --git-dir=/home/git/repos/blog.git checkout -f                  ↑博客静态文件储存的位置                 ↑仓库位置然后给权限cd blog.git/hooks/sudo chmod +x post-update  #赋予其可执行权限sudo chown -R git:git /home/git/repos/ #仓库所有者改为gitsudo chown -R git:git /www/wwwroot/blog.xxin.xyz/ #站点文件夹所有者改为git
5.测试可用性#在主机端，如果能将仓库拉下来，说明Git仓库搭建成功git clone git@server\_ip:/home/git/repos/blog.git
三、修改本地配置1.本地config.yml配置本地Hexo博客文件夹中的_config.yml文件尾部deploy:  type: git  repo: git@159.75.7.25:/home/git/repos/blog.git #仓库地址  branch: master
2.测试hexo clean  #清除缓存hexo generate #生成静态页面hexo delopy  #将本地静态页面目录部署到云服务器
也可以在package.json 中添加 npm 脚本，这样就可以直接npm run dd一下执行&quot;scripts&quot;: &#123;    &quot;build&quot;: &quot;hexo generate&quot;,    &quot;clean&quot;: &quot;hexo clean&quot;,    &quot;deploy&quot;: &quot;hexo deploy&quot;,    &quot;dd&quot;: &quot;hexo clean &amp;&amp; hexo g -d&quot;,    &quot;server&quot;: &quot;hexo server&quot;,    &quot;ss&quot;: &quot;hexo clean &amp;&amp; hexo g &amp;&amp; hexo s&quot;  &#125;,
3.访问测试https://blog.xxin.xyz
参考文章https://cloud.tencent.com/developer/article/1823096
]]></content>
      <categories>
        <category>菜鸡手记</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程使用方式</title>
    <url>/2023/05/22/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[线程睡眠&ensp;&ensp;在需要睡眠的线程中添加一行Thread.sleep(long millis)new Thread(new Runnable&#123;    @Override    public void run() &#123;        try &#123;            Thread.sleep(1000);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;).start();
线程名称&ensp;&ensp;设置线程名称Thread thread = new Thread() &#123;    @Override    public void run() &#123;        super.run();    &#125;&#125;;// 设置线程名thread.setName(&quot;test&quot;);
&ensp;&ensp;获取线程名称Thread thread = new Thread() &#123;    @Override    public void run() &#123;        super.run();    &#125;&#125;;thread.setName(&quot;test&quot;);// 获取线程名System.out.println(thread.getName());
获取当前线程&ensp;&ensp;在main(String[] args)方法主线程中获取当前线程，并输出线程名称public static void main(String[] args) &#123;    Thread currentThread = Thread.currentThread();    System.out.println(currentThread.getName());&#125;
&ensp;&ensp;将会输出main
线程优先级&ensp;&ensp;线程优先级的范围是从1-10，默认是5，数值越大优先级越高，优先级高的线程获得的CPU资源较多Thread thread = new Thread(new Runnable() &#123;    @Override    public void run() &#123;            &#125;&#125;);thread.setPriority(10);                 // 设置优先级int priority = thread.getPriority();    // 获取优先级
&ensp;&ensp;如下代码，线程1的优先级设置为5，线程2的优先级设置为10，执行发现线程2几乎每次都在线程1之前执行完毕public class NewThread extends Thread &#123;    public static void main(String[] args) &#123;        // 线程1 循环100次        NewThread thread1 = new NewThread();        thread1.setName(&quot;线程1&quot;);        // 设置优先级        thread1.setPriority(5);        thread1.start();        // 线程2 循环100次        NewThread thread2 = new NewThread() ;        thread2.setName(&quot;线程2&quot;);        // 设置优先级        thread2.setPriority(10);        thread2.start();    &#125;    @Override    public void run() &#123;        super.run();        for (int i = 1; i &lt;= 100; i++) &#123;            try &#123;                Thread.sleep(10);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            System.out.println(getName() + &quot;第&quot; + i + &quot;轮任务&quot;);        &#125;    &#125;&#125;
守护线程&ensp;&ensp;如果一个线程没有设置守护线程或非守护线程，那么它的状态取决于父类是否为守护线程public class NewThread extends Thread &#123;    public static void main(String[] args) &#123;        NewThread newThread = new NewThread();                // 设置守护线程 true:守护线程 false:非守护线程        newThread.setDaemon(true);        // 线程是否是守护线程        boolean daemon = newThread.isDaemon();    &#125;    @Override    public void run() &#123;        super.run();    &#125;&#125;
&ensp;&ensp;当所有非守护线程执行完成或退出后，守护线程会随即终止&ensp;&ensp;如下代码，当非守护线程中的循环执行完50次结束后，守护线程此时执行了大概40-80轮，并随着非守护线程结束
public class NewThread extends Thread &#123;    public static void main(String[] args) &#123;        // 线程1 非守护线程        NewThread thread1 = new NewThread();        thread1.setDaemon(false);        thread1.start();        // 线程2 守护线程        NewThread thread2 = new NewThread();        thread2.setDaemon(true);        thread2.start();    &#125;    @Override    public void run() &#123;        super.run();        // 是否是守护线程        boolean daemon = isDaemon();        if (daemon) &#123;            for (int i = 1; i &lt;= 500; i++) &#123;                System.out.println(&quot;守护线程，执行第&quot; + i + &quot;轮&quot;);            &#125;        &#125; else &#123;            for (int i = 1; i &lt;= 50; i++) &#123;                System.out.println(&quot;用户线程，执行第&quot; + i + &quot;轮&quot;);            &#125;        &#125;    &#125;&#125;
礼让线程&ensp;&ensp;使当前线程暂停执行，让出CPU资源给其他线程。调用Thread..yield()方法后，线程将从运行状态转变为就绪状态，然后重新竞争CPU资源。这会使得如下代码的输出结果相对之前变得均匀
&ensp;&ensp;当线程调用Thread.yield()方法后，它并不会立即重新竞争CPU资源，而是进入就绪状态，与其他就绪状态的线程竞争CPU资源，这样可以给其他线程更多的机会来执行。public class NewThread extends Thread &#123;    public static void main(String[] args) &#123;        NewThread thread1 = new NewThread();        thread1.setName(&quot;线程1&quot;);        thread1.start();                NewThread thread2 = new NewThread();        thread2.setName(&quot;线程2&quot;);        thread2.start();    &#125;    @Override    public void run() &#123;        super.run();        for (int i = 1; i &lt;= 100; i++) &#123;            System.out.println(getName() + &quot;第&quot; + i + &quot;轮&quot;);            // 将线程设置为礼让线程            Thread.yield();        &#125;    &#125;&#125;
插入线程join()&ensp;&ensp;thread.join()使当前线程等待thread线程完成其执行后，继续向下执行当前线程。
&ensp;&ensp;如下代码，当一个线程通过调用thread.start()方法启动后，主线程会继续执行而不等待该线程完成。如果想让主线程等待thread线程完成后再继续执行，可以在thread.start()后调用thread.join()方法，阻塞主线程public static void main(String[] args) &#123;    Thread thread = new Thread() &#123;        @Override        public void run() &#123;            super.run();            for (int i = 1; i &lt;= 20; i++) &#123;                try &#123;                    Thread.sleep(100);                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;                System.out.println(&quot;正在执行&quot; + getName() + &quot;第&quot; + i + &quot;轮&quot;);            &#125;        &#125;    &#125;;    thread.setName(&quot;thread&quot;);    thread.start();    try &#123;        // 阻塞main线程，在thread执行完毕后main线程继续向下执行        thread.join();    &#125; catch (InterruptedException e) &#123;        e.printStackTrace();    &#125;    System.out.println(currentThread().getName() + &quot;线程执行完毕&quot;);&#125;
&ensp;&ensp;将会输出正在执行thread第1轮正在执行thread第2轮...正在执行thread第19轮正在执行thread第20轮main线程执行完毕
&ensp;&ensp;如下代码，在执行thread2时会等待thread1执行完毕，而执行thread3又会等待thread2执行完毕，所以将会按照thread1、thread2、thread3的执行顺序public static void main(String[] args) &#123;    Thread thread1 = new Thread() &#123;        @Override        public void run() &#123;            super.run();            for (int i = 1; i &lt;= 20; i++) &#123;                try &#123;                    Thread.sleep(100);                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;                System.out.println(&quot;正在执行&quot; + getName() + &quot;第&quot; + i + &quot;轮&quot;);            &#125;        &#125;    &#125;;    thread1.setName(&quot;thread1&quot;);    Thread thread2 = new Thread() &#123;        @Override        public void run() &#123;            super.run();            try &#123;                thread1.join();            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            for (int i = 1; i &lt;= 20; i++) &#123;                try &#123;                    Thread.sleep(100);                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;                System.out.println(&quot;正在执行&quot; + getName() + &quot;第&quot; + i + &quot;轮&quot;);            &#125;        &#125;    &#125;;    thread2.setName(&quot;thread2&quot;);    Thread thread3 = new Thread() &#123;        @Override        public void run() &#123;            super.run();            try &#123;                thread2.join();            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            for (int i = 1; i &lt;= 20; i++) &#123;                try &#123;                    Thread.sleep(100);                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;                System.out.println(&quot;正在执行&quot; + getName() + &quot;第&quot; + i + &quot;轮&quot;);            &#125;        &#125;    &#125;;    thread3.setName(&quot;thread3&quot;);    thread1.start();    thread2.start();    thread3.start();&#125;
join(long millis)&ensp;&ensp;最多等待被join的线程millis秒，millis后不再等待public static void main(String[] args)&#123;    Thread thread1 = new Thread() &#123;        @Override        public void run() &#123;            super.run();            for (int i = 1; i &lt;= 20; i++) &#123;                try &#123;                    Thread.sleep(100);                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;                System.out.println(&quot;正在执行&quot; + getName() + &quot;第&quot; + i + &quot;轮&quot;);            &#125;        &#125;    &#125;    thread1.setName(&quot;thread1&quot;);    Thread thread2 = new Thread() &#123;        @Override        public void run() &#123;            super.run();            // 最多等1000ms，1000ms内thread1没有执行结束，不再等待            thread1.join(1000);            for (int i = 1; i &lt;= 20; i++) &#123;                try &#123;                    Thread.sleep(100);                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;                System.out.println(&quot;正在执行&quot; + getName() + &quot;第&quot; + i + &quot;轮&quot;);            &#125;        &#125;    &#125;    thread2.setName(&quot;thread2&quot;);    thread2.start();    thread3.start();&#125;
join(long millis, int nanos)&ensp;&ensp;最多等待被join的线程millis + nanos秒，millis + nanos后不再等待
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程实现方式</title>
    <url>/2023/04/26/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[创建线程的几种方法继承Thread&ensp;&ensp;继承Thread类并重写run()方法，public class TestThread extends Thread &#123;    @Override    public void run() &#123;        super.run();        for (int i = 0; i &lt; 20; i++) &#123;            System.out.println(i);        &#125;    &#125;&#125;
&ensp;&ensp;创建TestThread对象，并调用start()方法public static void main(String[] args) &#123;    TestThread testThread = new TestThread();    testThread.start();&#125;
&ensp;&ensp;如果逻辑并不复杂，可以直接创建Thread对象并重写run()方法public static void main(String[] args) &#123;    new Thread() &#123;        @Override        public void run() &#123;            super.run();            for (int i = 0; i &lt; 20; i++) &#123;                System.out.println(i);            &#125;        &#125;    &#125;.start();&#125;
实现Runnable&ensp;&ensp;实现Runnable接口并重写run()方法public class TestRunnable implements Runnable &#123;    @Override    public void run() &#123;        for (int i = 0; i &lt; 20; i++) &#123;            System.out.println(i);        &#125;    &#125;&#125;
&ensp;&ensp;创建TestRunnable对象，创建Thread对象，并传入TestRunnable对象public static void main(String[] args) &#123;    TestRunnable testRunnable = new TestRunnable();    new Thread(testRunnable).start();&#125;
&ensp;&ensp;或者直接传入匿名类public static void main(String[] args) &#123;    new Thread(new Runnable() &#123;        @Override        public void run() &#123;            for (int i = 0; i &lt; 20; i++) &#123;                System.out.println(i);            &#125;        &#125;    &#125;).start();&#125;
&ensp;&ensp;注意：如果在创建Thread对象时，传入Runnable同时重写run()方法，那么它们两个都会被执行public static void main(String[] args) &#123;    new Thread(new Runnable() &#123;        @Override        public void run() &#123;            System.out.println(&quot;执行Runnable匿名类的run方法&quot;);        &#125;    &#125;) &#123;        @Override        public void run() &#123;            super.run();            System.out.println(&quot;执行重写run方法&quot;);        &#125;    &#125;.start();&#125;
实现Callable&ensp;&ensp;实现Callable类,重写run()方法并指定其泛型类型public class TestCallable implements Callable&lt;String&gt; &#123;    @Override    public String call() throws Exception &#123;        return &quot;测试&quot;;    &#125;&#125;
&ensp;&ensp;创建FutureTask对象，并传入TestCallable，将FutureTask放在Thread中执行，执行后通过FutureTask的get()方法可以获取到TestCallable的返回值public static void main(String[] args) &#123;    TestCallable testCallable = new TestCallable();    FutureTask&lt;String&gt; futureTask = new FutureTask&lt;&gt;(testCallable);    new Thread(futureTask).start();    try &#123;        String s = futureTask.get();        System.out.println(s);    &#125; catch (InterruptedException | ExecutionException e) &#123;        e.printStackTrace();    &#125;&#125;
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>子View超出父View</title>
    <url>/2021/11/19/%E5%AD%90View%E8%B6%85%E5%87%BA%E7%88%B6View/</url>
    <content><![CDATA[&ensp;&ensp;&ensp;&ensp;常见于底部导航栏，例如
&ensp;&ensp;&ensp;&ensp;用一张图来解释一下这个布局方式
&ensp;&ensp;&ensp;&ensp;在布局的根View中添加属性android:clipChildren=&quot;false&quot;
&ensp;&ensp;&ensp;&ensp;如果以inclede引入布局的方式，则需要在两边的根View中同时加入android:clipChildren=&quot;false&quot;
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android开发手记</tag>
      </tags>
  </entry>
  <entry>
    <title>宝塔面板开启系统防火墙后无法访问</title>
    <url>/2022/01/08/%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BF%E5%BC%80%E5%90%AF%E7%B3%BB%E7%BB%9F%E9%98%B2%E7%81%AB%E5%A2%99%E5%90%8E%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AE/</url>
    <content><![CDATA[1.开启系统防火墙之前，正常访问没有什么问题
2.打开系统防火墙，刷新页面就进不去了
3.这大概是因为宝塔的系统防火墙会屏蔽腾讯的一些域名，所以导致无法访问，这时候需要使用其他工具连接服务器的终端，关掉防火墙
4.CentOS7版本的防火墙默认使用firewall，与之前的版本使用iptables不一样，在终端中输入以下命令控制防火墙:# 关闭防火墙：sudo systemctl stop firewalld.service
# 关闭开机启动：sudo systemctl disable firewalld.service
CentOS6# 关闭防火墙：service iptables stop# 启动防火墙service iptables start# 重启防火墙service iptables restart# 查看防火墙状态service iptables status# 永久关闭防火墙chkconfig iptables off# 永久关闭后启用chkconfig iptables on
5.关掉防火墙
6.刷新宝塔面板
]]></content>
      <categories>
        <category>菜鸡手记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>封装的OkHttpUtils</title>
    <url>/2021/12/07/%E5%B0%81%E8%A3%85%E7%9A%84OkHttpUtils/</url>
    <content><![CDATA[&ensp;&ensp;工具类import okhttp3.Callback;import okhttp3.OkHttpClient;import okhttp3.Request;import okhttp3.RequestBody;public class OkHttpUtils &#123;    private static OkHttpUtils okHttpUtils;//封装的OkHtpp工具类    private static Request.Builder builder;    private static OkHttpClient okHttpClient;    public static OkHttpUtils getInstance()&#123;        builder = new Request.Builder();        if (okHttpUtils == null)&#123;            okHttpUtils = new OkHttpUtils();            okHttpClient = new OkHttpClient();        &#125;        return okHttpUtils;    &#125;    /**     * 添加请求地址     * @param url 请求地址     */    public OkHttpUtils url(String url)&#123;        builder.url(url);        return okHttpUtils;    &#125;    /**     * 添加请求头     * @param name 请求头键名     * @param value 请求头键值     */    public OkHttpUtils addHeader(String name, String value)&#123;        builder.addHeader(name, value);        return okHttpUtils;    &#125;    /**     * post请求     * @param requestBody 请求体     * @param callback 回调     */    public void post(RequestBody requestBody, Callback callback)&#123;        Request request = OkHttpUtils.builder.post(requestBody).build();        okHttpClient.newCall(request).enqueue(callback);    &#125;    /**     * get请求     * @param callback 回调     */    public void get(Callback callback)&#123;        Request request = OkHttpUtils.builder.get().build();        okHttpClient.newCall(request).enqueue(callback);    &#125;    // 禁止创建对象调用    private OkHttpUtils() &#123;&#125;&#125;
&ensp;&ensp;发送post请求RequestBody requestBody = RequestBody.create(content, MediaType.parse(&quot;text/x-markdown; charset=utf-8&quot;));OkHttpUtils.getInstance().url(url).post(requestBody, new Callback() &#123;    @Override    public void onFailure(@NonNull Call call, @NonNull IOException e) &#123;        Log.d(TAG, &quot;请求失败 = &quot; + e);    &#125;    @Override    public void onResponse(@NonNull Call call, @NonNull Response response) throws IOException &#123;        ResponseBody body = response.body();        if (response.isSuccessful() &amp;&amp; body != null)&#123;            String string = body.string();            Log.d(TAG, &quot;result = &quot; + string);        &#125;        else &#123;            Log.d(TAG, &quot;请求失败&quot;);        &#125;    &#125;&#125;);
&ensp;&ensp;发送get请求OkHttpUtils.getInstance().url(url).get(newCallback() &#123;    @Override    public void onFailure(@NonNull Call call, @NonNull IOException e) &#123;        Log.d(TAG, &quot;加载失败 = &quot; + e);    &#125;    @Override    public void onResponse(@NonNull Call call, @NonNull Response response) throws IOException &#123;        ResponseBody body = response.body();        if (response.isSuccessful() &amp;&amp; body != null)&#123;            String result = body.string();            Log.d(TAG, &quot;result = &quot; + result);        &#125;        else &#123;            Log.d(TAG, &quot;加载失败&quot;);        &#125;    &#125;&#125;);
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android开发手记</tag>
      </tags>
  </entry>
  <entry>
    <title>封装DocumentFile</title>
    <url>/2022/10/23/%E5%B0%81%E8%A3%85DocumentFile/</url>
    <content><![CDATA[使用范围&ensp;&ensp;使用文中方式封装的DocumentFile工具类适用范围极为广阔，不仅可以操作Android10-Android13(目前最新版)的Android/data目录，还可以操作外置TF卡中的文件，以及手机外接U盘中的文件，理论支持一切连接手机的外部储存硬件
添加权限&ensp;&ensp;读取和写入外部储存不需要多说，所有文件访问权限好像是能提升SAF框架的读写速度
&lt;!-- 读取外部储存 --&gt;&lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot; /&gt;&lt;!-- 写入外部储存 --&gt;&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt;&lt;!-- 所有文件访问权限 --&gt;&lt;uses-permission android:name=&quot;android.permission.MANAGE_EXTERNAL_STORAGE&quot; /&gt;
DocumentFileUtils&ensp;&ensp;新建一个DocumentFileUtils类，使用这个类来对DocumentFile进行读写操作
常量&ensp;&ensp;所需的一些常量
private final Context context;          // 上下文private final String URI_HEAD;          // uri地址头，任何一个DocumentFile的Uri地址都包含这个地址头private final String permissionPath;    // 请求权限的目录地址（如：storage/sdcard/test）private final String permissionUriStr;  // 请求权限的目录的uri地址（该Uri地址仅用于申请权限，切勿直接操作）public final static String PRIMARY_STORAGE;     // 主储存目录:   /storage/emulated/0public final static String ANDROID_PATH;        // Android目录: /storage/emulated/0/Androidpublic final static String ANDROID_DATA_PATH;   // data目录:    /storage/emulated/0/Android/datapublic final static String ANDROID_OBB_PATH;    // obb目录:     /storage/emulated/0/Android/obb&#123;    URI_HEAD = &quot;content://com.android.externalstorage.documents/tree/&quot;;&#125;static &#123;    // 一般来说主储存目录是/storage/emulated/0    PRIMARY_STORAGE = Environment.getExternalStorageDirectory().getAbsolutePath();    ANDROID_PATH = PRIMARY_STORAGE + &quot;/Android&quot;;    ANDROID_DATA_PATH = ANDROID_PATH + &quot;/data&quot;;    ANDROID_OBB_PATH = ANDROID_PATH + &quot;/obb&quot;;&#125;
添加和移除斜杠&ensp;&ensp;然后为了防止传入的目录绝对正确，我们要先对目录的前后添加斜杠“/”，在后续的操作中会用到移除
/** * 在地址头和地址尾添加斜线 * * @param permissionDir 请求权限的目录 */private String addSlash(String permissionDir) &#123;    if (!permissionDir.startsWith(&quot;/&quot;)) &#123;        permissionDir = &quot;/&quot; + permissionDir;    &#125;    if (!permissionDir.endsWith(&quot;/&quot;)) &#123;        permissionDir = permissionDir + &quot;/&quot;;    &#125;    return permissionDir;&#125;/** * 移除地址头和地址尾的斜杠 * * @param path 文件地址 */private String removeSlash(String path) &#123;    if (path.startsWith(&quot;/&quot;)) &#123;        path = path.substring(1);    &#125;    if (path.endsWith(&quot;/&quot;)) &#123;        path = path.substring(0, path.length() - 1);    &#125;    return path;&#125;
将目录地址转换为Uri地址&ensp;&ensp;再将目录地址转换为Uri地址

/** * 将目录地址转换为uri地址，此处要求绝对正确的完整的目录地址 * &lt;p&gt; * 转换后的Uri地址仅申请权限时可用，不可以直接使用该Uri地址转换为DocumentFile * 注：储存器（外置TF卡、内置SD卡都称为储存器）根目录除外 * * @param path 文件路径，注意一定要传入文件的完整的绝对路径 * @return 格式化后的Uri地址字符串 */private String pathToUri(String path) &#123;    // 在头尾添加斜杠    path = addSlash(path);    // 定义路径头规范，一般路径头是/storage/    // 例1：/storage/6238-3332/               =&gt; /storage/    // 例2：/storage/6238-3332/Android/       =&gt; /storage/    // 例3：/storage/emulated/0/Android/data/ =&gt; /storage/    String pathHead = PRIMARY_STORAGE.substring(0, PRIMARY_STORAGE.indexOf(&quot;/&quot;, 1) + 1);    // 如果传入的路径头与规范头不同，说明路径不对    if (!path.startsWith(pathHead)) return null;    // 这一步去除路径头，假设规范路径头是/storage/    // 例1：/storage/6238-3332/               =&gt; 6238-3332/    // 例2：/storage/6238-3332/Android/       =&gt; 6238-3332/Android/    // 例3：/storage/emulated/0/Android/data/ =&gt; emulated/0/Android/data/    String pathContent = path.substring(pathHead.length());    // 取/storage/下的主储存目录，一般主储存目录是emulated/0，不需要考虑路径头不属于主储存目录的情况    // 例1：/storage/emulated/0 =&gt; emulated/0    String primaryPath = PRIMARY_STORAGE.substring(pathHead.length());    // 如果传入的目录是Android内置SD卡下的主目录，假设主目录是emulated/0，将传入路径中的emulated/0替换为primary    // 例1：emulated/0/Android/data/ =&gt; primary/Android/data/    if (pathContent.startsWith(primaryPath))        pathContent = &quot;primary&quot; + pathContent.substring(primaryPath.length());    // 拿到储存器目录的目录名    // 理论上讲，所传入的目录路径中，/storage/的直接子目录就是储存器（外置TF卡、内置SD卡都称为储存器）目录的目录名    // 例1：6238-3332/            =&gt; 6238-3332    // 例2：6238-3332/Android/    =&gt; 6238-3332    // 例3：primary/Android/data/ =&gt; primary    String rootPathName = pathContent.substring(0, pathContent.indexOf(&quot;/&quot;));    // 从路径中剔除储存器目录    // 例1：6238-3332/            =&gt; /    // 例2：6238-3332/Android/    =&gt; Android/    // 例3：primary/Android/data/ =&gt; Android/data/    pathContent = pathContent.substring(rootPathName.length() + 1);    // 去除末尾的“/”    // 例1：/             =&gt;    // 例2：Android/      =&gt; Android    // 例3：Android/data/ =&gt; Android/data    if (pathContent.endsWith(&quot;/&quot;))        pathContent = pathContent.substring(0, pathContent.length() - 1);    // 将目录路径中的/全部替换为%2F    // 例1：              =&gt;    // 例2：Android       =&gt; Android    // 例2：Android/data  =&gt; Android%2Fdata    pathContent = pathContent.replaceAll(&quot;/&quot;, &quot;%2F&quot;);    // 得到完整Uri地址    return URI_HEAD + rootPathName + &quot;%3A&quot; + pathContent;&#125;
写构造器&ensp;&ensp;在构造器中要得到请求权限的目录地址、请求权限的目录的uri地址、上下文，请求码可以暂时不传&ensp;&ensp;1. Context context: 上下文&ensp;&ensp;2. String permissionDir: 需要请求权限的目录，下文中称为“权限目录”
/** * @param context       上下文 * @param permissionDir 请求权限的目录 */public static DocumentFileUtils create(Context context, String permissionDir) &#123;    return new XAFUtil(context, permissionDir);&#125;/** * @param context       上下文 * @param permissionDir 请求权限的目录 */private DocumentFileUtils(Context context, String permissionDir) &#123;    this.permissionPath = addSlash(permissionDir);    this.permissionUriStr = pathToUri(permissionDir);    this.context = context;    // 错误时提示    if (this.permissionUriStr == null)        Log.e(TAG, &quot;DocumentFileUtils: root directory permissionDir field&quot;);&#125;
权限判断&ensp;&ensp;判断权限目录是否拥有访问权限
/** * 权限目录是否拥有访问权限 */public boolean isPermission() &#123;    if (permissionUriStr == null) Log.e(TAG, &quot;isPermission: root directory path field&quot;);    Uri uriPath = Uri.parse(permissionUriStr);    DocumentFile documentFile = DocumentFile.fromTreeUri(this.context, uriPath);    if (documentFile != null) &#123;        return documentFile.canWrite();    &#125;    return false;&#125;
&ensp;&ensp;判断是否拥有所有文件访问权限，我个人感觉这是一个很操蛋的名字，既然叫所有文件访问权限，我们拥有这个权限之后又不能访问所有文件，例如Android/data
/** * 是否拥有所有文件访问权限，安卓11之前无需申请 */public boolean isManagerExternalPermission() &#123;    if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.R) &#123;        return Environment.isExternalStorageManager();    &#125;    return true;&#125;
申请权限&ensp;&ensp;申请权限目录的访问权限&ensp;&ensp;这里注意一个困扰了我很久的细节问题，app的gradle文件中的最大sdk尽量不要超过29，从30开始将无法获得某些目录的权限例如storage/emulated/0和storage/emulated/0/Android
/** * 请求所传入目录的访问权限 * * @param activity    调用的activity * @param requestCode 请求码 */public void requestPermission(Activity activity, int requestCode) &#123;    requestPermission(activity, null, requestCode);&#125;/** * 请求所传入目录的访问权限 * * @param fragment    调用的fragment * @param requestCode 请求码 */public void requestPermission(Fragment fragment, int requestCode) &#123;    requestPermission(null, fragment, requestCode);&#125;private void requestPermission(Activity activity, Fragment fragment, int requestCode) &#123;    if (permissionUriStr == null) &#123; // 请求权限的目录的uri地址错误        Log.e(TAG, &quot;requestPermission: permission directory path field&quot;);        return;    &#125;    if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.O) &#123; // 系统版本过低        Log.e(TAG, &quot;requestPermission: sdk version too low&quot;);        return;    &#125;    // 请求码    this.requestCode = requestCode;    // 将请求权限的目录的uri地址转换为Uri对象    Uri uriPath = Uri.parse(permissionUriStr);    // 通过Uri对象得到DocumentFile对象，该对象只能在申请权限时使用，不可以直接读写，权限目录除外    DocumentFile documentFile = DocumentFile.fromTreeUri(this.context, uriPath);    if (documentFile != null) &#123;        Intent intent = createIntent(documentFile);        if (activity != null) &#123;            activity.startActivityForResult(intent, requestCode);        &#125; else &#123;            fragment.startActivityForResult(intent, requestCode);        &#125;    &#125; else &#123;        Log.e(TAG, &quot;requestPermission: &quot; + permissionUriStr + &quot; not exists&quot;);    &#125;&#125;@RequiresApi(api = Build.VERSION_CODES.O)private Intent createIntent(DocumentFile documentFile) &#123;    Intent intent = new Intent(Intent.ACTION_OPEN_DOCUMENT_TREE);    intent.setFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION            | Intent.FLAG_GRANT_WRITE_URI_PERMISSION            | Intent.FLAG_GRANT_PERSISTABLE_URI_PERMISSION            | Intent.FLAG_GRANT_PREFIX_URI_PERMISSION);    intent.putExtra(DocumentsContract.EXTRA_INITIAL_URI, documentFile.getUri());    return intent;&#125;
&ensp;&ensp;申请权限之后需要进行保存权限
/** * 请求权限后，在onActivityResult中调用保存 * * @param requestCode 请求码 * @param intent      请求数据 */@SuppressLint(&quot;WrongConstant&quot;)public void savePermission(int requestCode, Intent intent) &#123;    if (intent == null) return;    if (this.requestCode == requestCode) &#123;        Uri uri = intent.getData();        if (uri != null) &#123;            DocumentFile documentFile = DocumentFile.fromTreeUri(context, uri);            if (documentFile != null &amp;&amp; documentFile.canWrite()) &#123;                if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123;                    this.context.getContentResolver().takePersistableUriPermission(uri,                            intent.getFlags() &amp; (Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION));                &#125; else &#123;                    Log.e(TAG, &quot;savePermission: sdk version too low&quot;);                &#125;            &#125; else &#123;                Log.e(TAG, &quot;savePermission: no write permission&quot;);            &#125;        &#125; else &#123;            Log.e(TAG, &quot;savePermission: data uri field&quot;);        &#125;    &#125; else &#123;        Log.e(TAG, &quot;savePermission: requestCode field&quot;);    &#125;&#125;
&ensp;&ensp;请求所有文件访问权限
/** * 申请所有文件访问权限，安卓11之前无需申请 * * @param activity    上下文 * @param requestCode 请求权限请求码 */@SuppressLint(&quot;InlinedApi&quot;)public void requestManagerExternalPermission(Activity activity, int requestCode) &#123;    Intent intent = new Intent(Settings.ACTION_MANAGE_APP_ALL_FILES_ACCESS_PERMISSION);    intent.setData(Uri.parse(&quot;package:&quot; + activity.getPackageName()));    activity.startActivityForResult(intent, requestCode);&#125;
获取DocumentFile对象&ensp;&ensp;获取某文件DocumentFile对象&ensp;&ensp;在这一步操作中，首先在传入地址的头尾添加斜杠，不管它是文件或文件夹&ensp;&ensp;然后将传入的路径转换为Uri地址，当Uri地址错误，或者Uri地址不属于权限目录的Uri地址时返回null&ensp;&ensp;如果传入的目录是权限目录直接return出去就好，如果是其子文件或子目录，则需要进行剔除相同部分，然后根据其不同的类型得到不同的DocumentFile
/** * 获取某文件或者目录的DocumentFile对象 * * @param filePath 目录或者文件路径 * @param isFile   目标是否是文件类型，如果是文件夹类型则传入false * @return DocumentFile对象 */public DocumentFile getDocumentFile(String filePath, boolean isFile) &#123;    // 在地址头和地址尾添加斜杠    filePath = addSlash(filePath);    // 将文件路径转换为uri地址    String _uriPathStr = pathToUriStr(filePath);    // 文件uri地址为空或者文件不属于权限目录时    if (_uriPathStr == null || !_uriPathStr.startsWith(permissionUriStr)) return null;    // 权限目录DocumentFile对象    DocumentFile documentFile = DocumentFile.fromTreeUri(context, Uri.parse(permissionUriStr));    // uri地址与权限目录的uri地址相同时，直接把权限目录的DocumentFile对象return出去    if (_uriPathStr.equals(permissionUriStr)) return documentFile;    // 去除与权限目录一样的部分，仅保留权限目录下的文件或文件夹路径    String pathContent = filePath.substring(this.permissionPath.length());    return getDocumentFile(documentFile, pathContent, isFile);&#125;/** * 获取目录DocumentFile对象下的目录或文件的DocumentFile对象，在搞懂这个方法前慎用 * 例：传入/storage/sdCard/的DocumentFile和/test/1.txt，那就是获取/storage/sdCard/test/1.txt的DocumentFile对象 * 注意，当路径中的文件或者文件夹不存在时，该方法会自动创建 * * @param documentFile DocumentFile对象 * @param filePath     DocumentFile对象下的目录或文件路径 * @param isFile       路径是否是文件类型，如果是文件夹类型则传入false，反之true */public DocumentFile getDocumentFile(DocumentFile documentFile, String filePath, boolean isFile) &#123;    // 如果documentFile有问题    if (documentFile == null) return null;    // 移除头尾的斜杠    filePath = removeSlash(filePath);    // 如果路径是空的    if (TextUtils.isEmpty(filePath)) return documentFile;    // 根据层级分隔符，将路径分开    String[] pathArr = filePath.split(&quot;/&quot;);    DocumentFile[] documentFiles = documentFile.listFiles();    // 路径完整的情况下    if (pathArr.length &gt; 0) &#123;        // 从路径中去除掉pathArr[0]        filePath = filePath.substring(pathArr[0].length());        for (DocumentFile _documentFile : documentFiles) &#123;            if (_documentFile.getName() != null &amp;&amp; _documentFile.getName().equals(pathArr[0])) &#123;                return getDocumentFile(_documentFile, filePath, isFile);            &#125;        &#125;        // 代码执行到这里表明文件夹中不存在指定的下一级文件夹/文件，需要我们创建一个        // 如果pathArr.length为1，说明只剩下最后一个文件夹或文件没有找到，反之则一定为文件夹，创建文件夹即可        // 如果指定的目标类型为文件，则创建文件，反之创建文件夹        if (pathArr.length == 1 &amp;&amp; isFile) &#123;            return documentFile.createFile(&quot;&quot;, pathArr[0]);        &#125; else &#123;            DocumentFile createDir = documentFile.createDirectory(pathArr[0]);            return getDocumentFile(createDir, filePath, isFile);        &#125;    &#125;    return documentFile;&#125;
创建、删除、重命名&ensp;&ensp;文件和文件夹的创建、删除、重命名
/** * 创建文件夹 * * @param folderPath 文件夹路径 */public DocumentFile createDirectory(String folderPath) &#123;    return getDocumentFile(folderPath, false);&#125;/** * 创建文件 * * @param filePath 文件路径 */public DocumentFile createFile(String filePath) &#123;    return getDocumentFile(filePath, true);&#125;/** * 删除文件或文件夹 * * @param filePath 文件/文件夹路径 * @param isFile   是否是文件 * @return 删除结果 */public boolean deleteFile(String filePath, boolean isFile) &#123;    return getDocumentFile(filePath, isFile).delete();&#125;/** * 文件、文件夹重命名 * * @param filePath 文件/文件夹路径 * @param isFile   是否是文件类型 * @param newName  新文件名 * @return 重命名结果 */public boolean renameFile(String filePath, boolean isFile, String newName) &#123;    return getDocumentFile(filePath, isFile).renameTo(newName);&#125;
文件复制&ensp;&ensp;文件复制有三种方式：File复制到DocumentFile，DocumentFile复制到File，DocumentFile复制到DocumentFile
/** * 将DocumentFile文件复制到File * * @param fromFile 源文件 * @param toFile   目标文件 */public void copyFile(DocumentFile fromFile, File toFile) &#123;    try &#123;        InputStream inputStream = context.getContentResolver().openInputStream(fromFile.getUri());        FileOutputStream fileOutputStream = new FileOutputStream(toFile);        copy(inputStream, fileOutputStream);    &#125; catch (IOException e) &#123;        e.printStackTrace();    &#125;&#125;/** * 将File复制到DocumentFile * * @param fromFile 源文件 * @param toFile   目标文件 */public void copyFile(File fromFile, DocumentFile toFile) &#123;    try &#123;        FileInputStream fileInputStream = new FileInputStream(fromFile);        OutputStream outputStream = context.getContentResolver().openOutputStream(toFile.getUri());        copy(fileInputStream, outputStream);    &#125; catch (IOException e) &#123;        e.printStackTrace();    &#125;&#125;/** * 将DocumentFile到DocumentFile * * @param fromFile 源文件 * @param toFile   目标文件 */public void copyFile(DocumentFile fromFile, DocumentFile toFile) &#123;    try &#123;        InputStream inputStream = context.getContentResolver().openInputStream(fromFile.getUri());        OutputStream outputStream = context.getContentResolver().openOutputStream(toFile.getUri());        copy(inputStream, outputStream);    &#125; catch (IOException e) &#123;        e.printStackTrace();    &#125;&#125;/** * 写入数据 * * @param inputStream  输入流 * @param outputStream 输出流 */private void copy(InputStream inputStream, OutputStream outputStream) &#123;    try &#123;        byte[] buffer = new byte[1024];        int len;        while ((len = inputStream.read(buffer)) != -1) &#123;            outputStream.write(buffer, 0, len);        &#125;    &#125; catch (IOException e) &#123;        e.printStackTrace();    &#125; finally &#123;        if (inputStream != null) &#123;            try &#123;                inputStream.close();            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;        &#125;        if (outputStream != null) &#123;            try &#123;                outputStream.flush();                outputStream.close();            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;&#125;
获取流&ensp;&ensp;ParcelFileDescriptor用于在某些场景中直接向DocumentFile中写入
/** * 获取输入流 * * @param filePath 文件地址 */public InputStream getInputStream(String filePath) &#123;    DocumentFile documentFile = getDocumentFile(filePath, true);    return getInputStream(documentFile);&#125;/** * 获取输入流 * * @param documentFile 文件 */public InputStream getInputStream(DocumentFile documentFile) &#123;    try &#123;        return context.getContentResolver().openInputStream(documentFile.getUri());    &#125; catch (FileNotFoundException e) &#123;        e.printStackTrace();    &#125;    return null;&#125;/** * 打开输出流 * * @param filePath 文件路径 */public OutputStream getOutputStream(String filePath) &#123;    DocumentFile documentFile = getDocumentFile(filePath, true);    return getOutputStream(documentFile);&#125;/** * 打开输出流 * * @param documentFile 文件 */public OutputStream getOutputStream(DocumentFile documentFile) &#123;    try &#123;        return context.getContentResolver().openOutputStream(documentFile.getUri());    &#125; catch (FileNotFoundException e) &#123;        e.printStackTrace();    &#125;    return null;&#125;/** * 获取DocumentFile类型的文件描述 * * @param documentFile 文件的DocumentFile对象 * @param openMode     打开文件的模式，一般情况下w是写模式，r是读模式 */public ParcelFileDescriptor getFileDescriptor(DocumentFile documentFile, String openMode) &#123;    Uri uri = documentFile.getUri();    try &#123;        // 以写模式打开        return context.getContentResolver().openFileDescriptor(uri, openMode);    &#125; catch (FileNotFoundException e) &#123;        e.printStackTrace();    &#125;    return null;&#125;
使用说明&ensp;&ensp;基础功能实现大体如下，注意调试时顶部的目录地址确定后，调试期间一定不要随意改动，因为很有可能改动后的目录地址没有申请权限，申请权限后点击按钮即可展示效果&ensp;&ensp;DocumentFileUtils类由于没有对Uri写死，所以可以进行任何DocumentFile操作，例如Android/data目录，外置TF卡，SD卡等

参考：从共享存储空间访问文档和其他文件开源地址：https://github.com/xxinPro/XAFUtil
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android开发手记</tag>
      </tags>
  </entry>
  <entry>
    <title>小衅笔记</title>
    <url>/2021/07/12/%E5%B0%8F%E8%A1%85%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[啦啦啦，啥也没有🌟写
啦啦啦，啥也没有🌟写
啦啦啦，啥也没有🌟写
啦啦啦，啥也没有🌟写
啦啦啦，啥也没有🌟写
]]></content>
      <categories>
        <category>便笺</category>
      </categories>
      <tags>
        <tag>站点日志</tag>
      </tags>
  </entry>
  <entry>
    <title>忿忿</title>
    <url>/2021/07/12/%E5%BF%BF%E5%BF%BF/</url>
    <content><![CDATA[&ensp;&ensp;只因前几日触犯了校规，被先生请去学生处喝茶。
&ensp;&ensp;七拼八凑的犯错经历讲至一半，来了一通电话，是个没见过的号码，凭着电话的地理位置猜测，应该是她的朋友吧。
&ensp;&ensp;“接了吧，开免提”，他们当然是想听的，正巴不得有人给我打电话，好在电话里透露出一些我犯错的证据，于是本就聚集在我身上的目光，又硬了几分。
&ensp;&ensp;“喂，打电话干什么”。
&ensp;&ensp;“%\&amp;￥../”
&ensp;&ensp;“#%$&amp;%~..”
&ensp;&ensp;“你能不能别再骚扰她了，也不要装作很深情”。
&ensp;&ensp;话到了这里，可以肯定的是对方不知道我所处的环境，正因如此我非常不解——在这个关头为什么刚好来了这个电话；对此亦感到可笑——世界上怎么会有人比我还自以为是，她又有什么资格让我惦记几个月。
&ensp;&ensp;脑海里思绪一阵翻滚，尽是些虎狼之辞从心底涌起，诸位先生好像看到我情绪有些波动，于是便打断说：“这个女孩我们都认识，你不能骂她”。
&ensp;&ensp;我怎么会骂她呢，显然，他们并不知道，电话另一头是她的憨批朋友。
&ensp;&ensp;话毕，他们的关注点似乎从对我违反校规的盘问，转而到了我与她干戈对峙的原因，原来老师也喜欢吃瓜。
&ensp;&ensp;“某天我睡醒就变成了出轨的渣男，没有一点防备，就像做梦一样。”随着这么一句话开头，继而讲述起那半真半假的故事，说自己有多好，说对方有多无情。人真的虚伪，包括我自己，哈哈，他妈的。
&ensp;&ensp;但是不可否认的，一个渴望成为铠甲勇士的少年，怎么会做出这种背信弃义的事？他们似乎也理解了我的委屈，于是问我为什么不把一切都解释清楚？
&ensp;&ensp;“解释清楚”，四个字说的好简单，谁会给我解释的机会呢？倘若每个被蒙蔽的真相都有机会去解释，那我想世界上会消失很多痛苦与遗憾。
&ensp;&ensp;我不想正面回答他们的疑问，只好反问到：“如果不是这种场合，你们会有人相信我的解释吗？”
&ensp;&ensp;他们也不敢回答我，只叫我把电话拨回去，说要当面替我平反昭雪。还是省了那心吧，我的落魄不会让任何人看见。
]]></content>
      <categories>
        <category>随笔一记</category>
      </categories>
  </entry>
  <entry>
    <title>常用网站</title>
    <url>/2022/02/22/%E5%B8%B8%E7%94%A8%E7%BD%91%E7%AB%99/</url>
    <content><![CDATA[
  f1582c4d8589911904d4cdc83a3052df4f3c48ddbfbd05f1587654dd0deb895dc0dffb68607e98762e4e914acfeb69d3197f79f3096440a00240d2f801831f494b930b284c6e208caf2e6f4d014c37604b776ce0ade0c57a397b21346f9c29b1ec5972c4252a34c713a77ce1c41b9e27b6722858cb66b1a4340218246240608f142e7ee28309e1bde93a68484075ab6fe5d789f42f42c3d93d78755932baa38d12f7b867cbb1d1fca8b0a4d28b15cb8bece13951bace8d38321a2b5147107e122c8ba5e74e545133f3ae5fdf4e9db7dc3699e9192ffd7e114e3559f57659219d7614a3d512ec152df5adc6d94e49c14737e2af70d0e879286998f12ba97823ceb3d63615cf65ebb629ce6586d102e306037e7276923f4215e6081f47feb0b6273a63605778f1c90d6964846868bd4d6cc9caaaf0f9a1a68e48fdf62a4f78067a059709d1c5647ab9a7df79310237a4cce98f46620fc9349cca6985f7fa2da1cdb978956d922853923a719e54b44d59d2813f64dd02ccf1f45d3d8c0ce04d0fd5938419d40ba43dc7405cfaf5f62ff811ed794f979ec305e2793cfb51d700bdff821a7304c73bd8bc78fc01ea3dd41e348d23b521e5366029bddb97c1dd1758795836aecb51c2e6ab0ea9497b6e9a501455628d93c3e2846adb25eb1771c238fa2c035cd421dcd5d69f35e8aa39dfa5b58b6fec23e03820ab42aeed810f6f89b3ab248aa14a9834731fa39b07db0c7dc50af542f4f0ac0ecd7151b97d5148f5a38f633b942703fb08b4c196f73eb573f66a14b0c37a876302b2208559bc76c93f26fa823ad213a5abb40c7aeafa844b2547300d94ab9d2f7044be8931817939ef4e1c802d2f961be5908216b898a7df6f16108736683ad19f2f6d630fd2676cda3bf3245288f4d1f6975c6b999b71d86ef1f339ff60e47cbb6d05e8945857670ebe71076a673a81b4b05243c7523fea27c5d88b70c350760557b9cc9d7f39eeb828f5c10af8787fcc533616a11ce59eb98511b68cf1e6237d51e6595192f11f5ba77c452f56da9e5e1963d1ada99bd3309e1c698e2f27a6e3c77df6c6277e3f26bfb71d1c258f61e19436cd4e3308388d6de5db657b5e81ba4740eef7dde604a9f4b1c6c586969fbdc8b1d335d92a277615d90c0d24b8232c6944054ba4c64650b5f0063f8d561035b5b483703a8abc8b518efea7a7139b08fa4c2085a4d174086cbd6aaefb5ae0494d0e0c5251d532c2fad2f5cd0a2ed8203a5a5a9f93e89296bc3b5a02215da1c6b821977e51a32566559af4c7ad0efb30781fc564b4d7de64353f130d4b5450e89bdeb7e6c6b7cf90dfdaf77f16537fd10dfe17274a14a5313fca6e084e2307719405d4efee880d1feb49bf55fe793256560194ee98a4d3f869ee98d401cc9b7fa3b7648e851c173840889936d8c0f662fdd8d57e72f5e5d23017279be23023b572502b1aa6ce0c07425d6c412526fab0bf2436a85cab341f182640e13fe90c913b39155a22bdcdf4b349967acbe5e96096af13775dd11753f985755546ac889cd2c5543071678deb2856882c27bed9fd7d77a080d3f07dea937edf376e9e5beb86f9ed447d7900aff117b4eaf04e7f884cea84ab1ac36f776bcaf44f153bf06eb8e65e4b982e15568222da681da9635af73b0aa24f3c2bc59017b2fcec4cc31e6628dbf18b428d4e8f284a8325ae749dc5969bd985fbaa079e57f08dbbdb895d6ecffe8fe34e55ef8f387d2e81a8e592ff029146f8675c27c9a0a466acabb09896e33938aabcbc39d43f46fdfecd2f51fe0bdcf8cb4fa1bae5c514b3ad6adcd5a45fa85be51faea95c6e757fc2a04fe0148c1339af79e9bd86ecbf8a86241352b071efa17a02d79c6420f4c4cd99dca538659933f7cd1e779e3fff18eaebe507c7886da78f81e674c3375f395086fdcc95e0ddeb4c7b14b249b78188eee60def1079e57d763f9a19e0de15eadac778448239efd85319b7ab6a494f532e00857ecb11e03b19a902dc82a0ee92e7d01c82d0d4bae398b7bdb748dc1dfa296b16158bff134bfca659afede60180c9f7c464adf3408f50bdbf0e395fa4faaf5bae19445cd3469ef3b3180beb2bf19285b06db81c7edcacb5cb536be01ac2167c38be472b6cd140211b0297e0b8f46321e9e6402eba89f3f38624f352a523837c6f9e5d8de57c1a5d0e4241a4c23d4c557268c2c7dff3fd958ebfc7564f1de963a3bb3df634405edadd3cedf162ffc1707564cee3d37bc2bc9f8a5bcbad4add37019948ed4460c15f6e668ac3f763c7ef81303e9d39f4c1d25d8d8ab478c7461f83a52792b2e0b8c796bcf4848c5152e2561df6bf87c613742261f7bb039739c0c6dab99399d7a6085420249dae0917d6040b2ab2537dbb1bf75ffc3176da38cfe2e5a9a285f08942c22da46053c4217e3f46a936ff5fb3e087ea4e70714ef51123b8eb3b9cb2fd76b2490cda3225ed397985777ee2bfe312175cc45ab4c784c25d05ce4d004a45c6877f907d8f5bdb7fb2272bc5b04ea6032550d17dd3e867f4da00303a23a674180a4949919356a866459965448ba15c2044f59454e3e7a6cc53b736ffe62767c84e1bee856d49cc6765848e3a9f8ca7fcf5cd37558cdd50f28bfdc5c014c6405844fed16800fdd72f64782cadbed279f5cc7ea5f41def4f5f1c75f6ed06f4dccca3a5f4e63c1de92eaba9b2ff86ea5d294424f6a4e2a2762247b145f5ef43422823b1d0904786d72af3eef2d5d3322f533296f2bae03e17a233406d1ae1d4021bf569f7779eb33187ab78121da8e7d88445c6fad2cc4d9a3ba505ff8a63527b6769e2ff2e68d5bed502ef7103c2a5f406625aa19fe2f0d5a28f81ffc89e604a094006e0220a3efe29ddb8767e77a9af4ec99a9e98bc5db84e7d682e97cd42baf3565deb9ac948fee26431c3bdd2acd15b727248dde30560af959047a1650090aa3dea2909873bbd2c6e18ac4c50f11346c45b94f6df021dd28101967dcb4e4f6a6cd52a2fa42195f26ad207d0370b387447466595e860fec01d93f7426f7b167c1bded225e0951f30b5495e9041080c5a681543dbfbd07f1df8c179a78f15605c978bd2c7ad05c41aa6547ab369dcff4b8bd41f96fa73ed2a3eddffe9801310c26a330e802ebceeb23f130fdae3f64b4d265b3aae7d7c7734a81407851d21c4418748b528effb3ce7373919947d794a6f8398b37aafa571fa95363a5a4016c9369c0f474041a7de644b171d7f79e0f931a190d740ca5cbb67bef8094c2cfcecfbd93a3dd0cffffa0f446a348ed7e4d1f065bd8c993049a1ee04b1e2745686f5a7b0019d8f59c3b1f2c479098e750da417e4e753d4468a457a9a2befb50175a24b1e67849fed1b45047c9d500bad356b7d2795382e6a2a097a9d74489cc82ed627382fde3dd74698a67dfd6e30c2491c66f371cf23762e3800950d56195be71268212a85984d12efc899005f96ced77b5d38efd874bca324cb0dabf40ea2fe86b6ae7bf5f1225f847c5d072fed6403a16ea75537c2e984dc8c08c8280b9e77f53c70c5c5f80cb98addf63258eed7d0f3c66b2a6b6d23125f6bf038d3e0ce6d4e6eeef814800b6063d073912f121bcdb12e5abce8467bf4c99776943e2311c2e09284e65f02beaa25f1397d3f258d6ee93a1df0366342d58b7aaac2c0359773d2a59c90fc84d6463207df131e48c46d903d4c3e79751d07024c4b8a185fddb7faca8b77c4c49b9f5739b904029cf7e8a3f15dc3dd1f277f618559db8725cac71ce51941ede3f87ba5e37b2f5c0daef7fdd0afa999772bc5eab3d8e5a4d06e068ab41cda71c4202652edad90726be459ab7a42b718da96266cf0744e700f537632d36ba6fed85344217d3d7a0f90aa746f52ecbee730142b4f9ec28eda8856151ac78afd5ce8d3e87e5287041c739fce778cd8193d682dc4f819e66e0852b3e9868ab06a1db9700906154f71d030d24c8067cd50ac00c3b04eae69b8ac7a14eb464780d05aca0a7cf5fe152a8f4625bfa70d005fe0cd8a32cbafedf3e9ef074ca1afee8fb93ee1394d534d8582938a4fd40a95e1e44780df232143076cd8eee9f826a01cada62e868ad2b6af2666fa56a7cb31762723513f216f243599b9a93702a3a07dd19c84caffd876b412d39bcefb1e192a10d3a28be9995ab9a4b008f0b8d7a290584b878686e393f2bbac92e8e92df476634af0ebc992181bfc89a04d4b4ec3edb518d37050380a60cda6c2b5eb63c8b9445a6df46fdaede98b70579ba6aca079bd64424dbde922311e79242e750b0e9d56f030aafd6c643b5cc3078442117565b22704a007ce0ff671d87408f1165b86c595a6a238bf0002dcc6f75ada7461077ab51490e65c22b950e90ef4665c9a47772bbc12ca307ce3f3d843b6bb8e5a4edbe148451db4c7ad3b5ea611ad601b4dedf441621d46c5046150b87cb6b75f82b785c0e66549e1c024b8ad8a35cb0965825280b21a6cc38e4d399ceb273102773157db12ba4bc1619c3e98b3359e1039313d591cc92e45f4bbb5520f079c357836f52ae9307149c5778338f7f8a8ee3b6388205706bcd48467f6ca8ead7a31925a0b0af37f5c845f54914001048601b0a81603e58759246aab376cb45a12b656a445b5d4becbd1619efe2e0cebd70df9f5cff946c2273869da9e1504af5af68cce47ea9d7935401c8f9bcfe7626bd94248d9af255fcbd541e2b60c138384bf6c431ef6774b696e94ff065021fc3511898cd905f935e3be837e61b51951cd32a3e482b4396f78a98bf0fe6d747cbb0f4586b3798f2ce0a9ab616256c9ca995cbc49b96cd5fd6385ff42695e9ddc48f00b316bf62cfcbcabb65f6eeda0cac8f72887efe069f675687bd1263751dc07bb3b9821a35223e5209d0ef45e9287a11469302a17980472494b49ee7a0354c6d378a403f09a7b93c3abad48a0b3502263a66d2e4065b7254ffdb133f79a3729643bb351ef81d35fd6c2134aa463f097a9c2a35b7bde0e1e486fd176054368da90cc2c946f1734a110acbd5c78f959d5a7e496550d0e725ba61d41dfa6ef3bc90002aa0920c7e5d052fb6667992e11fa4dba15a0c55cdcceacb21ae1a1984c4404078d3f7438c6588d9a7ddd3605ba05a9b94328b4d0986f5326c8588fb6351e0fe2052b5f1c82732c79d40bdf0fd7843b4a14d062e9312ca79a635c1f0b18a3d19404f8c5580d855cd18b46d749b443593d5bc382fd6a3ba08d64709dcb3a78966790e16cb6481ca967b5a9eb1d19223e08514ac7a9c5616dda0fdec7d4a248bbbb476c37665aa1cfacdeb371bff0688be8c4f74ae5a5f1ada5137a480be03bcb9885872f37d92d916d179e66d229a6849e71c42042d934a39387d1c47f12dc4bbe30fdd972487f08e902762c3e1337bba00e36d9d5d834274c43fd71018e7a6dfea824ce2565aa1bb3bb114b0f032cb7b561fb89e39bc38f137c7a6c17f8826f4bf6da98f173a19f85ecaaaf8b3c85b8f715e5d00e04a53caf31f9d9d3d31dffe57c96f5f48034595b69874ee76329a3352a0aaa8bdfe985ac8d460697babf4b7b97e273673c8d27e88eebfe5f5a50b2380fe5b458f71c041c7ea66753ddf630d77f199c2bfbb584f6a8079bdc23c91400af50b361f5b9e75c11c83863b4967152d9af50b68b7fef62f9b724d3d98fb7a66e916291199834f0bb9de14204514fb307c334d23697c2fdf2c759a9032d17fb70c36a68c89401f6fb4effb10dbac052fba7e174f49ff424fb29065ab62cc8138d948271ab274cf4ae36dbb4a5c9441e281671b4800446d2bf3db783de94d9a8dd056977057e357ac1a3978acf0bda9efb611603c4fd894129f2d31599924626c1af23d535eb4f54162e61f27669bc660ca3de1f1350001355c44616824b391d039ae83877e4c1ef718d15aaff394bf587f347e6c6b8c8bc1742d93874cb3050de2389bc5567926589814492ebb0394664b1c38ce7b42619dd1ebfbb0beca05bec649e06f41e49a4859efb15e52fdf5974fb98ba0141cd3aa4eca161eb52e17c6d7a8c54db4c212209dbc7320e9f9d29e1756f836d2c25914c65ac1a3422c692c06b889ff7270e2d0abb7f31c0699b744b4d7c88a30b75fb7535bb1de763edca0f77e78a41367a839fe9b78f59eee918a0e53b3f73503aa8e457b9ed81b08f9caf9e718a44b15b039f60cad1e2e27af28fecf7c102d0b9c585d99aa2b7a7ad94a4aac768f94125fa855ac7670ee5afb20e3c89dcd02a10c251807c40d158af0c84981f0a19a775b9ed05ee1cdd07a98d0c2d0130b312b6f6c93a2ef05407903b6e88829d83f1fb2ed6332c8aae226d908013ea58b7e38efb7d4b7c37b8f8c937fa91be837ddd7c885ebe389f674356dc0908f04f85fc76041df5330a88e0e028cadcb120144c2db9a71974a4756b470f2f8c0663ad6215da87fd945e1a2763d3189780fdcf9148fe97cf30455ae291f370400434ed3e2d701786bc8aa4eed4abd029bcdb4c9989cf33924467949f3a8054d516b05faba38eedf36845cac972e813d0ab8dfd10270628e8f0fc781c25fefb522a14a9e1d9f380a6e6b3763994d903af621a98e0e4b5d5f65aee7c425c6855a7a8f4030dfbea9f1c2950c012bcfbbd3bc1dff2fbf713e875e87c85b2a164b5b571bbcabe897c328c2cdc9de4f35e0370faf3488f2df5a5c6d0e636d4931ca05715196f3c6580a617ed87353c8a143e0c772a65b95022faec48129c254b9afd6841165ae0e07cb3c2da02ec87d1c7f5930cd4708b5de48c2491842f38510ecf78fe41e4df7b52ab18c310c7d29f06a59242ee1bf375ddea9bbaaaac1808683f41d47cbbaee00ff1bda7212d1194c32617761efaad48709a2e878b45a619bd78d1102d03f6cef6ebe894d0464b55f287809bf6f0b8163f5f110172526867d38521c3e3e84de3853abf7bd069abc644a5cc08d35fcd94d8b6b9178ad2fb19b03bfdeae54fa8f98347f28eda040cc4e69ff2cb862fca7a81e181ed61483b890d7226b846012605d858aded893dde2812d30775c633c4d76630b17a9ba63c1793c84e979dacc908014d524817b5b3f9057602c04e03c0de92453adfd24c30668f98116076b8d9a42c6531fd0f9ef0b5de01a3d5a1bd478488b7e4f5e6a08562bf4a7b0d0737034043a808206da60f41477b00740e4aecfd95e244a5d56908385546146b8444ad74661124ebc58f13956fbd1463c5bfd929a7486defb819a99b3fecebebebf217d4af9fe37e503d47fb859c9186d4c82746e1aa428501c9ba2eccc0be5d7bf4045f660b1a4d1f636e6ad991e91a5b7ea674764054da2fb541791eb6b79df31a102a2bb892f730677eab41d473751aab7862a259e0d9f63d53faa44e7137948f4fe4a149770b024488e0e5d51a1ac03a8276a8e08dcb050d4558954381557c3d665c92fd5b8849a40d803d30e3af6f86a384d354d6f0999e07635eae1f94274a3134373151dcce7243cea3dc7b7f3d8740508d14fc8d93642c69976d07dbf61a479da482ca0555013e808fdd07831b8a80ad1883fa828e039f054204bda638f62c9ddec699da411a86a4f2975a1887201c6e41044d7eef08b2ea3752b5cb406394c8c5c1eea98d4a840fa32b9e0417fc31fab0481c3f5d622155159fa088b3e436febd3a3c4b8784518ae4d03a283e3883335f1a6cb45a3af5db1fccf85de5c39be41c7036777a1e0ceb21931c6ad638b365ecfb4ed34de8fc3b16c3f9c3a004368cc73326d14c77aa6ad35fdf4a29e68598d776b9122b2fdcef96e24f12654ce65b05104d3bf44e750253f1a3f7d061383d13242a54a4a4768669c4360f5741f263caf7c33cf4bf23e0a930fe2b5a237f2c307a0179230a31411fe6219be3327b4ec8ec72039e62469962d6c336d57ba6abb7c9e6889fc40dc4359cd69ec51865863822fe75e2cb2ddf22f24219fa5f07f9cb7f7e33333593cc3550e0b44331a0b7f5c5278000fd54f94bac657281901bfaf44e2a656dec17a1a173e8eef614e356eff4b4c276ad28eed83c90002458ca5ed0132e05e93f3cee7916d74aa2f3a7cf6442fc8161c709481ee2035e021a6a32285dc357c51f46f368b0be157385435547c930918387edd58d37747b9cce0d232ebd9821e7607e7991dcfb87c30c7e223fd958c70f8fde82ed1d666fec08c9065105f6bc129bcfbd92088f5e7725c86921932fc852e7ff0f95619e04a086cb1f1e67179e8de64f0cae884aff7c1f1182ff13f454f7b88c251c78f3be6c7b9cca99e30c9324d4d8cf618dde4032ccd082486173b8adb9dee9b05e6be36d0b84171e99f20923475af59e21a0f9f4cf21729442bdc5d48694e6e01e0b05d185f742ff14bb189c14ef4ba1563554b00fc771bbd56937d37961aa8e78ae07f0959adb68ce20b90e411cc4adb9e8d1106ebc3774449591a54d94c4582e0d9f9cb11fd2ff2a3f20b1306c2f7f556d208b4bded6725655ed2288c0ca755b1d82a5cc1e916c8331f01e234e9b2856518565a635f481518b0ad87c4caeed045eee27e27ebeccf1b26163f3c69d8a0309d36a443779a414acb94b587e5627bb744474d2bac2c8bca1550551cbaa76d20c5e1c784d1f08cb981c38cd83dd0c3eed71663453cf79ba663b673958e96b9234ba94d4ffe6d425f453ac7c96557c5bf6d4a65dccc59924d6c370dd53ea8656c9e85148d0bba2fba4e61a34927d9272f8618b0858b23097aaded4bfa3e5dde4b6991d713c74441c44866036b2eddd560fac3851ac7d98515d4cb261c11a952f15fab1a9e3dc0b562f30533a593c3669a12d92a02512c5d1da97a39044b16fda9ba60ed4ac736361ef20a4d9244507f3e3e0cab45fc99e5eaa0eb92020fe409ca0c39d9ffc100e54169f118941c80ddff0cf16087198a421e96041cdf641cdfef1326d4c3f43d9fe08109ba4611c174034b34175dec788dc6a6a022b44b7110dd6d53a11a16ba5e50b547524493e5f9e90b3671ebe4f07162c4153e5260a5bb0c2775440cae14fe65722c16c45272f6e0f94cacccc67158d370b1ccc82401e50385f9b138052278b7be077d9967447823dd2834a3cfab66064b1a8a3200bd1fa8abb5a4b7dade12173de0709dcdf456a3bab0e49c9dd94aa2c2a662960b5e6ee2805a3f6ba71b24ea31e6f7d9da61a25be271f7b24b2b93887bddf0eab4f38ff5f3344d7665927065420b61949605a6567a61f2b5c0d5b1af80bcbf4d1fdfd23ce475b612bf754560fd5ccc5e583be32e8ae75b6d07c4c4819a7342aac4af4db19a2fc18f2c0d0c786bb537e94f743eae787de06e724f7848e7a52009fbffd4f09c57717354f5daca3159ccb6d016515cc3aa2766b33d2fb6dafb59f42215b51c48fd6efb5c221849ddb77a12d21b272da192d3f2e5dbc32ebcb106e05ed8713fd32bd3505fe3f97d270671bb8bdf68c22c7c7a3141cf028c25729dd08a3644b19845ae71598bd879909ca6c4a68e7839eb73c433e9edb0d41ea5c3eb2989dc3a0d825bbfac119c1e41aa87d7d5878fd43ce8b16e84ccff16e76fe11c79e3fa7b2dd03ddc7c46c5e433efb0a817868027bbe7e1dedbd12a0c3f57d51c21bd3bb1771c0341290e24cc432d0caba53c4957348a8249f72ca3edf89f73dce5087828409583d470262fe3515ba4f11193eb881adc659e6e62bd52c73d60d7927e7c0ac2ab60dfd7e17ef7d10fccac1ccddec8e7e053ad1c746a996881d4ecfdd561fccfba113fb17c68d56ac3ecd36fba905745846c570ebdb25206dffb08b4c57b39b0cfd45f1689679bd073f5c3d89b0
  
    
      
      
        请输入正确密码后查看
      
    
  

]]></content>
      <categories>
        <category>便笺</category>
      </categories>
      <tags>
        <tag>频繁查阅</tag>
      </tags>
  </entry>
  <entry>
    <title>手机调试代码</title>
    <url>/2021/09/09/%E6%89%8B%E6%9C%BA%E8%B0%83%E8%AF%95%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[Ⅰ 魅族*#*#4636#*#* – 显示手机信息、电池信息、电池记录、使用统计数据、WiFi 信息
*#*#7780#*#* – 重设为原厂设定，不会删除预设程序，及 SD 卡档案
*2767*3855# –重设为原厂设定，会删除 SD 卡所有档案
*#*#34971539#*#* –显示相机相机韧体版本，或更新相机韧体
*#*#7594#*#* –当长按关机按钮时，会出现一个切换手机模式的窗口，包括： 静音模式、飞航模式及关机，你可以用以上代码，直接变成关机按钮
*#*#273283*255*663282*#*#* –开启一个能让你备份媒体文件的地方，例如相片、声音及影片等
*#*#197328640#*#* –启动服务模式，可以测试手机部分设置及更改设定 WLAN、 GPS 及蓝牙测试的代码
*#*#232339#*#* 或 *#*#526#*#* 或 *#*#528#*#* – WLAN 测试
*#*#232338#*#* – 显示 WiFi MAC 地址
*#*#1472365#*#* – GPS 测试
*#*#1575#*#* – 其它 GPS 测试
*#*#232331#*#* – 蓝牙测试
*#*#232337#*# – 显示蓝牙装置地址
*#*#8255#*#* –启动 GTalk 服务监视器 显示手机软件版本的代码
*#*#4986*2650468#*#* – PDA、 Phone、 H/W、 RFCallDate
*#*#1234#*#* – PDA 及 Phone *#*#1111#*#* – FTA SW 版
*#*#2222#*#* – FTA HW 版本
*#*#44336#*#* – PDA 、Phone、 CSC、 Build Time、 Changelist number 各项硬件测试
*#*#0283#*#* – Packet Loopback
*#*#0*#*#* – LCD 测试
*#*#0673#*#* 或 *#*#0289#*#* – Melody 测试
*#*#0842#*#* – 装置测试，例如振动、亮度
*#*#2663#*#* – 触控屏幕版本
*#*#2664#*#* – 触控屏幕测试
*#*#0588#*#* – 接近感应器测试
*#*#3264#*#* – 内存版本
Ⅱ 小米*#*#64663#*#*  综合测试指令*#*#4636#*#*  显示手机信息、电池信息、电池记录、使用统计数据、WiFi信息*#*#7780#*#*  重设为原厂设定，不会删除预设程序，及SD卡档案。*2767*3855#  重设为原厂设定，会删除SD卡所有档案。*#*#34971539#*#*  显示相机相机韧体版本，或更新相机韧体*#*#7594#*#*6  当长按关机按钮时，会出现一个切换手机模式的窗口，包括:静音模式、飞航模式及关机，你可以用以上代码，直接变成关机按钮。*#*#273283*255*663282*#*#*  开启一个能让你备份媒体文件的地方，例如相片、声音及影片等*#*#197328640#*#* 启动服务模式，可以测试手机部分设置及更改设定  ;WLAN、GPS及蓝牙测试的代码*#*#232339#*#*或*#*#526#*#*或*#*#528#*#*–WLAN测试*#*#232338#*#*–显示WiFiMAC地址*#*#1472365#*#*–GPS测试*#*#1575#*#*–其它GPS测试*#*#232331#*#*–蓝牙测试*#*#232337#*#–显示蓝牙装置地址*#*#8255#*#*启动GTalk服务监视器显示手机软件版本的代码*#*#4986*2650468#*#*–PDA、Phone、H/W、RFCallDate*#*#1234#*#*–PDA及Phone*#*#1111#*#*–FTASW版本*#*#2222#*#*–FTAHW版本*#*#44336#*#*–PDA、Phone、csc、buildTime、anzhi.name、changelistnumber各项硬件测试*#*#0283#*#*–PacketLoopback*#*#0*#*#*–LCD测试*#*#0673#*#*或*#*#0289#*#*–Melody测试*#*#0842#*#*–装置测试，例如振动、亮度*#*#2663#*#*–触控屏幕版本*#*#2664#*#*–触控屏幕测试*#*#0588#*#*–接近感应器测试*#*#3264#*#*–内存版本    
Ⅲ 华为*#*#4636#*#* - 当前手机号码、IMEI信息、信号强度、所使用的网络类型、电池信息、各种程序使用统计数据、WiFi信息等；输入*#06#，会显示本机的IMEI国际通信识别码，这个可用于查询手机是否行货水货。
*#*#2846579#*#* - 工程模式，依次点击ProjectMenu、单板基本信息的查询、器件型号查询，即可获知挑选手机配备的各项元件的详细型号。
*#*#197328640#*#*  - 启动服务模式，可以测试手机部分设置及更改设定WLAN、 GPS 及蓝牙测试的代码。*#*#232339#*#*或 *#*#526#*#*或*#*#528#*#*     WLAN 测试*#*#232338#*#* - 显示 WiFi MAC 地址。  *#*#1472365#*#* - GPS 测试。  
*#*#1575#*#* - 其它 GPS 测试。*#*#232331#*#* - 蓝牙测试。*#*#232337#*# - 显示蓝牙装置地址。*#*#4636#*#* - 显示手机信息、电池信息、电池记录、使用统计数据、WiFi 信息。*#*#7780#*#* - 重设为原厂设定，不会删除预设程序，及 SD 卡档案。     
*2767*3855# - 重设为原厂设定，会删除 SD 卡所有档案。        
*#*#34971539#*#* - 显示相机相机韧体版本，或更新相机韧体。*#*#7594#*#* - 当长按关机按钮时，会出现一个切换手机模式的窗口，包括: 静音模式、飞航模式及关机，你可以用以上代码，直接变成关机按钮。*#*#273283*255*663282*#*#* - 开启一个能让你备份媒体文件的地方，例如相片、声音及影片等。*#*#8255#*#* -  启动 GTalk 服务监视器显示手机软件版本的代码。*#*#4986*2650468#*#* - PDAPDA、 Phone、 H/W、 RFCallDate*#*#1234#*#*- PDA 及 Phone。  *#*#1111#*#* - FTA SW 版本。*#*#2222#*#* - FTA HW 版本。*#*#44336#*#* - PDA 、Phone、 CSC、 Build Time、 Changelist number各项硬件测试。*#*#0283#*#* - Packet Loopback  
*#*#0*#*#* - LCD 测试。*#*#2663#*#* - 触控屏幕版本。*#*#2664#*#* - 触控屏幕测试。*#*#0588#*#* - 接近感应器测试。*#*#0673#*#*或 *#*#0289#*#*Melody 测试*#*#0842#*#* – 装置测试，例如振动、亮度。  *#*#3264#*#*         内存版本
Ⅳ OPPO*#06# 手机串号
*#99# 打开/关闭屏幕常亮
*#800# log-test
*#801# 工程模式开关，全端口开关，Serial
*#802# TTFF
*#803# WLAN设置
*#804# 自动搜索
*#805# 工程模式 蓝牙测试
*#806# 自动老化 测试
*#807# 自动测试
*#808# 手动测试
*#809# 回音测试
*#888# 主板的PCB号
*#1234# 可查询硬件代码和手机版本
*#6776# 可查询手机版本、出厂信息等（几乎为手机全部信息）
*#8778# 总清除（重置手机）
*#36446337# 进入工程模式
*#*#4636#*#* 进入手机、电池、网络设置信息
*#2323# 显示3 g网络开关
…*,*#*#4636#*#* 调手机信息改网络制式(T版用联通卡时)
Ⅴ 一加*#99#:打开/关闭屏幕常亮*#888#:查看硬件版本*#1234#:查看软件版本*#06#:查看本机ID*#6776#:本机出厂日期*#807#:自动测试*#808#:原厂设定*#8778#:恢复原厂设置*#900# 蓝牙开启*#901# 蓝牙关闭*#4321# 蓝牙模式却换*#*#4636#*#*显示手机信息，电池信息，电池记录，使用统计数据，wifi信息(安卓通用指令)*2767*3855# 重设为原厂设定，会删除SD卡所有档案。*#*#7594#*#*6 当长按关机按钮时，会出现一个切换手机模式的窗口，包括:静音模式、飞航模式及关机，你可以用以上代码，直接变成关机按钮。*#*#273283*255*663282*#*#* 开启一个能让你备份媒体文件的地方，例如相片、声音及影片等*#*#197328640#*#*启动服务模式，可以测试手机部分设置及更改设定WLAN、GPS及蓝牙测试的代码*#*#232339#*#*或*#*#526#*#*或*#*#528#*#*–WLAN测试*#*#232338#*#*–显示WiFiMAC地址*#*#1472365#*#*–GPS测试*#*#1575#*#*–其它GPS测试*#*#232331#*#*–蓝牙测试*#*#232337#*#–显示蓝牙装置地址*#*#8255#*#*启动GTalk服务***器显示手机软件版本的代码*#*#4986*2650468#*#*–PDA、Phone、H/W、RFCallDate*#*#1234#*#*–PDA及Phone*#*#1111#*#*–FTASW版本*#*#2222#*#*–FTAHW版本*#*#44336#*#*–PDA、Phone、csc、buildTime、anzhi.name、changelistnumber各项硬件测试*#*#0283#*#*–PacketLoopback*#*#0*#*#*–LCD测试*#*#0673#*#*或*#*#0289#*#*–Melody测试   
Ⅵ 努比亚*#805# - 自带的系统测试模式*#*#4636#*#* - 显示手机信息、电池信息、电池记录、使用统计数据、WiFi信息等*#406# - 校准屏幕代码*#06#查看IMEI码，也就是手机序列号(国际移动装备辨识码)*#7678#，打开后两个勾勾上即可-工程端口打开(线刷时用到)*#1208888999# - 查看系统版本*#776# - 红外感应校准*#777# - 接近传感器校准(可用于校准通话黑屏亮屏的问题)*#632# - NFC测试*#8615# - 蓝牙/WiFi/GPS测试*#8605# - 所有硬件测试*#8604# - 各个模块测试*#8607# - 内存容量测试*#8612# - 收音机测试*#8688# - 格式化内置存储(此代码一旦执行即不可逆，数据无价，请勿尝试)*#746# - 双卡测试*#983564# - 抓log用*#94884# - 主题相关
]]></content>
      <categories>
        <category>便笺</category>
      </categories>
      <tags>
        <tag>硬件与系统</tag>
      </tags>
  </entry>
  <entry>
    <title>接口interface</title>
    <url>/2021/07/22/%E6%8E%A5%E5%8F%A3interface/</url>
    <content><![CDATA[接口，比抽象类还要抽象的类:

接口中的方法会被隐式的指定为  public abstract （只能是 public abstract，其他修饰符都会报错）。
接口中的变量会被隐式的指定为  public static final   变量（并且只能是 public，用 private 修饰会报编译错误。）
接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。


定义接口定义接口不再使用class关键字，而是interface[修饰符] interface 接口名 extends 父接口1,父接口2...&#123;    常量	抽象方法	内部类、接口、枚举	方法&#125;
接口中的成员变量始终默认添加public static final修饰符public interface interfaceTest &#123;//    成员变量始终添加public static final修饰符    String name = &quot;默认&quot;;//    等同于public static final String name = &quot;默认&quot;;&#125;
接口中的方法public interface interfaceTest &#123;//    抽象方法methods()，默认添加public abstract    void methods();	//    j8开始允许有static方法，所以接口可以直接运行，可以省略访问权限控制符不写，默认添加public    static void main(String[] args)&#123;        System.out.println(&quot;Hi~&quot;);    &#125;	//    若要创建默认方法，就得把static改成default，default并无实际作用，仅用于抵消abstract//    接口的默认方法其实就是实例方法，由于早期接口中的实例方法不能有方法体不能直接推到    default void test()&#123;        System.out.println(&quot;实例方法&quot;);        this.test2();    &#125;	//    私有方法	private static void foo()&#123;//    从java9开始，接口允许私有静态方法    &#125;    private void bar()&#123;//    从java9开始，接口允许私有默认方法    &#125;&#125;
接口的继承接口支持多继承public interface inter1 extends inter2,inter3,inter4&#123;    &#125;interface inter2&#123;&#125;interface inter3&#123;&#125;interface inter4&#123;&#125;接口不能显式继承任何类(隐式继承Object)
类使用接口public class 类名 extends 父类 implements 接口1,接口2,接口3&#123;//    与继承父类一样，可以获得接口内的常量、方法&#125;
使用接口的类必须重写接口的全部抽象方法
public class public_test implements interfaceTest &#123;    public static void main(String[] args) &#123;    &#125;	@Override    public void main2()&#123;    &#125;&#125;interface interfaceTest &#123;    void main2();    default void main3()&#123;//    非抽象方法，不必须重写    &#125;&#125;
接口和抽象类相同

都不能被实例化
都可以包含抽象方法

不同

接口只能包含抽象方法、静态方法、默认方法和私有方法，不能为普通方法提供实现；抽象类可以包含普通方法
接口只能定义静态常量，不能定义普通成员变量；抽象类能定义静态常量，也能定义普通成员变量
接口不包含构造器；抽象类可以包含构造器，用于让子类调用构造器完成初始化操作
接口不能包含初始化块；抽象类能包含初始化块
一个类只能继承一个类；一个类可以实现多个接口

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>抽象类abstract</title>
    <url>/2021/07/22/%E6%8A%BD%E8%B1%A1%E7%B1%BBabstract/</url>
    <content><![CDATA[
抽象类与抽象方法必须用abstract修饰(与final互斥)，抽象方法不可有方法体
抽象类不可被实例化，不能用于创建对象
抽象类包括成员变量、方法(普通方法和抽象方法)、构造器、初始化块、内部类，主要用于派生子类
抽象类的子类要么重写父类的全部抽象方法，要么只能定义为抽象类


public class abstractTest &#123;    public static void main(String[] args)&#123;//        用抽象类创建对象时，只能用其子类向上转型        铠甲勇士2 炎龙技能类型 = new 炎龙铠甲2();        铠甲勇士2 风鹰技能类型 = new 风影铠甲2();        炎龙技能类型.铠甲技能2();        风鹰技能类型.铠甲技能2();    &#125;&#125;

abstract抽象类最主要的功能：派生子类，abstract与final互斥
相对于普通类，abstract类多了abstract方法，抽象类不可实例化，即不能被分配内存、不能创建对象
static修饰的方法属于类本身，必须被分配内存，static和abstract不可同时修饰一个方法

abstract class 铠甲勇士2&#123;//    抽象方法    public abstract void 铠甲技能2();//    public abstract static void main()&#123;//        System.out.println(&quot;测试&quot;);//    &#125;    public void 非抽象()&#123;//        非抽象方法，不必须重写    &#125;&#125;
抽象类的子类，要么重写父类的全部抽象方法，要么也是抽象类
class 炎龙铠甲2 extends 铠甲勇士2 &#123;    @Override    public void 铠甲技能2() &#123;        System.out.println(&quot;封魔斩&quot;);    &#125;&#125;class 风影铠甲2 extends 铠甲勇士2 &#123;    @Override    public void 铠甲技能2() &#123;        System.out.println(&quot;穿风刺&quot;);    &#125;&#125;abstract class 帝皇铠甲 extends 铠甲勇士2&#123;//    抽象类&#125;
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>电脑基本操作（一）</title>
    <url>/2022/09/11/%E6%95%99%E6%88%91%E7%88%B8%E7%8E%A9%E7%94%B5%E8%84%91%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[开机键&ensp;&ensp;开机键一般在电脑的右上角，不同电脑型号可能开机键的位置也不一样，下图的右上角箭头指的位置是咱家电脑的开机键位置，点击它就可以给电脑开机了。
笔记本电脑自带的键盘&ensp;&ensp;笔记本电脑自带的键盘一眼就能看见，它是不需要做任何连接的，电脑开机就能使用这个键盘
触摸板&ensp;&ensp;触摸板的位置一般在笔记本电脑自带键盘的前面，一块向下凹的区域，它等同于鼠标的作用
USB接口&ensp;&ensp;U大部分鼠标和键盘就是通过USB接口才能连接到电脑，在成功连接电脑后，我们的鼠标和键盘才能正常工作，下面演示一下鼠标和键盘怎么连接电脑。&ensp;&ensp;下图是键盘的USB接口
&ensp;&ensp;一般情况下，在笔记本电脑的侧面会有对应的插入接口（笔记本电脑的左侧和右侧可能都有）
&ensp;&ensp;将键盘的USB接口插入
&ensp;&ensp;鼠标的接口和键盘一样，所以就不重复了
电源&ensp;&ensp;笔记本电脑虽然可以离开电源工作，但是性能会变得很差，所以在使用时，非必要情况下尽量连接电源
个人建议&ensp;&ensp;这里不建议使用笔记本自带的键盘和触摸板，因为笔记本自带的键盘很容易损坏，而触摸板相对于鼠标而言并不好用，所以大部分情况下我们应该通过USB接口连接其他的键盘和鼠标
]]></content>
      <categories>
        <category>便笺</category>
      </categories>
  </entry>
  <entry>
    <title>电脑基本操作（三）</title>
    <url>/2022/09/12/%E6%95%99%E6%88%91%E7%88%B8%E7%8E%A9%E7%94%B5%E8%84%91%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[鼠标按键示例图&ensp;&ensp;我们就拿一般的鼠标来举例，一般的鼠标只有三个按键：左键，右键，滚轮键
左键&ensp;&ensp;相当于选中键、打开键，点击谁就选中谁，双击谁就打开谁，注意，一般情况下，只有“打开一个新窗口”（“窗口”在第二章有提到）的时候才需要双击
右键&ensp;&ensp;右键为属性键，可以打开鼠标箭头当前所指的东西的属性，比在桌面上，在不同的文件或者窗口下，点击鼠标右键会有不同的属性和操作，比如可以删除文件、复制粘贴等
滚轮键&ensp;&ensp;滚轮键相当于手机里的上下滑动，虽然也可以点击，但是一般不会点它，只用作上下滑动，比如当窗口一侧显示有进度条的时候，可以上下滑动滚轮键
&ensp;&ensp;现在的鼠标上还有其他的功能键，后面用到的时候再做了解
]]></content>
      <categories>
        <category>便笺</category>
      </categories>
  </entry>
  <entry>
    <title>电脑基本操作（二）</title>
    <url>/2022/09/11/%E6%95%99%E6%88%91%E7%88%B8%E7%8E%A9%E7%94%B5%E8%84%91%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[开机&ensp;&ensp;首先点击右上角的开机键给电脑开机
输入密码&ensp;&ensp;开机后，静待10-20秒，将会进入输入密码的页面，也就是锁屏页面
&ensp;&ensp;此时点击键盘的任意一个按键（我习惯点击键盘上最宽的那个按键，叫空格键）或者使用鼠标点击电脑任意位置，将会显示出输入密码的输入框
&ensp;&ensp;在这个输入框中输入密码，密码输入完成后，点击回车键就能进入电脑里的主页面了，下图是输入密码和回车键
&ensp;&ensp;如果密码输入正确，那我们将会进入系统的主页面，也叫“桌面”（桌面这个专业性名词在后面会经常用到，牢记），我们安装的软件一般会在桌面上出现一个图标，像手机安装的软件一样上边是图标下边是软件名，但是与手机不同的是，电脑需要使用鼠标左键连续点击两次才能打开软件（特别快速的点击两次鼠标左键）
打开一个软件&ensp;&ensp;如果想打开一个软件，比如微信，先用右手移动鼠标，会发现电脑上有个箭头跟随鼠标移动，把箭头放在图标上
&ensp;&ensp;然后对准图标连续点击两次鼠标左键，就打开了一个“窗口”（窗口这个专业性名词在后面会经常用到，牢记），这个“窗口”里显示的东西就是软件所展示的内容了
关掉软件&ensp;&ensp;用鼠标点击窗口右上角的“×”号，就可以关掉软件了
关机&ensp;&ensp;关机和开机不一样，如果用开机的按钮关机，虽然也可以关掉，但是属于强制关机，对电脑不好，所以平时关机可以这样关
&ensp;&ensp;第一步，先点击桌面左下角的四方块
&ensp;&ensp;第二步，把鼠标箭头放在这里点一下
&ensp;&ensp;最后点这里就可以关机了
]]></content>
      <categories>
        <category>便笺</category>
      </categories>
  </entry>
  <entry>
    <title>电脑基本操作（四）</title>
    <url>/2022/09/13/%E6%95%99%E6%88%91%E7%88%B8%E7%8E%A9%E7%94%B5%E8%84%91%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
    <content><![CDATA[&ensp;&ensp;键盘的按键使用详解，下面的内容我们得在一个可以输入文字的地方才能看见效果，所以现在需要按照以下步骤创建一个文本文档
&ensp;&ensp;在桌面（什么是桌面在第二章有讲）点击鼠标右键，会出现一个操作栏，然后点击操作栏中的“新建”，然后点击“文本文档”
&ensp;&ensp;然后就创建了一个“文本文档”，这个时候可以对它进行重命名，如果不需要重命名或者想以后再重命名，直接用鼠标左键双击它的图标就好了
&ensp;&ensp;然后会发现打开了一个这种窗口，在这里面可以随意输入文字
26个字母&ensp;&ensp;这也就是我们打字用到的最多的按键，26个字母
阿拉伯数字&ensp;&ensp;这张图盘里圈起来的部分是从0-9还有小数点
&ensp;&ensp;这边也能按出来0-9，但是没有小数点
功能键&ensp;&ensp;最上面的F1-F12叫功能键，一般很少会用到，在一些特定的软件中可能会被赋予特定的功能，所以不需要太在意这12个按键
&ensp;&ensp;这边的九个按键咱们先不管，以后用到的时候会慢慢说，因为还不知道这九个按键的功能，所以尽量小心不要按到
&ensp;&ensp;上下左右移动，比如在打字的时候，点击上下左右可以移动打字的位置
退出键&ensp;&ensp;最左上角的“ESC”叫退出键，可以通过它退出一些场景，比如在全屏看电影、玩游戏的时候可以退出全屏，反正如果想退出或者关闭什么东西但是找不到“×”号的时候，就点ESC试试
制表键&ensp;&ensp;这个写着“TAB”的就是制表键，这个键在日常使用中也很少用到，所以暂时不用了解
大写锁定键&ensp;&ensp;开启大写锁定键之后，再按键盘上的字母就只会出现大写英文字母，不能打字，可以通过右边的三个指示灯来判断是不是开启了大写锁定
上档键&ensp;&ensp;上档键在键盘上有左右两个，两个上档键的功能一模一样，上档键比较重要，而且功能很多很麻烦，下面一点点说
上档键切换中英文模式&ensp;&ensp;我们平时打字的时候，有中文和英文两种模式，在屏幕的右下角可以看现在打字出现的是什么，如果显示“中”说明现在可以用拼音拼出来中文，反之输入的是小写英文，这里有一个前提是大写锁定键（写着“Caps Lock”的键，上面刚刚讲过）没有开，如果开启了大写锁定键那输入的一定是大写英文
&ensp;&ensp;点击上档键（SHIFT）就可以做到中英文模式切换，或者也可以用鼠标去右下角点击那个“中”字也可以切换
配合其他键使用&ensp;&ensp;上档键最大的功能就是配合其他按键使用，比如下图中圈起来的这些按键，这些都有一个明显的特点：同一个按键显示上下两种不同的内容，如果单独点击他们的时候，出现的就是下面的内容，当按下SHIFT上档键的同时（不要松开），再按这些键，出现的就是上面的内容
&ensp;&ensp;现在演示一下，比如键盘左上角的“1”
&ensp;&ensp;我们在打字的时候，点击这个“1”，将会输入“1”，但是如果先按住SHFTE上档键的同时（不要松开）再点击“1”，将会输入一个感叹号“！”
控制键&ensp;&ensp;CTRL键在键盘上也有两个，它的主要功能也是和其他按键组合发挥，比如按住CTRL再按A就实现全部选中，按住CTRL再按C就可以复制，然后再按住CTRL按V就可以粘贴，目前就先说这三个使用方式，后面用到的地方再讲
转换键&ensp;&ensp;ALT转换键在键盘上同样有两个，大多数情况下与其他按键组合用，在这个按键在以后用到的地方再讲
Windows徽标键&ensp;&ensp;一般上边不写字，会画一个不规则的方块，单独点击它的时候，跟用鼠标点击屏幕左下角的方块功能一样，它也可以配合其他键使用，比如按住Windows徽标键再按D可以把所有窗口最小化，快速回到桌面
空格键&ensp;&ensp;那个啥也没写的最大的按键就是空格键，点击空格键会打出一个小空格，在输入中文的时候，按空格键会将选中部分的字直接打出来
回车键&ensp;&ensp;有些键盘的回车键会写一个“Enter”，有些会有一个拐弯的箭头“↵”，不过它的位置不会变，打字的时候点击回车符会换行输入，在其他地方回车符一般作为“确定键”
删除键&ensp;&ensp;有些键盘的删除键会写“Back Space”，有些会有一个向左的箭头“←”，跟手机上打字的删除键一样用
小键盘锁定键&ensp;&ensp;小键盘锁定键“Num Lock”，一般都在开启状态，点击关闭后右边的的数字将不能使用，可以通过键盘的第一个等判断它的开关状态，灯亮为开，灯灭为关
属性键&ensp;&ensp;属性键相当于鼠标的右键，一般用不到
其他符号键&ensp;&ensp;剩下的就是一些符号键了，逗号问号啥的，有些需要配合SHIFT上档键使用
]]></content>
      <categories>
        <category>便笺</category>
      </categories>
  </entry>
  <entry>
    <title>数学常用公式定理1</title>
    <url>/2021/12/30/%E6%95%B0%E5%AD%A6%E5%B8%B8%E7%94%A8%E5%85%AC%E5%BC%8F%E5%AE%9A%E7%90%861/</url>
    <content><![CDATA[数学常用公式定理2
数学常用公式定理3
数学常用公式定理4
数学常用公式定理5
数学常用公式定理6


三角函数
正弦：$\sin A = \frac{a}{c} $&ensp;&ensp;余弦：$\cos A = \frac{b}{c} $
正切：$\tan A = \frac{a}{b} $&ensp;&ensp;余切：$\cot A = \frac{b}{a} $
正割：$\sec A = \frac{c}{b} $&ensp;&ensp;余割：$\csc A = \frac{c}{a} $

基本关系
$ \sec A = \frac{1}{\cos A} $
$ \csc A = \frac{1}{\sin A} $
$ \cot A = \frac{1}{\tan A} $
$ \sin ^{2}A + \cos ^{2}A = 1 $
$ \tan ^{2}A + 1 = \sec ^{2}A $
$ \tan A = \frac{\sin A}{\cos A} $
$ \cos 2A = \cos ^{2} A - \sin ^{2} A = 1 - 2\sin ^{2} A = 2\cos ^{2} A - 1 $
$ \sin 2A = 2\sin A \times \cos A $
$ \csc ^{2} A = \frac{1}{\sin ^{2} A}  = \frac{\cos ^{2} A + \sin ^{2} A}{\sin ^{2} A} = \frac{\cos ^{2} A}{\sin ^{2} A} + 1 = \cot ^{2}A + 1 $
$ \cos (\alpha \pm  \beta ) = \cos \alpha \cos \beta \mp \sin \alpha \sin \beta  $
$ \sin (\alpha \pm \beta ) = \sin \alpha \cos \beta \pm \cos \alpha \sin \beta  $

基本属性




正弦函数
余弦函数
正切函数
余切函数




定义域
$R$
$R$
$x$不等于$k\pi + \frac{\pi}{2} $
不等于$k\pi $


值域
$[-1,1]$
$[-1,1]$
$R$
$R$


奇偶性
奇函数
偶函数
奇函数
奇函数


单调性


单调递增
单调递减


周期
$2\pi$
$2\pi$
$\pi$
$\pi$


$x=0$时
$0$
$1$
$0$
无意义


$x=\frac{\pi}{6}时$
$\frac{1}{2}$
$\frac{\sqrt {3}}{2}$
$\frac{\sqrt {3}}{3}$
$\sqrt {3}$


$x=\frac{\pi}{4}时$
$\frac{\sqrt {2}}{2}$
$\frac{\sqrt {2}}{2}$
$1$
$1$


$x=\frac{\pi}{3}时$
$\frac{\sqrt {3}}{2}$
$\frac{1}{2}$
$\sqrt {3}$
$\frac{\sqrt {3}}{3}$


$x=\frac{\pi}{2}时$
$1$
$0$
无意义
$0$


$x=\pi$时
$0$
$-1$
$0$
无意义


图像








和差化积公式
$\sin \alpha + \sin \beta = 2\sin \frac{\alpha + \beta }{2} \cos \frac{\alpha - \beta }{2} $
$\sin \alpha - \sin \beta = 2\cos \frac{\alpha + \beta }{2} \sin \frac{\alpha - \beta }{2} $
$\cos \alpha + \cos \beta = 2\cos \frac{\alpha + \beta }{2} \cos \frac{\alpha - \beta }{2} $
$\cos \alpha - \cos \beta = -2\sin \frac{\alpha + \beta }{2} \sin \frac{\alpha - \beta }{2} $
$\tan \alpha + \tan \beta = \frac{\sin \left ( \alpha + \beta \right )}{\cos \alpha \cos \beta } $
$\tan \alpha - \tan \beta = \frac{\sin \left ( \alpha - \beta \right )}{\cos \alpha \cos \beta } $
$\cot \alpha + \cot \beta = \frac{\sin \left ( \alpha + \beta \right )}{\sin \alpha \sin  \beta } $
$\cot \alpha - \cot \beta = -\frac{\sin \left ( \alpha - \beta \right )}{\sin \alpha \sin  \beta } $
$\tan \alpha + \cot \beta = \frac{\cos \left ( \alpha - \beta \right )}{\cos \alpha \sin  \beta } $
$\tan \alpha - \cot \beta = -\frac{\cos \left ( \alpha + \beta \right )}{\cos \alpha \sin  \beta } $

积化和差公式
$\sin \alpha \cos \beta = \frac{1}{2} \left [ \sin (\alpha + \beta ) + \sin (\alpha - \beta ) \right]$
$\cos \alpha \sin \beta = \frac{1}{2} \left [ \sin (\alpha + \beta ) - \sin (\alpha - \beta ) \right]$
$\cos \alpha \cos \beta = \frac{1}{2} \left [ \cos (\alpha + \beta ) + \cos (\alpha - \beta ) \right]$
$\sin \alpha \sin \beta = -\frac{1}{2} \left [ \cos (\alpha + \beta ) - \cos (\alpha - \beta ) \right]$

反三角函数




反正弦函数
反余弦函数
反正切函数
反余切函数




函数式
$y = \arcsin X$
$y = \arccos X$
$y = \arctan X$
$y = \operatorname{arccot} X$


定义域
$[-1,1]$
$[-1,1]$
$R$
$R$


值域
$[-\frac{\pi }{2} ,\frac{\pi }{2} ]$
$[0,\pi]$
$(-\frac{\pi }{2} ,\frac{\pi }{2} )$
$(0,\pi)$


奇偶性
奇函数
非奇非偶
奇函数
非奇非偶


图像








对数公式
$ $
\begin{matrix}
a^x=N (a>0,且a≠1) \\
\Downarrow \\
x=log_{(a)}(N)
\end{matrix}
$ $


对数恒等式对数第一恒等式

$ $
\begin{align*}
a^{\log_{a}{N} } = N
\end{align*}
$ $


对数第二恒等式

$ $
\begin{align}
\log_{a}{a^{b} } & = b
\end{align}
$ $


对数推导公式
$ \log_{a}{(MN)} = \log_{a}{M} + \log_{a}{N} $
$ \log_{a}{\frac{M}{N} } = \log_{a}{M} - \log_{a}{N} $
$ \log_{a}{M ^{n} } = n\log_{a}{M}  $
$ \log_{a ^{n}}{M} = \frac{1}{n} \log_{a}{M}  $
$ \frac{\log_{c}{b} }{\log_{c}{a} } = \log_{a}{b} $
$ \log_{a}{b} = \frac{1}{\log_{b}{a}}  $
$ a^{x} = e^{x\ln_{}{a} }  $

极限公式定理与性质极限存在定理&ensp;&ensp;函数$f(x)$当$x \to x_0$时极限存在的充分必要条件是左极限和右极限各自存在且相等，即

$ $
\begin{align*}
\lim_{x \to x_0^+}f(x)=\lim_{x \to x_0^-}f(x)
\end{align*}
$ $


因此，即使左右极限都存在，但若不相等，则$\lim_{x \to x_0}f(x)$也不存在
单调有界定理&ensp;&ensp;单调有界数列必有极限，如果一个数列单调递增且有上界，或单调递减且有下界，则该数列收敛
零点定理&ensp;&ensp;设函数$f(x)$在闭区间$[a,b]$上连续，且$f(a)$与$f(b)$异号，则在开区间$(a,b)$内至少有一点$\xi$，使$f(\xi)=0$
介值定理&ensp;&ensp;函数$f(x)$在闭区间$[a,b]$上连续，且在区间的端点处取不同的函数值，$f(a)=A$及$f(b)=B$，则对于$A$与$B$之间的任意一个数$C$，在开区间$(a,b)$内至少有一点$\xi$，使得$f(\xi)=C \space (a \lt \xi \lt b)$
极限唯一性&ensp;&ensp;如果$\lim_{x \to x_0}f(x)$存在，那么这极限唯一
局部有界性&ensp;&ensp;如果$\lim_{x \to x_0}f(x)=A$，那么存在常数$M \gt 0$和$\delta \gt 0$，使得当$0 \lt |x-x_0| \lt \delta$时，有$|f(x)| \le M$


局部保号性&ensp;&ensp;如果$\lim_{x \to x_0}f(x)=A$，且$A \gt 0$（或$A \lt 0$），那么存在常数$\delta \gt 0$，使得当$0 \lt |x-x_0| \lt \delta$时，有$f(x) \gt 0$（或$f(x) \lt 0$）
极限运算法则
两个无穷小之和是无穷小
有界函数与无穷小的乘积是无穷小
如果$\lim f(x)=A$，$\lim g(x)=B$，那么
$\lim[f(x) \pm  g(x)] = \lim f(x) \pm \lim g(x) = A\pm B$
$\lim[f(x) \times  g(x)] = \lim f(x) \times \lim g(x) = A\times B$
若$B\ne 0$，则$\lim \frac {f(x)}{g(x)}=\frac{\lim f(x)}{\lim g(x)}= \frac {A}{B}$
若$\lim f(x)$存在，$n$为正整数，则$\lim [f(x)]^n = [ \lim f(x) ]^n$


如果$\varphi (x) \ge \psi (x)$，$\lim \varphi (x)=A$，$\lim \psi (x)=B$，那么$A \ge B$
设函数$y=f[g(x)]$是由函数$u=g(x)$与$y=f(u)$复合而成，$f[g(x)]$在点$x_0$某去心邻域内有定义，若$\lim_{x \to x_0}g(x)=u_0$，$\lim_{u \to u_0}f(u)=A$，且存在$\delta_0 \gt 0$，当$x \in \stackrel {\circ}{U} (x_0, \delta_0 )$时，有$g(x) \ne u_0$，则
$\lim_{x \to x_0} f[g(x)] = \lim_{x \to u_0} f(u) = A$



极限存在准则准则一（夹逼准则）
&ensp;&ensp;如果函数$g(x)$、$f(x)$、$h(x)$满足以下条件：

当$x \in \stackrel {\circ}{U}(x_0,r)$（或$|x|\gt M$）时，$g(x)\le f(x) \le h(x)$
$\lim _{x \to x_0} g(x) = A$，$\lim _{x \to x_0} h(x) = A$，

那么$\lim _{x \to x_0} f(x)$的极限存在，且等于$A$
准则二
&ensp;&ensp;单调有界数列必有极限
无穷小比较&ensp;&ensp;如果$\lim \frac{\beta}{\alpha} = 0$，那么就说$\beta$是比$\alpha$高阶的无穷小，记作$\beta = o(\alpha)$&ensp;&ensp;如果$\lim \frac{\beta}{\alpha} = \infty$，那么就说$\beta$是比$\alpha$低阶的无穷小&ensp;&ensp;如果$\lim \frac{\beta}{\alpha} = c \ne 0$，那么就说$\beta$与$\alpha$是同阶无穷小&ensp;&ensp;如果$\lim \frac{\beta}{\alpha^k} = c \ne 0,k \gt 0$，那么就说$\beta$是关于$\alpha$的$k$阶无穷小&ensp;&ensp;如果$\lim \frac{\beta}{\alpha} = 1$，那么就说$\beta$与$\alpha$是等阶无穷小，记作$\beta \sim \alpha$
函数连续性&ensp;&ensp;设函数$y=f(x)$在点$x_0$的某一邻域内有定义，如果

$ $
\begin{align*}
\lim _{x \to x_0}f(x)=f(x_0)
\end{align*}
$ $


那么就称函数$f(x)$在点$x_0$连续
两个重要极限第一类重要极限$ \eqref {eq3} $

$ $ 
\begin{align} \label {eq3}
\lim_{x \to 0} \frac{\sin x}{x} & = 1
\end{align}
$ $


第二类重要极限$ \eqref {eq4} $

$ $
\begin{align} \label {eq4}
\lim_{x \to \infty} (1+\frac{1}{x} )^{x} & = e
\end{align}
$ $


由$ \eqref {eq4} $推导$ \eqref {eq5} $

$ $
\begin{align} \label {eq5}
\lim_{x \to 0} (1+x )^{\frac{1}{x}} & = e
\end{align}
$ $


常见等价无穷小(当$ x\longrightarrow 0 $时)

$ \sin x \sim x $
$ \tan x \sim x $
$ \arcsin x \sim x $
$ \arctan x \sim x $
$ e^{x} - 1 \sim x $
$ a^{x} - 1 \sim x\ln_{}{a}  (a&gt;0,a≠1) $
$ \ln_{}{(1+x)} \sim x $
$ \log_{}{(1+x)} \sim \frac{1}{\ln_{}{a}} x (a&gt;0,a≠1) $
$ \ln_{}{(x+\sqrt[]{1+x^2} )}\sim x $
$ (1+x)^{a} -1 \sim ax $
$ \sqrt[n]{1+x} -1 \sim \frac{1}{n} x $
$ x-\sin x\sim \frac{1}{6} x^3 $
$ \tan x-x\sim \frac{1}{3} x^3 $
$ \tan x-\sin x\sim \frac{1}{2} x^3 $
$ 1 - \cos x \sim \frac{1}{2} x^{2}  $
$ x-\arctan x \sim \frac{1}{3} x^3 $
$ x-\arcsin x \sim -\frac{1}{6} x^3 $
$ x-\sin x \sim \frac{1}{6} x^3 $
$ \ln (x+\sqrt[]{x^2+1} )\sim x $

渐近线垂直渐近线
&ensp;&ensp;若$\lim_{x \to a^+} f(x)=\infty$或$\lim_{x \to a^-} f(x)=\infty$，&ensp;&ensp;则称$x=a$为曲线$y=f(x)$的垂直渐近线
水平渐近线
&ensp;&ensp;若$\lim_{x \to +\infty} f(x)=b$或$\lim_{x \to -\infty} f(x)=b$，&ensp;&ensp;则称$y=b$为曲线$y=f(x)$的水平渐近线
斜渐近线
&ensp;&ensp;若$\lim_{x \to +\infty} \frac{f(x)}{x}=a \space (a\ne 0)$，$\lim_{x \to +\infty} \left[f(x)-ax\right]=b$，&ensp;&ensp;或$\lim_{x \to -\infty} \frac{f(x)}{x}=a \space (a\ne 0)$，$\lim_{x \to -\infty} \left[f(x)-ax\right]=b$，&ensp;&ensp;则称$y=ax+b$为曲线$y=f(x)$的斜渐近线

&ensp;&ensp;例：求曲线$f(x)=\frac {2x^3}{x^2-3x+2}$的斜渐近线
$ $
\begin{array}{l}
a=\lim_{x \to \infty} \frac{f(x)}{x}=\lim_{x \to \infty} \frac {2x^2}{x^2-3x+2}=2\\
b=\lim_{x \to \infty} [f(x) - ax]=\lim_{x \to \infty} [\frac {2x^3}{x^2-3x+2} - 2x]=6\\
曲线f(x)的斜渐近线为y=2x+6
\end{array}
$ $



极值与最值函数单调性判定定理1&ensp;&ensp;设函数$y=f(x)$在$[a,b]$上连续，在$(a,b)$内可导

如果在$(a,b)$内$f’(x) \ge 0$，那么函数$y=f(x)$在$[a,b]$上单调增加
如果在$(a,b)$内$f’(x) \le 0$，那么函数$y=f(x)$在$[a,b]$上单调减少

定理2&ensp;&ensp;设函数$y=f(x)$在$[a,b]$上连续，在$(a,b)$内具有一阶和二阶导数，那么

若在$(a,b)$内$f’’(x) \gt 0$，则$f(x)$在$[a,b]$上的图形是凹的
若在$(a,b)$内$f’’(x) \lt 0$，则$f(x)$在$[a,b]$上的图形是凸的

极值与最值定理1&ensp;&ensp;设函数$f(x)$在$x_0$处可导，且在$x_0$处取得极值，则$f’(x_0)=0$
定理2&ensp;&ensp;设函数$f(x)$在$x_0$处连续，且在$x_0$的某去心邻域$\stackrel {\circ}{U} (x_0, \delta )$内可导

若$x \in (x_0-\delta ,x_0)$时，$f’(x) \gt 0$，$x \in (x_0 ,x_0+\delta)$时，$f’(x) \lt 0$，则$f(x)$在$x_0$处取得极大值
若$x \in (x_0-\delta ,x_0)$时，$f’(x) \lt 0$，$x \in (x_0 ,x_0+\delta)$时，$f’(x) \gt 0$，则$f(x)$在$x_0$处取得极小值
若$x \in \stackrel {\circ}{U} (x_0, \delta )$时，$f’(x)$的符号保持不变，则$f(x)$在$x_0$处没有极值

定理3&ensp;&ensp;设函数$f(x)$在$x_0$处具有二阶导数，且$f’(x_0) = 0$，$f’’(x_0) \ne 0$，则

当$f’’(x_0) \lt 0$时，函数$f(x)$在$x_0$处取得极大值
当$f’’(x_0) \gt 0$时，函数$f(x)$在$x_0$处取得极小值

拐点的判别拐点定义&ensp;&ensp;连续曲线的凹弧与凸弧的分界点称为该曲线的拐点
必要条件&ensp;&ensp;设$f’’(x_0)$存在，且点$(x_0, f(x_0))$为曲线的拐点，则$f’’(x_0) = 0$
第一充分条件&ensp;&ensp;设$f(x)$在点$x=x_0$处连续，在点$x=x_0$的某去心邻域内二阶可导，且在该店的左右邻域内$f’’(x)$变号，则点$(x_0, f(x_0))$为曲线的拐点
第二充分条件&ensp;&ensp;设$f(x)$在点$x=x_0$的某邻域内三阶可导，且$f’’(x_0) = 0$，$f’’’(x_0) \ne 0$，则点$(x_0, f(x_0))$为曲线的拐点
第三充分条件&ensp;&ensp;设$f(x)$在$x_0$处$n(n \ge 2)$阶可导，且$f^{(n)}(x_0) = 0$，$f^{(n+1)}(x_0) \ne 0$，则当$n$为偶数时，点$(x_0, f(x_0))$为曲线的拐点
导数公式导数表达式结构
$f’(x_{0} ) = \lim_{\Delta x \to 0} \frac{f(x_{0} + \Delta x) - f(x_{0} )}{\Delta x} $
$f’(x_{0} ) = \lim_{h \to 0} \frac{f(x_{0} + h) - f(x_{0} )}{h} (h = \Delta x)$
$f’(x_{0} ) = \lim_{x \to x_{0}} \frac{f(x) - f(x_{0} )}{x-x_{0}} (x = x_{0} + \Delta x)$

导数基本公式
$ C’ = 0(C为常数) $
$ (x ^{n})’ = nx^{n-1}(n为实数) $
$ (\log_{a}{x})’ = \frac{1}{x\ln_{}{a}} (a&gt;0,a≠1) $
$ (\ln_{}{x})’ = \frac{1}{x} $
$ (a ^{x})’ = a^{x}\ln_{}{a}(a&gt;0,a≠1) $
$ (e^{x})’ = e^{x} $
$ (\sin {x})’ = \cos {x} $
$ (\cos {x})’ = -\sin {x} $
$ (\tan {x})’ = \frac {1}{\cos ^2 {x}} = \sec ^2 {x} $
$ (\cot {x})’ = -\frac{1}{\sin ^2 {x}} = -\csc ^2 {x} $
$ (\sec {x})’ = \sec {x} \tan {x} $
$ (\csc {x})’ = -\csc {x} \cot {x} $
$ (\arcsin {x})’ = \frac {1}{\sqrt{1- x^2}} $
$ (\arccos {x})’ = -\frac {1}{\sqrt{1- x^2}} $
$ (\arctan {x})’ = \frac {1}{1+x^2} $
$ (\operatorname{arccot} x)’ = -\frac {1}{1+x^2} $
$ \left [\ln (x+\sqrt[]{x^2+a} )\right ]’=\frac{1}{\sqrt[]{x^2+a} } $

导数四则运算法则&ensp;&ensp;设$u=u(x)$，$v=v(x)$都可导

$ [u(x) \pm v(x)]’ = u’(x) \pm v’(x) $
$ [u(x)v(x)]’ = u’(x)v(x) + u(x)v’(x) $
$ [Cu(x)]’ = Cu’(x)(C为常数) $
$ [\frac {u(x)}{v(x)}]’ = \frac {u’(x)v(x) - u(x)v’(x)}{v^2(x)}(v(x)≠0) $
$ [\frac {C}{v(x)}]’ = -\frac {Cv’(x)}{v^2(x)}(v(x)≠0,C为常数) $

反函数求导法则&ensp;&ensp;设$y=f(x)$在区间$I_x$内单调、可导且$f’(x) \ne 0$，则它的反函数$x=f^{-1}(y)$在$I_y=f(I_x)$内也可导，且

$ $
\begin{align*}
[f^{-1}(y)]'=\frac{1}{f'(x)}
\end{align*}
$ $


&ensp;&ensp;因为

$ $
\begin{align*}
\frac{\mathrm{d}y}{\mathrm{d}x} = \frac{1}{\frac{\mathrm{d}x}{\mathrm{d}y} } 
\end{align*}
$ $


&ensp;&ensp;二阶导

$ $
\begin{align*}
[f^{-1}(y)]''=-\frac{f''(x)}{[f'(x)]^3} 
\end{align*}
$ $


复合函数的求导法则&ensp;&ensp;设$y=f(u),u=g(x)$，且$f(u),g(x)$都可导，则复合函数$y=f[g(x)]$的导数为

$ $
\begin{align*}
y'(x)=f'(u)\cdot g'(x)
\end{align*}

\begin{align*}
\frac{\mathrm{d}y}{\mathrm{d}x} = \frac{\mathrm{d}y}{\mathrm{d}u} \cdot \frac{\mathrm{d}u}{\mathrm{d}x}
\end{align*}
$ $



常用n阶导数公式
$ (e^x)^{(n)} = e^x $
$ (a^x)^{(n)} = a^x · \ln^n_{\,}{b}  $
$ (\sin {x}) ^{(n)} = \sin {(x + n · \frac {\pi}{2})} $
$ (\cos {x}) ^{(n)} = \cos {(x + n · \frac {\pi}{2})} $
$ (x ^n)^{(n)} = n! $
$ (x^m)^{(n)} = 0(正整数m&lt;n) $
$ (x^m)^{(n)} = \frac {m!}{(m-n)!} x^{m-n}(正整数m&gt;n) $
$ (\frac {1}{x+a})^{(n)} = \frac {(-1)^n n!}{(x+a)^{n+1}} $
$ \left[(\ln_{}{(x+a)}\right]^{(n)} = (-1)^{n-1}\frac {(n-1)!}{(x+a)^n} $

切线与法线方程函数$f(x)$在点$(x_{0},f(x_{0}))$处的切线与法线方程

若$f’(x_{0})≠0$且$f’(x_0)≠\infty $，切线方程为：$y-f(x_0) = f’(x_0)(x-x_0)$，法线方程为：$y-f(x_0) = -\frac{1}{f’(x_0)}(x-x_0)$；
若$f’(x_{0})=0$，切线方程为：$y=f(x_0)$，法线方程为：$x=x_0$；
若$f’(x_{0})=\infty$，切线方程为：$x=x_0$，法线方程为：$y=f(x_0)$

隐函数的导数&ensp;&ensp;对隐函数的等号两边同时求导，不赘述

&ensp;&ensp;例：求由方程$e^y+xy-e=0$所确定的隐函数的导数
$ $
\begin{align*}
 e^yy'+y+xy' & =0\\
 \frac{y}{y'}& = -(e^y+ x ) \\
 y' & = -\frac{y}{e^y+ x } 
\end{align*}
$ $



参数方程的导数&ensp;&ensp;若参数方程$\begin{cases} x=\varphi (t)\\ y=\psi (t)\end{cases}$确定$y$与$x$间的函数关系，假设$\varphi (t)$、$\psi (t)$都可导，且$\varphi’(t) \ne 0$，于是有

$ $
\begin{align*}
\frac{\mathrm{d}y}{\mathrm{d}x} = \frac{\mathrm{d}y}{\mathrm{d}t}/\frac{\mathrm{d}x}{\mathrm{d}t} = \frac{\varphi'(t)}{\psi'(t)} 
\end{align*}
$ $


二阶导

$ $
\begin{align*}
\frac{\mathrm{d}^2y}{\mathrm{d}x^2} =\frac{\mathrm{d}}{\mathrm{d}x}(\frac{\mathrm{d}y}{\mathrm{d}x}) = \frac{\mathrm{d}}{\mathrm{d}t}(\frac{\mathrm{d}y}{\mathrm{d}x})/\frac{\mathrm{d}x}{\mathrm{d}t}=\frac{\psi''(t)\varphi'(t)-\psi'(t)\varphi''(t)}{\varphi'^3(t)}
\end{align*}
$ $


微分公式微分基本公式
$ \mathrm{d}C = 0(C为常数) $
$ \mathrm{d}(x ^{n}) = nx^{n-1}\mathrm{d}x(n为实数) $
$ \mathrm{d}(\log_{a}{x}) = \frac{1}{x\ln_{}{a}}\mathrm{d}x (a&gt;0,a≠1) $
$ \mathrm{d}(\ln_{}{x}) = \frac{1}{x}\mathrm{d}x $
$ \mathrm{d}(a ^{x}) = a^{x}\ln_{}{a}\mathrm{d}x(a&gt;0,a≠1) $
$ \mathrm{d}(e^{x}) = e^{x}\mathrm{d}x $
$ \mathrm{d}(\sin {x}) = \cos {x}\mathrm{d}x $
$ \mathrm{d}(\cos {x}) = \sin {x}\mathrm{d}x $
$ \mathrm{d}(\tan {x}) = \frac {1}{\cos ^2 {x}}\mathrm{d}x = \sec ^2 {x}\mathrm{d}x $
$ \mathrm{d}(\cot {x}) = -\frac{1}{\sin ^2 {x}}\mathrm{d}x = -\csc ^2 {x}\mathrm{d}x $
$ \mathrm{d}(\sec {x}) = \sec {x} \tan {x}\mathrm{d}x $
$ \mathrm{d}(\csc {x}) = -\csc {x} \cot {x}\mathrm{d}x $
$ \mathrm{d}(\arcsin {x}) = \frac {1}{\sqrt{1- x^2}}\mathrm{d}x $
$ \mathrm{d}(\arccos {x}) = -\frac {1}{\sqrt{1- x^2}}\mathrm{d}x $
$ \mathrm{d}(\arctan {x}) = \frac {1}{1+x^2}\mathrm{d}x $
$ \mathrm{d}(\operatorname{arccot} x) = -\frac {1}{1+x^2}\mathrm{d}x $

微分四则运算法则设$u = u(v)$、$v = v(x)$可微，则

$ $
\begin{align*}
\mathrm{d}(u \pm v) = \mathrm{d}u \pm \mathrm{d}v
\end{align*}

\begin{align*}
\mathrm{d}(Cu) = C\mathrm{d}u(C为常数)
\end{align*}

\begin{align*}
\mathrm{d}(uv) = v\mathrm{d}u + u\mathrm{d}v
\end{align*}

\begin{align*}
\mathrm{d}(\frac {u}{v}) = \frac {v\mathrm{d}u - u\mathrm{d}v}{v^2}(v≠0)
\end{align*}
$ $


微分中值定理罗尔定理如果函数$f(x)$满足

在闭区间$[a,b]$上连续；
在开区间$(a,b)$内可导；
在区间端点处的函数值相等，即$f(a)=f(b)$；

那么在$(a,b)$内至少有一点$\xi \;(a\lt \xi \le b)$，使得$f’(\xi)=0$
拉格朗日中值定理如果函数$f(x)$满足

在闭区间$[a,b]$上连续；
在开区间$(a,b)$内可导；

那么在$(a,b)$内至少有一点$ \xi \; (a \lt \xi \le b)$，使等式$\eqref {eq8}$成立

$ $
\begin{align} \label {eq8}
f(b)-f(a)=f'(\xi)(b-a)
\end{align}
$ $


柯西中值定理如果函数$f(x)$及$F(x)$满足

在闭区间$[a,b]$上连续；
在开区间$(a,b)$内可导；
对任一$ x\in (a,b) $，$F’(x)\ne 0$；

那么在$(a,b)$内至少有一点$\xi$，使等式$\eqref {eq9}$成立

$ $
\begin{align} \label {eq9}
\frac{f(b)-f(a)}{F(b)-F(a)} =\frac{f'(\xi)}{F'(\xi)} 
\end{align}
$ $


弧微分与曲率弧微分公式
$\mathrm{d}s = \sqrt[]{1+y’^2} \mathrm{d}x $
曲率公式
曲率$K=\frac {\mathrm{d}\alpha}{\mathrm{d}s} = \frac {|y’’|}{(1+y’^2)^{\frac{2}{3}}}$
曲率半径$\rho = \frac {1}{K}$
泰勒公式泰勒公式
  $ $
  \begin{align} \label {eq10}
  f(x)=f(x_0)+f'(x_0)(x-x_0)+\frac{f''(x_0)}{2!} (x-x_0)^2+···+\frac{f^{(n)}(x_0)}{n!}(x-x_0)^n+R_n(x)
  \end{align}
  $ $


佩亚诺余项当$\eqref {eq10}$中$R_n(x)$的表达式为$\eqref {eq11}$时，称为佩亚诺余项，近似表达$n$次泰勒多项式产生的误差

$ $
\begin{align} \label {eq11}
R_n(x)=o[(x-x_0)^n]
\end{align}
$ $


拉格朗日余项当$\eqref {eq10}$中$R_n(x)$的表达式为$\eqref {eq12}$时，称为拉格朗日余项，拉格朗日余项能够具体估算出误差的大小，其中$\xi$是$x_0$与$x$之间的某个值

  $ $
  \begin{align} \label {eq12}
  R_n(x)=\frac{f^{(n+1)}(\xi)}{(n+1)!}(x-x_0)^{n+1}
  \end{align}
  $ $



误差估计式

  $ $
  \begin{align} \label {eq13}
  \left|R(x)\right|=\left|\frac{f^{(n+1)}(\xi)}{(n+1)!}(x-x_0)^{n+1}\right|\le \frac{M}{(n+1)!} \left|x-x_0\right|^{n+1}
  \end{align}
  $ $


麦克劳林公式在$\eqref {eq10}$中，如果取$x_0=0$，那么有麦克劳林公式

  $ $
  \begin{align} \label {eq14}
  f(x)=f(0)+f'(0)x+\frac{f''(0)}{2!}x^2+···+\frac{f^{(n)}(0)}{n!}x^n+R_n(x)
  \end{align}
  $ $


佩亚诺余项当$\eqref {eq14}$中$R_n(x)$的表达式为$\eqref {eq15}$时，称为佩亚诺余项

$ $
\begin{align} \label {eq15}
R_n(x)=o[(x-x_0)^n]
\end{align}
$ $


拉格朗日余项麦克劳林公式$\eqref {eq14}$由泰勒公式$\eqref {eq10}$取$x_0=0$得到，那么泰勒公式拉格朗日余项$\eqref {eq12}$中$\xi$在$0$与$x$之间，因此可以令$\xi=\theta x\space(x &lt; \theta &lt; 1)$，从而有麦克劳林拉格朗日余项

  $ $
  \begin{align} \label {eq16}
  R_n(x)=\frac{f^{(n+1)}(\theta x)}{(n+1)!}x^{n+1} \space (0 < \theta < 1)
  \end{align}
  $ $


相应的，误差估计式变成

  $ $
  \begin{align} \label {eq17}
  \left|R(x)\right|=\left|\frac{f^{(n+1)}(\theta x)}{(n+1)!}x^{n+1}\right|\le \frac{M}{(n+1)!} \left|x\right|^{n+1}
  \end{align}
  $ $



常用泰勒公式
$e^x = \sum_{n=0}^{\infty}\frac{x^n}{n!}  = 1+x+\frac{x^2}{2!}+\frac{x^3}{3!}+\frac{x^4}{4!}+o(x^4)$
$\ln (1+x)= \sum_{n=1}^{\infty}(-1)^{n-1}\frac{x^n}{n} = x-\frac{x^2}{2}+\frac{x^3}{3}-\frac{x^4}{4}+o(x^4)$
$\frac{1}{1+x} = \sum_{n=0}^{\infty}(-1)^nx^n = 1-x+x^2-x^3+o(x^3)$
$\frac{1}{1-x} = \sum_{n=0}^{\infty}x^n = 1+x+x^2+x^3+o(x^3)$
$\sin x = \sum_{n=0}^{\infty}(-1)^n\frac{x^{2n+1}}{(2n+1)!} = x-\frac{x^3}{3!} + \frac{x^5}{5!} + o(x^{5})$
$\cos x = \sum_{n=0}^{\infty}(-1)^n\frac{x^{2n}}{(2n)!} = 1 - \frac{x^2}{2!} + \frac{x^4}{4!} + o(x^{4})$
$\tan x = x + \frac{2}{3!} x^3 + \frac{16}{5!} x^5+o(x^5)$
$\arcsin x = x + \frac{1}{3!}x^3 + \frac{9}{5!}x^5 + o(x^5)$
$\arctan x = x-\frac{x^3}{3} + \frac{x^5}{5} + o(x^5)$
$(1+x)^a = 1 + ax + \frac{a(a - 1)}{2!} x^2 + \frac{a(a-1)(a-2)}{3!} x^3 + o(x^3)$

数学常用公式定理2
数学常用公式定理3
数学常用公式定理4
数学常用公式定理5
数学常用公式定理6




]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>数学常用公式定理2</title>
    <url>/2022/04/04/%E6%95%B0%E5%AD%A6%E5%B8%B8%E7%94%A8%E5%85%AC%E5%BC%8F%E5%AE%9A%E7%90%862/</url>
    <content><![CDATA[数学常用公式定理1
数学常用公式定理3
数学常用公式定理4
数学常用公式定理5
数学常用公式定理6

不定积分不定积分的性质性质1 设函数$f(x)$及$g(x)$的原函数存在，则

  $ $
    \begin{align*}
    \int \left [ f(x) \pm g(x) \right ] \mathrm{d}x = \int f(x) \mathrm{d}x  \pm \int g(x) \mathrm{d}x
    \end{align*}
    $ $



性质2 设函数$f(x)$的原函数存在，$k$为非零常数，则

$ $
\begin{align*}
\int kf(x)dx = k\int f(x)dx
\end{align*}
$ $


性质3

$ $
\begin{align*}
  {\left ( \int f(x)dx \right ) }' = f(x)
\end{align*}

\begin{align*}
  d\int f(x)dx = f(x)dx
\end{align*}
$ $


性质4

$ $
\begin{align*}
\int {f}'(x)dx = f(x)+C
\end{align*}

\begin{align*}
\int df(x) = f(x)+C
\end{align*}
$ $


三角代换一般的，a&gt;0时，当被积函数有

$\sqrt{a^{2} - x^{2} } $，可做代换$x=a\sin {u}(-\frac{\pi }{2} &lt; u &lt; \frac{\pi }{2} )$
$\sqrt{x^{2} + a^{2} } $，可做代换$x=a\tan {u}(-\frac{\pi }{2} &lt; u &lt; \frac{\pi }{2} )$
$\sqrt{x^{2} - a^{2} } $，可做代换$ x=a\sec {u}(x&gt;a时，0&lt;u&lt;\frac{\pi}{2}；x&lt;-a时，令x=t，则t \gt a) $

基本积分公式
$\int k\mathrm{d}x = kx+C $
$\int x^{n}\mathrm{d}x=\frac{x^{n +1}}{n +1}+C, \left({n \neq -1}\right) $
$\int \frac{1}{x}\mathrm{d}x= \ln \left| x \right| +C $
$\int \frac{1}{x^{2} }\mathrm{d}x= -\frac{1}{x}  +C $
$\int e^{x}\mathrm{d}x= e^{x} + C $
$\int a^{x}\mathrm{d}x=\frac{a^{x}}{\ln_{}{a} }+C \,\,\, \left({a &gt; 0\text{且}a≠1 }\right) $
$\int \cos x \mathrm{d}x = \sin x + C$
$\int \sin x \mathrm{d}x = -\cos x + C $
$\int \tan {x} \mathrm{d}x = -\ln \left|\cos {x}\right| + C $
$\int \cot {x}\mathrm{d}x = \ln \left|\sin {x}\right| + C $
$\int \sec {x}\mathrm{d}x = \ln \left|\sec {x} + \tan {x}\right| + C  $
$\int \csc {x}\mathrm{d}x = \ln \left|\cot {x} - \csc {x}\right| + C $
$\int \sec x \tan x \mathrm{d}x = \sec x + C $
$\int \csc x \cot x \mathrm{d}x = -\csc x + C $
$\int \frac{\mathrm{d}x }{\cos ^{2}x}  = \int \sec ^{2}x\mathrm{d}x = \tan x + C$
$\int \frac{\mathrm{d}x }{\sin ^{2}x}  = \int \csc ^{2}x\mathrm{d}x = -\cot x + C$
$\int \frac{\mathrm{d}x }{\sqrt{1-x^{2}} } = \arcsin x + C$
$\int \frac{\mathrm{d}x }{\sqrt{a^2-x^{2}} } = \arcsin \frac{x}{a}  + C$
$\int -\frac{\mathrm{d}x }{\sqrt{1-x^{2}} } = \arccos x + C$
$\int \frac{1}{\sqrt[]{x^2+a^2} } \mathrm{d} x = \ln (x+\sqrt[]{x^2+a^2} ) + C$
$\int \frac{1}{\sqrt[]{x^2-a^2} } \mathrm{d} x = \ln \left|x+\sqrt[]{x^2-a^2} \right| + C(x^2\ge a^2)$
$\int \frac{\mathrm{d}x }{1+x^{2} } = \arctan x + C$
$\int \frac{\mathrm{d}x }{a^2+x^{2} } = \frac{1}{a} \arctan \frac{x}{a}  + C$
$\int -\frac{\mathrm{d}x }{1+x^{2} } = \operatorname{arccot} x + C$
$\int \frac{1}{x^2-a^2} \mathrm{d}x = \frac{1}{2a} \ln \left |\frac{x-a}{x+a} \right | +C$

常用凑微分等式
$\mathrm{d}x = \frac{1}{a} \mathrm{d} (ax) $
$x\mathrm{d}x = \frac{1}{2} \mathrm{d} (x^2) $
$x^{2}\mathrm{d}x = \frac{1}{3} \mathrm{d} (x^3) $
$\frac{\mathrm{d}x }{\sqrt{x} } = 2\mathrm{d} (\sqrt[]{x} )$
$\frac{1}{x} \mathrm{d}x  = \mathrm{d} (\ln \left | x \right | )$
$\frac{1}{x^{2}} \mathrm{d}x  = \mathrm{d} (-\frac{1}{x} )$
$e^{x} \mathrm{d}x = \mathrm{d}(e^{x}) $
$\cos x \mathrm{d}x = \mathrm{d}(\sin x) $
$\sin x \mathrm{d}x = \mathrm{d}(-\cos x) $
$\frac{1}{1+x^{2}} \mathrm{d}x = \mathrm{d}(\arctan x) $
$\frac{1}{\sqrt[]{1-x^{2}} } \mathrm{d}x = \mathrm{d}(\arcsin x) $
$\sec ^{2} x \mathrm{d}x = \mathrm{d}(\tan x) $
$\csc ^{2} x \mathrm{d}x = \mathrm{d}(-\cot x) $

定积分定积分定义
&ensp;&ensp;设函数$f(x)$在$[a,b]$上有界，在$[a,b]$中任意插入若干个分支点

  $ $
  \begin{align*}
  a=x_0 \lt x_1 \lt \cdots \lt x_{n-1} \lt x_n=b
  \end{align*}
  $ $


把区间$[a,b]$分成$n$个小区间

  $ $
  \begin{align*}
  [x_0,x_1],[x_1,x_2],\cdots ,[x_{n-1},x_n]
  \end{align*}
  $ $


各个小区间的长度依次为

  $ $
  \begin{align*}
  \Delta x_1=x_1-x_0,\Delta x_2=x_2-x_1,\cdots ,\Delta x_n=x_n-x_{n-1}
  \end{align*}
  $ $


在每个小区间$[x_i,x_{i+1}]$上任取一点$\xi_i$（$x_{i-1} \le \xi_i \le x_i$），对函数值$f(\xi_i)$与$\Delta x_i$的乘积求和

  $ $
  \begin{align*}
  S=\sum_{i=1}^{n} f(\xi _i)\Delta x_i
  \end{align*}
  $ $


记$\lambda = \max \left \{ \Delta x_1,\Delta x_2,\cdots,\Delta x_n \right \} $，当$\lambda \to 0$时，和式的极限总存在，则该极限称为$f(x)$在区间$[a,b]$上的定积分

  $ $
  \begin{align*}
  \int_{a}^{b} f(x) \mathrm{d}x = \lim_{\lambda \to 0} \sum_{i=1}^{n} f(\xi_i)\Delta x_i
  \end{align*}
  $ $



定积分的精确定义
&ensp;&ensp;将$[a,b]$等分为n个小区间，则各小区间的长度$\Delta x_i$相等，取每个小区间的右端点为$\xi _i$，于是有和式极限

  $ $
  \begin{align*}
  \int_{a}^{b} f(x) \mathrm{d}x=\lim_{n \to \infty} \sum_{i=1}^{n} \frac{b-a}{n} f\left [ a+\frac{(b-a)i}{n} \right ] 
  \end{align*}
  $ $


其中

$ $
\begin{align*}
& x=\xi_i = \left [ a+\frac {(b-a)i}{n} \right],\\
& a=\xi_1,b=\xi_n,\\
& \mathrm{d}x=\frac{b-a}{n}\\
\end{align*}
$ $


当$a$、$b$取$0$、$1$时

$ $
\begin{align*}
\int_{0}^{1} f(x)\mathrm{d}x = \lim_{n \to \infty}\sum_{i=1}^{n} f(\frac{i}{n} )\frac{1}{n} 
\end{align*}
$ $


若要将和式极限转换为定积分形式

$ $
\begin{align*}
& \color{red} Tip:先凑出小积分区间长度\Delta x_i \\
& \mathrm{d}x = \Delta x_i =  \frac{b-a}{n} \\
& \color{red} Tip:根据小积分区间长度，得到精确定义的\xi_i \\
& x = \xi _i =a+\frac{(b-a)i}{n} \\
& \color{red}Tip:确定积分下限和积分上限 \\
& a为积分下限(a = \lim_{n \to \infty } \xi_1)，b为积分上限(b=\lim_{n \to \infty} \xi_n)\\
&\color{red} Tip: 根据原式确定函数f(x)，于是得到\\
& \int_{a}^{b}f(x)\mathrm{d}x 
\end{align*}
$ $




&ensp;&ensp;例：将$\lim_{n \to \infty } \sum_{i=1}^{n} \frac{i}{n^2} \ln \left ( 1+\frac {i}{n} \right ) $转化为定积分形式
$ $
\begin{align*}
& 原式=\lim_{n \to \infty } \sum_{i=1}^{n} \frac{1}{n} \cdot \frac{i}{n} \ln \left ( 1+\frac {i}{n} \right ) \\
& 令\mathrm{d}x = \Delta x_i = \frac{1}{n} \\
& \therefore x = \xi_i  = (0+\frac{i}{n}) \\
& \therefore a = 0，b = 1 \\
& 根据原式，f(x) = x\ln (1+x) \\
& 于是有\int_{0}^{1} x\ln (1+x)\mathrm{d}x  
\end{align*}
$ $





定积分的性质规定1 当$ b=a $时

  $ $
  \begin{align*}
  \int_{a}^{b} f(x)\mathrm{d}x = 0
  \end{align*}
  $ $


规定2 当$ a\gt b $时

  $ $
  \begin{align*}
  \int_{a}^{b} f(x)\mathrm{d}x = -\int_{b}^{a} f(x)\mathrm{d}x
  \end{align*}
  $ $


性质1 被积函数中的常数因子可以提到积分号外

  $ $
  \begin{align*}
  \int_{a}^{b} kf(x)\mathrm{d}x = k\int_{a}^{b}  f(x)\mathrm{d}x \; (k是常数) 
  \end{align*}
  $ $


性质2 两个函数代数和、差的积分等于积分代数的和、差

  $ $
  \begin{align*}
  \int_{a}^{b} [f(x) \pm g(x)]\mathrm{d}x = \int_{a}^{b}  f(x)\mathrm{d}x \pm \int_{a}^{b} g(x) \mathrm{d}x 
  \end{align*}
  $ $


性质3 可加性，设$ a \lt b \lt c $，有

  $ $
  \begin{align*}
  \int_{a}^{b} f(x)\mathrm{d}x = \int_{a}^{c} f(x) \mathrm{d}x + \int_{c}^{b} f(x)\mathrm{d} x
  \end{align*}
  $ $


性质4 如果在区间$[a,b]$上$f(x) \equiv 1$，则

  $ $
  \begin{align*}
  \int_{a}^{b} 1\mathrm{d}x = \int_{a}^{b} \mathrm{d}x = b-a
  \end{align*}
  $ $



性质5 如果在区间$[a,b]$上$f(x) \ge 0$，则

  $ $
  \begin{align*}
  \int_{a}^{b} f(x)\mathrm{d}x \ge 0 \; (a \lt b)
  \end{align*}
  $ $


推论1 如果在区间$[a,b]$上$f(x) \le g(x)$，则

  $ $
  \begin{align*}
  \int_{a}^{b} f(x)\mathrm{d} x \le \int_{a}^{b} g(x)\mathrm{d} x \; (a \lt b)
  \end{align*}
  $ $



推论2

  $ $
  \begin{align*}
  \left|\int_{a}^{b}f(x)\mathrm{d}x \right| \le \int_{a}^{b} \left|f(x)\right| \mathrm{d} x \; (a \lt b) 
  \end{align*}
  $ $


性质6 估值定理。设$M$及$m$分别是函数$f(x)$在区间$[a,b]$上的最大值及最小值，则

  $ $
  \begin{align*}
  m(b-a) \le \int_{a}^{b}f(x)\mathrm{d}x \le M(b-a)
  \end{align*}
  $ $


性质7 定积分中值定理。如果函数$f(x)$在积分区间$[a,b]$上连续，那么在$[a,b]$上至少存在一个点$\xi$，使下式成立

  $ $
  \begin{align*}
  \int_{a}^{b}f(x)\mathrm{d}x=f(\xi)(b-a) \; (a \le \xi \le b)
  \end{align*}
  $ $



推论3 推广的定积分中值定理。如果函数$f(x)$，$g(x)$在积分区间$[a,b]$上连续，且$g(x)$在$[a,b]$上不变号，那么在$(a,b)$上至少存在一个点$\xi$，使下式成立

  $ $
  \begin{align*}
  \int_{a}^{b} f(x)g(x)\mathrm{d}x = f(\xi)\int_{a}^{b} g(x)\mathrm{d}x
  \end{align*}
  $ $



性质8 由定积分的几何意义可知，当$a\gt 0$时

  $ $
  \begin{align*}
  \int_{-a}^{a} \sqrt{a^{2}-x^{2}} \mathrm{d}x = \frac{\pi }{2} a^{2} \\
  \int_{0}^{a} \sqrt{a^{2}-x^{2}} \mathrm{d}x = \frac{\pi }{4} a^{2}
  \end{align*}
  $ $


牛顿-莱布尼兹公式微积分基本定理 如果函数$F(x)$是连续函数$f(x)$在区间$[a,b]$上的一个原函数，那么

  $ $
  \begin{align*}
  \int_{a}^{b}f(x)\mathrm{d}x=F(b) -F(a)
  \end{align*}
  $ $


反常积分无穷区间&ensp;&ensp;1.设函数$f(x)$在区间$[a,+\infty )$上连续，则$f(x)$在无穷区间$[a,+\infty )$上的反常积分

$ $
\begin{align*}
\int_{a}^{+\infty } f(x)\mathrm{d}x = \lim_{t \to +\infty} \int_{a}^{t}f(x)\mathrm{d}x 
\end{align*}
$ $



&ensp;&ensp;2.设函数$f(x)$在区间$(-\infty,b]$上连续，则$f(x)$在无穷区间$(-\infty,b]$上的反常积分

$ $
\begin{align*}
\int_{-\infty}^{b } f(x)\mathrm{d}x = \lim_{t \to -\infty} \int_{t}^{b}f(x)\mathrm{d}x 
\end{align*}
$ $


&ensp;&ensp;3.设函数$f(x)$在区间$(-\infty,+\infty)$上连续，则函数$f(x)$在无穷区间$(-\infty,+\infty)$上的反常积分

$ $
\begin{align*}
\int_{-\infty}^{ +\infty} f(x)\mathrm{d}x = \int_{-\infty}^{ 0} f(x)\mathrm{d}x + \int_{0}^{ +\infty} f(x)\mathrm{d}x = \lim_{t \to -\infty} \int_{t}^{b}f(x)\mathrm{d}x +\lim_{t \to +\infty} \int_{a}^{t}f(x)\mathrm{d}x 
\end{align*}
$ $


无界函数（瑕积分）&ensp;&ensp;1.设函数$f(x)$在区间$(a,b]$上连续，则$f(x)$在区间$(a,b]$上的反常积分

$ $
\begin{align*}
\int_{a}^{b} f(x)\mathrm{d}x = \lim_{t \to a^+} \int_{t}^{b} f(x)\mathrm{d}x 
\end{align*}
$ $


&ensp;&ensp;2.设函数$f(x)$在区间$[a,b)$上连续，则$f(x)$在区间$[a,b)$上的反常积分

$ $
\begin{align*}
\int_{a}^{b} f(x)\mathrm{d}x = \lim_{t \to b^-} \int_{a}^{t} f(x)\mathrm{d}x 
\end{align*}
$ $


&ensp;&ensp;3.设函数$f(x)$在区间$[a,c)\cup(c,b]$上连续，则$f(x)$在区间$[a,b]$上的反常积分

$ $
\begin{align*}
\int_{a}^{b} f(x)\mathrm{d}x = \int_{a}^{c} f(x)\mathrm{d}x +\int_{c}^{b} f(x)\mathrm{d}x = \lim_{t \to c^-} \int_{a}^{t} f(x)\mathrm{d}x +\lim_{t \to c^+} \int_{t}^{b} f(x)\mathrm{d}x 
\end{align*}
$ $


$\Gamma$函数$\Gamma$函数定义式

$ $
\begin{align*}
\Gamma (s)=\int_{0}^{+\infty } e^{-x}x^{s-1}\mathrm{d} x \space \space (s\gt0)
\end{align*}
$ $


常用公式

$\Gamma (s+1)= s\Gamma (s)$
$\Gamma (n+1)=n!$ (n为正整数)
$\Gamma (\frac{1}{2} ) = \sqrt[]{\pi} $

反常积分申敛法比较判别法&ensp;&ensp;设函数$f(x)$，$g(x)$在区间$\left[a,b\right)$上连续，其中$b \in \left(a, +\infty\right)$，并且$ 0 \le f(x) \le g(x) $，则

如果$ \int_{a}^{b } g(x)\mathrm{d}x $收敛，那么$ \int_{a}^{b } f(x)\mathrm{d}x $收敛
如果$ \int_{a}^{b } f(x)\mathrm{d}x $发散，那么$ \int_{a}^{b } g(x)\mathrm{d}x $发散

极限形式比较判别法&ensp;&ensp;设函数$f(x)$，$g(x)$在区间$\left[a,b\right)$上连续，其中$b \in \left(a, +\infty\right)$，并且$ f(x) \ge 0 $，$ g(x) \gt 0 $，$\lim_{x \to +\infty} \frac{f(x)}{g(x)} = \lambda $，则

当$\lambda \ne 0$且$\lambda \ne \infty$时，$\int_{a}^{b} g(x)\mathrm{d} x$与$\int_{a}^{b} f(x)\mathrm{d} x$有相同的敛散性
当$\lambda =0$时，若$\int_{a}^{b} g(x)\mathrm{d} x$收敛，则$\int_{a}^{b} f(x)\mathrm{d} x$收敛
当$\lambda = \infty$时，若$\int_{a}^{b} g(x)\mathrm{d} x$发散，则$\int_{a}^{b} f(x)\mathrm{d} x$发散

重要结论
  $ $
  \begin{align*}
  &\int_{0}^{1} \frac{1}{x^p} \mathrm{d} x \begin{cases}
  \text{收敛}  & 0 \lt p \lt 1 \\
  \text{发散}  & p \ge 1
  \end{cases} \\

  &\int_{0}^{+\infty } \frac{1}{x^p} \mathrm{d} x \begin{cases}
  \text{收敛}  & p \gt 1 \\
  \text{发散}  & p \le 1
  \end{cases}
  \end{align*}

  \begin{align*}
  &\int_{0}^{1} \frac{\ln x}{x^p} \mathrm{d} x \begin{cases}
  \text{收敛}  & 0 \lt p \lt 1 \\
  \text{发散}  & p \ge 1
  \end{cases} \\

  &\int_{0}^{+\infty } \frac{\ln x}{x^p} \mathrm{d} x \begin{cases}
  \text{收敛}  & p \gt 1 \\
  \text{发散}  & 0 \lt p \le 1
  \end{cases}
  \end{align*}
  $ $



区间再现公式若$f(x)$为连续函数，则

  $ $
  \begin{align*}
  \int_{a}^{b} f(x)\mathrm{d} x = \int_{a}^{b} f(a+b-x)\mathrm{d} x
  \end{align*}
  $ $


定积分求导公式设有$F(x)=\int_{g(x)}^{h(x)}f(t)\mathrm{d}t$
则它的导数$F’(x)$为

  $ $
  \begin{align*}
  F'(x) = h'(x)f[h(x)]-g'(x)f[g(x)]
  \end{align*}
  $ $


定积分几何应用平面图形面积
&ensp;&ensp;曲线$y_1=f_1(x)$、$y_2=f_2(x)$与$x=a$、$x=b$所围成的平面图形的面积为

  $ $
  \begin{align*}
  S=\int_{a}^{b} \left | y_1-y_2\right | \mathrm{d} x
  \end{align*}
  $ $


如果曲线$y_1=f_1(x)$由参数方程$\begin{cases} x=\varphi(t) \\ y_1=\psi(t)\end{cases}$（$\alpha \le t \le \beta$）给出，那么$y_1$与$x$轴所围成的平面图形的面积为

  $ $
  \begin{align*}
  S_1=\int_{\alpha}^{\beta} \left | \psi (t)\right | \mathrm{d} [\varphi (t)]
  \end{align*}
  $ $


曲边扇形面积
&ensp;&ensp;曲线$r_1=r_1(\theta)$、$r_2=r_2(\theta)$与$\theta=\alpha$、$\theta=\beta$所围成的平面图形的面积为

  $ $
  \begin{align*}
  S=\frac{1}{2} \int_{\alpha }^{\beta } |r_1^2(\theta ) - r_2^2(\theta )|\mathrm{d} \theta 
  \end{align*}
  $ $



&ensp;&ensp;直角坐标与极坐标的对应关系
  $ $
  \begin{align*}
  x=r(\theta )\cos \theta \\
  y=r(\theta )\sin \theta 
  \end{align*}
  $ $


旋转体体积
&ensp;&ensp;曲线$y=f(x)$与$x=a$、$x=b$及$x$轴围成的平面绕$x$轴旋转一周所得旋转体的体积为

  $ $
  \begin{align*}
  V=\int_{a}^{b} \pi [f(x)]^2\mathrm{d}x
  \end{align*}
  $ $


当曲线由参数方程$\begin{cases} x=\varphi(t) \\ y=\psi(t)\end{cases}$（$\alpha \le t \le \beta$）给出时

  $ $
  \begin{align*}
  V=\int_{\alpha}^{\beta} \pi [\psi(t)]^2\mathrm{d}[\varphi(t)]
  \end{align*}
  $ $



环形旋转体体积
&ensp;&ensp;拱形曲线$y=f(x)$与$x$轴围成的平面绕$y$轴旋转一周所得旋转体的体积为

  $ $
  \begin{align*}
  V=2\pi \int_{a}^{b} \left|x \right| \left|f(x) \right| \mathrm{d}x
  \end{align*}
  $ $


当曲线由参数方程$\begin{cases} x=\varphi(t) \\ y=\psi(t)\end{cases}$（$\alpha \le t \le \beta$）给出时

  $ $
  \begin{align*}
  V=2\pi \int_{\alpha }^{\beta } \left|\varphi(t) \right| \left|\psi(t) \right| \mathrm{d}[\varphi(t)]
  \end{align*}
  $ $


定直线旋转体体积
&ensp;&ensp;设平面曲线$L:y=f(x)$（$a \le x \le b$），且$f(x)$可导，定直线$L_0:Ax+By+C=0$，且过$L_0$的任一条垂线与$L$至多有一个交点，则$L$绕$L_0$旋转一周所得旋转体的体积为

  $ $
  \begin{align*}
  V=\frac{\pi}{(A^2+B^2)^{\frac{3}{2} }} \int_{a}^{b} \left [ Ax+Bf(x)+C \right ]^2\left| Af'(x)-B\right| \mathrm{d} x
  \end{align*}
  $ $


平面曲线弧长
&ensp;&ensp;$[a,b]$区间内函数$y=f(x)$的长度为

  $ $
  \begin{align*}
  S=\int_{a}^{b}\mathrm{d}s = \int_{a}^{b} \sqrt[]{1+[f'(x)]^2}\mathrm{d}x
  \end{align*}
  $ $


当曲线由参数方程$\begin{cases} x=\varphi(t) \\ y=\psi(t)\end{cases}$（$\alpha \le t \le \beta$）给出时

  $ $
  \begin{align*}
  S=\int_{\alpha }^{\beta } \sqrt[]{[\varphi'(t)]^2+[\psi'(t)]^2}\mathrm{d}t
  \end{align*}
  $ $


当曲线由极坐标方程$r=r(\theta)$（$\alpha \le \theta \le \beta$）给出时

  $ $
  \begin{align*}
  S=\int_{a}^{b} \sqrt[]{[r(\theta)]^2 + [r'(\theta )]^2} \mathrm{d} \theta 
  \end{align*}
  $ $


旋转体侧面积
&ensp;&ensp;曲线$y=f(x)$与$x=a$、$x=b$及$x$轴围成的平面绕$x$轴旋转一周所得旋转体的侧面积为

  $ $
  \begin{align*}
  S=2\pi \int_{a}^{b} \left| y\right| \mathrm{d} s=2\pi \int_{a}^{b} \left| y\right| \sqrt[]{1+\left[ f'(x)\right]^2} \mathrm{d} x
  \end{align*}
  $ $


当曲线由参数方程$\begin{cases} x=\varphi(t) \\ y=\psi(t)\end{cases}$（$\alpha \le t \le \beta$）给出时

  $ $
  \begin{align*}
  S=2\pi \int_{\alpha }^{\beta} \left| \psi (t)\right| \sqrt[]{\left[ \varphi ' (t)\right]^2+\left[ \psi' (t)\right]^2} \mathrm{d} t
  \end{align*}
  $ $


当曲线由极坐标方程$r=r(\theta)$（$\alpha \le \theta \le \beta$）给出时

  $ $
  \begin{align*}
  S=2\pi \int_{\alpha }^{\beta} \left| r(\theta) \sin \theta \right| \sqrt[]{\left[ r(\theta )\right]^2+\left[ r'(\theta )\right]^2} \mathrm{d} \theta 
  \end{align*}
  $ $


平面图形的形心坐标
&ensp;&ensp;设平面区域$D=\left \{ (x,y)|0 \le y \le f(x), a \le x \le b \right \} $，$y=f(x)$在$[a,b]$上连续，则$D$的形心坐标$(\bar{x}, \bar{y})$的计算公式为

  $ $
  \begin{gather*}
  \bar{x} = \frac{\iint\limits_{D}x\mathrm{d}\sigma }{\iint\limits_{D}\mathrm{d}\sigma} =\frac{\int_{a}^{b} \mathrm{d} x\int_{0}^{f(x)} x\mathrm{d} y}{\int_{a}^{b} \mathrm{d} x\int_{0}^{f(x)} \mathrm{d} y} = \frac{\int_{a}^{b}xf(x) \mathrm{d} x}{\int_{a}^{b}f(x) \mathrm{d} x} \\
  \bar{y} = \frac{\iint\limits_{D}y\mathrm{d}\sigma }{\iint\limits_{D}\mathrm{d}\sigma} =\frac{\int_{a}^{b} \mathrm{d} x\int_{0}^{f(x)} y\mathrm{d} y}{\int_{a}^{b} \mathrm{d} x\int_{0}^{f(x)} \mathrm{d} y} = \frac{\frac{1}{2}\int_{a}^{b}f^2(x) \mathrm{d} x}{\int_{a}^{b}f(x) \mathrm{d} x} 
  \end{gather*}
  $ $


微分方程定义定义1：&ensp;&ensp;凡含有参数，未知函数和未知函数导数(或微分)的方程，称为微分方程，有时简称为方程，未知函数是一元函数的微分方程称作常微分方程，未知函数是多元函数的微分方程称作偏微分方程。微分方程中出现的未知函数最高阶导数的阶数，称为微分方程的阶。
定义2：&ensp;&ensp;任何代入微分方程后使其成为恒等式的函数，都叫做该方程的解。若微分方程的解中含有任意常数的个数与方程的阶数相同，且任意常数之间不能合并，则称此解为该方程的通解(或一般解)。当通解中的各任意常数都取特定值时所得到的解，称为方程的特解。通解和特解都是微分方程的解。
定义3：&ensp;&ensp;设$\varphi_1(x)$、$\varphi_2(x)$为两个函数，二者有如下两种线性关系

当$\varphi_1(x)$、$\varphi_2(x)$不成比例，称$\varphi_1(x)$、$\varphi_2(x)$线性无关
当$\varphi_1(x)$、$\varphi_2(x)$的比为常数，称$\varphi_1(x)$、$\varphi_2(x)$线性相关

可分离变量的微分方程&ensp;&ensp;如果一阶微分方程能写成$g(y)\mathrm{d}y=f(x)\mathrm{d}x$的形式，则称为可分离变量的微分方程
&ensp;&ensp;例如$\frac{\mathrm{d}y}{\mathrm{d}x} = 2xy^2$分离变量后得到$\frac{\mathrm{d}y}{y^2} = 2x\mathrm{d}x$，两边积分即得到通解
齐次微分方程&ensp;&ensp;如果一阶微分方程可化成$\frac{\mathrm{d}y}{\mathrm{d}x} = \varphi(\frac{y}{x})$的形式，就称为齐次方程

$ $
\begin{gather*}
(xy-y^2)\mathrm{d}x-(x^2-2xy)\mathrm{d}y=0\\
\Downarrow \\
\frac{\mathrm{d}y}{\mathrm{d}x} = \frac{xy-y^2}{x^2-2xy} \\
\Downarrow \\
\frac{\mathrm{d}y}{\mathrm{d}x} = \frac{\frac{y}{x}-(\frac{y}{x})^2}{1-2(\frac{y}{x})} 
\end{gather*}
$ $


&ensp;&ensp;在齐次方程$\frac{\mathrm{d}y}{\mathrm{d}x} = \varphi(\frac{y}{x})$中，令$u=\frac {y}{x}$，则$y=ux$，$y=ux$两边对$x$求导得$\frac{\mathrm{d}y}{\mathrm{d}x} = u+x\frac{\mathrm{d}u}{\mathrm{d}x} $，于是原齐次微分方程$\frac {\mathrm{d}y}{\mathrm{d}x}$化为可分离变量的微分方程$u+x\frac {\mathrm{d}u}{\mathrm{d}x} = \varphi (u)$
一阶线性微分方程非齐次&ensp;&ensp;一阶非齐次线性微分方程

$ $
\begin{align*}
\frac{\mathrm{d}y}{\mathrm{d}x}+P(x)y=Q(x)
\end{align*}
$ $


&ensp;&ensp;一阶非齐次线性微分方程的通解

  $ $
  \begin{align*}
  y=e^{-\int P(x)\mathrm{d}x}[\int Q(x)e^{\int P(x)\mathrm{d}x}\mathrm{d}x+C]
  \end{align*}
  $ $


也可写为$\eqref {eq1}$，题目未对$x_0$提出具体要求时，可以任取

  $ $
  \begin{align} \label {eq1}
  y=e^{-\int _{x_0}^{x}P(t)\mathrm{d}t}[\int _{x_0}^{x} Q(t)e^{\int _{x_0}^{t} P(s)\mathrm{d}s}\mathrm{d}t+C]
  \end{align}
  $ $



齐次&ensp;&ensp;一阶齐次线性微分方程

$ $
\begin{align*}
\frac{\mathrm{d}y}{\mathrm{d}x}+P(x)y=0
\end{align*}
$ $


&ensp;&ensp;一阶齐次线性微分方程的通解

$ $
\begin{align*}
y=Ce^{-\int P(x)\mathrm{d}x} \; (C=\pm e^{C_1})
\end{align*}
$ $


可降阶的高阶微分方程$y^{(n)}=f(x)$型&ensp;&ensp;两边一直积分就行
$y’’=f(x,y’)$型&ensp;&ensp;方程中隐式包含$y$，若求通解，设$y’=p$ （$p=p(x)$），那么$y’’=\frac {\mathrm{d}p}{\mathrm{d}x}=p’$，原方程可化为关于$x$、$p$的一阶微分方程$p’=f(x,p)$
$y’’=f(y,y’)$型&ensp;&ensp;方程中隐式包含$x$，若求通解，设$y’=p$ （$p=p(y)$），那么$y’’=\frac {\mathrm{d}p}{\mathrm{d}x}=\frac{\mathrm{d}p}{\mathrm{d}y} \cdot \frac{\mathrm{d}y}{\mathrm{d}x}=p\frac {\mathrm{d}p}{\mathrm{d}y}$，原方程可化为关于$y$、$p$的一阶微分方程$p\frac {\mathrm{d}p}{\mathrm{d}y}=f(y,p)$
高阶线性微分方程性质&ensp;&ensp;有二阶常系数非齐次线性微分方程$ $\begin{align} \label {eq26}  y’’+P(x)y’+Q(x) = f(x)\end{align}$ $
&ensp;&ensp;当$f(x) \equiv 0$时，有二阶常系数齐次线性微分方程$ $\begin{align} \label {eq27}  y’’+P(x)y’+Q(x) = 0\end{align}$ $
性质1&ensp;&ensp;若$\varphi_1(x)$、$\varphi_2(x)$为齐次方程$\eqref {eq27}$的两个线性无关解，则$y=C_1 \varphi_1(x) + C_2 \varphi_2(x)$为齐次方程$\eqref {eq27}$的通解
性质2&ensp;&ensp;若$\varphi(x)$是非齐次方程$\eqref {eq26}$的一个特解，$\psi (x)$为齐次方程$\eqref {eq27}$的通解，则$y=\varphi(x)+\psi (x)$为非齐次方程$\eqref {eq26}$的通解
性质3&ensp;&ensp;若$\varphi_1(x)$、$\varphi_2(x)$为非齐次方程$\eqref {eq26}$的特解，则$y=\varphi_2(x)-\varphi_1(x)$为齐次方程$\eqref {eq27}$的解
性质4&ensp;&ensp;对于非齐次方程$\eqref {eq26}$，设以下两式成立$ $\begin{align} \label {eq28}  y’’+P(x)y’+Q(x) = f_1(x)\end{align}\begin{align} \label {eq29}  y’’+P(x)y’+Q(x) = f_2(x)\end{align}$ $且$f(x)=f_1(x)+f_2(x)$，$\varphi_1(x)$、$\varphi_2(x)$分别为$\eqref {eq28}$、$\eqref {eq29}$的解，则$y=\varphi_1(x) + \varphi_2(x)$为非齐次方程$\eqref {eq26}$的解
常系数齐次线性微分方程&ensp;&ensp;形如$ \eqref {eq36} $称为常系数齐次线性微分方程，其中$p$、$q$为常数
$ $\begin{align} \label {eq36}y’’+py’+qy = 0\end{align}$ $
常系数齐次线性微分方程的通解&ensp;&ensp;根据$ \eqref {eq36} $列出特征方程，如一元二次方程$ \eqref {eq37} $$ $\begin{align}\label {eq37}r^2+pr+q=0\end{align}$ $
&ensp;&ensp;解方程$ \eqref {eq37} $，有如下三种情况

情况1：当$\Delta = p^2-4q \gt 0$时，特征方程$ \eqref {eq37} $有两个不相等的实数根$r_1,r_2$


$ $
\begin{align*}
r_1 = \frac{-p+\sqrt{\Delta } }{2} \\
r_2 = \frac{-p-\sqrt{\Delta } }{2}
\end{align*}
$ $


&ensp;&ensp;此时微分方程$ \eqref {eq36} $的通解是

$ $
\begin{align*}
y=C_1e^{r_1x}+C_2e^{r_2x}
\end{align*}
$ $



情况2：当$\Delta = p^2-4q=0$时，特征方程$ \eqref {eq37} $有两个相等的实数根$r_1=r_2=-\frac{p}{2} $

&ensp;&ensp;此时微分方程$ \eqref {eq36} $的通解是

$ $
\begin{align*}
y=(C_1+C_2x)e^{r_1x}
\end{align*}
$ $



情况3：当$\Delta = p^2-4q \lt 0$时，特征方程$ \eqref {eq37} $有一对共轭的复根$r_1,r_2$（$\alpha,\beta$均为实数,$\beta\ne0$），$i$为虚数，等于$\sqrt[]{-1} $


$ $
\begin{align*}
r_1 = \frac{-b+\sqrt[]{\Delta } }{2} = \alpha +i\beta \\
r_2 = \frac{-b-\sqrt[]{\Delta } }{2} = \alpha - i\beta
\end{align*}
$ $


&ensp;&ensp;此时微分方程$ \eqref {eq36} $的通解是

$ $
\begin{align*}
y=e^{\alpha x}(C_1\cos {\beta x}+C_2\sin {\beta x})
\end{align*}
$ $


常系数非齐次线性微分方程&ensp;&ensp;形如$ \eqref {eq38} $称为常系数非齐次线性微分方程，其中$p$、$q$为常数

$ $
\begin{align} \label {eq38}
y''+py'+qy = f(x)
\end{align}
$ $


常系数非齐次线性微分方程的特解&ensp;&ensp;形如如下两种形式的常系数非齐次线性微分方程可以使用待定系数法求特解

  $ $
  \begin{align} \label {eq39}
  f(x)=e^{\lambda x}P_m(x)
  \end{align}

  \begin{align} \label {eq40}
  f(x)=e^{\lambda x}[P_l(x)\cos (\omega x)+Q_n(x)\sin (\omega x)]
  \end{align}
  $ $



对于$\eqref {eq39}$型，其中$\lambda$是常数，$P_m(x)$是$x$的一个$m$次多项式


  $ $
  \begin{align*}
  P_m(x) = a_0x^m+a_1x^{m-1}+\cdots + a_{m-1}x+a_m
  \end{align*}
  $ $


特解的待定式为

  $ $
  \begin{align*}
  y_0(x) = x^k e^{\lambda x}R_m(x)
  \end{align*}
  $ $



对于$\eqref {eq40}$型，其中$\lambda$、$\omega$是常数，$\omega \ne 0$，$P_l(x)$、$Q_n(x)$分别是$x$的$l$次、$n$次多项式


  $ $
  \begin{gather*}
  P_l(x) = a_0x^l+a_1x^{l-1}+\cdots + a_{l-1}x+a_l \\
  P_n(x) = a_0x^n+a_1x^{n-1}+\cdots + a_{n-1}x+a_n
  \end{gather*}
  $ $


特解待定式为

  $ $
  \begin{align*}
  y_0(x) = x^ke^{\lambda x}[R_{m1}(x)\cos (\omega x)+R_{m2}\sin (\omega x)]
  \end{align*}
  $ $



待定系数法求通解对于$\eqref {eq39}$型&ensp;&ensp;设有常系数非齐次线性微分方程$\eqref {eq41}$

  $ $
  \begin{align} \label {eq41}
  y''+py'+qy=e^{\lambda x}P_m(x)
  \end{align}
  $ $


若要求其通解，有以下四个步骤

步骤1：求$\eqref {eq41}$对应的齐次方程的通解

&ensp;&ensp;令$y’’+py’+qy=0$，于是有特征方程

  $ $
  \begin{align} \label {eq42}
  r^2+pr+q=0
  \end{align}
  $ $


假设解得不相等的实数根$r_1=\alpha$，$r_2=\beta$，则对应的齐次方程的通解为

  $ $
  \begin{align*}
  y_0=C_1e^{\alpha x}+C_2e^{\beta x}
  \end{align*}
  $ $




步骤2：得出$\eqref {eq41}$特解的待定式

&ensp;&ensp;其特解待定式可拆解为三个部分

  $ $
  \begin{gather*}
  y_1(x) = x^k e^{\lambda x}R_m(x)\\
  \Downarrow \\
  y_1(x) = \underline{x^k_{}} \space \underline{e^{\lambda x}_{}} \space \underline{R_m(x)}
  \end{gather*}
  $ $



其中$k$的取值与原方程$\eqref {eq41}$中的$\lambda$及特征方程$\eqref {eq42}$的特征根$r_1$、$r_2$有关
当$\lambda = r_1$或$r_2$时，$k=1$
当$\lambda = r_1 = r_2$时，$k=2$
当$\lambda \ne r_1$且$\lambda \ne r_2$时，$k=0$




待定式中的$e^{\lambda x}$与$\eqref {eq41}$中的$e^{\lambda x}$完全一致，

&ensp;&ensp;若$\eqref {eq41}$中不存在$e^{\lambda x}$，说明$\lambda = 0$

$R_m(x)$是与$\eqref {eq41}$的多项式$P_m(x)$不同系数但相同次数的多项式待定式


&ensp;&ensp;例：
  $ $
  \begin{align*}
  &若P_m(x)=3x+1，则R_m(x)=ax+b；\\
  &若P_m(x)=x^2+4，则R_m(x)=ax^2+bx+c
  \end{align*}
  $ $


&ensp;&ensp;假设$P_m(x)$为$1$次多项式，$\lambda = r_1 = r_2$，那么$\eqref {eq41}$特解的待定式为

  $ $
  \begin{align*}
  y_1=x^2 e^{\lambda x} (ax+b)
  \end{align*}
  $ $




步骤3：待定系数法求$a$、$b$的值，得到$\eqref {eq41}$的特解

&ensp;&ensp;根据$\eqref {eq41}$可知

  $ $
  \begin{align*}
  y_1''+py_1'+qy_1=e^{\lambda x}P_m(x)
  \end{align*}
  $ $


代入$y_1$、$y_1’$、$y_1’’$的待定式，由此可解出$a$、$b$的值，进而得到特解$y_1$

步骤4：求$\eqref {eq41}$的通解

&ensp;&ensp;非齐次线性微分方程的通解=对应的齐次线性微分方程的通解+自身的一个特解，即

  $ $
  \begin{align*}
  y = y_0+y_1
  \end{align*}
  $ $




对于$\eqref {eq40}$型&ensp;&ensp;设有常系数非齐次线性微分方程$\eqref {eq43}$

  $ $
  \begin{align} \label {eq43}
  y''+py'+qy=e^{\lambda x}[P_{l}(x)\cos(\omega x) + Q_{n}(x)\sin(\omega x)]
  \end{align}
  $ $


若要求其通解，有以下四个步骤

步骤1：求$\eqref {eq43}$对应的齐次方程的通解

&ensp;&ensp;令$y’’+py’+qy=0$，于是有特征方程

  $ $
  \begin{align} \label {eq44}
  r^2+pr+q=0
  \end{align}
  $ $


假设解得一对共轭的复根$r_1=\alpha + \beta i$，$r_2= \alpha - \beta i$，则对应的齐次方程的通解为

  $ $
  \begin{align*}
  y_0=e^{\alpha x}[C_1\cos(\beta x) + C_2\sin (\beta x)]
  \end{align*}
  $ $



步骤2：得出$\eqref {eq43}$特解的待定式

&ensp;&ensp;其特解待定式可拆解为三个部分

  $ $
  \begin{gather*}
  y_1(x) = x^k e^{\lambda x} [R_{m1}\cos(\omega x) + R_{m2}\sin(\omega x)]\\
  \Downarrow \\
  y_1(x) = \underline{x^k_{}} \space \underline{e^{\lambda x}_{}} \space \underline{[R_{m1}\cos(\omega x) + R_{m2}\sin(\omega x)]}
  \end{gather*}
  $ $



其中$k$的取值与原方程$\eqref {eq43}$中的$\lambda$、$\omega$及特征方程$\eqref {eq44}$的特征根$r_1$、$r_2$有关（$i$为虚数，等于$\sqrt[]{-1} $）

当$\lambda + \omega i = r_1$或$r_2$时，$k=1$
当$\lambda + \omega i \ne r_1$且$\lambda + \omega i \ne r_2$时，$k=0$


待定式中的$e^{\lambda x}$与$\eqref {eq43}$中的$e^{\lambda x}$完全一致，


&ensp;&ensp;若$\eqref {eq43}$中不存在$e^{\lambda x}$，说明$\lambda = 0$

$R_{m1}(x)$与$R_{m2}(x)$是两个待定多项式，与$M_n(x)$不同系数但相同次数，$M_n(x)$与$P_l(x)$、$Q_n(x)$中次数较大的一个相同


&ensp;&ensp;例：
  $ $
  \begin{align*}
  &若P_l(x)=3x+1，Q_n(x)=5，\\
  &则R_{m1}(x)=ax+b，R_{m2}(x)=cx+d；\\
  &若P_l(x)=x^2+4，Q_n(x)=x+4，\\
  &则R_{m1}=ax^2+bx+c，R_{m2}(x)=\xi x^2+ \eta x + \mu 
  \end{align*}
  $ $


&ensp;&ensp;假设$P_n(x)$、$Q_l(x)$均为$1$次多项式，$\lambda + \omega i = r_1$，那么$\eqref {eq43}$特解的待定式为

  $ $
  \begin{align*}
  y_1=x e^{\lambda x} [(ax+b)\cos(\omega x) + (cx+d)\sin(\omega x)]
  \end{align*}
  $ $




步骤3：待定系数法求$a$、$b$、$c$、$d$的值，得到$\eqref {eq43}$的特解

&ensp;&ensp;根据$\eqref {eq43}$可知

  $ $
  \begin{align*}
  y_1''+py_1'+qy_1=e^{\lambda x}[P_{l}(x)\cos(\omega x) + Q_{n}(x)\sin(\omega x)]
  \end{align*}
  $ $


代入$y_1$、$y_1’$、$y_1’’$的待定式，由此可解出$a$、$b$的值，进而得到特解$y_1$

步骤4：求$\eqref {eq43}$的通解

&ensp;&ensp;非齐次线性微分方程的通解=对应的齐次线性微分方程的通解+自身的一个特解，即

  $ $
  \begin{align*}
  y = y_0+y_1
  \end{align*}
  $ $



数学常用公式定理1
数学常用公式定理3
数学常用公式定理4
数学常用公式定理5
数学常用公式定理6



]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>数学常用公式定理3</title>
    <url>/2023/09/04/%E6%95%B0%E5%AD%A6%E5%B8%B8%E7%94%A8%E5%85%AC%E5%BC%8F%E5%AE%9A%E7%90%863/</url>
    <content><![CDATA[数学常用公式定理1
数学常用公式定理2
数学常用公式定理4
数学常用公式定理5
数学常用公式定理6

多元函数微分平面点集邻域&ensp;&ensp;点$P$的$\delta$邻域

$ $
\begin{align*}
\stackrel {}{U} (P_0, \delta ) & = \left \{  P \mid \left|P P_0\right| \lt \delta \right \} 
\end{align*}
$ $


&ensp;&ensp;点$P$的去心$\delta$邻域

$ $
\begin{align*}
\stackrel {\circ}{U} (P_0, \delta ) & = \left \{  P \mid 0 \lt \left|P P_0\right| \lt \delta \right \} 
\end{align*}
$ $


点和点集之间的关系内点
&nbsp;&nbsp;存在点$P$的邻域$\stackrel {}{U}(P)$，且$\stackrel {}{U}(P) \subset E$，则称$P$为$E$的内点
外点
&nbsp;&nbsp;存在点$P$的邻域$\stackrel {}{U}(P)$，且$\stackrel {}{U}(P) \cap E = \varnothing$，则称$P$为$E$的外点
边界点
&nbsp;&nbsp;点$P$的任意邻域$\stackrel {}{U}(P)$，既含有属于$E$的点，又含有不属于$E$的点，则称$P$为$E$的边界点
聚点&nbsp;&nbsp;对于$\forall \delta \gt 0$，点$P$的去心邻域$\stackrel {0}{U}(P,\delta )$内总有$E$中的点，那么称$P$是$E$的聚点
重要平面点集开集
&nbsp;&nbsp;如果点集$E$的点都是内点，称$E$为开集
闭集
&nbsp;&nbsp;如果点集$E$的边界$\partial E \subset E$，称$E$为闭集
连通集
&nbsp;&nbsp;如果点集$E$内任何两点，都可用折线连接起来，并且折线上的所有点属于$E$，称$E$为连通集
区域
&nbsp;&nbsp;连通的开集$E$，称为区域或开区域
闭区域
&nbsp;&nbsp;开区域连同其边界一起构成的点集称为闭区域
偏导数定义&nbsp;&nbsp;设$z=f(x,y)$，$z$在$(x_0,y_0)$处对$x$的偏导数为

$ $
\begin{align*}
\left.\frac{\partial z}{\partial x}\right |_{\substack{x=x_{0} \\ y=y_{0}}}=
\lim _{\Delta x \rightarrow 0} \frac{f\left(x_{0}+\Delta x, y_{0}\right)-f\left(x_{0}, y_{0}\right)}{\Delta x}
\end{align*}
$ $


&nbsp;&nbsp;对$y$的偏导数为

$ $
\begin{align*}
\left.\frac{\partial z}{\partial y}\right |_{\substack{x=x_{0} \\ y=y_{0}}}= 
\lim_{\Delta y \to 0} \frac{f(x_0,y_0 + \Delta y)-f(x_0,y_0)}{\Delta y} 
\end{align*}
$ $


&nbsp;&nbsp;如果$z=f(x,y)$在区域$D$每一点$(x,y)$处，对$x$的偏导数存在，称这个偏导数为函数$z$对自变量$x$的偏导函数；对$y$同理
高阶偏导数&nbsp;&nbsp;设在区域$D$内，${f}’_x(x,y)=\frac{\partial z}{\partial x} $，${f}’_y(x,y)=\frac{\partial z}{\partial y} $，如果二阶偏导数存在，则

$ $
\begin{align*}
&\frac{\partial }{\partial x} \left (\frac{\partial z}{\partial x} \right ) = \frac{\partial ^2z}{\partial x^2}={f}''_{xx}(x,y)\\
&\frac{\partial }{\partial y} \left (\frac{\partial z}{\partial y} \right ) = \frac{\partial ^2z}{\partial y^2}={f}''_{yy}(x,y)\\
&\frac{\partial }{\partial x} \left (\frac{\partial z}{\partial y} \right ) = \frac{\partial ^2z}{\partial x \partial y}={f}''_{xy}(x,y)\\
&\frac{\partial }{\partial y} \left (\frac{\partial z}{\partial x} \right ) = \frac{\partial ^2z}{\partial y \partial x}={f}''_{yx}(x,y)
\end{align*}
$ $


&nbsp;&nbsp;其中，${f}’’_{xy}(x,y)$与${f}’’_{yx}(x,y)$称为混合偏导数，如果二者在区域$D$内连续，那么必定相等
求导法则一元函数与多元函数复合情形&nbsp;&nbsp;设$z=f(u,v)$在点$(u,v)$有连续偏导数，$u=\varphi (t)$、$v=\psi (t)$在$t$点可导，则有

$ $
\begin{align*}
\frac{\mathrm{d}z }{\mathrm{d}t } = \frac{\partial z}{\partial u} \frac{\mathrm{d}u }{\mathrm{d}t } + \frac{\partial z}{\partial v} \frac{\mathrm{d}v }{\mathrm{d}t } 
\end{align*}
$ $


二阶导

$ $
\begin{align*}
  \frac{\mathrm{d}^2z}{\mathrm{d}t^2} & = \frac{\mathrm{d} }{\mathrm{d} t}\left (\frac{\partial z}{\partial u} \frac{\mathrm{d}u }{\mathrm{d}t } + \frac{\partial z}{\partial v} \frac{\mathrm{d}v }{\mathrm{d}t } \right ) \\
  & = \frac{\mathrm{d} }{\mathrm{d} t}\left ( \frac{\partial z}{\partial u} \frac{\mathrm{d}u }{\mathrm{d}t } \right) + \frac{\mathrm{d} }{\mathrm{d} t}\left ( \frac{\partial z}{\partial v} \frac{\mathrm{d}v }{\mathrm{d}t } \right) \\
  & = \left [ \frac{\mathrm{d} }{\mathrm{d} t}\left ( \frac{\partial z}{\partial u}  \right)\frac{\mathrm{d}u }{\mathrm{d}t } + \frac{\mathrm{d} }{\mathrm{d} t}\left ( \frac{\mathrm{d}u }{\mathrm{d}t } \right)\frac{\partial z}{\partial u} \right ] + \left [ \frac{\mathrm{d} }{\mathrm{d} t}\left ( \frac{\partial z}{\partial v}  \right)\frac{\mathrm{d}v }{\mathrm{d}t } + \frac{\mathrm{d} }{\mathrm{d} t}\left ( \frac{\mathrm{d}v }{\mathrm{d}t } \right)\frac{\partial z}{\partial v} \right ] \\
  & = \left \{ \left [ \frac{\partial }{\partial u}\left ( \frac{\partial z}{\partial u}  \right)\frac{\mathrm{d}u }{\mathrm{d}t } + \frac{\partial }{\partial v}\left ( \frac{\partial z}{\partial u}  \right)\frac{\mathrm{d}v }{\mathrm{d}t } \right ] \frac{\mathrm{d}u }{\mathrm{d}t } + \frac{\partial z}{\partial u} \frac{\mathrm{d}^2u }{\mathrm{d}t^2 } \right \} + \left \{ \left [ \frac{\partial }{\partial u}\left ( \frac{\partial z}{\partial v}  \right)\frac{\mathrm{d}u }{\mathrm{d}t } + \frac{\partial }{\partial v}\left ( \frac{\partial z}{\partial v}  \right)\frac{\mathrm{d}v }{\mathrm{d}t } \right ] \frac{\mathrm{d}v }{\mathrm{d}t } + \frac{\partial z}{\partial v} \frac{\mathrm{d}^2v }{\mathrm{d}t^2 } \right \} 
\end{align*}
$ $


&nbsp;&nbsp;令$\frac {\partial z}{\partial u} = f_1’$，$\frac {\partial z}{\partial v} = f_2’$，则有

$ $
\begin{align*}
\frac{\mathrm{d}z }{\mathrm{d}t } = f_1' \cdot \frac{\mathrm{d}u }{\mathrm{d}t } + f_2' \cdot \frac{\mathrm{d}v }{\mathrm{d}t } 
\end{align*}
$ $


二阶导

$ $
\begin{align*}
\frac{\mathrm{d}^2z}{\mathrm{d} t^2} = f_1' \cdot \frac{\mathrm{d} ^2u }{\mathrm{d} t^2 } + f_2' \cdot \frac{\mathrm{d} ^2v }{\mathrm{d} t^2 } + f_{11}'' \cdot \left ( \frac{\mathrm{d} u }{\mathrm{d} t } \right)^2 + 2f_{12}'' \cdot \frac{\mathrm{d} v }{\mathrm{d} t } \cdot \frac{\mathrm{d} u }{\mathrm{d} t } + f_{22}'' \cdot \left (\frac{\mathrm{d} v }{\mathrm{d} t }  \right )^2
\end{align*}
$ $



多元函数与多元函数复合情形&nbsp;&nbsp;设$z=f(u,v)$在点$(u,v)$有连续偏导数，$u=\varphi (x,y)$、$v=\psi (x,y)$在点$(x,y)$有对$x$、$y$的偏导数，则有

$ $
\begin{align*}
\frac{\partial z }{\partial x } = \frac{\partial z}{\partial u} \frac{\partial u }{\partial x } + \frac{\partial z}{\partial v} \frac{\partial v }{\partial x }\\
\frac{\partial z }{\partial y } = \frac{\partial z}{\partial u} \frac{\partial u }{\partial y } + \frac{\partial z}{\partial v} \frac{\partial v }{\partial y } 
\end{align*}
$ $


二阶导

$ $
\begin{align*}
  \frac{\partial^2z}{\partial x^2} & = \frac{\partial }{\partial x}\left (\frac{\partial z}{\partial u} \frac{\partial u }{\partial x } + \frac{\partial z}{\partial v} \frac{\partial v }{\partial x } \right ) \\
  & = \frac{\partial }{\partial x}\left ( \frac{\partial z}{\partial u} \frac{\partial u }{\partial x } \right) + \frac{\partial }{\partial x}\left ( \frac{\partial z}{\partial v} \frac{\partial v }{\partial x } \right) \\
  & = \left [ \frac{\partial }{\partial x}\left ( \frac{\partial z}{\partial u}  \right)\frac{\partial u }{\partial x } + \frac{\partial }{\partial x}\left ( \frac{\partial u }{\partial x } \right)\frac{\partial z}{\partial u} \right ] + \left [ \frac{\partial }{\partial x}\left ( \frac{\partial z}{\partial v}  \right)\frac{\partial v }{\partial x } + \frac{\partial }{\partial x}\left ( \frac{\partial v }{\partial x } \right)\frac{\partial z}{\partial v} \right ] \\
  & = \left \{ \left [ \frac{\partial }{\partial u}\left ( \frac{\partial z}{\partial u}  \right)\frac{\partial u }{\partial x } + \frac{\partial }{\partial v}\left ( \frac{\partial z}{\partial u}  \right)\frac{\partial v }{\partial x } \right ] \frac{\partial u }{\partial x } + \frac{\partial z}{\partial u} \frac{\partial ^2u }{\partial x^2 } \right \} + \left \{ \left [ \frac{\partial }{\partial u}\left ( \frac{\partial z}{\partial v}  \right)\frac{\partial u }{\partial x } + \frac{\partial }{\partial v}\left ( \frac{\partial z}{\partial v}  \right)\frac{\partial v }{\partial x } \right ] \frac{\partial v }{\partial x } + \frac{\partial z}{\partial v} \frac{\partial ^2v }{\partial x^2 } \right \} \\
  \\
  \frac{\partial^2z}{\partial y^2} & = \frac{\partial }{\partial y}\left (\frac{\partial z}{\partial u} \frac{\partial u }{\partial y } + \frac{\partial z}{\partial v} \frac{\partial v }{\partial y } \right ) \\
  & = \frac{\partial }{\partial y}\left ( \frac{\partial z}{\partial u} \frac{\partial u }{\partial y } \right) + \frac{\partial }{\partial y}\left ( \frac{\partial z}{\partial v} \frac{\partial v }{\partial y } \right) \\
  & = \left [ \frac{\partial }{\partial y}\left ( \frac{\partial z}{\partial u}  \right)\frac{\partial u }{\partial y } + \frac{\partial }{\partial y}\left ( \frac{\partial u }{\partial y } \right)\frac{\partial z}{\partial u} \right ] + \left [ \frac{\partial }{\partial y}\left ( \frac{\partial z}{\partial v}  \right)\frac{\partial v }{\partial y } + \frac{\partial }{\partial y}\left ( \frac{\partial v }{\partial y } \right)\frac{\partial z}{\partial v} \right ] \\
  & = \left \{ \left [ \frac{\partial }{\partial u}\left ( \frac{\partial z}{\partial u}  \right)\frac{\partial u }{\partial y } + \frac{\partial }{\partial v}\left ( \frac{\partial z}{\partial u}  \right)\frac{\partial v }{\partial y } \right ] \frac{\partial u }{\partial y } + \frac{\partial z}{\partial u} \frac{\partial ^2u }{\partial y^2 } \right \} + \left \{ \left [ \frac{\partial }{\partial u}\left ( \frac{\partial z}{\partial v}  \right)\frac{\partial u }{\partial y } + \frac{\partial }{\partial v}\left ( \frac{\partial z}{\partial v}  \right)\frac{\partial v }{\partial y } \right ] \frac{\partial v }{\partial y } + \frac{\partial z}{\partial v} \frac{\partial ^2v }{\partial y^2 } \right \}
\end{align*}
$ $


&ensp;&ensp;令$\frac {\partial z}{\partial u} = f_1’$，$\frac {\partial z}{\partial v} = f_2’$，则有

$ $
\begin{align*}
\frac{\partial z }{\partial x } = f_1' \cdot \frac{\partial u }{\partial x } + f_2' \cdot \frac{\partial v }{\partial x }\\
\frac{\partial z }{\partial y } = f_1' \cdot \frac{\partial u }{\partial y } + f_2' \cdot \frac{\partial v }{\partial y } 
\end{align*}
$ $


二阶导

$ $
\begin{align*}
\frac{\partial^2z}{\partial x^2} = f_1' \cdot \frac{\partial ^2u }{\partial x^2 } + f_2' \cdot \frac{\partial ^2v }{\partial x^2 } + f_{11}'' \cdot \left ( \frac{\partial u }{\partial x } \right)^2 + 2f_{12}'' \cdot \frac{\partial v }{\partial x } \cdot \frac{\partial u }{\partial x } + f_{22}'' \cdot \left (\frac{\partial v }{\partial x }  \right )^2\\
\\
\frac{\partial^2z}{\partial y^2} = f_1' \cdot \frac{\partial ^2u }{\partial y^2 } + f_2' \cdot \frac{\partial ^2v }{\partial y^2 } + f_{11}'' \cdot \left ( \frac{\partial u }{\partial y } \right)^2 + 2f_{12}'' \cdot \frac{\partial v }{\partial y } \cdot \frac{\partial u }{\partial y } + f_{22}'' \cdot \left (\frac{\partial v }{\partial y }  \right )^2
\end{align*}
$ $



隐函数隐函数存在定理1&ensp;&ensp;设函数$F(x,y)$在点$P(x_0,y_0)$的某一邻域内具有连续偏导数，且$F(x_0,y_0)=0$，$F_y(x_0,y_0) \ne 0$，则方程$F(x,y)=0$在点$(x_0,y_0)$的某邻域内恒能唯一确定一个连续且具有连续导数的函数$y=f(x)$，它满足条件$y_0=f(x_0)$，并有

$ $
\begin{align*}
\frac {\mathrm{d}y}{\mathrm{d}x} = -\frac {F_x}{F_y}
\end{align*}
$ $


隐函数存在定理2&ensp;&ensp;设函数$F(x,y,z)$在点$P(x_0,y_0,z_0)$的某一邻域内具有连续偏导数，且$F(x_0,y_0,z_0)=0$，$F_z(x_0,y_0,z_0) \ne 0$，则方程$F(x,y,z)=0$在点$(x_0,y_0,z_0)$的某邻域内恒能唯一确定一个连续且具有连续导数的函数$z=f(x,y)$，它满足条件$z_0=f(x_0,y_0)$，并有

$ $
\begin{align*}
\frac {\partial z}{\partial x} = -\frac {F_x}{F_z}，\frac {\partial z}{\partial y} = -\frac {F_y}{F_z}
\end{align*}
$ $



全微分定理一
&nbsp;&nbsp;如果$z=f(x,y)$在点$(x,y)$可微分，那么在点$(x,y)$的偏导数$\frac{\partial z}{\partial x} $、$\frac{\partial z}{\partial y} $必定存在，且全微分为

$ $
\begin{align*}
\mathrm{d}z = \frac{\partial z}{\partial x} \Delta x + \frac{\partial z}{\partial y} \Delta y
\end{align*}
$ $


&nbsp;&nbsp;通常写作

$ $
\begin{align*}
\mathrm{d}z = \frac{\partial z}{\partial x} \mathrm{d}x + \frac{\partial z}{\partial y} \mathrm{d} y
\end{align*}
$ $


定理二
&nbsp;&nbsp;如果$z=f(x,y)$的偏导数$\frac{\partial z}{\partial x} $、$\frac{\partial z}{\partial y} $在点$(x,y)$连续，那么在该点可微分
多元函数极值极值求法定理一
&ensp;&ensp;设$z=f(x,y)$在点$(x_0,y_0)$有偏导数，且有极值，则有

$ $
\begin{align*}
{f}'_x(x_0,y_0) = 0\\
{f}'_y(x_0,y_0) = 0
\end{align*}
$ $


定理二
&ensp;&ensp;设$z=f(x,y)$在点$(x_0,y_0)$的某邻域内有一阶和二阶连续偏导数，又${f}’_x(x_0,y_0) = 0$，${f}’_y(x_0,y_0) = 0$，令

$ $
\begin{align*}
{f}''_{xx}(x_0,y_0) = A,\space {f}''_{xy}(x_0,y_0) = B,\space {f}''_{yy}(x_0,y_0) = C
\end{align*}
$ $


则$f(x,y)$在$(x_0,y_0)$处是否取得极值的条件如下：

$AC-B^2 \gt 0$时，有极值，且$A \lt 0$时有极大值，$A \gt 0$时有极小值
$AC-B^2 \lt 0$时，没有极值
$AC-B^2 = 0$时，需要讨论


&ensp;&ensp;如果三元函数$u=f(x,y,z)$在点$(x_0,y_0,z_0)$具有偏导数，那么它在点$(x_0,y_0,z_0)$具有极值的充分必要条件是
$ $
\begin{align*}
f'_x(x_0,y_0,z_0)=0,f'_y(x_0,y_0,z_0)=0,f'_z(x_0,y_0,z_0)=0
\end{align*}
$ $



条件极值拉格朗日乘数法
&ensp;&ensp;要找$z=f(x,y)$在附加条件$\varphi (x,y)=0$下的可能极值点，先做拉格朗日函数

$ $
\begin{align*}
L(x,y)=f(x,y)+\lambda \varphi (x,y)
\end{align*}
$ $


其中$\lambda$为参数；求拉格朗日函数对$x$、$y$的一阶偏导，并使之为零，然后与附加条件方程联立

$ $
\begin{align*}
\begin{cases}
  {f}'_x(x,y) + \lambda {\varphi}'_x(x,y) = 0 \\  
  {f}'_y(x,y) + \lambda {\varphi}'_y(x,y) = 0 \\
  \varphi(x,y) = 0
\end{cases}
\end{align*}
$ $


解出$x$、$y$、$\lambda$，列出所有$(x,y)$组合，就得到了$z=f(x,y)$在附加条件$\varphi (x,y)=0$下的可能极值点（约束条件如果存在端点，端点处的极值需要额外考虑）
&ensp;&ensp;当自变量和条件增加时，例如$u=f(x,y,z,t)$在附加条件$\varphi (x,y,z,t)=0$，$\psi (x,y,z,t)=0$下的极值，可做拉格朗日函数

$ $
\begin{align*}
L(x,y,z,t)=f(x,y,z,t)+\lambda \varphi (x,y,z,t)+\mu \psi (x,y,z,t)
\end{align*}
$ $


其中$\varphi$、$\mu$均为参数；求拉格朗日函数对$x$、$y$、$z$、$t$的一阶偏导，并使之为零，然后与附加条件方程联立，并解出$x$、$y$、$z$、$t$、$\varphi$、$\mu$，并列出所有$(x,y,z,t)$组合，就得到了$u=f(x,y,z,t)$在附加条件$\varphi (x,y,z,t)=0$，$\psi (x,y,z,t)=0$下的可能极值点（约束条件如果存在端点，端点处的极值需要额外考虑）

&ensp;&ensp;例：将长为2m的铁丝分成三段，依次围成圆、正方形与正三角形，求三个图形面积之和的最小值
$ $
\begin{array}{l}
设圆形的周长为x，正方形周长为y，正三角形周长为z，则x+y+z-2=0\\
\therefore S_圆=\frac{x^2}{4\pi},S_正=\frac{y}{16},S_三=\frac{\sqrt[]{3} }{36}z^2 \\ 
令f(x,y,z)=\frac{x^2}{4\pi}+\frac{y^2}{16}+\frac{\sqrt[]{3} }{36}z^2，\varphi (x,y,z)=x+y+z-2\\
做拉格朗日函数L(x,y,z)=f(x,y,z)+\lambda \varphi (x,y,z)\\
\therefore L(x,y,z)= \frac{x^2}{4\pi}+\frac{y^2}{16}+\frac{\sqrt[]{3} }{36}z^2+\lambda (x+y+z-2)\\
L'_x=\frac{x}{2\pi}+\lambda，L'_y=\frac{y}{8}+\lambda，L'_z=\frac{\sqrt[]{3}}{18}z+\lambda\\
联立方程组\begin{cases}
 \frac{x}{2\pi}+\lambda=0\\
 \frac{y}{8}+\lambda=0\\
 \frac{\sqrt[]{3}}{18}z+\lambda=0\\
 x+y+z-2=0
\end{cases}\space 解得\begin{cases}
 \lambda = -\frac{1}{\pi + 4 + 3\sqrt[]{3} } \\
 x=\frac{2\pi}{\pi + 4 + 3\sqrt[]{3}} \\
 y=\frac{8}{\pi + 4 + 3\sqrt[]{3}} \\
 z=\frac{6\sqrt[]{3}}{\pi + 4 + 3\sqrt[]{3}}
\end{cases}\\
此时S取最小值为\frac{1}{\pi + 4 + 3\sqrt[]{3}} 
\end{array}
$ $



重积分二重积分的性质性质1&ensp;&ensp;设$\alpha $与$\beta $为常数，则

  $ $
  \begin{align*}
  \iint\limits_{D}^{} [\alpha f(x,y)+\beta g(x,y)]\mathrm{d} \sigma = \alpha \iint \limits_{D}^{}f(x,y)\mathrm{d}\sigma + \beta \iint \limits_{D}^{}g(x,y)\mathrm{d} \sigma 
  \end{align*}
  $ $


性质2&ensp;&ensp;如果闭区域$D$被有限条曲线分为有限个部分闭区域，那么在$D$上的二重积分等于在各部分闭区域上的二重积分的和，例如$D$分为两个闭区域$D_1$和$D_2$，则

  $ $
  \begin{align*}
  \iint \limits _{D}^{}f(x,y)\mathrm{d} \sigma =\iint \limits _{D_1}^{}f(x,y)\mathrm{d} \sigma+\iint \limits _{D_2}{}f(x,y)\mathrm{d} \sigma
  \end{align*}
  $ $


性质3&ensp;&ensp;如果在$D$上，$f(x,y)=1$，$\sigma$为$D$的面积，那么

  $ $
  \begin{align*}
  \sigma =\iint \limits _{D}^{}1\cdot \mathrm{d}\sigma =\iint \limits _{D}^{} \mathrm{d} \sigma 
  \end{align*}
  $ $



性质4 ①&ensp;&ensp;如果在$D$上，$f(x,y) \le g(x,y)$，那么有

  $ $
  \begin{align*}
  \iint \limits _{D}^{} f(x,y)\mathrm{d} \sigma \le \iint \limits _{D}^{} g(x,y)\mathrm{d} \sigma  
  \end{align*}
  $ $


性质4 ②&ensp;&ensp;由于$f(x,y) \le \left|f(x,y)\right|$，那么有

  $ $
  \begin{align*}
  \left|\iint \limits _{D}^{} f(x,y)\mathrm{d} \sigma\right| \le \iint \limits _{D}^{} \left|f(x,y)\right|\mathrm{d} \sigma  
  \end{align*}
  $ $


性质5&ensp;&ensp;设$M$和$m$分别是$f(x,y)$在闭区域$D$上的最大值和最小值，$\sigma$是$D$的面积，则有

  $ $
  \begin{align*}
  m\sigma \le \iint \limits _{D}^{} f(x,y)\mathrm{d}\sigma \le M\sigma
  \end{align*}
  $ $


性质6 二重积分的中值定理&ensp;&ensp;设$f(x,y)$在闭区域$D$上连续，$\sigma$是$D$的面积，则在$D$上至少存在一点$(\xi ,\eta )$，使得

  $ $
  \begin{align*}
  \iint \limits _{D}^{} f(x,y)\mathrm{d}\sigma =f(\xi, \eta)\sigma 
  \end{align*}
  $ $



直角坐标下二重积分的计算&ensp;&ensp;X-型：若区域$D$表示为

$ $
\begin{align*}
D=\{(x,y)|a\le x\le b, \varphi _1(x)\le y \le \varphi _2(x)\}
\end{align*}
$ $


则有

  $ $
  \begin{align*}
  \iint\limits_{D}^{} f(x,y)\mathrm{d}\sigma  = \int_{a}^{b}\mathrm{d}x\int_{\varphi_{1}(x)}^{\varphi_{2}(x)}(x,y)\mathrm{d}y
  \end{align*}
  $ $



&ensp;&ensp;Y-型：若区域$D$表示为

$ $
\begin{align*}
D=\{(x,y)|\varphi _1(x)\le x \le \varphi _2(x), c \le y \le d\}
\end{align*}
$ $


则有

  $ $
  \begin{align*}
  \iint\limits_{D}^{} f(x,y)\mathrm{d}\sigma  = \int_{c}^{d}\mathrm{d}y\int_{\varphi_{1}(y)}^{\varphi_{2}(y)}(x,y)\mathrm{d}x
  \end{align*}
  $ $



极坐标系下二重积分的计算直角坐标与极坐标的对应关系&ensp;&ensp;令$\begin{cases} x=\rho \cos \theta \\  y=\rho \sin \theta \end{cases} $，&ensp;&ensp;于是$f(x,y)=f(\rho \cos\theta,\rho \sin\theta)$，&ensp;&ensp;其中$\rho =\rho (\theta )$，&ensp;&ensp;若区域$D$表示为

$ $
\begin{align*}
D=\{(\rho,\theta)|\alpha \le \theta \le \beta ,\rho_1(\theta) \le \rho \le \rho_2(\theta)\}
\end{align*}
$ $


则有

  $ $
  \begin{align*}
  \iint\limits_{D}^{} f(x,y)\mathrm{d}\sigma  = \int_{\alpha }^{\beta }\mathrm{d}\theta \int_{\rho_1(\theta )}^{\rho_2(\theta )} f(\rho \cos\theta,\rho \sin\theta)\rho\mathrm{d}\rho
  \end{align*}
  $ $



三种情况&ensp;&ensp;1、若极点在区域$D$内部时

$ $
\begin{align*}
D=\{(\theta ,\rho )\, |\, 0 \le \theta \le 2\pi ,0 \le \rho  \le \rho (\theta )\}
\end{align*}
$ $


则有

  $ $
  \begin{align*}
  \iint\limits_{D}^{} f(\rho \cos\theta,\rho \sin\theta)\rho \mathrm{d}\rho \mathrm{d}\theta = \int_{0}^{2\pi}\mathrm{d}\theta\int_{0}^{\rho (\theta)}f(\rho \cos\theta,\rho \sin\theta)\rho \mathrm{d}\rho 
  \end{align*}
  $ $


&ensp;&ensp;2、若极点在区域$D$的边界线上

$ $
\begin{align*}
D=\{(\theta ,\rho )\, |\, \alpha \le \theta \le \beta  ,0 \le \rho  \le \rho (\theta )\}
\end{align*}
$ $

则有

  $ $
  \begin{align*}
  \iint\limits_{D}^{} f(\rho \cos\theta,\rho \sin\theta)\rho \mathrm{d}\rho \mathrm{d}\theta = \int_{\alpha }^{\beta}\mathrm{d}\theta\int_{0}^{\rho (\theta)}f(\rho \cos\theta,\rho \sin\theta)\rho \mathrm{d}\rho 
  \end{align*}
  $ $



&ensp;&ensp;3、若极点在区域$D$之外

$ $
\begin{align*}
D=\{(\theta ,\rho )\, |\, \alpha \le \theta \le \beta  ,\rho _{1}(\theta) \le \rho \le \rho _2(\theta )\}
\end{align*}
$ $

则有

  $ $
  \begin{align*}
  \iint\limits_{D}^{} f(\rho \cos\theta,\rho \sin\theta)\rho \mathrm{d}\rho \mathrm{d}\theta = \int_{\alpha }^{\beta}\mathrm{d}\theta\int_{\rho _{1}(\theta)}^{\rho _{2}(\theta)}f(\rho \cos\theta,\rho \sin\theta)\rho \mathrm{d}\rho 
  \end{align*}
  $ $


二重积分特性偶倍奇零对称性&ensp;&ensp;设$f(x,y)$在有界闭区域$D$上连续，当积分区域有如下三种对称方式时

若积分区域$D$关于$y$轴对称，则


&ensp;&ensp;(其中$D_1$是$D$的右半部分)
$ $
\begin{align*}
\iint\limits_{D}^{} f(x,y)\mathrm{d}x\mathrm{d}y = 
\begin{cases}
  2\iint\limits_{D_1}^{}f(x,y)\mathrm{d}x\mathrm{d}y ,& \space f(-x,y)=f(x,y) \\  
  0 ,& \space f(-x,y)=-f(x,y)
\end{cases}
\end{align*}
$ $



若积分区域$D$关于$x$轴对称，则


&ensp;&ensp;(其中$D_1$是$D$的上半部分)
$ $
\begin{align*}
\iint\limits_{D}^{} f(x,y)\mathrm{d}x\mathrm{d}y = 
\begin{cases}
  2\iint\limits_{D_1}^{}f(x,y)\mathrm{d}x\mathrm{d}y,&\space f(x,-y)=f(x,y) \\  
  0,&\space f(x,-y)=-f(x,y)
\end{cases}
\end{align*}
$ $



若积分区域$D$关于原点对称，则


&ensp;&ensp;(其中$D_1$是$D$的上半部分)
$ $
\begin{align*}
\iint\limits_{D}^{} f(x,y)\mathrm{d}x\mathrm{d}y = 
\begin{cases}
  2\iint\limits_{D_1}^{}f(x,y)\mathrm{d}x\mathrm{d}y,&\space f(-x,-y)=f(x,y) \\  
  0,&\space f(-x,-y)=-f(x,y)
\end{cases}
\end{align*}
$ $


轮换对称性
设$f(x,y)$在有界闭区域$D$上连续，积分区域$D$关于$y=x$对称，则


$ $
\begin{align*}
\iint \limits _{D}^{}f(x,y)\mathrm{d}x\mathrm{d}y= \iint \limits _{D}^{} f(y,x)\mathrm{d}x\mathrm{d}y=\frac{1}{2} \iint \limits _{D}^{}[f(x,y)+f(y,x)]\mathrm{d}x\mathrm{d}y
\end{align*}
$ $



若被积函数$f(x,y)$满足$f(x,y)=f(y,x)$，则称$f(x,y)$关于$x$和$y$轮换对称，那么


$ $
\begin{align*}
\iint \limits _{D}^{}f(x,y)\mathrm{d}x\mathrm{d}y=2 \iint \limits _{D_1}^{}f(x,y)\mathrm{d}x\mathrm{d}y
\end{align*}
$ $



若被积函数$f(x,y)$满足$f(x,y)=-f(y,x)$，那么


$ $
\begin{align*}
\iint \limits _{D}^{}f(x,y)\mathrm{d}x\mathrm{d}y=0
\end{align*}
$ $



二重积分换元法雅可比行列式
$ $
\begin{align*}
J = 
\begin{vmatrix}
\frac{\partial (f_1 ,\cdots, f_n)}{\partial (x_1, \cdots, x_n)} 
\end{vmatrix}
=
\begin{vmatrix}
  \frac{\partial f_1}{\partial x_1}  & \cdots & \frac{\partial f_1}{\partial x_n} \\  
  \vdots & \ddots & \vdots \\  
  \frac{\partial  f_n}{\partial x_1} & \cdots & \frac{\partial  f_n}{\partial x_n}  
\end{vmatrix}
\end{align*}
$ $


换元法
$ $
\begin{align*}
&有直角坐标系下的二重积分\iint\limits_{D_{xy}}^{} f(x,y)\mathrm{d} x\mathrm{d} y\\
&令\begin{cases}
 x=x(u,v)\\
 y=y(u,v)
\end{cases}，可推出\begin{cases}
 u=u(x,y)\\
 v=v(x,y)
\end{cases}\\ \\
&则有：\\
&1. f(x,y) \to f[x(u,v),y(u,v)]，\\
&2. \iint\limits_{D_{xy}}^{} \to \iint\limits_{D_{uv}}^{}，\\
&3. \mathrm{d}x\mathrm{d}y \to \begin{vmatrix}
\frac{\partial (x,y)}{\partial (u,v)} 
\end{vmatrix}\mathrm{d}u\mathrm{d}v \to J\mathrm{d}u\mathrm{d}v，\\ \\
&对J取绝对值，即有：\\
&\iint\limits_{D_{xy}}^{} f(x,y)\mathrm{d} x\mathrm{d} y = 
\iint\limits_{D_{uv}}^{}f[x(u,v),y(u,v)]\left|J\right|\mathrm{d}u\mathrm{d}v
\end{align*}
$ $



无穷级数三大参照级数几何级数（等比级数）&ensp;&ensp;其中$a \ne 0$，$q$是级数的公比

  $ $
  \begin{align*}
  \sum_{n=1}^{\infty} aq^{n-1}=a+aq+aq^2+···+aq^{n-1}+···
  \end{align*}
  $ $


&ensp;&ensp;当$\left| q \right| \lt 1$时，级数收敛；当$\left|q \right|\ge1$时，级数发散
调和级数&ensp;&ensp;调和级数$\sum_{n=1}^{\infty } \frac{1}{n} $是发散的
$p$级数
$ $
\begin{align*}
\sum_{n=1}^{\infty } \frac{1}{n^p} 
\end{align*}
$ $


&ensp;&ensp;$p$级数当$0 \lt p \le 1$时是发散的，当$p\gt 1$时是收敛的
数项级数&ensp;&ensp;如果级数的部分和数列$ \{S_n\} $有极限S（级数的和），则称级数是收敛的，如果没有极限，则称级数是发散的
收敛级数的性质性质1&ensp;&ensp;若级数$\sum_{n=1}^{\infty } u_n$收敛于$S$，则级数$\sum_{n=1}^{\infty } ku_n$也收敛，且收敛于$kS$
性质2&ensp;&ensp;若级数$\sum_{n=1}^{\infty } u_n$与级数$\sum_{n=1}^{\infty } v_n$分别收敛于$S_1,S_2$，则级数$\sum_{n=1}^{\infty } (u_n \pm v_n)$收敛于$S_1 \pm S_2$；但级数$\sum_{n=1}^{\infty } u_n$与级数$\sum_{n=1}^{\infty } v_n$都发散时，级数$\sum_{n=1}^{\infty } (u_n \pm v_n)$不一定发散
性质3&ensp;&ensp;在级数中去掉、加上或改变有限项，不会改变该级数的敛散性
性质4&ensp;&ensp;如果级数收敛，则该级数的任意项加括号所成的级数仍收敛，且其和不变；如果加括号后所成的级数收敛，则不能断定原级数也收敛；如果加括号后的级数发散，则原级数也发散
级数收敛的必要条件定理1若级数$\sum_{n=1}^{\infty } u_n$收敛，则$\lim_{n \to \infty } u_n=0$
推论若$\lim_{n \to \infty } u_n \ne 0$或不存在，则级数$\sum_{n=1}^{\infty } u_n$发散
正项级数正项级数的部分和数列$\{S_n\}$是单调增加的，所以定理2正项级数$\sum_{n=1}^{\infty } u_n$收敛的充分必要条件是它的部分和数列$\{S_n\}$有界
定理3（比较判别法）设$\sum_{n=1}^{\infty } u_n$和$\sum_{n=1}^{\infty } v_n$均为正项级数，且$u_n \le v_n$，

如果级数$\sum_{n=1}^{\infty } v_n$收敛，则级数$\sum_{n=1}^{\infty } u_n$收敛
如果级数$\sum_{n=1}^{\infty } u_n$发散，则级数$\sum_{n=1}^{\infty } v_n$发散

定理4（比较判别法的极限形式）设$\sum_{n=1}^{\infty } u_n$和$\sum_{n=1}^{\infty } v_n$均为正项级数，且$\lim_{n \to \infty } \frac{u_n}{v_n} = A$

若$0 \lt A \lt +\infty$，则$\sum_{n=1}^{\infty } u_n$和$\sum_{n=1}^{\infty } v_n$同时收敛或发散
若$A=0$，且$\sum_{n=1}^{\infty } v_n$收敛，则$\sum_{n=1}^{\infty } u_n$收敛
若$A=+\infty$且$\sum_{n=1}^{\infty } v_n$发散，则$\sum_{n=1}^{\infty } u_n$发散

定理5（比值判别法）设$\sum_{n=1}^{\infty } u_n$为正项级数，如果$\lim_{n \to \infty } \frac{u_n+1}{u_n} = \rho $

当$\rho \lt 1$时，级数收敛
当$\rho \gt 1$时，级数发散
当$\rho = 1$时，级数可能收敛，也可能发散

定理6（根值判别法）设$\sum_{n=1}^{\infty } u_n$为正项级数，如果$\lim_{n \to \infty } \sqrt[n]{u_n}=p$

当$p \lt 1$时，级数收敛
当$p \gt 1$时，级数发散
当$p=1$时，可能收敛，也可能发散

定理7（极限判别法）设$\sum_{n=1}^{\infty } u_n$为正项级数

如果$\lim_{n \to \infty} nu_n=l \gt 0$，则级数发散
如果$p \gt 1$，而$\lim_{n \to \infty} n^pu_n=l(0\le l \lt +\infty)$，则级数收敛

交错级数定理8（莱布尼兹判别法）如果交错级数$\sum_{n=1}^{\infty } (-1)^{n-1}u_n$满足如下条件，则级数收敛，且其和$S \le u_1$，其余项$r_n$的绝对值为$\left|r_n\right| \le u_{n+1}$

$u_n \ge u_{n+1}$
$\lim_{n \to \infty} u_n=0$

任意项级数定义&ensp;&ensp;如果级数$\sum_{n=1}^{\infty } \left|u_n\right|$收敛，则级数$\sum_{n=1}^{\infty } u_n$也收敛，此时称级数$\sum_{n=1}^{\infty } u_n$绝对收敛&ensp;&ensp;如果级数$\sum_{n=1}^{\infty } \left|u_n\right|$发散，而级数$\sum_{n=1}^{\infty } u_n$也收敛，此时称级数$\sum_{n=1}^{\infty } u_n$条件收敛
定理9如果级数$\sum_{n=1}^{\infty } \left|u_n\right|$收敛，则级数$\sum_{n=1}^{\infty } u_n$一定收敛推论

如果级数$\sum_{n=1}^{\infty } u_n$发散，则级数$\sum_{n=1}^{\infty } \left|u_n\right|$一定发散
当$\sum_{n=1}^{\infty } u_n$条件收敛时，级数$\sum_{n=1}^{\infty} \frac{\left|u_n\right|+u_n}{2}$和$\sum_{n=1}^{\infty} \frac{\left|u_n\right|-u_n}{2} $均发散

幂级数求幂级数的方法&ensp;&ensp;先求幂级数的收敛区间$(-R,R)$，然后讨论幂级数在$x=R$与$x=-R$处的敛散性，从而得出幂级数的收敛域
定理1（阿贝尔定理）&ensp;&ensp;如果幂级数$\sum_{n=0}^{\infty}a_nx^n$当$x=x_0(x_0\ne0)$时收敛，则对于所有满足$\left|x\right| \lt \left|x_0\right|$的点$x$，幂级数$\sum_{n=0}^{\infty}a_nx^n$绝对收敛，&ensp;&ensp;反之，如果幂级数$\sum_{n=0}^{\infty}a_nx^n$当$x=x_0(x_0\ne0)$时发散，则对于所有满足$\left|x\right| \gt \left|x_0\right|$的点$x$，幂级数$\sum_{n=0}^{\infty}a_nx^n$发散
定理2设幂级数$\sum_{n=0}^{\infty}a_nx^n$，有$\lim_{n \to \infty} \left|\frac{a_n+1}{a_n} \right| = \rho$，则

若$\rho \ne 0$，则收敛半径$R=\frac{1}{\rho}$
若$\rho = 0$，则收敛半径$R = +\infty$
若$\rho = +\infty$，则收敛半径$R=0$

幂级数四则运算&ensp;&ensp;设幂级数$\sum_{n=0}^{\infty}a_nx^n$在其收敛区间$(-R_1,R_1)(R_1 \gt 0)$内的和函数为$S_1(x)$，幂级数$\sum_{n=0}^{\infty}b_nx^n$在其收敛区间$(-R_2,R_2)(R_2 \gt 0)$内的和函数为$S_2(x)$，取$R=\mathrm{min}\{R_1,R_2\} $，则有
1.加减运算$\eqref {eq27}$，其收敛区间为$(-R,R)$

  $ $
  \begin{align} \label {eq27}
  \sum_{n=0}^{\infty}a_nx^n \pm \sum_{n=0}^{\infty}b_nx^n=\sum_{n=0}^{\infty}(a_n \pm b_n)x^n = S_1(x) \pm S_2(x)
  \end{align}
  $ $


2.乘法运算$\eqref {eq28}$，其收敛区间为$(-R,R)$

  $ $
  \begin{align} \label {eq28}
  \sum_{n=0}^{\infty}a_nx^n \cdot \sum_{n=0}^{\infty}b_nx^n = a_0b_0 + (a_0b_1+a_1b_0)x+(a_0b_2+a_1b_1+a_2b_0)x^2+ \cdot \cdot \cdot + (a_0b_n+a_1b_{n-1}+a_2b_{n-2}+\cdot \cdot \cdot +a_nb_0)x^n+\cdot \cdot \cdot = S_1(x)S_2(x)
  \end{align}
  $ $


幂函数的和函数的性质&ensp;&ensp;幂级数在其收敛区间内可以逐项求导或逐项积分，并且逐项求导或者逐项积分后所得幂级数的收敛区间不变，但在其收敛区间的端点处，级数的敛散性可能会改变
设幂级数$\sum_{n=0}^{\infty}a_nx^n$的和函数为$S(x)$，则1.$S(x)$在其收敛域上连续，当$x_0 \in (-R,R)$时，有

  $ $
  \begin{align*}
  \lim_{x \to x_0 } (\sum_{n=0}^{\infty } a_nx^n) = \sum _{n=0}^{\infty}(\lim_{x \to x_0 }a_nx^n) = \sum _{n=0}^{\infty}a_nx^n_0 = S(x_0)
  \end{align*}
  $ $


2.微分运算，$S(x)$在其收敛区间$(-R,R)$内可导，且

  $ $
  \begin{align*}
  S'(x)=(\sum_{n=0}^{\infty}a_nx^n)'=\sum_{n=0}^{\infty}(a_nx^n)'=\sum_{n=0}^{\infty}na_nx^{n-1}
  \end{align*}
  $ $


&ensp;&ensp;其收敛区间为$(-R,R)$
3.积分运算，$S(x)$在其收敛域上可积，且

  $ $
  \begin{align*}
  \int_{0}^{x}S(t)\mathrm{d}t=\int_{0}^{x} (\sum_{n=0}^{\infty}a_nt^n)\mathrm{d}t=\sum_{n=0}^{\infty}(\int_{0}^{x}a_nt^n\mathrm{d}t)=\sum_{n=0}^{\infty} \frac{a_n}{n+1}x^{n+1}
  \end{align*}
  $ $


&ensp;&ensp;其收敛区间为$(-R,R)$
数学常用公式定理1
数学常用公式定理2
数学常用公式定理4
数学常用公式定理5
数学常用公式定理6
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>数学常用公式定理4</title>
    <url>/2023/09/23/%E6%95%B0%E5%AD%A6%E5%B8%B8%E7%94%A8%E5%85%AC%E5%BC%8F%E5%AE%9A%E7%90%864/</url>
    <content><![CDATA[数学常用公式定理1
数学常用公式定理2
数学常用公式定理3
数学常用公式定理5
数学常用公式定理6

行列式行列式概念逆序数
&ensp;&ensp;排列$i_1 i_2 i_3 i_4$的逆序数记为$\tau (i_1 i_2 i_3 i_4)$
二阶行列式

$ $
\begin{align*}
\begin{vmatrix}
 a_{11} & a_{12}\\
 a_{21} & a_{22}
\end{vmatrix}=a_{11}a_{22}-a_{12}a_{21}
\end{align*}
$ $


三阶行列式

$ $
\begin{align*}
\begin{vmatrix}
 a_{11} & a_{12} & a_{13}\\
 a_{21} & a_{22} & a_{23}\\
 a_{31} & a_{32} & a_{33}
\end{vmatrix}
=
\begin{matrix}
 a_{11}a_{22}a_{33}+a_{12}a_{23}a_{31}+a_{13}a_{21}a_{32}\\
 -a_{13}a_{22}a_{31}-a_{12}a_{21}a_{33}-a_{11}a_{23}a_{32}
\end{matrix}
\end{align*}
$ $


定义计算三阶行列式
&ensp;&ensp;将三阶行列式分为如下六项，取每项$a_{ij}$中的$j$并组成排列，再取排列的逆序数，若逆序数为偶数，则该项为正，反之为负。三、四阶行列式使然

$ $
\begin{align*}
\begin{vmatrix}
 a_{11} & a_{12} & a_{13}\\
 a_{21} & a_{22} & a_{23}\\
 a_{31} & a_{32} & a_{33}
\end{vmatrix}
=
\left\{\begin{matrix}
 a_{11}\left\{\begin{matrix}
  a_{22} \left\{\begin{matrix}
   a_{33} \space  \left [ \tau \left ( 123 \right )=0 \right ]
  \end{matrix}\right.\\
  a_{23} \left\{\begin{matrix}
   a_{32} \space  \left [ \tau \left ( 132 \right )=1 \right ]
  \end{matrix}\right.\\
 \end{matrix}\right.\\
 a_{12}\left\{\begin{matrix}
  a_{21} \left\{\begin{matrix}
   a_{33} \space  \left [ \tau \left ( 213 \right )=1 \right ]
  \end{matrix}\right.\\
  a_{23} \left\{\begin{matrix}
   a_{31} \space  \left [ \tau \left ( 231 \right )=2 \right ]
  \end{matrix}\right.\\
 \end{matrix}\right.\\
 a_{13} \left\{\begin{matrix}
  a_{21} \left\{\begin{matrix}
   a_{32} \space  \left [ \tau \left ( 312 \right )=2 \right ]
  \end{matrix}\right.\\
  a_{22} \left\{\begin{matrix}
   a_{31} \space  \left [ \tau \left ( 321 \right )=3 \right ]
  \end{matrix}\right.\\
 \end{matrix}\right.
\end{matrix}\right.
\end{align*}
$ $


余子式与代数余子式&ensp;&ensp;把$\eqref {eq3}$中元素$a_{ij}$所在的第$i$行元素和第$j$列元素去掉，剩下的$n-1$行$n-1$列元素按照原排列次序构成的$n-1$阶行列式，称为元素$a_{ij}$的余子式，记为$M_{ij}$，并称$A_{ij}=(-1)^{i+j}M_{ij}$为元素$a_{ij}$的代数余子式

$ $
\begin{align} \label {eq3}
D=
\begin{vmatrix}
 a_{11} & a_{12} & \cdots & a_{1n}\\
 a_{21} & a_{22} & \cdots & a_{2n}\\
 \vdots & \vdots & \ddots & \vdots\\
 a_{n1} & a_{n2} & \cdots & a_{nn}
\end{vmatrix}
\end{align}
$ $


特殊行列式对角、上（下）三角行列式

$ $
\begin{align*}
\begin{vmatrix}
 a_{11} & 0 & \cdots & 0\\
 0 & a_{22} & \cdots & 0\\
 \vdots & \vdots &        & \vdots\\
 0 & 0 & \cdots & a_{nn}
\end{vmatrix}
=
\begin{vmatrix}
 a_{11} & a_{12} & \cdots & a_{1n}\\
 0 & a_{22} & \cdots & a_{2n}\\
 \vdots & \vdots &        & \vdots\\
 0 & 0 & \cdots & a_{nn}
\end{vmatrix}
=
\begin{vmatrix}
 a_{11} & 0 & \cdots & 0\\
 a_{21} & a_{22} & \cdots & 0\\
 \vdots & \vdots &        & \vdots\\
 a_{n1} & a_{n2} & \cdots & a_{nn}
\end{vmatrix}
=
a_{11}a_{22}\cdots a_{nn}
\end{align*}
$ $



范德蒙行列式
&ensp;&ensp;其中$\prod$表示全体同类因子的乘积

$ $
\begin{align*}
D_n=\begin{vmatrix}
 1 & 1 & \cdots & 1\\
 x_1 & x_2 & \cdots & x_n\\
 x_1^2 & x_2^2 & \cdots & x_n^2\\
 \vdots & \vdots &  & \vdots\\
 x_1^{n-1} & x_2^{n-1} & \cdots & x_n^{n-1}
\end{vmatrix}
=
\prod \limits_{n\ge i \gt j\ge 1}^{}(x_i-x_j)
\end{align*}
$ $



&ensp;&ensp;例：
$ $
\begin{align*}
&D_2=\begin{vmatrix}
 1 & 1\\
 x_1 & x_2
\end{vmatrix}=(x_2-x_1) \\

&D_3=\begin{vmatrix}
 1 & 1 & 1\\
 x_1 & x_2 & x_3\\
 x_1^2 & x_2^2 & x_3^2
\end{vmatrix}
=
(x_3-x_1)(x_3-x_2)(x_2-x_1) \\

&D_4=\begin{vmatrix}
 1 & 1 & 1 & 1\\
 x_1 & x_2 & x_3 & x_4\\
 x_1^2 & x_2^2 & x_3^2 & x_4^2\\
 x_1^3 & x_2^3 & x_3^3 & x_4^3
\end{vmatrix}
=
\begin{matrix}
(x_4-x_1)(x_4-x_2)(x_4-x_3)\\
(x_3-x_1)(x_3-x_2)(x_2-x_1)
\end{matrix}
\end{align*}
$ $


行列式的性质计算性质性质1：行列式与其转置行列式相等

$ $
\begin{align*}
\begin{vmatrix}
 a_{11} & a_{12} & a_{13}\\
 a_{21} & a_{22} & a_{23}\\
 a_{31} & a_{32} & a_{33}
\end{vmatrix}
=
\begin{vmatrix}
 a_{11} & a_{21} & a_{31}\\
 a_{12} & a_{22} & a_{32}\\
 a_{13} & a_{23} & a_{33}
\end{vmatrix}
\end{align*}
$ $


性质2：对调两行或两列，行列式改变符号

$ $
\begin{align*}
\begin{vmatrix}
 a_{11} & a_{12} & a_{13}\\
 a_{21} & a_{22} & a_{23}\\
 a_{31} & a_{32} & a_{33}
\end{vmatrix}
=
-\begin{vmatrix}
 a_{21} & a_{22} & a_{23}\\
 a_{11} & a_{12} & a_{13}\\
 a_{31} & a_{32} & a_{33}
\end{vmatrix}
=
-\begin{vmatrix}
 a_{12} & a_{11} & a_{13}\\
 a_{22} & a_{21} & a_{23}\\
 a_{32} & a_{31} & a_{33}
\end{vmatrix}
\end{align*}
$ $


性质2推论：由性质2得，如果行列式有两行或两列完全相同，行列式的值为零，$D=-D\Rightarrow D=0$

$ $
\begin{align*}
\begin{vmatrix}
 l_{1} & l_{2} & l_{3}\\
 l_{1} & l_{2} & l_{3}\\
 l_{4} & l_{5} & l_{6}
\end{vmatrix}
=
-\begin{vmatrix}
 l_{1} & l_{2} & l_{3}\\
 l_{1} & l_{2} & l_{3}\\
 l_{4} & l_{5} & l_{6}
\end{vmatrix}
\end{align*}
$ $


性质3：行列式某行或某列有公因子可以提取到行列式的外面

$ $
\begin{align*}
\begin{vmatrix}
 3a_{11} & 3a_{12} & 3a_{13}\\
 6a_{21} & a_{22} & a_{23}\\
 9a_{31} & a_{32} & a_{33}
\end{vmatrix}
=
3\begin{vmatrix}
 a_{11} & a_{12} & a_{13}\\
 6a_{21} & a_{22} & a_{23}\\
 9a_{31} & a_{32} & a_{33}
\end{vmatrix}
=
3\begin{vmatrix}
 a_{11} & 3a_{12} & 3a_{13}\\
 2a_{21} & a_{22} & a_{23}\\
 3a_{31} & a_{32} & a_{33}
\end{vmatrix}
\end{align*}
$ $


性质4：行列式中如果有两行或两列元素成正比，则行列式值为零，$2D=-2D \Rightarrow D=0$

$ $
\begin{align*}
\begin{vmatrix}
 l_{1} & l_{2} & l_{3}\\
 2l_{1} & 2l_{2} & 2l_{3}\\
 l_{4} & l_{5} & l_{6}
\end{vmatrix}
\Rightarrow 
2\begin{vmatrix}
 l_{1} & l_{2} & l_{3}\\
 l_{1} & l_{2} & l_{3}\\
 l_{4} & l_{5} & l_{6}
\end{vmatrix}
=
-2\begin{vmatrix}
 l_{1} & l_{2} & l_{3}\\
 l_{1} & l_{2} & l_{3}\\
 l_{4} & l_{5} & l_{6}
\end{vmatrix}
\end{align*}
$ $


性质5：行列式某一行或某一列的元素都是两数之和，则行列式可拆分为两个行列式之和

$ $
\begin{align*}
\begin{vmatrix}
 l_{1} & l_{2} & l_{3}\\
 l_{4}+l_{10} & l_{5}+l_{11} & l_{6}+l_{12}\\
 l_{7} & l_{8} & l_{9}
\end{vmatrix}
=
\begin{vmatrix}
 l_{1} & l_{2} & l_{3}\\
 l_{4} & l_{5} & l_{6}\\
 l_{7} & l_{8} & l_{9}
\end{vmatrix}
+
\begin{vmatrix}
 l_{1} & l_{2} & l_{3}\\
 l_{10} & l_{11} & l_{12}\\
 l_{7} & l_{8} & l_{9}
\end{vmatrix}
\end{align*}
$ $


性质6：行列式的某一行（列）的各元素乘同一数然后加到另一行（列）的对应元素上，行列式的值不变

$ $
\begin{align*}
\begin{vmatrix}
 l_{1} & l_{2} & l_{3}\\
 l_{4} & l_{5} & l_{6}\\
 l_{7} & l_{8} & l_{9}
\end{vmatrix}
=
\begin{vmatrix}
 l_{1} & l_{2} & l_{3}\\
 l_{4}+3l_{1} & l_{5}+3l_{2} & l_{6}+3l_{3}\\
 l_{7} & l_{8} & l_{9}
\end{vmatrix}
\end{align*}
$ $


性质7：行列式某一行或某一列的元素全为零，则行列式值为零

$ $
\begin{align*}
\begin{vmatrix}
 0 & a_{12} & a_{13}\\
 0 & a_{22} & a_{23}\\
 0 & a_{32} & a_{33}
\end{vmatrix}
= 
\begin{vmatrix}
 0 & 0 & 0\\
 a_{21} & a_{22} & a_{23}\\
 a_{31} & a_{32} & a_{33}
\end{vmatrix}
=
0
\end{align*}
$ $


展开性质行列式展开法则：行列式等于它的任一行或列的各元素与其对应的代数余子式的乘积之和

$ $
\begin{align*}
D &=
\begin{vmatrix}
 a_{11} & a_{12} & \cdots & a_{1n}\\
 a_{21} & a_{22} & \cdots & a_{2n}\\
 \vdots & \vdots & \ddots & \vdots\\
 a_{n1} & a_{n2} & \cdots & a_{nn}
\end{vmatrix}\\
&=a_{i1}A_{i1}+a_{i2}A_{i2}+\cdots +a_{in}A_{in}\space (i=1,2,3,\cdots ,n)\\
&=a_{1j}A_{1j}+a_{2j}A_{2j}+\cdots +a_{nj}A_{nj}\space (j=1,2,3,\cdots ,n)
\end{align*}
$ $



&ensp;&ensp;例：
$ $
\begin{align*}
D&=\begin{vmatrix}
 a_{11} & a_{12} & a_{13}\\
 a_{21} & a_{22} & a_{23}\\
 a_{31} & a_{32} & a_{33}
\end{vmatrix}\\
&=
a_{11}A_{11}+a_{12}A_{12}+a_{13}A_{13}=a_{11}A_{11}+a_{21}A_{21}+a_{31}A_{31}
\end{align*}
$ $


推论1：一个$n$阶行列式，如果其中第$i$行所有元素除$(i,j)$元$a_{i,j}$外都为零，那么该行列式等于$a_{i,j}$和它的代数余子式的乘积

$ $
\begin{align*}
\begin{vmatrix}
 a_{11} & a_{12} & a_{13}\\
 0 & a_{22} & 0\\
 a_{31} & a_{32} & a_{33}
\end{vmatrix}
=
a_{22}A_{22}
\end{align*}
$ $


推论2：行列式的某一行（列）的元素与另一行（列）的对应元素的代数余子式乘积之和等于零

$ $
\begin{align*}
a_{i1}A_{j1}+a_{i2}A_{j2}+\cdots +a_{in}A_{jn}=0 \space (i \ne j)
\end{align*}
\begin{align*}
a_{1i}A_{1j}+a_{2i}A_{2j}+\cdots +a_{ni}A_{nj}=0 \space (i \ne j)
\end{align*}
$ $



&ensp;&ensp;例：
$ $
\begin{align*}
D=\begin{vmatrix}
 a_{11} & a_{12} & a_{13}\\
 a_{21} & a_{22} & a_{23}\\
 a_{31} & a_{32} & a_{33}
\end{vmatrix}
\Rightarrow 
a_{11}A_{21}+a_{12}A_{22}+a_{13}A_{23}=0
\end{align*}
$ $


拉普拉斯行列式&ensp;&ensp;设$A$为$m$阶矩阵，$B$为$n$阶矩阵，$C$为$n \times m$阶矩阵，$O$为零矩阵，则对应分块矩阵的行列式可以进行如下运算

$ $
\begin{gather*}
\begin{vmatrix}
 A & O\\
 O & B
\end{vmatrix}
=
\begin{vmatrix}
 A & C\\
 O & B
\end{vmatrix}
=
\begin{vmatrix}
 A & O\\
 C & B
\end{vmatrix}
=
\begin{vmatrix}
A
\end{vmatrix}\begin{vmatrix}
B
\end{vmatrix}\\

\begin{vmatrix}
 O & A\\
 B & O
\end{vmatrix}
=
\begin{vmatrix}
 C & A\\
 B & O
\end{vmatrix}
=
\begin{vmatrix}
 O & A\\
 B & C
\end{vmatrix}
=
(-1)^{mn}
\begin{vmatrix}
A
\end{vmatrix}\begin{vmatrix}
B
\end{vmatrix}
\end{gather*}
$ $


克莱姆法则（克拉默法则）&ensp;&ensp;注意：只有当方程组中的方程个数与未知数个数相等时才可以使用克莱姆法则；即，如果方程组由$n$个线性方程组成，那么每个线性方程中必须包含$n$个未知数.
&ensp;&ensp;设，由$n$个线性方程组成的齐次方程组$\eqref {eq23}$，其中每个线性方程包含$n$个未知数，当$\eqref {eq23}$中的齐次线性方程不等于$0$时，有非齐次线性方程组$\eqref {eq24}$

$ $
\begin{align} \label {eq23}
\left\{ 
\begin{array}{lll} 
a_{11}x_{1}+a_{12}x_{2}+\cdots +a_{1n}x_{n}=0 \\
a_{21}x_{1}+a_{22}x_{2}+\cdots +a_{2n}x_{n}=0 \\
\vdots\\
a_{n1}x_{1}+a_{n2}x_{2}+\cdots +a_{nn}x_{n}=0
\end{array} \right.
\end{align}

\begin{align} \label {eq24}
\left\{ 
\begin{array}{lll} 
a_{11}x_{1}+a_{12}x_{2}+\cdots +a_{1n}x_{n}=b_{1} \\
a_{21}x_{1}+a_{22}x_{2}+\cdots +a_{2n}x_{n}=b_{2} \\
\vdots\\
a_{n1}x_{1}+a_{n2}x_{2}+\cdots +a_{nn}x_{n}=b_{n}
\end{array} \right.
\end{align}
$ $


&ensp;&ensp;$\eqref {eq23} \eqref {eq24}$ 的系数行列式 $\eqref {eq25}$

$ $
\begin{align} \label {eq25}
D=\begin{vmatrix}
 a_{11} & a_{12} & \cdots & a_{1n}\\
 a_{21} & a_{22} & \cdots & a_{2n}\\
 \vdots & \vdots &  & \vdots\\
 a_{n1} & a_{n2} & \cdots & a_{nn}
\end{vmatrix}
\end{align}
$ $


定理1&ensp;&ensp;方程组$\eqref {eq23}$只有零解的充分必要条件是$D\ne 0$；方程组$\eqref {eq23}$有非零解（或有无穷多个解）的充分必要条件是$D=0$
定理2&ensp;&ensp;方程组$\eqref {eq24}$有唯一解的充分必要条件是$D\ne 0$，此时$x_i=\frac {D_i}{D} \space (i=1,2,\cdots,n)$，当$D=0$时，方程组$\eqref {eq24}$要么无解，要么有无穷多个解
&ensp;&ensp;在定理2中，$D_i$代表将系数行列式$D$的第$i$列，替换成线性方程组中的值向量，即：

$ $
\begin{align*}
D_i \space (i=1,2,\cdots,n)\Rightarrow 
D_1=\begin{vmatrix}
 b_1 & a_{12} & \cdots & a_{1n}\\
 b_2 & a_{22} & \cdots & a_{2n}\\
 \vdots & \vdots &  & \vdots\\
 b_n & a_{n2} & \cdots & a_{nn}
\end{vmatrix}
\cdots\space 
D_n=\begin{vmatrix}
 a_{11} & a_{12} & \cdots & b_1\\
 a_{21} & a_{22} & \cdots & b_2\\
 \vdots & \vdots &  & \vdots\\
 a_{n1} & a_{n2} & \cdots & b_n
\end{vmatrix}
\end{align*}
$ $



矩阵矩阵概念&ensp;&ensp;$m$行$n$列矩阵，简称$m \times n$矩阵，拥有$m \times n$个元（元素），以数$a_{ij}$为$(i,j)$元的矩阵可记作$(a_{i,j})$或$(a_{i,j})_{m \times n}$，$m \times n$矩阵$A$记作$A_{m \times n}$

$ $
\begin{align*}
A_{m\times n} = 
\begin{pmatrix}
 a_{11} & a_{12} & \cdots & a_{1n}\\
 a_{21} & a_{22} & \cdots & a_{2n}\\
 \vdots & \vdots &       & \vdots\\
 a_{m1} & a_{m2} & \cdots & a_{mn}
\end{pmatrix}
\end{align*}
$ $



$n$阶矩阵（$n$阶方阵）&ensp;&ensp;行数和列数都等于$n$的矩阵称为$n$阶矩阵或$n$阶方阵，$n$阶矩阵$A$记作$A_n$

$ $
\begin{align*}
A_{n} = 
\begin{pmatrix}
 a_{11} & a_{12} & \cdots & a_{1n}\\
 a_{21} & a_{22} & \cdots & a_{2n}\\
 \vdots & \vdots &       & \vdots\\
 a_{n1} & a_{n2} & \cdots & a_{nn}
\end{pmatrix}
\end{align*}
$ $


同型矩阵&ensp;&ensp;两个矩阵的行数相等，列数也相等，称它们为同型矩阵
相等矩阵&ensp;&ensp;在同型矩阵的前提下，如果矩阵$A、B$的对应元素相等，则称两个矩阵相等，即$A=B$
零矩阵&ensp;&ensp;元素全部为$0$的矩阵称为零矩阵，记作$O$

$ $
\begin{align*}
O = 
\begin{pmatrix}
 0 & 0 & \cdots & 0\\
 0 & 0 & \cdots & 0\\
 \vdots & \vdots & \ddots & \vdots\\
 0 & 0 & \cdots & 0
\end{pmatrix}
\end{align*}
$ $


对角矩阵&ensp;&ensp;除对角线外都为$0$的矩阵称为对角矩阵

$ $
\begin{align*}
A_n = 
\begin{pmatrix}
 l_1 & 0 & \cdots & 0\\
 0 & l_2 & \cdots & 0\\
 \vdots & \vdots & \ddots & \vdots\\
 0 & 0 & \cdots & l_n
\end{pmatrix}
\end{align*}
$ $


单位矩阵&ensp;&ensp;对角线上的元素都是$1$，其他元素都是$0$的方阵，称为单位矩阵

$ $
\begin{align*}
E = 
\begin{pmatrix}
 1 & 0 & \cdots & 0\\
 0 & 1 & \cdots & 0\\
 \vdots & \vdots & \ddots & \vdots\\
 0 & 0 & \cdots & 1
\end{pmatrix}
\end{align*}
$ $


向量矩阵&ensp;&ensp;行矩阵又称行向量，只有一行

$ $
\begin{align*}
A = 
\begin{pmatrix}
 a_{1} & a_{2} & \cdots & a_{n}
\end{pmatrix}
\end{align*}
$ $


&ensp;&ensp;列矩阵又称列向量，只有一列

$ $
\begin{align*}
B = 
\begin{pmatrix}
 b_{1} \\
 b_{2} \\
 \vdots \\
 b_{m} 
\end{pmatrix}
\end{align*}
$ $



增广矩阵
&ensp;&ensp;有非齐次线性方程组

$ $
\begin{align*}
\left\{ 
\begin{array}{lll} 
a_{11}x_{1}+a_{12}x_{2}+\cdots +a_{1n}x_{n}=b_{1} \\
a_{21}x_{1}+a_{22}x_{2}+\cdots +a_{2n}x_{n}=b_{2} \\
\vdots\\
a_{m1}x_{1}+a_{m2}x_{2}+\cdots +a_{mn}x_{n}=b_{m}
\end{array} \right.
\end{align*}
$ $


&ensp;&ensp;该方程组可表示为$Ax=b$，其中$A$称为系数矩阵，$x$称为未知数矩阵，$b$称为常数项矩阵

$ $
\begin{align*}
A = 
\begin{pmatrix}
 a_{11} & a_{12} & \cdots & a_{1n}\\
 a_{21} & a_{22} & \cdots & a_{2n}\\
 \vdots & \vdots &       & \vdots\\
 a_{m1} & a_{m2} & \cdots & a_{mn}
\end{pmatrix}
，
x = 
\begin{pmatrix}
x_1 \\
x_2 \\
\vdots \\
x_n
\end{pmatrix}
，
b = 
\begin{pmatrix}
b_1 \\
b_2 \\
\vdots \\
b_m
\end{pmatrix}
\end{align*}
$ $


&ensp;&ensp;将常数项矩阵$b$添加到系数矩阵$A$的右边，得到增广矩阵$B = \left ( \begin{array} {c:c} A &amp; b\end{array}\right)$，书写时通常不写矩阵中的增广线“$\begin{array} {c:c}  &amp; \end{array}$”

$ $
\begin{align*}
B = 
\left ( 
\begin{array} {c:c}
 A & b
\end{array}
\right)
 = 
\left ( 
\begin{array} {cccc:c}
 a_{11} & a_{12} & \cdots & a_{1n} & b_1 \\
 a_{21} & a_{22} & \cdots & a_{2n} & b_2 \\
 \vdots & \vdots &        & \vdots & \vdots\\
 a_{m1} & a_{m2} & \cdots & a_{mn} & b_n
\end{array}
\right)
\end{align*}
$ $


矩阵的运算加减运算&ensp;&ensp;只有当两个矩阵是同型矩阵时，才能进行加减运算

$ $
\begin{align*}
A = 
\begin{pmatrix}
 a_{11} & a_{12} & a_{13}\\
 a_{21} & a_{22} & a_{23}\\
 a_{31} & a_{32} & a_{33}
\end{pmatrix}
，
B = 
\begin{pmatrix}
 b_{11} & b_{12} & b_{13}\\
 b_{21} & b_{22} & b_{23}\\
 b_{31} & b_{32} & b_{33}
\end{pmatrix}
\end{align*}

\begin{align*}
A\pm B = 
\begin{pmatrix}
 a_{11}\pm b_{11} & a_{12}\pm b_{12} & a_{13}\pm b_{13}\\
 a_{21}\pm b_{21} & a_{22}\pm b_{22} & a_{23}\pm b_{23}\\
 a_{31}\pm b_{31} & a_{32}\pm b_{32} & a_{33}\pm b_{33}
\end{pmatrix}
\end{align*}
$ $


&ensp;&ensp;满足以下规律

$A+B=B+A$
$(A+B)+C=A+(B+C)$

数与矩阵相乘
$ $
\begin{align*}
A = 
\begin{pmatrix}
 a_{11} & a_{12} & a_{13}\\
 a_{21} & a_{22} & a_{23}\\
 a_{31} & a_{32} & a_{33}
\end{pmatrix}
\end{align*}

\begin{align*}
kA = 
\begin{pmatrix}
 ka_{11} & ka_{12} & ka_{13}\\
 ka_{21} & ka_{22} & ka_{23}\\
 ka_{31} & ka_{32} & ka_{33}
\end{pmatrix}
\end{align*}
$ $


&ensp;&ensp;满足以下规律（$k$和$l$为数）

$klA=k(lA)$
$(k+l)A=kA+lA$
$k(A+B)=kA+kB$

矩阵与矩阵相乘&ensp;&ensp;只有当第一个矩阵的列数与第二个矩阵的行数相等时，两个矩阵才能相乘，即$A_{m \times s} \times B_{s \times n} = C_{mn}$

$ $
\begin{align*}
A = 
\begin{pmatrix}
 a_{11} & a_{12} & a_{13}\\
 a_{21} & a_{22} & a_{23}
\end{pmatrix}
，
B = 
\begin{pmatrix}
 b_{11} & b_{12} \\
 b_{21} & b_{22} \\
 b_{31} & b_{32} 
\end{pmatrix}
\end{align*}

\begin{align*}
A \times B=C=\begin{pmatrix}
 c_{11} & c_{12}\\
 c_{21} & c_{22}
\end{pmatrix}
\end{align*}
$ $


&ensp;&ensp;矩阵$C$的各元素为

$ $
\begin{align*}
\begin{array} {c}
c_{11}=a_{11}b_{11}+a_{12}b_{21}+a_{13}b_{31}\\
c_{12}=a_{11}b_{12}+a_{12}b_{22}+a_{13}b_{32}\\
c_{21}=a_{21}b_{11}+a_{22}b_{21}+a_{23}b_{31}\\
c_{22}=a_{21}b_{12}+a_{22}b_{22}+a_{23}b_{32}
\end{array}
\end{align*}
$ $


&ensp;&ensp;矩阵与矩阵相乘满足如下规律

$(AB)C=A(BC)$
$k(AB)=(kA)B=A(kB)$
$A(B+C)=AB+AC，(B+C)A=BA+CA$

转置矩阵&ensp;&ensp;把矩阵$A$的行换成同序数的列得到一个新矩阵，叫做$A$的转置矩阵，记作$A^T$

$ $
\begin{gather*}
A = 
\begin{pmatrix}
 a_{11} & a_{12} & \cdots & a_{1n}\\
 a_{21} & a_{22} & \cdots & a_{2n}\\
 \vdots & \vdots &       & \vdots\\
 a_{m1} & a_{m2} & \cdots & a_{mn}
\end{pmatrix} \\
\Downarrow \\
A^T = 
\begin{pmatrix}
 a_{11} & a_{21} & \cdots & a_{m1}\\
 a_{12} & a_{22} & \cdots & a_{m2}\\
 \vdots & \vdots &       & \vdots\\
 a_{1n} & a_{2n} & \cdots & a_{mn}
\end{pmatrix}
\end{gather*}
$ $


&ensp;&ensp;如果$A$为$n$阶方阵，满足$A^T=A$，那么称$A$为对称矩阵，对称矩阵的特点是，以对角线为对称轴，左下和右上的元素对应相等

$ $
\begin{align*}
A = 
\begin{pmatrix}
 l_{1} & x_{1} & x_{2}\\
 x_{1} & l_{2} & x_{3}\\
 x_{2} & x_{3} & l_{3}
\end{pmatrix}
=A^T
\end{align*}
$ $


&ensp;&ensp;转置矩阵满足如下规律

$(A^T)^T=A$
$(A+B)^T=A^T+B^T$
$(kA)^T=kA^T$
$(AB)^T=B^TA^T$

伴随矩阵&ensp;&ensp;方阵的行列式：由$n$阶方阵$A$的元素所构成的行列式，称为方阵$A$的行列式，记作$|A|$&ensp;&ensp;方阵的行列式计算满足如下规律

$|A^T|=|A|$
$|kA| = k^n|A|$
$|AB| = |A||B|$

&ensp;&ensp;行列式$|A|$的各个元素的代数余子式$A_{ij}$所构成的矩阵，称为$A$的伴随矩阵，记作$A^{*}$&ensp;&ensp;$A^{*}$由$|A|$的各元素对应的代数余子式组成的矩阵转置得到

$ $
\begin{align*}
A^{*}=
\begin{pmatrix}
 A_{11} & A_{21} & \cdots & A_{n1}\\
 A_{12} & A_{22} & \cdots & A_{n2}\\
 \vdots & \vdots &       & \vdots\\
 A_{1n} & A_{2n} & \cdots & A_{nn}
\end{pmatrix}
\end{align*}
$ $


&ensp;&ensp;伴随矩阵满足以下运算规律

$AA^{*}=A^{*}A=\left|A\right|E$
$\left|A^{*}\right| = \left|A\right|^{n-1}$
$(A^T)^{*} = (A^{*})^T$
$(A^{-1})^{*} = (A^{*})^{-1}$
$(AB)^{*} = B^{*}A^{*}$
$(A^{*})^{*}=|A|^{n-2}A$

可逆矩阵&ensp;&ensp;对于$n$阶矩阵$A$,如果有一个$n$阶矩阵$B$，使$AB=BA=E$，则说矩阵$A$是可逆的，并把$B$称为$A$的逆矩阵，$A$的逆矩阵记作$A^{-1}$，即$B=A^{-1}$&ensp;&ensp;如果矩阵$A$是可逆的，那么$A$的逆矩阵是唯一的
定理1&ensp;&ensp;若矩阵$A$可逆，则$|A| \ne 0$
定理2&ensp;&ensp;若$|A| \ne 0$，则矩阵$A$可逆，且$A^{-1}=\frac {1}{|A|}A^{*}$（当$|A| = 0$时，$|A|$称为奇异矩阵，否则称非奇异矩阵）

&ensp;&ensp;可逆矩阵满足以下运算规律

若$A$可逆，则$A^{-1}$也可逆，且$(A^{-1})^{-1}=A$，$\left |A^{-1} \right | = \left |A\right |^{-1} = \frac {1}{\left |A\right |}$
若$A$可逆，数$k \ne 0$，则$kA$可逆，且$(kA)^{-1}=\frac {1}{k}A^{-1}$
若$A$、$B$为同阶矩阵且均可逆，则$AB$也可逆，且$(AB)^{-1}=B^{-1}A^{-1}$
若$A$可逆，则$A^T$也可逆，且$(A^T)^{-1}=(A^{-1})^T$

数学常用公式定理1
数学常用公式定理2
数学常用公式定理3
数学常用公式定理5
数学常用公式定理6

]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>数学常用公式定理5</title>
    <url>/2023/09/30/%E6%95%B0%E5%AD%A6%E5%B8%B8%E7%94%A8%E5%85%AC%E5%BC%8F%E5%AE%9A%E7%90%865/</url>
    <content><![CDATA[数学常用公式定理1
数学常用公式定理2
数学常用公式定理3
数学常用公式定理4
数学常用公式定理6

矩阵初等变换初等变换&ensp;&ensp;下面三种变换称为矩阵的初等行变换

对换两行（对换$i，j$两行，记作$r_i \longleftrightarrow r_j$）
以数$k \ne 0$乘某一行中的所有元（第$i$行乘$k$，记作$r_i \times k$）
把某一行所有元的$k$倍加到另一行对应的元上（第$j$行的$k$倍加到第$i$行上，记作$r_i+kr_j$）

&ensp;&ensp;上述“行”换做“列”，“r”换做“c”，即得到初等列变换，初等行变换和初等列变换统称为初等变换
等价矩阵&ensp;&ensp;如果矩阵$A$经过有限次初等行变换变成矩阵$B$，就称矩阵$A$与$B$行等价，记作$A\underset{}{\overset{r}{\sim}}B$；如果矩阵$A$经过有限次初等列变换变成矩阵$B$，就称矩阵$A$与$B$列等价，记作$A\underset{}{\overset{c}{\sim}}B$；如果矩阵$A$经过有限次初等变换变成矩阵$B$，就称矩阵$A$与$B$等价，记作$A \sim B$
&ensp;&ensp;矩阵之间的等价关系具有下列性质：

反身性 $A \sim A$
对称性 若$A \sim B$，则$B \sim A$
传递性 若$A \sim B$，$B \sim C$，则$A \sim C$

初等变换运算阶梯型、最简型、标准型行阶梯型矩阵&ensp;&ensp;非零矩阵若满足：

非零行在零行的上面，
非零行的首非零元所在列 在上一行的首非零元所在列 的右边，

则称此矩阵为行阶梯型矩阵。
&ensp;&ensp;在行列式$A$中每一行的第一个非零元称为首非零元

$ $
\begin{align*}
A = 
\begin{pmatrix}
 1 & 1 & -2 & 1 & 0\\
 0 & 1 & -1 & 1 & 1\\
 0 & 0 & 0 & 1 & 1\\
 0 & 0 & 0 & 0 & 0
\end{pmatrix}
\end{align*}
$ $


行最简型矩阵&ensp;&ensp;若$A$是阶梯型矩阵，并且满足：

非零行的首非零元为1，
首非零元所在的列的其它元均为0，

则称$A$为行最简型矩阵

$ $
\begin{align*}
A = 
\begin{pmatrix}
 1 & 0 & -1 & 0 & 0\\
 0 & 1 & -1 & 0 & 0\\
 0 & 0 & 0 & 1 & 0\\
 0 & 0 & 0 & 0 & 0
\end{pmatrix}
\end{align*}
$ $



标准型矩阵&ensp;&ensp;对最简型矩阵施以初等列变换可以得到标准型矩阵$F$，其左上角是一个单位矩阵，其余元全为0

$ $
\begin{align*}
F=
\begin{pmatrix}
 E_r & O\\
 O & O
\end{pmatrix}
=
\begin{pmatrix}
 1 & 0 & 0 & 0 & 0\\
 0 & 1 & 0 & 0 & 0\\
 0 & 0 & 0 & 0 & 0\\
 0 & 0 & 0 & 0 & 0
\end{pmatrix}
\end{align*}
$ $


&ensp;&ensp;对于$m \times n$矩阵$A$，总可经过初等变换（行变换和列变换）把它化为标准型$F=\begin{pmatrix} E_r &amp; O\\ O &amp; O \end{pmatrix}$，其中$r$是行阶梯矩阵中非零行的行数
初等矩阵定义3&ensp;&ensp;由单位矩阵$E$经过一次初等变换得到的矩阵称为初等矩阵，三种初等变换对应有三种初等矩阵
两行对换&ensp;&ensp;把单位矩阵中第$i$，$j$两行（或两列）对换，得初等矩阵$E(i,j)$

$ $
\begin{align*}
&E(i,j)=\begin{pmatrix}
 {\color{Red}1} & 0 & 0 & \cdots & 0 & 0 & 0\\
 0 & {\color{Red}0} & 0 & \cdots & 0 & {\color{Red}1} & 0\\
 0 & 0 & {\color{Red}1} & \cdots & 0 & 0 & 0\\
 \vdots & \vdots & \vdots & \ddots & \vdots & \vdots & \vdots\\
 0 & 0 & 0 & \cdots & {\color{Red}1} & 0 & 0\\
 0 & {\color{Red}1} & 0 & \cdots & 0 & {\color{Red}0} & 0\\
 0 & 0 & 0 & \cdots & 0 & 0 & {\color{Red}1}
\end{pmatrix}
\\
&E_4(2,3)=\begin{pmatrix}
 1 & 0 & 0 & 0\\
 0 & 0 & 1 & 0\\
 0 & 1 & 0 & 0\\
 0 & 0 & 0 & 1
\end{pmatrix}
\end{align*}
$ $



数乘某行&ensp;&ensp;以数$k \ne 0$乘单位矩阵的第$i$行（或第$i$列），得初等矩阵$E\left(i\left(k\right)\right)$

$ $
\begin{align*}
&E(i(k))=
\begin{pmatrix}
 1 &  &  &  &  &  & \\
  & \ddots &  &  &  &  & \\
  &  & 1 &  &  &  & \\
  &  &  & k &  &  & \\
  &  &  &  & 1 &  & \\
  &  &  &  &  & \ddots & \\
  &  &  &  &  &  & 1
\end{pmatrix}
\\
&E_4(3(k))=
\begin{pmatrix}
 1 & 0 & 0 & 0\\
 0 & 1 & 0 & 0\\
 0 & 0 & k & 0\\
 0 & 0 & 0 & 1
\end{pmatrix}
\end{align*}
$ $


数乘相加&ensp;&ensp;以$k$乘单位矩阵的第$j$行加到第$i$行上（或以$k$乘单位矩阵的第$i$列加到第$j$列上），得到初等矩阵$E(ij(k))$

$ $
\begin{align*}
&E(ij(k))=
\begin{pmatrix}
 1 &  &  &  &  &  & \\
  & \ddots &  &  &  &  & \\
  &  & 1 & \cdots & k &  & \\
  &  &  & \ddots & \vdots &  & \\
  &  &  &  & 1 &  & \\
  &  &  &  &  & \ddots & \\
  &  &  &  &  &  & 1
\end{pmatrix}
\\
&E_4(23(k))=
\begin{pmatrix}
 1 & 0 & 0 & 0\\
 0 & 1 & k & 0\\
 0 & 0 & 1 & 0\\
 0 & 0 & 0 & 1
\end{pmatrix}
\end{align*}
$ $


&ensp;&ensp;初等矩阵的逆阵：

$E(i,j)^{-1}=E(i,j)$
$E(i(k))^{-1}=E(i(\frac {1}{k}))$
$E(ij(k))^{-1}=E(ij(-k))$

初等矩阵的性质性质1：设$A$是一个$m \times n$矩阵，对$A$实施一次初等行变换，相当于在$A$的左边乘相应的$m$阶初等矩阵；对$A$实施一次初等列变换，相当于在$A$的右边乘相应的$n$阶初等矩阵

&ensp;&ensp;例1：两行（两列）对换
$ $
\begin{align*}
&A = 
\begin{pmatrix}
 a_{11} & a_{12} & a_{13} & a_{14}\\
 a_{21} & a_{22} & a_{23} & a_{24}\\
 a_{31} & a_{32} & a_{33} & a_{34}\\
 a_{41} & a_{42} & a_{43} & a_{44}
\end{pmatrix}
\\
&E_4(2,3)=
\begin{pmatrix}
 1 & 0 & 0 & 0\\
 0 & 0 & 1 & 0\\
 0 & 1 & 0 & 0\\
 0 & 0 & 0 & 1
\end{pmatrix}
\\
&E_4(2,3)A=
\begin{pmatrix}
 a_{11} & a_{12} & a_{13} & a_{14}\\
 {\color{Red} a_{31}} & {\color{Red} a_{32}} & {\color{Red} a_{33}} & {\color{Red} a_{34}}\\
 {\color{Red} a_{21}} & {\color{Red} a_{22}} & {\color{Red} a_{23}} & {\color{Red} a_{24}}\\
 a_{41} & a_{42} & a_{43} & a_{44}
\end{pmatrix}
\\
&AE_4(2,3)=
\begin{pmatrix}
 a_{11} & {\color{Red} a_{13}} & {\color{Red} a_{12}} & a_{14}\\
 a_{21} & {\color{Red} a_{23}} & {\color{Red} a_{22}} & a_{24}\\
 a_{31} & {\color{Red} a_{33}} & {\color{Red} a_{32}} & a_{34}\\
 a_{41} & {\color{Red} a_{43}} & {\color{Red} a_{42}} & a_{44}
\end{pmatrix}
\end{align*}
$ $



&ensp;&ensp;例2：数乘某行（列）
$ $
\begin{align*}
&A = 
\begin{pmatrix}
 a_{11} & a_{12} & a_{13}\\
 a_{21} & a_{22} & a_{23}\\
 a_{31} & a_{32} & a_{33}
\end{pmatrix}
\\
&E_3(2(k))=
\begin{pmatrix}
 1 & 0 & 0\\
 0 & k & 0\\
 0 & 0 & 1
\end{pmatrix}
\\
&E_3(2(k))A = 
\begin{pmatrix}
 a_{11} & a_{12} & a_{13}\\
 {\color{Red} ka_{21}} & {\color{Red} ka_{22}} & {\color{Red} ka_{23}}\\
 a_{31} & a_{32} & a_{33}
\end{pmatrix}
\\
&AE_3(2(k))=
\begin{pmatrix}
 a_{11} & {\color{Red} ka_{12}} & a_{13}\\
 a_{21} & {\color{Red} ka_{22}} & a_{23}\\
 a_{31} & {\color{Red} ka_{32}} & a_{33}
\end{pmatrix}
\end{align*}
$ $



&ensp;&ensp;例3：数乘相加
$ $
\begin{align*}
&A = 
\begin{pmatrix}
 a_{11} & a_{12} & a_{13} & a_{14}\\
 a_{21} & a_{22} & a_{23} & a_{24}\\
 a_{31} & a_{32} & a_{33} & a_{34}\\
 a_{41} & a_{42} & a_{43} & a_{44}
\end{pmatrix}
\\
&E_4(23(k))=
\begin{pmatrix}
 1 & 0 & 0 & 0\\
 0 & 1 & k & 0\\
 0 & 0 & 1 & 0\\
 0 & 0 & 0 & 1
\end{pmatrix}
\\
&E_4(23(k))A=
\begin{pmatrix}
 a_{11} & a_{12} & a_{13} & a_{14}\\
 {\color{Red} a_{21}+ka_{31}}  & {\color{Red} a_{22}+ka_{32}}  & {\color{Red} a_{23}+ka_{33}}  & {\color{Red} a_{24}+ka_{34}} \\
 a_{31} & a_{32} & a_{33} & a_{34}\\
 a_{41} & a_{42} & a_{43} & a_{44}
\end{pmatrix}
\\
&AE_4(23(k))=
\begin{pmatrix}
 a_{11} & a_{12} & {\color{Red} ka_{12}+a_{13}}  & a_{14}\\
 a_{21} & a_{22} & {\color{Red} ka_{22}+a_{23}}  & a_{24}\\
 a_{31} & a_{32} & {\color{Red} ka_{32}+a_{33}}  & a_{34}\\
 a_{41} & a_{42} & {\color{Red} ka_{42}+a_{43}}  & a_{44}
\end{pmatrix}
\end{align*}
$ $


性质2：方阵$A$可逆的充分必要条件是，存在有限个初等矩阵$P_1$，$P_2$，$\cdots$，$P_l$，使$A=P_1 P_2 \cdots P_l$
性质2推论：方阵$A$可逆的充分必要条件是$A\underset{}{\overset{r}{\sim}}E$
性质3
&ensp;&ensp;设$A$与$B$为$m \times n$矩阵，那么

$A\underset{}{\overset{r}{\sim}}B$的充分必要条件是存在$m$阶可逆矩阵$P$，使$PA=B$；
$A\underset{}{\overset{c}{\sim}}B$的充分必要条件是存在$n$阶可逆矩阵$Q$，使$AQ=B$；
$A \sim B$的充分必要条件是存在$m$阶可逆矩阵$P$及$n$阶可逆矩阵$Q$，使$PAQ=B$。

初等变换法求逆矩阵&ensp;&ensp;设$A$是$n$阶可逆矩阵，则$\left ( \begin{array} {c:c} A &amp; E\end{array}\right) \underset{}{\overset{初等行变换}{\longrightarrow }} \left ( \begin{array} {c:c} E &amp; A^{-1}\end{array}\right)$
矩阵的秩$k$阶子式&ensp;&ensp;在$m \times n$矩阵中，任取$k$行与$k$列（其中$k \le min\{m,n\}$），不改变它们在$A$中所处的位置次序而得的$k$阶行列式，称为矩阵$A$的$k$阶子式
矩阵的秩&ensp;&ensp;设在矩阵$A$中有一个不等于$0$的$r$阶子式$D$，且所有$r + 1$阶子式（如果存在）全等于$0$，那么$D$称为$A$的最高阶非零子式，数$r$称为矩阵$A$的秩，并记作$R(A)$，规定$0$矩阵的秩等于$0$
秩的计算
&ensp;&ensp;若$A \sim B$，则$R(A) = R(B)$（矩阵的初等变换不改变矩阵的秩）
&ensp;&ensp;对于$n$阶矩阵A，其$n$阶子式只有$|A|$，当$|A| \ne 0$时，$R(A) = n$，当$|A| = 0$时，$R(A) \lt n$，因此可逆矩阵又称满秩矩阵，不可逆矩阵又称降秩矩阵
&ensp;&ensp;矩阵秩的计算：当矩阵阶数较低时，可以采用定义法求出矩阵的秩；当矩阵阶数较高时，将高阶矩阵通过初等行变换转化为行阶梯型矩阵，它的秩等于非零行的行数
矩阵秩的性质
$0 \le R(A_{m \times n}) \le min\{m,n\}$
$R(A^T)=R(A)=R(A^T A)=R(A A^T)$
若$A \sim B$，则$R(A) = R(B)$
若$P$、$Q$可逆，则$R(PAQ)=R(PA)=R(AQ)=R(A)$
$max\{R(A),R(B)\} \le R(A,B) \le R(A)+R(B)$
$R(A+B) \le R(A)+R(B)$
$R(AB) \le min\{R(A),R(B)\}$
若$A_{m \times n}B_{n \times l}=O$，则$R(A)+R(B) \le n$
$R(A^{*})=\begin{cases}n，&amp;R(A)=n，\\1，&amp;R(A)=n-1，\\0，&amp;R(A)\lt n-1，\end{cases}$其中$A$为$n(n\ge 2)$阶方阵

向量向量定义&ensp;&ensp;$n$个有次序的数$a_1,a_2,\cdots,a_n$所组成的数组称为$n$维向量，这$n$个数组称为向量的分量，第$i$个数$a_i$称为第$i$个分量

&ensp;&ensp;例，两个3维向量：
$ $
\begin{align*}
&\text{3维列向量} \space
a=\begin{pmatrix}
 a_{1}\\
 a_{2}\\
 a_{3}
\end{pmatrix}
\\
&\text{3维行向量} \space
b=\begin{pmatrix}
 b_1 & b_2 & b_3
\end{pmatrix}
\end{align*}
$ $


&ensp;&ensp;若干个同维数的列向量（或行向量）所组成的集合叫向量组，例如一个$m \times n$矩阵的全体列向量是一个含$n$个$m$维列向量的向量组，全体行向量是一个含$m$个$n$维行向量的向量组

&ensp;&ensp;例，4个3维列向量所组成的列向量组$A:a_1,a_2,a_3,a_4$构成一个$3 \times 4$的矩阵：
$ $
\begin{align*}
A=(a_1,a_2,a_3,a_4)=
\begin{pmatrix}
 a_{11} & a_{21} & a_{31} & a_{41}\\
 a_{12} & a_{22} & a_{32} & a_{42}\\
 a_{13} & a_{23} & a_{33} & a_{43}
\end{pmatrix}\text{} 
\end{align*}
$ $
&ensp;&ensp;4个3维行向量所组成的行向量组$B:b_1,b_2,b_3,b_4$构成一个$4 \times 3$的矩阵：
$ $
\begin{align*}
B=\begin{pmatrix}
b_1 \\
b_2 \\
b_3 \\
b_4
\end{pmatrix}=
\begin{pmatrix}
 b_{11} & b_{12} & b_{13}\\
 b_{21} & b_{22} & b_{23}\\
 b_{31} & b_{32} & b_{33}\\
 b_{41} & b_{42} & b_{43}
\end{pmatrix}
\end{align*}
$ $



线性组合向量的线性表示&ensp;&ensp;给定向量组$A:a_1,a_2,\cdots,a_m$，对于任意一组实数$k_1,k_2,\cdots,k_m$，表达式$k_1a_1+k_2a_2+\cdots+k_ma_m$称为向量组$A$的一个线性组合，$k_1,k_2,\cdots,k_m$称为这个线性组合的系数
&ensp;&ensp;给定向量组$A:a_1,a_2,\cdots,a_m$和向量$b$，如果存在一组数$\lambda_1,\lambda_2,\cdots,\lambda_m$，使$b=\lambda_1a_1+\lambda_2a_2+\cdots+\lambda_ma_m$，则向量$b$是向量$A$的线性组合，称向量$b$能由向量组$A$线性表示&ensp;&ensp;等同于线性方程组$x_1a_1+x_2a_2+\cdots+x_ma_m=b$有解
&ensp;&ensp;向量$b$能由向量组$A:a_1,a_2,\cdots,a_m$线性表示的充分必要条件是矩阵$A=(a_1,a_2,\cdots,a_m)$的秩等于矩阵$B=(a_1,a_2,\cdots,a_m,b)$的秩&ensp;&ensp;当$R(A)=R(B)$时，线性方程组$x_1a_1+x_2a_2+\cdots+x_ma_m=b$有解
向量组的线性表示向量组等价&ensp;&ensp;设有两个向量组$A:a_1,a_2,\cdots,a_m$及$B:b_1,b_2,\cdots,b_l$，若$B$组中的每个向量都能由向量组$A$线性表示，则称向量组$B$能由向量组$A$线性表示。若向量组$A$与向量组$B$能互相线性表示，则称这两个向量组等价
&ensp;&ensp;把向量组$A$和$B$所构成的矩阵依次记作$A=(a_1,a_2,\cdots,a_m)$和$B=(b_1,b_2,\cdots,b_l)$，向量组$B$能由向量组$A$线性表示，即对每个向量$b_j(j=1,2,\cdots,l)$存在数$k_{1j},k_{2j},\cdots,k_{mj}$，使

$ $
\begin{align*}
b_j=k_{1j}a_1+k_{2j}a_2+\cdots+k_{mj}a_m=(a_1,a_2,\cdots,a_m)\begin{pmatrix}
 k_{1j}\\
 k_{2j}\\
 \vdots\\
 k_{mj}
\end{pmatrix}
\end{align*}

\begin{align*}
(b_1,b_2,\cdots,b_l)=(a_1,a_2,\cdots,a_m)\begin{pmatrix}
 k_{11} & k_{12} & \cdots & k_{1l}\\
 k_{21} & k_{22} & \cdots & k_{2l}\\
 \vdots & \vdots &        & \vdots\\
 k_{m1} & k_{m2} & \cdots & k_{ml}
\end{pmatrix}
\end{align*}
$ $


其中，矩阵$K_{m \times l}=(k_{ij})$称为这一线性表示的系数矩阵

&ensp;&ensp;例：
$ $
\begin{align*}
&有两个如下向量组A、B\\
&A=\left (\alpha _1,\alpha _2 \right) = \begin{pmatrix}
 1 & 2\\
 0 & 1
\end{pmatrix}\\
&B=\left (\beta _1,\beta _2 \right) = \begin{pmatrix}
 2 & 1\\
 2 & -1
\end{pmatrix}\\
&并有系数矩阵K_1、K_2\\
&K_1=\begin{pmatrix}
 -2 & 3\\
 2 & -1
\end{pmatrix}\\
&K_2=\begin{pmatrix}
 \frac{1}{4}  & \frac{3}{4} \\
 \frac{1}{2}  & \frac{1}{2} 
\end{pmatrix}\\
&又AK_1=B，BK_2=A\\
&于是有：A、B等价
\end{align*}
$ $


列向量组与行向量组的线性表示&ensp;&ensp;若$C_{m \times n}=A_{m \times l} \times B_{l \times n}$，则矩阵$C$的列向量组能由矩阵$A$的列向量组表示，$B$为这一表示的系数矩阵：

$ $
\begin{align*}
(c_1,c_2,\cdots,c_n)=(a_1,a_2,\cdots,a_l)\begin{pmatrix}
 b_{11} & b_{12} & \cdots & b_{1n}\\
 b_{21} & b_{22} & \cdots & b_{2n}\\
 \vdots & \vdots &        & \vdots\\
 b_{l1} & b_{l2} & \cdots & b_{ln}
\end{pmatrix}
\end{align*}
$ $




&ensp;&ensp;若$C_{m \times n}=A_{m \times l} \times B_{l \times n}$，则矩阵$C$的行向量组能由矩阵$B$的行向量组表示，$A$为这一表示的系数矩阵：

$ $
\begin{align*}
\begin{pmatrix}
 c_1^T\\
 c_2^T\\
 \vdots \\
 c_m^T
\end{pmatrix}
=
\begin{pmatrix}
 a_{11} & a_{12} & \cdots & a_{1l}\\
 a_{21} & a_{22} & \cdots & a_{2l}\\
 \vdots & \vdots &       & \vdots\\
 a_{m1} & a_{m2} & \cdots & a_{ml}
\end{pmatrix}
\begin{pmatrix}
 b_1^T\\
 b_2^T\\
 \vdots \\
 b_l^T
\end{pmatrix}
\end{align*}
$ $



定理1&ensp;&ensp;向量组$B:b_1,b_2,\cdots,b_l$能由向量组$A:a_1,a_2,\cdots,a_m$线性表示的充分必要条件是矩阵$A=(a_1,a_2,\cdots,a_m)$的秩等于矩阵$(A,B)=(a_1,a_2,\cdots,a_m,b_1,b_2,\cdots,b_l)$的秩，即$R(A)=R(A,B)$
定理1推论&ensp;&ensp;向量组$A:a_1,a_2,\cdots,a_m$与向量组$B:b_1,b_2,\cdots,b_l$等价的充分必要条件是$R(A)=R(B)=R(A,B)$，其中$A$和$B$是向量组$A$和$B$所构成的矩阵
定理2&ensp;&ensp;设向量组$B:b_1,b_2,\cdots,b_l$能由向量组$A:a_1,a_2,\cdots,a_m$线性表示，则$R(b_1,b_2,\cdots,b_l) \le R(a_1,a_2,\cdots,a_m)$
线性相关线性相关性的定义&ensp;&ensp;给定向量组$A:a_1,a_2,\cdots,a_m$，如果存在不全为零的数$k_1,k_2,\cdots,k_m$，使

$ $
\begin{align*}
k_1a_1+k_2a_2+\cdots+k_ma_m=0
\end{align*}
$ $

则称向量组$A$是线性相关的，否则称它线性无关

&ensp;&ensp;如果向量组$A:a_1,a_2,\cdots,a_m$线性相关，那么在向量$A$中至少有一个向量能由其余$m-1$个向量线性表示，这是因为有不全为$0$的数$k_1,k_2,\cdots,k_m$，使$k_1a_1+k_2a_2+\cdots+k_ma_m=0$，假设$k_1 \ne 0$，那么有

$ $
\begin{align*}
a_1=\frac {-1}{k_1}(k_2a_2+\cdots+k_ma_m)
\end{align*}
$ $


即$a_1$能由$a_2,\cdots,a_m$线性表示&ensp;&ensp;同样，如果向量组$A:a_1,\cdots,a_m$中某个向量能由其余$m-1$个向量线性表示，即有$\lambda_1,\cdots,\lambda_{m-1}$，使$a_m=\lambda_1a_1+\cdots+\lambda_{m-1}a_{m-1}$，于是有

$ $
\begin{align*}
\lambda_1a_1+\lambda_2a_2+\cdots+\lambda_{m-1}a_{m-1}+(-1)a_m=0
\end{align*}
$ $


因为$\lambda_1,\lambda_2,\cdots,\lambda_{m-1},-1$这$m$个数不全为$0$，所以向量组$A$线性相关&ensp;&ensp;线性相关的向量组中，至少有一个向量是其余向量的线性组合，并称这个向量是多余的；在线性无关的向量组中，没有任何向量是其余向量的线性组合
线性相关性的判别&ensp;&ensp;向量组$A:a_1,a_2,\cdots,a_m$线性相关的充分必要条件是
&ensp;&ensp;1.向量组$A$中至少有一个向量可由其余向量线性表示

$ $
\begin{array}{l}
\because A线性相关 \\
\therefore 存在不全为0的数k_1,k_2,\cdots,k_m，\\
使k_1a_1+k_2a_2+\cdots+k_ma_m=0 \\ \\
如果设k_1\ne 0，则有\\
a_1=\frac {-1}{k_1}(k_2a_2+\cdots+k_ma_m)\\ \\
即:a_1能由a_2,\cdots,a_m线性表示
\end{array}
$ $


特别的，(1).对于只有一个向量$a$的向量组$A$，当$a=0$（$a$为零向量）时$A$是线性相关的，当$a\ne 0$时（$a$不为零向量）时$A$是线性无关的；此外，如果任意一个向量组$A$中含有零向量，则$A$必定线性相关

$ $
\begin{array}{l}
设a_1=0\\
\therefore 存在不全为0的数k_1,k_2,\cdots,k_m\\
使a_1=0\\ \\
即:A线性相关
\end{array}
$ $


(2).只有两个向量的向量组$A:a_1,a_2$，当$a_1$、$a_2$的分量对应成比例时，$A$是线性相关的

$ $
\begin{array}{l}
设a_1,a_2成比例\\
\therefore 存在不全为0的数k_1,k_2\\
使k_1a_1+k_2a_2=0\\ \\
即:A线性相关
\end{array}
$ $




&ensp;&ensp;2.齐次线性方程组$x_1a_1+x_2a_2+\cdots+x_ma_m=0$有非零解
&ensp;&ensp;定理：向量组$A:a_1,a_2,\cdots,a_m$线性相关的充分必要条件是它所构成的矩阵$A=(a_1,a_2,\cdots,a_m)$的秩小于向量个数$m$，即$R(A) \lt m$；向量组$A$线性无关的充分必要条件是$R(A)=m$
&ensp;&ensp;(1).线性方程组$x_1a_1+x_2a_2+\cdots+x_ma_m=0$有非零解，则$R(a_1,a_2,\cdots,a_m) \lt m$，即$A$线性相关；若线性方程组$x_1a_1+x_2a_2+\cdots+x_ma_m=0$只有零解，那么$R(a_1,a_2,\cdots,a_m) = m$，$A$线性无关
&ensp;&ensp;(2).线性方程组$x_1a_1+x_2a_2+\cdots+x_ma_m=0$有非零解，存在不全为零的数$k_1,k_2,\cdots,k_m$，使$k_1a_1+k_2a_2+\cdots+k_ma_m=0$成立，则$A$线性相关；线性方程组$x_1a_1+x_2a_2+\cdots+x_ma_m=0$只有零解，那么只有当$k_1,k_2,\cdots,k_m$全为零时，$k_1a_1+k_2a_2+\cdots+k_ma_m=0$成立，则$A$线性无关
&ensp;&ensp;3.$|a_1,a_2,\cdots,a_m| = 0$&ensp;&ensp;设向量组$A$中有$m$个$n$维列向量$a_1,a_2,\cdots,a_m$，如果$m=n$时$|a_1,a_2,\cdots,a_m| = 0$，则有$R(a_1,a_2,\cdots,a_m) \lt m=n$，对应线性方程组有非零解，$A$线性相关；若$|a_1,a_2,\cdots,a_m| \ne 0$，那么$R(a_1,a_2,\cdots,a_m) = m=n$，对应线性方程组只有零解，$A$线性无关
线性相关的性质
设向量组$A:a_1,a_2,\cdots,a_m$线性无关，而向量组$B:a_1,a_2,\cdots,a_m,b$线性相关，则向量$b$必能由向量组$A$线性表示，且表示式是唯一的
若向量组$A:a_1,a_2,\cdots,a_m$线性相关，则向量组$B:a_1,a_2,\cdots,a_m,a_{m+1}$线性相关；若向量组$B:a_1,a_2,\cdots,a_m,a_{m+1}$线性无关，则向量组$A:a_1,a_2,\cdots,a_m$线性无关
设$A:a_1,a_2,\cdots,a_m$为$m$个$n$维向量组成的向量组，当$n \lt m$时，$A$线性相关

向量组的秩最大无关组&ensp;&ensp;设有向量组$A$，如果在$A$中能选出$r$个向量$a_1,a_2,\cdots,a_r$满足

向量组$A_0:a_1,a_2,\cdots,a_r$线性无关
向量组$A$中任意$r+1$个向量（如果$A$中有$r+1$个向量的话）都线性相关那么称向量组$A_0$是向量组$A$的一个最大线性无关向量组（简称最大无关组）

向量组的秩&ensp;&ensp;向量组$A$的最大无关组所包含向量的个数$r$，称为向量组$A$的秩，记作$R_A$
&ensp;&ensp;注意：最大无关组不一定唯一

&ensp;&ensp;例：
$ $
\begin{array}{l}
向量组A:a_1,a_2,a_3\\
其中
a_1=\begin{pmatrix}
1 \\
3 \\
8
\end{pmatrix}，
a_2=\begin{pmatrix}
2 \\
7 \\
7
\end{pmatrix}，
a_3=\begin{pmatrix}
2 \\
6 \\
16
\end{pmatrix}\\
可取最大无关组A_0:a_1,a_2或A_1:a_2,a_3\\
\end{array}
$ $


向量组秩的性质
只含零向量的向量组没有最大无关组，规定它的秩为零
若向量组$A$线性无关，则$A$自身就是它的最大无关组
向量组$A$和它的最大无关组$A_0$是等价的

推论（最大无关组的等价定义）&ensp;&ensp;设向量组$A_0:a_1,a_2,\cdots,a_r$是向量组$A$的一个部分组，且满足

向量组$A_0$线性无关
向量组$A$的任一向量都能由向量组$A_0$线性表示

那么向量组$A_0$便是向量组$A$的一个最大无关组
定理&ensp;&ensp;矩阵的秩等于它的列向量组的秩，也等于它的行向量组的秩
线性方程组的解&ensp;&ensp;设有$n$个未知数$m$个方程的线性方程组$\eqref {eq1}$

$ $
\begin{align} \label {eq1}
\left\{ 
\begin{array}{lll} 
a_{11}x_{1}+a_{12}x_{2}+\cdots +a_{1n}x_{n}=b_{1} \\
a_{21}x_{1}+a_{22}x_{2}+\cdots +a_{2n}x_{n}=b_{2} \\
\vdots\\
a_{m1}x_{1}+a_{m2}x_{2}+\cdots +a_{mn}x_{n}=b_{m}
\end{array} \right.
\end{align}
$ $


&ensp;&ensp;方程组$\eqref {eq1}$可表示为$Ax=b$，其中$A$为系数矩阵，$x$为未知数矩阵，$b$为常数项矩阵，利用$A$与增广矩阵$\overline{A} = (A \space \vdots \space b)$的秩讨论线性方程组的解，如果线性方程组有解，则称它是相容的，反之称为不相容
&ensp;&ensp;定理1：对于上述方程组$Ax=b$

无解的充分必要条件是$R(A) \lt R(\overline{A})$
有惟一解的充分必要条件是$R(A)=R(\overline{A})=n$
有无限多解的充分必要条件是$R(A)=R(\overline{A}) \lt n$

&ensp;&ensp;定理2：$n$元齐次线性方程组$Ax=0$有非零解的充分必要条件是$R(A) \lt n$
&ensp;&ensp;定理3：线性方程组$Ax=b$有解的充分必要条件是$R(A) = R(\overline{A})$
&ensp;&ensp;定理4：矩阵方程$AX=B$有解的充分必要条件是$R(A)=R(A \space \vdots \space B)$
&ensp;&ensp;定理5：设$AB=C$，则$R(C) \le min\{R(A),R(B)\}$
线性方程组解的结构齐次线性方程组解的结构&ensp;&ensp;设有齐次线性方程组

$ $
\begin{align} \label {eq2}
\left\{ 
\begin{array}{lll} 
a_{11}x_{1}+a_{12}x_{2}+\cdots +a_{1n}x_{n}=0 \\
a_{21}x_{1}+a_{22}x_{2}+\cdots +a_{2n}x_{n}=0 \\
\vdots\\
a_{m1}x_{1}+a_{m2}x_{2}+\cdots +a_{mn}x_{n}=0
\end{array} \right.
\end{align}
$ $


其向量方程为$Ax=0$，设它的解向量$x=\xi _i=\begin{pmatrix}\xi_{1i} \\\xi_{2i} \\\vdots \\\xi_{ni}\end{pmatrix}$，其解的结构有如下性质
性质1&ensp;&ensp;若$x=\xi_1$，$x=\xi_2$为齐次方程组$\eqref {eq2}$的解，则$x=\xi_1+\xi_2$也是齐次方程组$\eqref {eq2}$的解
性质2&ensp;&ensp;若$x=\xi_1$为齐次方程组$\eqref {eq2}$的解，$k$为实数，则$x=k\xi_1$也是齐次方程组$\eqref {eq2}$的解
齐次线性方程组的通解&ensp;&ensp;把齐次线性方程组的全体解所组成的集合记作$S$，求得解集$S$的一个最大无关组$S_0:\xi_1,\xi_2,\cdots,\xi_t$，向量方程的任一解都可由最大无关组$S_0$线性表示，则最大无关组$S_0$的任何线性组合

$ $
\begin{align*}
x=k_1\xi_1+k_2\xi_2+\cdots+k_t\xi_t（k_1,k_2,\cdots,k_t为任意实数）
\end{align*}
$ $


都是齐次方程组$\eqref {eq2}$的通解，该最大无关组称为该齐次线性方程组的基础解系
&ensp;&ensp;如果$x=\xi_i(i=1,2,\cdots,t)$都是$Ax=0$的解，$k_i(i=1,2,\cdots,t)$为任意实数，那么$x=k_1\xi_1+k_2\xi_2+\cdots+k_t\xi_t$也是$Ax=0$的解
定理7&ensp;&ensp;设有$m \times n$矩阵$A$的秩$R(A)=r$，则$n$元齐次线性方程组$Ax=0$的解集$S$的秩为$R_S=n-r$
非齐次线性方程组解的结构&ensp;&ensp;设有非齐次线性方程组

$ $
\begin{align} \label {eq3}
\left\{ 
\begin{array}{lll} 
a_{11}x_{1}+a_{12}x_{2}+\cdots +a_{1n}x_{n}=b_1 \\
a_{21}x_{1}+a_{22}x_{2}+\cdots +a_{2n}x_{n}=b_2 \\
\vdots\\
a_{m1}x_{1}+a_{m2}x_{2}+\cdots +a_{mn}x_{n}=b_m
\end{array} \right.
\end{align}
$ $


其向量方程为$Ax=b$，设它的解向量$x=\eta _i=\begin{pmatrix}\eta_{1i} \\\eta_{2i} \\\vdots \\\eta_{ni}\end{pmatrix}$
性质3&ensp;&ensp;设$x=\eta_1$，$x=\eta_2$都是非齐次方程组$\eqref {eq3}$的解，则$x=\eta_1-\eta_2$为对应的齐次方程组$\eqref {eq2}$的解
性质4&ensp;&ensp;设$x=\eta$是非齐次方程组$\eqref {eq3}$的解，$x=\xi$是对应的齐次方程组$\eqref {eq2}$的解，则$x=\eta+\xi$仍是非齐次方程组$\eqref {eq3}$的解
非齐次线性方程组的通解&ensp;&ensp;如果$\eta_0$是$Ax=b$的特解，$\xi_1,\cdots,\xi_{n-r}$是$Ax=0$的一个基础解系，则$Ax=b$的通解为$\eta=\eta_0+k_1\xi_1+\cdots+k_{n-r}\xi_{n-r}$；其中$k_i(i=1,\cdots,n-r)$为任意实数，$n$是未知数$x_n$的个数，$r=R(A)$
向量空间定义6&ensp;&ensp;设$V$为$n$维向量的集合，如果集合$V$非空，且集合$V$对于向量的加法及数乘两和运算封闭，那么就称集合$V$为向量空间&ensp;&ensp;所谓封闭，是指在集合$V$中可以进行向量的加法及数乘两种运算；若$a\in V，b\in V$，则$a+b\in V$；若$a\in V，k\in R$，则$ka \in V$
向量空间的基定义7
&ensp;&ensp;设有向量空间$V_1$及$V_2$，若$V_1\subseteq V_2$，就称$V_1$是$V_2$的子空间
定义8&ensp;&ensp;设$V$为向量空间，如果$r$个向量$a_1,a_2,\cdots,a_r \in V$，且满足

$a_1,a_2,\cdots,a_r$线性无关
$V$中任一向量都可由$a_1,a_2,\cdots,a_r$线性表示

那么，向量组$a_1,a_2,\cdots,a_r$就称为向量空间的一个基，$r$称为向量空间$V$的维数，并称$V$为$r$维向量空间
坐标定义9&ensp;&ensp;设向量空间$V$的基为$a_1,a_2,\cdots,a_r$，对于$V$中任一向量$\alpha$可惟一的表示为

$ $
\begin{align*}
\alpha = \lambda_1\alpha_1+\lambda_2\alpha_2+\cdots+\lambda_r\alpha_r
\end{align*}
$ $


则称$\lambda_1,\lambda_2,\cdots,\lambda_r$为向量$\alpha$在基$\alpha_1,\alpha_2,\cdots,\alpha_r$中的坐标
过渡矩阵与坐标转换&ensp;&ensp;设$a_1,a_2,a_3$和$b_1,b_2,b_3$均为$R^3$的基，$y_1,y_2,y_3$和$z_1,z_2,z_3$分别为基中坐标，并设矩阵$A=(a_1,a_2,a_3)$，$B=(b_1,b_2,b_3)$，求用$a_1,a_2,a_3$表示$b_1,b_2,b_3$的表示式的公式为基变换公式，求向量在两个基中的坐标之间的关系式的公式为坐标变换公式
&ensp;&ensp;基变换公式：

$ $
\begin{align*}
(b_1,b_2,b_3)=(a_1,a_2,a_3)P
\end{align*}
$ $


其中，过渡矩阵$P=A^{-1}B$
&ensp;&ensp;坐标变换公式：

$ $
\begin{align*}
\begin{pmatrix}
z_1 \\
z_2 \\
z_3
\end{pmatrix}
=
P^{-1}
\begin{pmatrix}
y_1 \\
y_2 \\
y_3
\end{pmatrix}
\end{align*}
$ $


数学常用公式定理1
数学常用公式定理2
数学常用公式定理3
数学常用公式定理4
数学常用公式定理6




]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>数学常用公式定理6</title>
    <url>/2023/10/01/%E6%95%B0%E5%AD%A6%E5%B8%B8%E7%94%A8%E5%85%AC%E5%BC%8F%E5%AE%9A%E7%90%866/</url>
    <content><![CDATA[数学常用公式定理1
数学常用公式定理2
数学常用公式定理3
数学常用公式定理4
数学常用公式定理5


向量的内积、长度及正交性内积定义1&ensp;&ensp;设$n$维向量

$ $
\begin{array} {c}
\alpha = \begin{pmatrix}
a_1 \\
a_2 \\
\vdots \\
a_n
\end{pmatrix}
，
\beta = \begin{pmatrix}
b_1 \\
b_2 \\
\vdots \\
b_n
\end{pmatrix}
\end{array}
$ $


令

$ $
\begin{array} {c}
[\alpha,\beta]=a_1b_1+a_2b_2+\cdots+a_nb_n
\end{array}
$ $


称$[\alpha,\beta]$为向量$\alpha$与$\beta$的内积
&ensp;&ensp;内积具有下列性质（其中$\alpha$、$\beta$、$\gamma$为$n$维向量，$k$为实数）

$[\alpha,\beta]=[\beta,\alpha]$
$[k\alpha,\beta]=[\alpha,k\beta]=k[\alpha,\beta]$
$[\alpha,\beta+\gamma]=[\alpha,\beta]+[\alpha,\gamma]$
当$\alpha=0$时，$[\alpha,\alpha]=0$；当$\alpha \ne 0$时，$[\alpha,\alpha]\gt 0$

长度（模）定义2&ensp;&ensp;设$\alpha=(\alpha_1,\alpha_2,\cdots,\alpha_n)^T$，令$\left \| \alpha \right \| = \sqrt[]{[\alpha ,\alpha ]} =\sqrt[]{\alpha _1^2+\alpha _2^2+\cdots+\alpha _n^2}$，称$\left \| \alpha \right \|$为向量$\alpha$的长度、模或范数
&ensp;&ensp;向量的长度有下列性质（其中$\alpha$为$n$维向量，$k$为实数）

非负性 当$\alpha \ne 0$时，$\left \| \alpha \right \| \gt 0$；当$\alpha = 0$时，$\left \| \alpha \right \| = 0$
齐次性 $\left \| k\alpha \right \|=|k|\left \| \alpha \right \|$

&ensp;&ensp;当$\left \| e \right \|=1$时，称$e$为单位向量。如果$\alpha \ne 0$，取$e=\frac {\alpha}{\left \| \alpha \right \|}$，则$e$是一个单位向量，由向量$\alpha$得到向量$e$的过程称为把向量$\alpha$单位化
正交&ensp;&ensp;当$[\alpha,\beta]=0$时，称向量$\alpha$与$\beta$正交；若$\alpha=0$，则$\alpha$与任何向量正交&ensp;&ensp;一组两两正交的非零向量组，称为正交向量组
定理1&ensp;&ensp;若$n$维向量$a_1,a_2,\cdots,a_r$是一组两两正交的非零向量，则$a_1,a_2,\cdots,a_r$线性无关
标准正交基定义3&ensp;&ensp;设$n$维向量$e_1,e_2,\cdots,e_r$是向量空间$V$（$V \subseteq R^n$）的一个基，如果$e_1,e_2,\cdots,e_r$两两正交，且都是单位向量，则称$e_1,e_2,\cdots,e_r$是$V$的一个标准正交基（标准正交基中的每个向量都是单位向量）
例：

$ $
\begin{array} {c}
e_1=\begin{pmatrix}
\frac{1}{\sqrt[]{2} }  \\
\frac{1}{\sqrt[]{2} } \\
0 \\
0
\end{pmatrix}，
e_2=\begin{pmatrix}
\frac{1}{\sqrt[]{2} }  \\
-\frac{1}{\sqrt[]{2} } \\
0 \\
0
\end{pmatrix}，
e_3=\begin{pmatrix}
0 \\
0 \\
\frac{1}{\sqrt[]{2} }  \\
\frac{1}{\sqrt[]{2} }
\end{pmatrix}
\end{array}
$ $


是$R^3$的标准正交基
标准正交化&ensp;&ensp;设$a_1,a_2,\cdots,a_r$是向量空间$V$的一个基，要求$V$的一个标准正交基，也就是要找一组两两正交的单位向量$e_1,e_2,\cdots,e_r$，使$e_1,e_2,\cdots,e_r$与$a_1,a_2,\cdots,a_r$等价，称为把基$a_1,a_2,\cdots,a_r$标准正交化
施密特正交化&ensp;&ensp;标准正交化第一步，从线性无关组$a_1,a_2,\cdots,a_r$导出正交向量组$b_1,b_2,\cdots,b_r$的过程称为施密特正交化，对任何$k$（$1 \ge k \ge r$），向量组$b_1,b_2,\cdots,b_r$与$a_1,a_2,\cdots,a_r$等价

$ $
\begin{array}{l}
b_1=a_1\\
b_2=a_2-\frac{[a_2,b_1]}{[b_1,b_1]}b_1 \\
b_3=a_3-\frac{[a_3,b_1]}{[b_1,b_1]}b_1 - \frac{[a_3,b_2]}{[b_2,b_2]}b_2 \\
\cdots \\
b_r=a_r-\frac{[a_r,b_1]}{[b_1,b_1]}b_1 -\frac{[a_r,b_2]}{[b_2,b_2]}b_2 -\cdots -\frac{[a_r,b_{r-1}]}{[b_{r-1},b_{r-1}]}b_{r-1}
\end{array}
$ $


单位化&ensp;&ensp;标准正交化第二步，把等价矩阵$b_1,b_2,\cdots,b_r$单位化

$ $
\begin{array} {c}
e_1=\frac{1}{\left \| b_1 \right \|}b_1,e_2=\frac{1}{\left \| b_2 \right \|}b_2 ,\cdots,e_r=\frac{1}{\left \| b_r \right \|}b_r 
\end{array}
$ $


$e_1,e_2,\cdots,e_r$就是$V$的一个标准正交基
坐标计算公式&ensp;&ensp;若$e_1,e_2,\cdots,e_r$$V$的一个标准正交基，那么$V$中任一向量$a$能由$e_1,e_2,\cdots,e_r$线性表示，设表示式为$a=k_1e_1+k_2e_2+\cdots+k_re_r$，向量在标准正交基中的坐标$k_i$（$i=i,2,\cdots,r$），计算公式为$k_i=e_i^Ta=[a,e_i]$
正交矩阵定义4&ensp;&ensp;如果$n$阶矩阵$A$满足$A^TA=E$（即$A^{-1}=A^T$），那么称$A$为正交矩阵，简称正交阵
&ensp;&ensp;方阵$A$为正交矩阵的充分必要条件是$A$的列向量（或行向量）都是单位向量，且两两正交

$ $
\begin{array}{l}
对于A^TA=E\Rightarrow \begin{pmatrix}
a_1^T \\
a_2^T \\
\vdots \\
a_n^T
\end{pmatrix}
\begin{pmatrix}
a_1,a_2,\cdots,a_n
\end{pmatrix}=E \\
有a_i^Ta_j \left\{ 
\begin {matrix}
1，当i=j时\\
0，当i\ne j时
\end {matrix} 
\right. \space
(i,j=1,2,\cdots,n)
\end{array}
$ $


&ensp;&ensp;正交矩阵有下述性质

若$A$为正交矩阵，则$A^{-1}=A^T$也是正交矩阵，且$|A| = 1$或$-1$
若$A$和$B$都是正交矩阵，则$AB$也是正交矩阵

定义5&ensp;&ensp;若$P$为正交矩阵，则线性变换$y=Px$称为正交变换

&ensp;&ensp;设$y=Px$为正交变换，则有
$ $
\begin{array} {c}
\left \| y \right \| = \sqrt[]{y^Ty}=\sqrt[]{x^TP^TPx} = \sqrt[]{x^Tx}= \left \| x \right \| 
\end{array}
$ $



正交变换例：
$ $
\begin{array} {l}
有二次型f(y_1,y_2)=4y_1^2+4y_2^2+2y_1y_2，\\
f(y_1,y_2)对应矩阵为y^TAy=(y_1,y_2)\begin{pmatrix}
 4 & 1\\
 1 & 4
\end{pmatrix}\begin{pmatrix}
y_1 \\
y_2
\end{pmatrix}，\\
则存在正交矩阵P=\begin{pmatrix}
 \frac{1}{\sqrt[]{2}} & \frac{1}{\sqrt[]{2}}\\
 \frac{1}{\sqrt[]{2}} & -\frac{1}{\sqrt[]{2}}
\end{pmatrix}，\\
使得P^{-1}AP=P^TAP=\begin{pmatrix}
 5 & 0\\
 0 & 3
\end{pmatrix}，\\
于是有线性变换y=Px \Longrightarrow 
\begin{pmatrix}
 y_1 \\
 y_2
\end{pmatrix}
=\begin{pmatrix}
 \frac{1}{\sqrt[]{2}} & \frac{1}{\sqrt[]{2}}\\
 \frac{1}{\sqrt[]{2}} & -\frac{1}{\sqrt[]{2}}
\end{pmatrix}
\begin{pmatrix}
 x_1 \\
 x_2
\end{pmatrix}，\\
y=Px对应的线性方程组为\begin{cases}
 y_1=\frac{1}{\sqrt[]{2}}x_1+\frac{1}{\sqrt[]{2}}x_2\\
 y_2=\frac{1}{\sqrt[]{2}}x_1-\frac{1}{\sqrt[]{2}}x_2
\end{cases}，\\
经y=Px{\color{Red} 正交变换}后，二次型f(y_1,y_2)=5x_1^2+3x_2^2
\end{array}
$ $


方阵的特征值与向量值基本定义定义6&ensp;&ensp;设$A$是$n$阶矩阵，如果数$\lambda$和$n$维非零列向量$x$使$Ax=\lambda x$成立，那么称$\lambda$为矩阵$A$的特征值，非零列向量$x$称为$A$的对应与特征值$\lambda$的特征向量&ensp;&ensp;$Ax=\lambda x$可写成$(A - \lambda E)x=0$，将该式视为$n$个未知数$n$个方程的齐次线性方程组，已知该方程组有非零解，即$x$不为零向量，则它的系数行列式$|A - \lambda E| = 0$

$ $
\begin{align} \label {eq1}
|A-\lambda E|=0 \Longrightarrow 
\begin{vmatrix}
 a_{11}-\lambda & a_{12} & \cdots & a_{1n}\\
 a_{21} & a_{22}-\lambda & \cdots & a_{2n}\\
 \vdots & \vdots &  & \vdots\\
 a_{n1} & a_{n2} & \cdots & a_{nn}-\lambda
\end{vmatrix}=0
\end{align}
$ $


&ensp;&ensp;$\eqref {eq1}$行列式是以$\lambda$为未知数的一元$n$次方程，称为矩阵$A$的特征方程，左端$|A-\lambda E|$是$\lambda$的$n$次多项式，记作$f(\lambda)$，称为矩阵$A$的特征多项式，$A$的特征值就是方程的解
特征值的性质&ensp;&ensp;设$n$阶矩阵$A=\begin{pmatrix} a_{11} &amp; \cdots &amp; a_{1n} \\ \vdots &amp;        &amp; \vdots \\ a_{n1} &amp; \cdots &amp; a_{nn}\end{pmatrix}$的特征值为$\lambda_1,\lambda_2,\cdots,\lambda_n$，可知

$\lambda_1+\lambda_2+\cdots+\lambda_n=a_{11}+a_{22}+\cdots+a_{nn}$
$\lambda_1\lambda_2\cdots\lambda_n=|A|$

&ensp;&ensp;$\lambda_1+\lambda_2+\cdots+\lambda_n$称为矩阵$A$的迹，记作$tr(A)$
&ensp;&ensp;设$Ax=\lambda x$成立，$\lambda$是方阵$A$的特征值，则$\lambda$符合如下性质


  
  $k\lambda$是$kA$的特征值，即$kAx=k\lambda x$
  
  $Ax=\lambda x \Rightarrow kAx=k\lambda x$
  

  
  $\lambda^k$是$A^k$的特征值，即$A^kx=\lambda^k x$
  
  $Ax=\lambda x \Rightarrow A(Ax)=\lambda(\lambda x) \Rightarrow A(A^{k-1}x)=\lambda(\lambda^{k-1}x) \Rightarrow A^kx=\lambda^kx$
  

  
  $f(\lambda)$是$f(A)$的特征值，即$f(A)x=f(\lambda) x$，其中$f(A)=a_0E+a_2A+\cdots+a_mA^m$是矩阵$A$的多项式，$f(\lambda)=a_0+a_1\lambda+\cdots+a_m\lambda^m$是$\lambda$的多项式
  
  
    $ 
    \begin{array}{l}
    \because kAx=k\lambda x\\
    \therefore a_mAx=a_m\lambda x\\
    又\because A^kx=\lambda ^kx\\
    \therefore A^mx=\lambda ^mx\\
    即，a_mA^mx=a_m\lambda ^mx\\
    于是有:f(A)x=f(\lambda )x
    \end{array}
    $ 
  
  

  
  $\frac {1}{\lambda}$（$\lambda \ne 0$）是$A^{-1}$的特征值，即$A^{-1}x=\frac {1}{\lambda} x$
  
  $Ax=\lambda x \Rightarrow x=\lambda A^{-1}x \Rightarrow \frac {1}{\lambda}x=A^{-1}x$
  

  
  $\frac {|A|}{\lambda}$是$A^{*}$的特征值，即$A^{*}x= \frac {|A|}{\lambda} x$
  
  $Ax=\lambda x \Rightarrow x=\lambda A^{-1}x \Rightarrow x=\lambda \frac {1}{|A|}A^{*}x \Rightarrow \frac {|A|}{\lambda}x=A^{*}x$
  



特征向量的性质
若$x$是矩阵$A$对应于特征值$\lambda$的特征向量，则$kx$（$k \ne 0$）也是对应于$\lambda$的特征向量
若$x_1$、$x_2$都是矩阵$A$对应于特征值$\lambda$的特征向量，则$k_1x_1+k_2x_2$（$k_1$、$k_2$不全为零）也是对应于$\lambda$的特征向量

定理2&ensp;&ensp;设$\lambda_1,\lambda_2,\cdots,\lambda_m$是方阵$A$的$m$个特征值，$\xi_1,\xi_2,\cdots,\xi_m$依次是与之对应的特征向量，如果$\lambda_1,\lambda_2,\cdots,\lambda_m$各不相等，则$\xi_1,\xi_2,\cdots,\xi_m$线性无关
推论&ensp;&ensp;设$\lambda_1$和$\lambda_2$是方阵$A$的两个不同特征值，$\xi_1,\xi_2,\cdots,\xi_s$和$\eta_1,\eta_2,\cdots,\eta_t$分别是对应于$\lambda_1$和$\lambda_2$的线性无关的特征向量，则$\xi_1,\xi_2,\cdots,\xi_s,\eta_1,\eta_2,\cdots,\eta_t$线性无关
相似矩阵矩阵的相似定义7&ensp;&ensp;设$A$、$B$都是$n$阶矩阵，若有可逆矩阵$P$，使$P^{-1}AP=B$，则称$B$是$A$的相似矩阵，或者说矩阵$A$与$B$相似，对$A$进行运算$P^{-1}AP$称为对$A$进行相似变换，可逆矩阵$P$称为把$A$变成$B$的相似变换矩阵&ensp;&ensp;相似矩阵必等价，等价矩阵不一定相似
定理3&ensp;&ensp;若$n$阶矩阵$A$与$B$相似，则$A$与$B$的特征多项式相同，从而$A$与$B$的特征值亦相同

$ $
\begin{array} {c}
{\color{Red} |B-\lambda E| = |P^{-1}AP-\lambda E| = |P^{-1}AP-\lambda P^{-1}EP|=|P^{-1}||A-\lambda E||P|=|A-\lambda E|} 
\end{array}
$ $


&ensp;&ensp;若$n$阶矩阵$A$与$B$相似，根据定理3可知：

  
  $|A| = |B|$
  
  由特征值的性质$\lambda_1\lambda_2\cdots\lambda_n= |A| = |B|$
  

  
  $tr(A)=tr(B)$
  
  $tr(A)=tr(B)=\lambda_1+\lambda_2+\cdots+\lambda_n$
  

  
  $R(A)=R(B)$
  



矩阵的相似对角化定理3推论&ensp;&ensp;若$n$阶矩阵$A$与对角矩阵$\Lambda$相似，则$\lambda_1,\lambda_2,\cdots,\lambda_n$是$A$的$n$个特征值，其中

$ $
\begin{array} {c}
\Lambda=\begin{pmatrix}
 \lambda_1 &  &  & \\
  & \lambda_2 &  & \\
  &  & \ddots & \\
  &  &  & \lambda_n
\end{pmatrix}
\end{array}
$ $


&ensp;&ensp;对$n$阶矩阵$A$，寻求相似变换矩阵$P$，使$P^{-1}AP=\Lambda$为对角矩阵，称为把矩阵$A$对角化

$ $
\begin{align} \label {eq2}
\begin{array}{l}
假设有可逆矩阵P，使P^{-1}AP=\Lambda为对角矩阵\\
令P用列向量表示为P=(p_1,p_2,\cdots,p_n)\\ \\
P^{-1}AP=\Lambda \Longrightarrow AP=P\Lambda \\ \\
将P=(p_1,p_2,\cdots,p_n)代入得:\\
A(p_1,p_2,\cdots,p_n)=(p_1,p_2,\cdots,p_n)\begin{pmatrix}
 \lambda_1 &  &  & \\
  & \lambda_2 &  & \\
  &  & \ddots & \\
  &  &  & \lambda_n
\end{pmatrix}\\ \\
矩阵对应相乘得:\\
(Ap_1,Ap_2,\cdots,Ap_n)=(\lambda_1p_1,\lambda_2p_2,\cdots,\lambda_np_n)\\ \\
于是有:\\
Ap_i=\lambda_ip_i \space (i=1,2,\cdots,n)
\end{array}
\end{align}
$ $


$\lambda_i$是$A$的特征值，$P$的列向量$p_i$就是$A$的对应于特征值$\lambda_i$的特征向量，$p_i$构成的矩阵$P$就是把$A$变成$\Lambda$的相似变换矩阵。综上所述，求得$\lambda_i$便可得到$p_i$，进而可求出$P=(p_i)$

例：设矩阵$A=\begin{pmatrix}
 -2 & 1 & 1\\
 0 & 2 & 0\\
 -4 & 1 & 3
\end{pmatrix}$，求$P$、$\Lambda$，使$P^{-1}AP=\Lambda$
$ $
\begin{array} {l}
\because P^{-1}AP=\Lambda\Longrightarrow Ap_i=\lambda_ip_i (根据\eqref {eq2}中推导)\\
\therefore |A-\lambda E|=\begin{vmatrix}
 -2-\lambda  & 1 & 1\\
 0 & 2-\lambda  & 0\\
 -4 & 1 & 3-\lambda 
\end{vmatrix}=0\\
于是有-(2-\lambda )^2(\lambda + 1)=0\\
\therefore A的特征值为\lambda _1=\lambda _2=2,\lambda _3=-1\\
当\lambda _1=\lambda _2=2时，A-2E=\begin{pmatrix}
 -4 & 1 & 1\\
 0 & 0 & 0\\
 -4 & 1 & 1
\end{pmatrix} 
\sim 
\begin{pmatrix}
 -4 & 1 & 1\\
 0 & 0 & 0\\
 0 & 0 & 0
\end{pmatrix}\\
有特征向量p_1=\begin{pmatrix}
1 \\
4 \\
0
\end{pmatrix},
p_2=\begin{pmatrix}
1 \\
0 \\
4
\end{pmatrix}\\
当\lambda _3=-1时，A+E=\begin{pmatrix}
 -1 & 1 & 1\\
 0 & 3 & 0\\
 -4 & 1 & 4
\end{pmatrix}
\sim 
\begin{pmatrix}
 1 & 0 & -1\\
 0 & 1 & 0\\
 0 & 0 & 0
\end{pmatrix}\\
有特征向量p_3=\begin{pmatrix}
1 \\
0 \\
1
\end{pmatrix}\\
\therefore P=(p_1,p_2,p_3)=\begin{pmatrix}
 1 & 1 & 1\\
 4 & 0 & 0\\
 0 & 4 & 1
\end{pmatrix}，
P^{-1}=\begin{pmatrix}
 0 & \frac{1}{4}  & 0\\
 -\frac{1}{3}  & \frac{1}{12}  & \frac{1}{3} \\
 \frac{4}{3}  & -\frac{1}{3}  & -\frac{1}{3}
\end{pmatrix}\\
于是有:P^{-1}AP=\begin{pmatrix}
 2 & 0 & 0\\
 0 & 2 & 0\\
 0 & 0 & -1
\end{pmatrix}=\Lambda
\end{array}
$ $


定理4&ensp;&ensp;$n$阶矩阵$A$与对角矩阵相似（即$A$能对角化）的充分必要条件是$A$有$n$个线性无关的特征向量&ensp;&ensp;如果$A$有$n$个不相等的特征值，则必有$n$个线性无关的特征向量
推论&ensp;&ensp;如果$n$阶矩阵$A$的$n$个特征值互不相等，则$A$与对角矩阵相似&ensp;&ensp;当$A$的特征方程有重根，例如$\lambda_1=\lambda_2=1$时，由于二重特征值$1$未必有两个线性无关的特征向量，所以$A$就未必有$n$个线性无关的特征向量，从而未必能相似对角化。通过$n - R(A - \lambda_1E)$可得到二重特征值$\lambda_1$对应的线性无关特征向量的个数
实对称矩阵的对角化性质1&ensp;&ensp;对称矩阵的特征值为实数
性质2&ensp;&ensp;设$\lambda_1$、$\lambda_2$是对称矩阵$A$的两个特征值，$p_1$、$p_2$是对应的特征向量，若$\lambda_1 \ne \lambda_2$，则$p_1$与$p_2$正交
定理5&ensp;&ensp;设$A$为$n$阶对称矩阵，则必有正交矩阵$P$，使$P^{-1}AP=P^TAP=\Lambda$，其中$\Lambda$是以$A$的$n$个特征值为对角元的对角矩阵
推论&ensp;&ensp;设$A$为$n$阶对称矩阵，$\lambda$是$A$的特征方程的$k$重根，则矩阵$A-\lambda E$的秩$R(A-\lambda E)=n-k$，从而对应特征值$\lambda$恰有$k$个线性无关的特征向量
&ensp;&ensp;综上所述，将$A$对应于特征值$\lambda_i$的特征向量$p_i$进行标准正交化（即施密特正交化和单位化），由此得到一组两两正交的单位向量$e_i$，$e_i$构成的正交矩阵$P=(e_i)$就是把$A$变成$\Lambda$的相似变换矩阵

例：设实对称矩阵$A=\begin{pmatrix}
 0 & -1 & 1\\
 -1 & 0 & 1\\
 1 & 1 & 0
\end{pmatrix}$，求一个正交矩阵$P$，使$P^{-1}AP=\Lambda$为对角矩阵
$ $
\begin{array} {l}
\because P^{-1}AP=\Lambda\Longrightarrow Ap_i=\lambda_ip_i (根据\eqref {eq2}中推导)\\
\therefore |A-\lambda E|=\begin{vmatrix}
 -\lambda & -1 & 1\\
 -1 & -\lambda  & 1\\
 1 & 1 & -\lambda 
\end{vmatrix}=0\\
于是有(\lambda - 1)^2(\lambda + 2)=0\\
\therefore A的特征值为\lambda_1=\lambda_2=1,\lambda_3=-2\\
当\lambda _1=\lambda _2=1时，A-E=\begin{pmatrix}
 -1 & -1 & 1\\
 -1 & -1 & 1\\
 1 & 1 & -1
\end{pmatrix} \sim 
\begin{pmatrix}
 1 & 1 & -1\\
 0 & 0 & 0\\
 0 & 0 & 0
\end{pmatrix}\\
有特征向量p_1=\begin{pmatrix}
1 \\
0 \\
1
\end{pmatrix},
p_2=\begin{pmatrix}
-1 \\
1 \\
0
\end{pmatrix}\\
当\lambda _3=-2时，A+E=\begin{pmatrix}
 2 & -1 & 1\\
 -1 & 2 & 1\\
 1 & 1 & 2
\end{pmatrix}
\sim 
\begin{pmatrix}
 1 & 0 & 1\\
 0 & 1 & 1\\
 0 & 0 & 0
\end{pmatrix}\\
有特征向量p_3=\begin{pmatrix}
-1 \\
-1 \\
1
\end{pmatrix}\\
\because \lambda_1 \ne \lambda_2 \\
\therefore p_1,p_3正交，p_2,p_3正交，经验证p_1,p_2不可正交，需将p_1,p_2正交化\\
取\eta_1=p_1=\begin{pmatrix}
1 \\
0 \\
1
\end{pmatrix}\\
\eta_2=p_2-\frac {[p_2,\eta_1]}{[\eta_1,\eta_1]}\eta_1=\begin{pmatrix}
-1 \\
1 \\
0
\end{pmatrix}
+\frac {1}{2}\begin{pmatrix}
1 \\
0 \\
1
\end{pmatrix}
=\frac {1}{2}\begin{pmatrix}
-1 \\
2 \\
1
\end{pmatrix}\\
将\eta_1,\eta_2,p_3单位化，有e_1=\frac {1}{\sqrt[]{2}}\begin{pmatrix}
1 \\
0 \\
1
\end{pmatrix},
e_2=\frac {1}{\sqrt[]{6}}\begin{pmatrix}
-1 \\
2 \\
1
\end{pmatrix},
e_3=\frac {1}{\sqrt[]{3}}\begin{pmatrix}
-1 \\
-1 \\
1
\end{pmatrix}\\
于是有正交矩阵P=(e_1,e_2,e_3)=\begin{pmatrix}
 \frac{1}{\sqrt[]{2}} & -\frac{1}{\sqrt[]{6}} & -\frac{1}{\sqrt[]{3}}\\
 0 & \frac{2}{\sqrt[]{6}} & -\frac{1}{\sqrt[]{3}}\\
 \frac{1}{\sqrt[]{2}} & \frac{1}{\sqrt[]{6}} & \frac{1}{\sqrt[]{3}}
\end{pmatrix}\\
使P^{-1}AP=P^{T}AP=\Lambda=\begin{pmatrix}
 1 & 0 & 0\\
 0 & 1 & 0\\
 0 & 0 & -2
\end{pmatrix}
\end{array}
$ $


二次型二次型定义定义8&ensp;&ensp;含有$n$个变量$x_1,x_2,\cdots,x_n$的二次齐次函数$f(x_1,x_2,\cdots,x_n)$称为二次型

$ $
\begin{align*}
  f(x_1,x_2,\cdots,x_n)=&a_{11}x_1^2+a_{22}x_2^2+\cdots+a_{nn}x_n^2+\\
  &2a_{12}x_1x_2+2a_{13}x_1x_3+\cdots +2a_{n-1,n}x_{n-1}x_n
\end{align*}
$ $



&ensp;&ensp;展开上式$\cdots$中的内容，然后移项，则可以看到
$ $
\begin{align*}
  f(x_1,x_2,\cdots,x_n)=&a_{11}x_1^2+2a_{12}x_1x_2+\cdots+2a_{1n}x_1x_n+\\
  &a_{22}x_2^2+2a_{23}x_2x_3+\cdots+2a_{2n}x_2x_n+\\
  &a_{33}x_1^2+2a_{34}x_1x_2+\cdots+2a_{3n}x_3x_n+\\
  &\cdots+\\
  &a_{n-1,n-1}x_{n-1}^2+2a_{n-1,n}x_{n-1}x_n+\\
  &a_{nn}x_n^2
\end{align*}
$ $


因为$a_{ij}=a_{ji}$，所以$2a_{ij}x_ix_j=a_{ji}x_ijx_i+a_{ji}x_iy_i$，则原$f(x_1,x_2,\cdots,x_n)$可写成

$ $
\begin{align*}
  f(x_1,x_2,\cdots,x_n)=&{\color{Red} a_{11}x_1^2} +a_{12}x_1x_2+\cdots+a_{1n}x_1x_n+\\
  &a_{21}x_2x_1+{\color{Red} a_{22}x_2^2} +\cdots+a_{2n}x_2x_n+\\
  &\cdots+\\
  &a_{n1}x_{n}x_1+a_{n2}x_{n}x_2+\cdots+{\color{Red} a_{nn}x_n^{2}} \\ \\
  =&\sum_{i,j=1}^{n} a_{ij}x_ix_j
\end{align*}
$ $



&ensp;&ensp;例：二次型$f(x_1,x_2,x_3)$
$ $
\begin{align*}
  f(x_1,x_2,x_3)=&a_{11}x_1^2+a_{12}x_1x_2+a_{13}x_1x_3+\\
  &a_{21}x_2x_1+a_{22}x_2^2+a_{23}x_2x_3+\\
  &a_{31}x_{3}x_1+a_{32}x_{3}x_2+a_{33}x_3^{2} \\ \\
  =&a_{11}x_1^2+2a_{12}x_1x_2+2a_{13}x_1x_3+\\
  &a_{22}x_2^2+2a_{23}x_2x_3+\\
  &a_{33}x_3^{2}
\end{align*}
$ $


利用矩阵，$f$可表示为

$ $
\begin{align*}
  f(x_1,x_2,\cdots,x_n)=&x_1(a_{11}x_1+a_{12}x_2+\cdots+a_{1n}x_n)+\\
  &x_2(a_{21}x_1+a_{22}x_2+\cdots+a_{2n}x_n)+\\
  &\cdots +\\
  &x_n(a_{n1}x_1+a_{n2}x_2+\cdots+a_{nn}x_n) \\ \\
 =&(x_1,x_2,\cdots,x_n)\begin{pmatrix}
 a_{11}x_1+a_{12}x_2+\cdots+a_{1n}x_n\\
 a_{21}x_1+a_{22}x_2+\cdots+a_{2n}x_n\\
 \vdots\\
 a_{n1}x_1+a_{n2}x_2+\cdots+a_{nn}x_n
\end{pmatrix} \\ \\
 =&(x_1,x_2,\cdots,x_n)\begin{pmatrix}
 a_{11} & a_{12} & \cdots & a_{1n}\\
 a_{21} & a_{22} & \cdots & a_{2n}\\
 \vdots & \vdots &  & \vdots\\
 a_{n1} & a_{nn2} & \cdots & a_{nn}
\end{pmatrix}\begin{pmatrix}
x_1 \\
x_2 \\
\vdots \\
x_n
\end{pmatrix}
\end{align*}
$ $
 

其中，$A=\begin{pmatrix} a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1n}\\ a_{21} &amp; a_{22} &amp; \cdots &amp; a_{2n}\\ \vdots &amp; \vdots &amp;  &amp; \vdots\\ a_{n1} &amp; a_{nn2} &amp; \cdots &amp; a_{nn}\end{pmatrix}$，$x=\begin{pmatrix}x_1 \\x_2 \\\vdots \\x_n\end{pmatrix}$，则$f$可记作$f=x^TAx$，对称矩阵$A$（因为$a_{ij}=a_{ji}$）叫做二次型$f$的矩阵，$f$叫做对称矩阵$A$的二次型，对称矩阵$A$的秩叫做二次型$f$的秩
&ensp;&ensp;任给一个二次型，可惟一确定一个对称矩阵$A$，任给一个对称矩阵，也可惟一确定一个二次型
合同对角化定义9&ensp;&ensp;设$A$和$B$是$n$阶矩阵，若有可逆矩阵$C$，使$B=C^TAC$，则称矩阵$A$与$B$合同，记作$A\simeq B$。对于对称矩阵$A$，寻求可逆矩阵$C$，使$C^TAC=B$为对角矩阵，称为把矩阵$A$合同对角化

&ensp;&ensp;例：
$ $
\begin{array}{l}
对于矩阵A=
\begin{pmatrix}
 4 & 1\\
 1 & 4
\end{pmatrix}，\\
存在可逆矩阵C=
\begin{pmatrix}
 1 & -\frac{1}{4} \\
 0 & 1
\end{pmatrix}，\\
使C^TAC成为对角矩阵\\
C^TAC=\begin{pmatrix}
 4 & 0\\
 0 & \frac{15}{4} 
\end{pmatrix}\\
若令B=C^TAC，则A与B合同
\end{array}
$ $
 

&ensp;&ensp;合同矩阵符合如下性质

如果$A$与$B$合同，则$A\sim B$，$R(A)=R(B)$
如果$A$与$B$合同，$A$为对称矩阵，则$B$也为对称矩阵
任一实对称矩阵必合同于一对角矩阵


&ensp;&ensp;实对称矩阵必可相似对角化与合同对角化
$ $
\begin{array} {l}
设A为n阶对称矩阵\\
根据定理5，必有正交矩阵P，\\
使:P^{-1}AP=P^TAP=\Lambda\\
其中\Lambda 是以A的n个特征值为对角元的对角矩阵
\end{array}
$ $


二次型的标准形&ensp;&ensp;有可逆的线性变换

$ $
\begin{cases}
  x_1= c_{11}y_1+c_{12}y_2+\cdots+c_{1n}y_n\\
  x_2= c_{21}y_1+c_{22}y_2+\cdots+c_{2n}y_n\\
  \cdots \\
  x_n= c_{n1}y_1+c_{n2}y_2+\cdots+c_{nn}y_n
\end{cases}
$ $


将其带入到二次型$f(x_1,x_2,\cdots,x_n)$中，使$f=k_1y_1^2+k_2y_2^2+\cdots+k_ny_n^2$，这种只含平方项的二次型，称为二次型的标准形，该可逆线性变换可记作$x=Cy$

&ensp;&ensp;因为
$ $
\begin{array} {c}
x=Cy 
\Longrightarrow 
\begin{pmatrix}
x_1 \\
x_2 \\
\vdots \\
x_n
\end{pmatrix}=
\begin{pmatrix}
 c_{11} & c_{12} & \cdots & c_{1n}\\
 c_{21} & c_{22} & \cdots & c_{2n}\\
 \vdots & \vdots &  & \vdots\\
 c_{n1} & c_{nn2} & \cdots & c_{nn}
\end{pmatrix}
\begin{pmatrix}
y_1 \\
y_2 \\
\vdots \\
y_n
\end{pmatrix}
 \Longrightarrow 
\begin{cases}
  x_1= c_{11}y_1+c_{12}y_2+\cdots+c_{1n}y_n\\
  x_2= c_{21}y_1+c_{22}y_2+\cdots+c_{2n}y_n\\
  \cdots \\
  x_n= c_{n1}y_1+c_{n2}y_2+\cdots+c_{nn}y_n
\end{cases}
\end{array}
$ $
 


正交变换化二次型成标准形&ensp;&ensp;将可逆的线性变换$x=Cy$代入二次型矩阵$f=x^TAx$中，有$f=x^TAx=(Cy)^TA(Cy)=y^T(C^TAC)y$，使$C^TAC$成为对角矩阵

$ $
\begin{array} {c}
y^TC^TACy=k_1y_1^2+k_2y_2^2+\cdots+k_ny_n^2=
(y_1,y_2,\cdots,y_n)
\begin{pmatrix}
 k_{1} &  &  & \\
  & k_{2} &  & \\
  &  & \ddots & \\
  &  &  & k_{n}
\end{pmatrix}
\begin{pmatrix}
y_1 \\
y_2 \\
\vdots \\
y_n
\end{pmatrix}
\end{array}
$ $


对于对称矩阵$A$，寻求可逆矩阵$C$，使$C^TAC$成为对角矩阵的过程，称为把对称矩阵$A$合同对角化
定理6&ensp;&ensp;任给二次型$f=\sum_{i,j=1}^{n} a_{ij}x_ix_j$（$a_{ij}=a_{ji}$），总有正交变换$x=Py$，使$f$化为标准形$f=\lambda_1y_1^2+\lambda_2y_2^2+\cdots+\lambda_ny_n^2$，其中$\lambda_1,\lambda_2,\cdots,\lambda_n$是$f$的矩阵$A=(a_{ij})$的特征值

$ $
\begin{array}{l}
由题意，二次型f的矩阵为A=
\begin{pmatrix}
 4 & 1\\
 1 & 4
\end{pmatrix}\\
\therefore |A - \lambda E|=
\begin{vmatrix}
 4-\lambda & 1\\
 1 & 4-\lambda
\end{vmatrix}=0\\
于是有(4-\lambda)^2-1=0\\
\therefore A的特征值为\lambda _1=5,\lambda _2=3\\
当\lambda _1=5时，A-5E=
\begin{pmatrix}
 -1 & 1\\
 1 & -1
\end{pmatrix}\sim 
\begin{pmatrix}
 1 & -1\\
 0 & 0
\end{pmatrix}\\
有特征向量\xi_1=\begin{pmatrix}
1 \\
1
\end{pmatrix}\\
当\lambda _2=3时，A-3E=
\begin{pmatrix}
 1 & 1\\
 1 & 1
\end{pmatrix}\sim 
\begin{pmatrix}
 1 & 1\\
 0 & 0
\end{pmatrix}\\
有特征向量\xi_2=\begin{pmatrix}
1 \\
-1
\end{pmatrix}\\
\because \lambda_1 \ne \lambda_2\\
\therefore \xi_1与\xi_2正交\\
将\xi_1,\xi_2单位化，e_1=\frac{1}{\sqrt[]{2} }\begin{pmatrix}
1 \\
1
\end{pmatrix} ,e_2=\frac{1}{\sqrt[]{2} }\begin{pmatrix}
1 \\
-1
\end{pmatrix} \\
令P=(e_1,e_2)=\begin{pmatrix}
 \frac{1}{\sqrt[]{2}} & \frac{1}{\sqrt[]{2}}\\
 \frac{1}{\sqrt[]{2}} & -\frac{1}{\sqrt[]{2}}
\end{pmatrix}\\
则P为正交矩阵，且P^TAP=\Lambda=\begin{pmatrix}
 5 & 0\\
 0 & 3
\end{pmatrix}\\
于是有正交变换\begin{pmatrix}
 x_1\\
 x_2
\end{pmatrix}=
\begin{pmatrix}
 \frac{1}{\sqrt[]{2}} & \frac{1}{\sqrt[]{2}}\\
 \frac{1}{\sqrt[]{2}} & -\frac{1}{\sqrt[]{2}}
\end{pmatrix}
\begin{pmatrix}
 y_1\\
 y_2
\end{pmatrix}\\
把二次型转换成标准形f=5y_1^2+3y_2^2
\end{array}
$ $
 

配方法化二次型为成标准形
&ensp;&ensp;例1：化二次型$f(x_1,x_2,x_3)=2x_1^2+5x_2^2+5x_3^2+4x_1x_2-4x_1x_3-8x_2x_3$为标准形
$ $
\begin{array}{l}
\begin{align*}
 原式= & \underline{2(x_1^2+2x_1x_2-2x_1x_3)} +5x_2^2+5x_3^2-8x_2x_3\\
  & {\color{Red} 把所有含x_1的项合并、配方} \\
  =& 2(x_1+x_2-x_3)^2+3x_2^2+3x_3^2-4x_2x_3\\
  =& 2(x_1+x_2-x_3)^2+\underline{3(x_2^2-\frac{4}{3}x_2x_3)} +3x_3^2\\
  & {\color{Red} 把所有含x_2的项合并、配方}\\
  =& 2(x_1+x_2-x_3)^2+3(x_2-\frac{2}{3}x_3)^2+\frac{5}{3}x_3^2
\end{align*}\\
令\begin{cases}
 y_1= x_1+x_2-x_3\\
 y_2= x_2-\frac{2}{3}x_3\\
 y_3= x_3
\end{cases}，即
\begin{cases}
 x_1= y_1-y_2+\frac{1}{3}y_3\\
 x_2= y_2+\frac{2}{3}y_3\\
 x_3= y_3
\end{cases}\\
于是有可逆矩阵C=\begin{pmatrix}
 1 & -1 & \frac{1}{3} \\
 0 & 1 & \frac{2}{3} \\
 0 & 0 & 1
\end{pmatrix}，使x=Cy成立\\
即，f(x_1,x_2,x_3)经x=Cy后，f=2y_1^2+3y_2^2+\frac{5}{3}y_3^2
\end{array}
$ $
 



&ensp;&ensp;例2：$f(x_1,x_2,x_3)=x_1x_2+x_1x_3+x_2x_3$
$ $
\begin{array}{l}
令\begin{cases}
x_1= y_1+y_2\\
x_2= y_1-y_2\\
x_3= y_3
\end{cases}，代入可得\underline{f=y_1^2-y_2^2+2y_1y_3} \\
{\color{Red} f中不含平方项，先构造平方项} \\
原式=(y_1+y_3)^2-y_2^2-y_3^2\\
令\begin{cases}
z_1=y_1+y_3 \\
z_2=y_2 \\
z_3=y_3
\end{cases}，即\begin{cases}
y_1=z_1-z_3 \\
y_2=z_2 \\
y_3=z_3
\end{cases}，
代入得\begin{cases}
x_1=z_1+z_2-z_3 \\
x_2=z_1-z_2-z_3 \\
x_3=z_3
\end{cases}\\
于是有可逆矩阵\underline{C=C_1C_2}=\begin{pmatrix}
 1 & 1 & -1\\
 1 & -1 & -1\\
 0 & 0 & 1
\end{pmatrix} ，使\underline{x=Cz} 成立\\
{\color{Red} x=C_1y，y=C_2z，\therefore x=C_1C_2z=Cz} \\
{\color{Red} C=C_1C_2=\begin{pmatrix}
 1 & 1 & 0\\
 1 & -1 & 0\\
 0 & 0 & 1
\end{pmatrix}\begin{pmatrix}
 1 & 0 & -1\\
 0 & 1 & 0\\
 0 & 0 & 1
\end{pmatrix}=\begin{pmatrix}
 1 & 1 & -1\\
 1 & -1 & -1\\
 0 & 0 & 1
\end{pmatrix}} \\
即，f(x_1,x_2,x_3)经x=Cz后，f=z_1^2-z_2^2-z_3^2
\end{array}
$ $


二次型的规范形&ensp;&ensp;如果标准形$f=k_1y_1^2+k_2y_2^2+\cdots+k_ny_n^2$的系数$k_1,k_2,\cdots,k_n$只在$1,-1,0$三个数中取值，则成为二次型的规范形
定理6推论&ensp;&ensp;任给$n$元二次型$f(x)=x^TAx$（$A^T=A$），总有可逆变换$x=Cz$，使$f(Cz)$为规范形

&ensp;&ensp;例：化二次型的标准形$f(y_1,y_1,y_3)=-2y_1^2+y_2^2+y_3^2$为规范形
$ $
\begin{array}{l}
令\begin{cases}
 y_1=\frac{1}{\sqrt[]{2}}z_1\\
 y_2=z_2\\
 y_3=z_3
\end{cases}，于是有可逆矩阵C=\begin{pmatrix}
 \frac{1}{\sqrt[]{2}} &  & \\
  & 1 & \\
  &  & 1
\end{pmatrix}使y=Cz成立\\
即f(y_1,y_1,y_3)经y=Cz后，f=-z_1+z_2+z_3\\
{\color{Red} 其实还是可逆的线性变换} 
\end{array}
$ $


正定二次型定理7（惯性定理）&ensp;&ensp;设二次型$f=x^TAx$的秩为$r$，且有两个可逆变换$x=Cy$及$x=Pz$使

$ $
\begin{array} {c}
f=k_1y_1^2+k_2y_2^2+\cdots+k_ry_r^2 （k_i \ne 0）\\
f=\lambda_1z_1^2+\lambda_2z_2^2+\cdots+\lambda_rz_r^2 （\lambda_i \ne 0）
\end{array}
$ $


则$k_1,k_2,\cdots,k_r$中正数的个数与$\lambda_1,\lambda_2,\cdots,\lambda_r$中正数的个数相等
&ensp;&ensp;二次型的标准形中正系数的个数称为二次型的正惯性指数，负系数的个数称为负惯性指数
&ensp;&ensp;若二次型$f$的正惯性指数为$p$，秩为$r$，则$f$的规范形便可确定为

$ $
\begin{array} {c}
f=y_1^2+\cdots+y_p^2-y_{p+1}^2-\cdots-y_r^2\\
{\color{Red} p个正系数，r-p个负系数} 
\end{array}
$ $


定义10&ensp;&ensp;设二次型$f(x)=x^TAx$，如果对任何$x \ne 0$，都有$f(x) \gt 0$，则称$f$为正定二次型，并称对称矩阵$A$是正定的；如果对任何$x\ne 0$都有$f(x) \lt 0$，则称$f$为负定二次型，并称矩阵$A$是负定的
定理8&ensp;&ensp;$n$元二次型$f(x)=x^TAx$为正定的充分必要条件是：它的标准形的$n$个系数全为正，即它的规范形的$n$个系数全为1，亦即它的正惯性指数等于$n$
推论&ensp;&ensp;对称矩阵$A$为正定矩阵的充分必要条件是：$A$的特征值全为正
定理9&ensp;&ensp;对称矩阵$A$为正定的充分必要条件是：$A$的各阶主子式都为正，即

$ $
\begin{array} {c}
a_{11} \gt 0,\begin{vmatrix}
 a_{11} & a_{12}\\
 a_{21} & a_{22}
\end{vmatrix} \gt 0,\cdots,\begin{vmatrix}
 a_{11} & \cdots & a_{1n} \\
 \vdots &  & \vdots \\
 a_{n1} & \cdots & a_{nn}
\end{vmatrix} \gt 0
\end{array}
$ $


对称矩阵$A$为负定的充分必要条件是：奇数阶主子式为负，偶数阶主子式为正，即

$ $
\begin{array} {c}
(-1)^r\begin{vmatrix}
 a_{11} & \cdots & a_{1r} \\
 \vdots &  & \vdots \\
 a_{r1} & \cdots & a_{rr}
\end{vmatrix} \gt 0（r=1,2,\cdots,n）
\end{array}
$ $



数学常用公式定理1
数学常用公式定理2
数学常用公式定理3
数学常用公式定理4
数学常用公式定理5






]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>构造器、初始化块</title>
    <url>/2023/03/27/%E6%9E%84%E9%80%A0%E5%99%A8%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E5%9D%97/</url>
    <content><![CDATA[构造器&ensp;&ensp;每个类都默认有一个无参的构造器，在使用类创建的对象时，会优先调用构造器，如果手动添加了构造器，那么默认的无参构造器将会消失
无参构造器&ensp;&ensp;创建如下类public class Root &#123;    public void print() &#123;        System.out.println(&quot;Root的print方法&quot;);    &#125;    public Root() &#123;        System.out.println(&quot;Root的构造器&quot;);    &#125;&#125;
&ensp;&ensp;使用如下方式调用，将会输出// 将会输出下面两行// Root的构造器// Root的print方法new Root().print();
构造器重载&ensp;&ensp;再给Root添加一个有参数的构造器，然后在无参构造器中调用它，如下public class Root &#123;    public void print() &#123;        System.out.println(&quot;Root的print方法&quot;);    &#125;    public Root() &#123;        this(&quot;Root无参构造器调用&quot;);        System.out.println(&quot;Root的构造器&quot;);    &#125;    public Root(String value) &#123;        System.out.println(&quot;Root的构造器，参数 = &quot; + value);    &#125;&#125;
&ensp;&ensp;使用如下方式调用，将会输出// 将会输出下面两行// Root的构造器，参数 = Root无参构造器调用// Root的构造器// Root的print方法new Root().print();
&ensp;&ensp;这是因为在Root的无参构造器中使用this()调用了另外一个构造器，需要注意的是，使用this()对构造器的重载中，必须在构造器的第一行调用
调用父类构造器&ensp;&ensp;创建一个Mid类，使他继承上面的Root类，并给它添加一个构造器public class Mid extends Root &#123;    public Mid() &#123;        System.out.println(&quot;Mid的构造器&quot;);    &#125;&#125;
&ensp;&ensp;使用如下方式调用，将会输出// 将会输出下面三行// Root的构造器，参数 = Root无参构造器调用// Root的构造器// Mid的构造器new Mid();
&ensp;&ensp;由上可以得出，父类的构造器要比子类构造器先执行，这是因为如果没有手动使用super()调用父类构造器的话，在子类构造器执行前，会隐式调用父类的无参构造器
&ensp;&ensp;如果手动使用super()调用父类构造器，则必须要写在子类构造器执行体的第一行，这注定了this()和super()不会同时出现在同一个构造方法中
&ensp;&ensp;如下，当使用this()重载构造器时，super()就只能写在最后一个被重载的构造器的第一行public class Mid extends Root &#123;    public Mid() &#123;        this(&quot;Mid无参构造器调用&quot;);        System.out.println(&quot;Mid的构造器&quot;);    &#125;    public Mid(String value) &#123;        super(&quot;Mid有参构造器调用&quot;);        System.out.println(&quot;Mid的构造器，参数 = &quot; + value);    &#125;&#125;
&ensp;&ensp;使用Mid创建对象，将会输出
// Root的构造器，参数 = Mid有参构造器调用// Mid的构造器，参数 = Mid无参构造器调用// Mid的构造器new Mid();
&ensp;&ensp;上面代码中的调用顺序，Mid无参构造器 -&gt; Mid有参构造器 -&gt; Root有参构造器
初始化块&ensp;&ensp;在Root和Mid中分别创建初始化块public class Root &#123;    &#123;        System.out.println(&quot;Root的初始化块&quot;);    &#125;    public Root() &#123;        this(&quot;Root无参构造器调用&quot;);        System.out.println(&quot;Root的构造器&quot;);    &#125;    public Root(String value) &#123;        System.out.println(&quot;Root的构造器，参数 = &quot; + value);    &#125;&#125;public class Mid extends Root &#123;    &#123;        System.out.println(&quot;Mid的初始化块&quot;);    &#125;        public Mid() &#123;        this(&quot;Mid无参构造器调用&quot;);        System.out.println(&quot;Mid的构造器&quot;);    &#125;    public Mid(String value) &#123;        System.out.println(&quot;Mid的构造器，参数 = &quot; + value);    &#125;&#125;
&ensp;&ensp;通过如下代码调用，将会输出// Root的初始化块// Root的构造器，参数 = Root无参构造器调用// Root的构造器// Mid的初始化块// Mid的构造器，参数 = Mid无参构造器调用// Mid的构造器new Mid();
&ensp;&ensp;由上可以得出，该类的初始化块总是在该类的构造方法执行前、在super()执行后被执行
静态初始化块&ensp;&ensp;在Root和Mid中分别创建静态初始化块public class Root &#123;    static &#123;        System.out.println(&quot;Root的静态初始化块&quot;);    &#125;    &#123;        System.out.println(&quot;Root的初始化块&quot;);    &#125;    public Root() &#123;        this(&quot;Root无参构造器调用&quot;);        System.out.println(&quot;Root的构造器&quot;);    &#125;    public Root(String value) &#123;        System.out.println(&quot;Root的构造器，参数 = &quot; + value);    &#125;&#125;
public class Mid extends Root &#123;    static &#123;        System.out.println(&quot;Mid的静态初始化块&quot;);    &#125;    &#123;        System.out.println(&quot;Mid的初始化块&quot;);    &#125;    public Mid() &#123;        this(&quot;Mid无参构造器调用&quot;);        System.out.println(&quot;Mid的构造器&quot;);    &#125;    public Mid(String value) &#123;        System.out.println(&quot;Mid的构造器，参数 = &quot; + value);    &#125;&#125;
&ensp;&ensp;通过如下代码调用，将会输出// Root的静态初始化块// Mid的静态初始化块// Root的初始化块// Root的构造器，参数 = Root无参构造器调用// Root的构造器// Mid的初始化块// Mid的构造器，参数 = Mid无参构造器调用// Mid的构造器new Mid();
&ensp;&ensp;由上可知，父类的静态初始化块先被执行，然后是子类的静态初始化块，接着是父类初始化块、父类构造器、子类初始化块、子类构造器。&ensp;&ensp;这是因为静态初始化块与类相关联，而不是与对象相关联，所以当类被加载到内存中时，静态初始化块被执行。&ensp;&ensp;而父类要先于子类加载到内存中，所以先执行了父类中的静态初始化块，然后是子类的静态初始化块。在创建Mid对象时，又执行了父类初始化块、父类构造器、子类初始化块、子类构造器。
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>枚举</title>
    <url>/2021/07/24/%E6%9E%9A%E4%B8%BE/</url>
    <content><![CDATA[&ensp;&ensp;枚举使用enum定义，默认继承java.lang.Enum，不再继承Object&ensp;&ensp;枚举中必须在第一行列出所有实例，枚举的构造器未接收形参的情况下，实例可以不写括号()
/** * 构造器未接收参数，所以四个实例可以不写括号 */public enum Direction&#123;    North, South, East, West;    Direction() &#123;    &#125;&#125;

&ensp;&ensp;当然，如果你想写括号也可以写public enum Direction&#123;    North(), South(), East(), West();    Direction() &#123;    &#125;&#125;
&ensp;&ensp;不过当构造器接收了参数的时候，则一定要在第一行列出的实例中传入对应参数/** * 构造器接收参数。则第一行列出的实例中必须传入对应参数 */public enum Direction&#123;    North(&quot;&quot;), South(&quot;&quot;), East(&quot;&quot;), West(&quot;&quot;);    Direction(String s) &#123;            &#125;&#125;
&ensp;&ensp;实际上，上述枚举类等同于如下public class Direction&#123;    public static final Direction North = new Direction(&quot;&quot;);    public static final Direction South = new Direction(&quot;&quot;);    public static final Direction East = new Direction(&quot;&quot;);    public static final Direction West = new Direction(&quot;&quot;);        private Direction(String s) &#123;            &#125;&#125;
&ensp;&ensp;在使用上，也大同小异public static void main(String[] args) &#123;    check(Direction.North);    check(Direction.South);&#125;private static void check(Direction direction) &#123;    if (direction == Direction.North) &#123;        System.out.println(&quot;North&quot;);    &#125; else if (direction == Direction.South) &#123;        System.out.println(&quot;South&quot;);    &#125;&#125;public enum Direction&#123;    North, South, East, West;&#125;
&ensp;&ensp;用switch更为便捷public static void main(String[] args) &#123;    check(Direction.North);    check(Direction.South);&#125;private static void check(Direction direction) &#123;    switch (direction) &#123;        case North:            System.out.println(&quot;North&quot;);            break;        case South:            System.out.println(&quot;South&quot;);            break;    &#125;&#125;public enum Direction&#123;    North, South, East, West;&#125;
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式</title>
    <url>/2022/12/27/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[正则表达式支持的常用字符



字符
解释




任意合法字符
任意合法字符，如abc_#等


\u0061
匹配对应的Unicode字符a


\t
匹配制表符


\n
匹配换行符


\r
匹配回车符


\f
匹配换页符





public static void main(String[] args) &#123;    System.out.println(&quot;test&quot;.matches(&quot;test&quot;)); // true    System.out.println(&quot;a&quot;.matches(&quot;\u0061&quot;));  // true    System.out.println(&quot;\t&quot;.matches(&quot;\t&quot;));     // true    System.out.println(&quot;\n&quot;.matches(&quot;\n&quot;));     // true    System.out.println(&quot;\r&quot;.matches(&quot;\r&quot;));     // true    System.out.println(&quot;\f&quot;.matches(&quot;\f&quot;));     // true&#125;
正则表达式中的特殊字符



字符
解释




$
匹配字符串结尾的字符


^
匹配字符串开头的字符


()
将括号中的表达式作为一个整体匹配


[]
中括号中的表达式匹配单个字符


{}
标记前面的表达式的出现频度


*
表示前面的表达式不出现或者出现多次


+
表示前面的表达式出现一次以上


?
表示前面的表达式不出现或者出现一次


.
匹配除换行符\n之外的任意一个字符


&#92;
用于转义下一个字符，或指定16进制字符、八进制字符


&#124;
表示或运算




&ensp;&ensp;注意：在java中，无论是String.matches()、Matcher.matches()或者是Pattern.matches()中，^和$都不能部分匹配，因为它们会将整个输入字符串与正则表达式进行匹配，所以正则表达式必须匹配整个输入字符串，replaceAll()和Matcher.find()可以进行部分匹配
public static void main(String[] args) &#123;    // 将会输出3434    System.out.println(&quot;1234&quot;.replaceAll(&quot;^12&quot;, &quot;34&quot;));    // 将会输出1212    System.out.println(&quot;1234&quot;.replaceAll(&quot;34$&quot;, &quot;12&quot;));    // 将括号中的所有子表达式作为一个整体，需要完全符合括号中的条件，输出true    System.out.println(&quot;123&quot;.matches(&quot;(123)&quot;));    // 表示单个字符匹配中括号中的任意一个子表达式，输出true    System.out.println(&quot;3&quot;.matches(&quot;[123]&quot;));    // 表示前面的表达式需要出现3次，输出true    System.out.println(&quot;121212&quot;.matches(&quot;(12)&#123;3&#125;&quot;));    // 表示前面的表达式至少出现两次，输出true    System.out.println(&quot;123123123&quot;.matches(&quot;(123)&#123;2,&#125;&quot;));    // 表示前面的表达式至少出现两次，最多出现三次，输出true    System.out.println(&quot;123123123&quot;.matches(&quot;(123)&#123;2,3&#125;&quot;));    // 表示前面的表达式出现0次或者多次，输出true    System.out.println(&quot;13&quot;.matches(&quot;12*3&quot;));    System.out.println(&quot;123&quot;.matches(&quot;12*3&quot;));    System.out.println(&quot;1222223&quot;.matches(&quot;12*3&quot;));    // 表示前面的表达式出现一次或者多次，输出true    System.out.println(&quot;123&quot;.matches(&quot;12+3&quot;));    System.out.println(&quot;1222223&quot;.matches(&quot;12+3&quot;));    // 表示前面的表达式出现0次或一次，输出true    System.out.println(&quot;123&quot;.matches(&quot;12?3&quot;));    System.out.println(&quot;13&quot;.matches(&quot;12?3&quot;));    // 匹配除\n之外的任何字符，输出true    System.out.println(&quot;123456&quot;.matches(&quot;.&#123;6&#125;&quot;));    // 用于转义，输出\    System.out.println(&quot;\\&quot;);    // 表示或运算，输出true    System.out.println(&quot;123&quot;.matches(&quot;(123)|(456)&quot;));    System.out.println(&quot;456&quot;.matches(&quot;(123)|(456)&quot;));&#125;
预定义字符



字符
解释




.
可以匹配任何字符


\d
匹配数字0-9


\D
匹配除数字0-9以外的字符


\s
匹配所有空白字符，包括空格、制表符、回车符、换页符、换行符等


\S
匹配所有非空白字符


\w
匹配所有单词字符，包括0-9、26个英文字母和下划线_


\W
匹配所有非单词字符




方括号表达式



表达式
解释




表示枚举
[abc]表示匹配a、b、c其中的一个字符


表示范围
[a-z]表示匹配a-z范围内的一个字符，[\u0001-\u0006]则表示匹配这个范围内的十六进制Unicode字符，范围可以配合枚举使用，如[a-dm-p]表示匹配范围a-z或者m-p中的字符


表示求否
[&#94;abc]表示除a、b、c以外的其他字符


表示与运算
[a-z&amp;&amp;[&#94;ach]]表示a-z范围内，除a、c、h外的其他字符


表示并运算
与枚举类似，[a-d[m-p]]表示[a-dm-p]


表示或运算
[a-d&#124;m-p]表示[a-dm-p]




]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>某巨人逆向分析</title>
    <url>/2021/09/15/%E6%9F%90%E5%B7%A8%E4%BA%BA%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[
  ff1e32adbf55caa91082832c5ba17bbf7726dcb8abe111e8e95e4bc84bb182cbb1b456c99e100af325c174da70e9dda164b17c9ad45de943a6713bbc08da0fbd1d22f29654ef29e0e03468f84b5351b5081a04fb8aebf53e8e89eb0afde5dbb986599a35c32bb530b1e227630532420f36d85ce95bfc9f944de96bb54aca81dd25aedbff01cb28586f7bac0a5ec7879e180048880a0a704fdba170375d93bfa44558fd0fd0dfda726e716c5fb808f8759132afb08070cda57397adbae1cc55d2bf7873b10e39dc17b11313993c839c007979a39c6da961ba671a61801be84d18bfde81568e497b74eb3bc0f928364e8f50de8fdaafb40e4f02d13a05bce018350cf9f42d762b3c7cd42d7ad51ab45c475684d83589769adf4602e300ecda8c2cd1391299d6d650d8e917e3d7b20510d730b29a857d917a0c9f5f9052c99dfb74c3fa865ede64b86645a837ef2fd0c2c1a59d415414f8b8aea7c87354b17dfdbfb2425574882418c8159c45a5851f275f4f68fabbb4d5c263abe15b1bb5ac46420c999793f2c8c4abb2b345930ccbe106687b454897a862c5936cc96b33b0f7d36c8d61db6269e93db7fa0ca96bd22abb7d5dae17b9e3ac5aa6af1407296c20ad6c02f49e1965ee4bebd5f68e391e770a6c3444a3df5fbb46cbadc1936987b286f7903933c1331b19dc4dcd89edc7f6b609903cdab720b48552e63f58f6dd16ab0ce56b61b784b2005c3b588237b09e0209dd0177f32b9ec0a2c097bf438d2e5ea2f96cb29c97c8adab41c23c550a94f6ef80d3d918a3ceffebd1280612ecbda208aa665b4f2fa785acd13a51241330412a9ce5a5bf0781be4856da24c46f7a0e71f19a502bdc327246979728405d65e5db07fee4d2343f384b0ea9faec32826591098dae32c269c43ab267dab35a4afda73f6647ac31ec672ad4f40f6a4008d0f3a739a1c7cf43b6b999796ca920f9611544c938c90530f9695d582de7e15ef2127003552cda110c7dc5c87e8ddc09c11d7cf1faa8de30fd960c3bfa22e97cb3bbfebdb5c0019a9148bd26704a8379a3d8344d0e013d1b5853b9d601be55ea76eaaf10ca87260a67d245dcedc5c509e5c32a3728c6bfbf1be9d499767c6b280f87f1455b53d39437cfc5303e32fddf8ece31b00e3c4e33b812151a137c5674e687018ca4a3eec37218c7f91eb3ea9d17bddc28dd4dd11e3b9bd72599aea8b29dc3f07aca4f2718d96c6121a74045cd50cbf539a58ccaf3d8629e0e1864e803425ee0417e2750247b3a8a9b69a1260f97dbd0b6e74eedb6592930e1e4d3e9cd50f1b3e1fd114a904729668eb00f2f9b83b3d12df3d4d7e4df899458f48edde71ee37e1770aa8f13947c8f357937d695b417668c334f125cd295282b585cbbaf6345b35bd19096172c9b91d41aa5a0d1f12b8dbaeb9da712fe1cc71b69baa4d41d3b15dd916b93db6b1b5e871a8aece281781ade209c2274a74be00fce1332bf8fdec60f3b7b79b1da2d5c1d23341a1d04e2ab25d63d0b69487b4b5d250c79e64f0aff6174ea38c122ef810d47811aabc8437acddb4d5c1d88be6d18baea16e4e86d3b50f79d1f9f3f8ca50b07d1fcb7827314f8a43c4717fa4cdf2d940c7b6ba4ae941c76654a8f8996af0ff7c94407eac109f0375771e81242386ff1bb9afbf3800bd37f20f101df5493f3876f9254053e6ac3caa8497985b69a7372f9e1a498b2a195c49b8282a9f0851357917f7a4bc167338e2a775589dcd0eeba75f4b68cdab99ef948f8b4f89949df35199ce72ef39575f672416c595cb762c0f83a039091f3723b87165baccf5129e8d8809626bb166eae71d8cd07b44afc2c0a0d80053646c2ba5a0b5f6a150fff0cc78c297f9a6de857ac762194e7b5b8f6cd807e9d79e1f77093c4c32a3fd654b70c5d7645be2878794dfcabf6b174b58f1d0e34e4a7c0b3e59c523c7cb5c97a28007a7a44bd5388388948684c00a020d8ac3beda3167edc00f3d1bda4488f73fa87906c87c834849b6bdd0f68ae9879297080e29544803401748582f38319e5fdbdc226a22350415f24006b0eb74b1aba0294b4704161e1945044653ee5c0324b872aede3479e3004bc1cd85b4686cba1a4c83d83f036e2958ef3b8f233a846097cc066e7b39c99240329040402d7c117987600e76530c47f7c83ef1bbb5fee0aad14a563b5855a40de79c68ec6b45cab9568663777a99d0b4fe3391239e20ed97ee7cad24284b0ec189087c1f7a22899bd4b828e3cf765a5af9257dad221a19e9c1f2ee7b277e6542f8d8fbdd27de7f1a988e8c337e90e726c77fe9c10b3584895b23e9ca595c18c63161b13f06c4534b75c881dcb81dc2ce5e4fb425784f6a6eba47cfda7690cbdd72b79e5f54e3d29b15acfde221f0ab15dcb9597343f0d81ad188a3a4343a84c110a586370ccfca69251cf58834efdf525b3ede1cf6f6750b3f83ec80181cbf07162d4bf013088da43da3a38b7ff0a98187f524401141e7301da445e4f2b3c0abd1794e355ffc24cfb19c73a586dcff31deeeedf52352df3593d2a3dd73a928ec1694e641814fb4310d06064d9e5d0cdc691df357751d6e6639f2fa17235e6aac9b3217e98f286cff02e8e4a001d163d4b1d177a807c346de9752a691a07a972ed33176b0a446b4442c2afc23993c5b7e475c8db8d84f3c11ddfc010266286fe5d6af3b1dc268c67cfca6593866b5a688875d0f58988dd981caec3f0869938ef15829d318e3b20cb7e58b79567892a7b514bb025cff224919b0c27ee7fc68d2b09c58148156e94a541b1c72664db3bcc9633efa70e8d6c07ff65ae3cdab94000daf9bcd87db775d60d20de2eecffa2648be990f318d9d87222ed06ceadaef152979e133f0785f2bea65df524c33737a982283344c349b71db8cdfa39a8657be56223f9d7d19f6a628f4e38484895abdb960b5c5ff5362ee402c9448fccf7fd07d4b9dc7e711ec53fa7fe2e2533b3811551eab2aa504b426f425780ef425e0cbe284560541ec45bc56ebb5d6125f30e31a914b0f850e0a692a7da4c2754cd54aec5d504a7ed4905d29b422212383bafd1ec26c2918b9e4e609f680d81
  
    
      
      
        请输入正确密码后查看
      
    
  

]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android逆向</tag>
      </tags>
  </entry>
  <entry>
    <title>测试用例的编写</title>
    <url>/2021/12/02/%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E7%9A%84%E7%BC%96%E5%86%99/</url>
    <content><![CDATA[测试用例的编写标准标志性&ensp;&ensp;&ensp;&ensp;每个测试用例应该有一个唯一的标志符，他将成为所有和测试用例相关的文档或者表格引用和参考的基本元素
测试项&ensp;&ensp;&ensp;&ensp;详细描述出测试设计说明中所列出的被测试对象的特性

测试环境要求&ensp;&ensp;&ensp;&ensp;用来表征执行该测试用例所需要的测试环境
输入标准&ensp;&ensp;&ensp;&ensp;用来执行测试用例的输入需求，这些输入可能包含数据、文件和操作
输出标准&ensp;&ensp;&ensp;&ensp;标识按照指定的环境、条件和输入而得到的期望输出结果
测试用例之间的关联&ensp;&ensp;&ensp;&ensp;用来标识该测试用例与其它测试用例之间的依赖关系
测试用例的编写格式测试用例基本要素
  
    要素名称
    含义
  
  
    功能模块
    待测试模块名称
  
  
    功能特性
    待测试模块功能描述
  
  
    测试时间
    测试进行时间
  
  
    用例编号
    唯一标识该测试用例的值
  
  
    前提条件
    开始后续测试步骤必须要预先做的操作
  
  
    输入数据
    测试需要的数据列举
  
  
    操作步骤
    按照操作步骤的顺序，准确详细的描述
  
  
    期望结果
    按照设计规格所要求的正确结果
  
  
    优先级
    依据重要程度确定的优先级，往往分别从测试执行、技术难度和业务难度几个角度综合度量
  


测试用例模板
  
    项目/软件
    
    程序版本
    
  
  
    功能 模块
    
    编制人
    
    编制时间
    
  
  
    功能特性
    
    测试日期
    
  
  
    测试目标
    
    特殊说明
    
  
  
    用例编号
    
  
  
    测试数据
    
  
  
    操作步骤
    操作描述
    数据
    期望结果
    实际结果
    测试结论
  
  
    1
    
    
    
    
    
  
  
    2
    
    
    
    
    
  
    
    &nbsp;
    &nbsp;
    &nbsp;
    &nbsp;
    &nbsp;
    &nbsp;
  
  
    
    测试人员
    
    开发人员
    
    项目经理
    
  


技巧
让用例短小，切题
从头开始，以一条主线贯穿始终，顶部是对全局有重要意义的用例，并分离出用户用例和最终子用例
用动词短语来编写用例，这些动词表明了这些用例想要达到的目的
从触发条件开始一直继续，知道目标被实现或取消，并且系统完成与这次事务处理相关的记录的保存
用完成的主动语态语句来描述所要完成的子目标
确保每一步执行者及其意图是可见的
突出失败条件，使失败恢复动作可读，最好为每个步骤编号，人们可以清楚知道下一步要做什么
将可选的行为放在扩展部分而不是放在用例条件的主题语句中

]]></content>
      <categories>
        <category>菜鸡手记</category>
      </categories>
      <tags>
        <tag>软件测试</tag>
      </tags>
  </entry>
  <entry>
    <title>理想和痞子</title>
    <url>/2021/09/26/%E7%90%86%E6%83%B3%E5%92%8C%E7%97%9E%E5%AD%90/</url>
    <content><![CDATA[&ensp;&ensp;做完今天的笔记，又到了凌晨的0点，收起书本，点上一根烟，看了下窗外，稀稀拉拉的还在下雨。
&ensp;&ensp;玻璃窗的反光映出了脸，禁不住停留一眼，竟然有些陌生，的确已经记不得上次看自己是什么样子，可笑不管哪次，都是一个吊样——三分不像学生，七分倒像痞子。
&ensp;&ensp;并非自嘲，不止我自己这样觉得，点头之交的路人、相识多年的挚友，甚至于我的老师也看不透这是个什么成分的学生。其实我也搞不太清，时而骄傲放纵，时而虚心内敛，我想我大概是个很努力的混子，一边拼搏着未来，一边沉迷于过去。
&ensp;&ensp;照理，倒映里的吊毛早该不上学了，这个时间，他应该在工厂的流水线上着夜班，或者工地的地铺上抽烟打牌，也可能躺在员工宿舍，和旁边的哥们讨论车间里哪个妹子更好看、明天休班去哪里吃饭，绝不该是用键盘敲打笔记的同时思索着明天，至于编程一事，更像是天方夜谭。
&ensp;&ensp;那为什么还在上学？或许是想以学习为借口从拖延的时间中得到救赎吧，或许是不敢面对社会而逃避吧，或许是要让那些抛过的冷眼通通收回去吧。无论何种原因，回过头看我的前二十年，竟然没有一分钟像现在这样的认真学习过。
&ensp;&ensp;人总要为自己犯下的错买单，早期的过度放纵，便有了今日迫不得已的约束来弥补，倒也不是真的迫不得已，甚至可以浪荡一生，可是不能让爱我的人继续失望，害怕他们绝望的看着我，好像在问为什么，我不知道该作何解释，这种拼了命也无法弥补的东西，比死亡还要可怕；害怕他们落寞离开时的背影，不想让他们怀揣着希望而来，却满带着失望离去，想告诉他们我尽力了，却又不知道尽力在哪里，千言万语只剩下一句对不起，真的对不起。
&ensp;&ensp;十八岁那年，大梦方初醒，才发现白活了十八年，醒的早也不早，晚也不晚，才明白任重而道远，父母、老师、朋友，他们眼中带着希望看着我，成就感和压力也来自于此间，人生在世，总要成一件事，总要在世界上留下点什么，一世不过匆忙数十年，雁过留声，风过留痕，如果不能留下踪迹长存于世间，百年过后，再无人知你来过，岂不可悲。
&ensp;&ensp;如今发生的变故，我明白，很难回到当初的心无旁骛，因为眼睛一闭，那些烦人的话就会像蚊子一样嗡嗡响，说我哪里哪里不对、没有做到什么什么、应该怎么怎么样…现在这般，好像死过了一次，因为的确变了很多，以往的嚣张、轻狂，还记得它们的样子，却感觉不到它们的气息，或许他们以另一种形态依附在我身上——满腔热血、不死不休。
&ensp;&ensp;这种状态，大概就是巅峰状态吧，没有任何外界因素可以影响我，日子忙碌且有意义，目标每天都在接近，理想耀眼而夺目；偶尔疲惫就停下，闭上眼，回想过去那些不堪，却总会在一个问题里挣扎——我到底哪里错了？我到底哪里错了？
&ensp;&ensp;习惯了这样的自由，被关心反而觉得不自在，哪怕一丢丢关心也会像过敏一样难受，大概是不知道该怎么回应对方吧，回应这种没有任何附件条件的、单纯的关心；每次面对他们，我想说些什么，但是好像说什么都没用，因为什么都描述不了牵引着血液流速加快的心脏颤动，大概那一刻我真的做好了用生命守护他们的准备。
&ensp;&ensp;无数的誓言，无数的承诺，把世界渲染的吵闹异常，有人做不到却偏要说，有人做得到却没有机会，有人有机会却不被相信，我们好像都高估了自己，高估了自己在对方心里的地位，所以一步步的用争吵去试探，直至铁锁崩环。可笑就是这么奇怪，有人在乎你时，你总是抓着一些细节，找对方不在乎你的证据，等到不再在乎你了，又拼命去寻找那些蛛丝马迹，来证明对方还在乎你。人么，就是贱。
&ensp;&ensp;由始至终，我明白，这世间的一切，通过努力都可以争取，唯有遥远的你，是我十二分的运气。
]]></content>
      <categories>
        <category>随笔一记</category>
      </categories>
  </entry>
  <entry>
    <title>禁用笔记本键盘和触摸板</title>
    <url>/2022/02/20/%E7%A6%81%E7%94%A8%E7%AC%94%E8%AE%B0%E6%9C%AC%E9%94%AE%E7%9B%98%E5%92%8C%E8%A7%A6%E6%91%B8%E6%9D%BF/</url>
    <content><![CDATA[cmd命令禁用，disable keyboard.cmd@cd/d&quot;%~dp0&quot;&amp;(cacls &quot;%SystemDrive%\System Volume Information&quot; &gt;nul 2&gt;nul)||(start &quot;&quot; mshta vbscript:CreateObject^(&quot;Shell.Application&quot;^).ShellExecute^(&quot;%~nx0&quot;,&quot; %*&quot;,&quot;&quot;,&quot;runas&quot;,1^)^(window.close^)&amp;exit /b)sc config i8042prt start=disabledshutdown -r -t 0
cmd命令启用，enable keyboard.cmd@cd/d&quot;%~dp0&quot;&amp;(cacls &quot;%SystemDrive%\System Volume Information&quot; &gt;nul 2&gt;nul)||(start &quot;&quot; mshta vbscript:CreateObject^(&quot;Shell.Application&quot;^).ShellExecute^(&quot;%~nx0&quot;,&quot; %*&quot;,&quot;&quot;,&quot;runas&quot;,1^)^(window.close^)&amp;exit /b)sc config i8042prt start=autoshutdown -r -t 0
]]></content>
      <categories>
        <category>菜鸡手记</category>
      </categories>
      <tags>
        <tag>硬件与系统</tag>
      </tags>
  </entry>
  <entry>
    <title>程序开发常用的142个单词</title>
    <url>/2021/09/08/%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E7%9A%84142%E4%B8%AA%E5%8D%95%E8%AF%8D/</url>
    <content><![CDATA[A. 6abstract 抽象的abstract class 抽象类account 账户address 地址annotation 注解、评注array 数组
B. 6bit 位boolean 布尔值( 真假值，true或false )breakpoint 断点buttons 按钮bug 错误byte 位元组(由8 bits组成)
C. 26cache 高速缓存calendar 日历chain 链(function calls)character 字符check box 复选框class 类class library 类库classification 分类client application 客户端应用程序cleanup 清理、清除client 客户、客户端clone 克隆collection 集合comment 注释commit 提交 (for database)compiler 编译器connection 连接 (for database)connection pooling 连接池console 控制台constructor 构造函数、构造器container 容器context 环境、上下文control 控件cookie (不译)copy 拷贝create/creation 创建、生成
D. 9data 数据data source 数据源 (for database)database 数据库 (for database)debug 调试deploy 部署destroy 销毁device 设备document 文档DOM (Document Object Model)文档对象模型​
E. 9entity 实体enum (enumeration) 枚举equal 相等error log 错误日志 (for database)event 事件exception 异常exit 退出export 导出expression 表达式
F.6field 字段(java)file 文件flag 标记font 字体framework 框架function 函数
G.4game 游戏global 全局的global object 全局对象group 组、群
H.3heap 堆HTML (HyperText Markup Language) 超文本标记语言HTTP (HyperText Transfer Protocol) 超文本传输协议
I. 12icon 图标IDE (Integrated Development Environment)集成开发环境image 图象index 索引 (for database)implement 实现import 导入instance 实例interface 接口invoke 调用iterate 迭代iterator 迭代器item 项、条款、项目
K. 1key 键 (for database)​
L. 9library 库link 连接、链接list 列表、表、链表load 装载、加载local 局部的lock 锁log 日志login 登录loop 循环
M. 7member 成员memory 内存memory leak 内存泄漏menu 菜单message 消息method 方法module 模块
N. 1network 网络
O. 3object 对象operation 操作override 覆写、重载、重新定义
P. 7package 包parameter 参数、形式参数、形参parent class 父类port 端口program 程序project 项目、工程property 属性
Q. 2quality 质量queue 队列​
R. 7radio button 单选按钮record 记录 (for database)reference 引用、参考reflection 反射regular expression 正则表达式return 返回row 行 (for database)
S. 9save 保存screen 屏幕search 查找serialization/serialize 序列化software 软件source code 源码、源代码SQL (Structured Query Language) 结构化查询语言 (for database)stream 流string 字符串
T. 7table 表 (for database)
text 文本thread 线程throw 抛出、引发(常指发出一个exception)token 符号、标记、令牌（看场合）transaction 事务 (for database)type 类型
U. 4URI (Uniform Resource identifier) 统一资源标识符URL (Uniform Resource Locator) 统一资源定位器user 用户user interface 用户界面
V. 2variable 变量view 视图
W. 2Web Services web服务word 单词​
]]></content>
      <categories>
        <category>便笺</category>
      </categories>
      <tags>
        <tag>英语</tag>
      </tags>
  </entry>
  <entry>
    <title>站点分类和标签说明</title>
    <url>/2022/01/01/%E7%AB%99%E7%82%B9%E5%88%86%E7%B1%BB%E5%92%8C%E6%A0%87%E7%AD%BE%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[全部分类&ensp;&ensp;Java：Java相关笔记&ensp;&ensp;Android：Android相关笔记&ensp;&ensp;学习笔记：编程之外的其他学习笔记&ensp;&ensp;工具使用：软件工具的基础使用方式&ensp;&ensp;我的文章：一些垃圾文章&ensp;&ensp;菜鸡手记：记录了一些教程&ensp;&ensp;记事便笺：相当于备忘录
全部标签&ensp;&ensp;Android基础：Android基础知识&ensp;&ensp;Android插件：开发中所使用过的插件&ensp;&ensp;Android开发手记：开发过程中的疑难点和容易忘记的东西&ensp;&ensp;Android逆向：Android逆向开发手记&ensp;&ensp;Java基础：Java基础知识&ensp;&ensp;Java开发手记：开发过程中的疑难点和容易忘记的东西&ensp;&ensp;SQL学习：SQL数据库&ensp;&ensp;软件测试：软件测试学习&ensp;&ensp;Linux：Linux相关&ensp;&ensp;git：与git仓库相关的东西&ensp;&ensp;hexo：与hexo博客相关的东西&ensp;&ensp;站点日志：站点更新明细&ensp;&ensp;频繁查阅：频繁查看的东西&ensp;&ensp;教我爸玩电脑：给家父写的教程&ensp;&ensp;硬件与系统：电脑、手机等设备硬件与系统的调试&ensp;&ensp;软件与工具：软件和工具的操作&ensp;&ensp;英语：&ensp;&ensp;数学：&ensp;&ensp;语文：&ensp;&ensp;计算机：
]]></content>
      <categories>
        <category>便笺</category>
      </categories>
      <tags>
        <tag>站点日志</tag>
      </tags>
  </entry>
  <entry>
    <title>算法分析</title>
    <url>/2023/12/25/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[时间复杂度&ensp;&ensp;问题规模：问题规模是算法求解问题输入量的多少，是问题大小的本质表示，一般用整数n表示&ensp;&ensp;语句频度：一条语句的重复执行次数称作语句频度
&ensp;&ensp;设每条语句执行一次所需的时间均是单位时间，则一个算法的执行时间可用该算法中所有语句频度之和来度量。&ensp;&ensp;如下算法频度之和可以记为$f(n)$，$f(n)=n+1+n^2+n+n^2+1$，该算法的执行时间与$f(n)$成正比for (int i = 0; i &lt; n; i++) &#123;         // 执行频度为 n+1    for (int j = 0; j &lt; n; j++) &#123;     // 执行频度为 (n+1)*n        printf(&quot;arr = %s\n&quot;, arr[i]); // 执行频度为 n*n    &#125;&#125;printf(&quot;over\n&quot;);                     // 执行频度为 1
&ensp;&ensp;当$n \to \infty$时，$f(n)$与$n^2$同阶，或者说数量级相同，用$O$来表示这个数量级，记作$T(n) = O(f(n)) = O(n^2)$
算法的时间复杂度分析
常量阶

&ensp;&ensp;如下代码，语句频度$f(n) = 2$，算法的执行时间是一个与问题规模n无关的常数，所以算法的时间复杂度$T(n) = O(1)$，称为常量阶
if (i &lt; j) &#123;           // 执行频度为1    printf(&quot;i &lt; j\n&quot;); // 执行频度为1&#125;

线性阶

&ensp;&ensp;如下代码，语句频度$f(n) = 3+3n+3+3n$，算法的时间复杂度$T(n) = O(n)$，称为线性阶
for (int i = 0; i &lt; 3; i++) &#123;     // 执行频度为 4    for (int j = 0; j &lt; n; j++) &#123; // 执行频度为 (n+1)*3        printf(&quot;j = %d\n&quot;, j);    // 执行频度为 3n    &#125;&#125;

平方阶

&ensp;&ensp;如下代码，语句频度$f(n) = n+1+n^2+n+n^2$，算法的时间复杂度$T(n) = O(n^2)$，称为平方阶
for (int i = 0; i &lt; n; i++) &#123;     // 执行频度为 n+1    for (int j = 0; j &lt; n; j++) &#123; // 执行频度为 (n+1)*n        printf(&quot;j = %d\n&quot;, j);    // 执行频度为 n*n    &#125;&#125;

立方阶

&ensp;&ensp;如下代码，语句频度$f(n) = n+1+n^2+n+n^3+n^2+n^3$，算法的时间复杂度$T(n) = O(n^3)$，称为立方阶
for (int i = 0; i &lt; n; i++) &#123;         // 执行频度为 n+1    for (int j = 0; j &lt; n; j++) &#123;     // 执行频度为 (n+1)*n        for (int k = 0; k &lt; n; k++) &#123; // 执行频度为 (n+1)*n*n            printf(&quot;k = %d\n&quot;, k);    // 执行频度为 n^3        &#125;    &#125;&#125;

对数阶

&ensp;&ensp;对数阶的时间复杂度计算是比较麻烦的，详细说一下&ensp;&ensp;如下代码，假设在$n$足够大的前提下，
for (int i = 1; i &lt; n; i = i*2) &#123;    printf(&quot;i = %d\n&quot;, i);  // 执行频度为小于 log_2 n + 1 的整数&#125;
当循环中的printf第一次被执行时，将会输出1，然后是2 4 8 16…，第$f(n)$次执行时，$i = 2^{f(n)-1}$，由于$i \lt n$，所以$2^{f(n)-1} \lt n$，那么这一行的执行频度$f(n) \lt \log_2 n + 1$，即$f(n)$是一个小于$\log_2 n + 1$的整数，

    
        循环轮次
        第1次
        第2次
        第3次
        第4次
        第5次
        第$f(n)$次
    

    
        i的值
        1
        2
        4
        8
        16
        $2^{f(n)-1}$
    


那么当$n=8$时，$\log_2 8 + 1 = 4$，printf所在行的执行频度$f(n) \lt 4$，得到$f(n) = 3$；而当$n=9$时，$\log_2 9 + 1 \gt 4$，printf所在行的执行频度$f(n) \lt \log_2 9 + 1$，得到$f(n) = 4$&ensp;&ensp;由上可知代码中的语句频度$f(n) = \log_2 n + 2 + \log_2 n + 1$，所以时间复杂度$T(n) = O(\log_2 n)$

&ensp;&ensp;须知：
$ $
\begin{array} {c}
O(1) \lt O(\log_2 n) \lt O(n) \lt O(n\log_2n) \lt O(n^2) \lt O(n^3) \lt O(2^n) \lt O(n!)
\end{array}
$ $


空间复杂度&ensp;&ensp;空间复杂度作为算法所需储存空间的量度，它也是问题规模n的函数，记作$S(n) = O(f(n))$&ensp;&ensp;空间复杂度只需要分析算法在实现时所需要的辅助空间，若算法执行时所需要的辅助空间相对于输入数据量而言是个常数，则称这个算法为原地工作，辅助空间为$O(1)$&ensp;&ensp;如下两种数组逆序算法，第一种算法的空间复杂度为$O(1)$，因为它只借助了一个变量t，与问题规模n大小无关；for (int i = 0; i &lt; len/2; i++) &#123;    int t = arr[i];    arr[i] = arr[len - i - 1];    arr[len - i - 1] = t;&#125;
第二种算法空间复杂度为$O(n)$，因为额外借助了一个与原数组等长的辅助数组int temp[len];for (int i = 0; i &lt; len; i++) &#123;    temp[len - i - 1] = arr[i];&#125;for (int i = 0; i &lt; len; i++) &#123;    arr[i] = temp[i];&#125;
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>红光</title>
    <url>/2021/12/31/%E7%BA%A2%E5%85%89/</url>
    <content><![CDATA[&ensp;&ensp;村子坐落在一个不起眼的角落，穷乡僻壤，几乎沦为三不管地带，但是却出了奇的属于市区，于是受着市区的约束，却又没有市区的待遇。在这个夹层里，城市的价值观与农村的世界观，养成了我不可理喻的扭曲人生观。
&ensp;&ensp;村子地处平原，几乎没有地形上的起伏，所以到了夜晚，从村头向东北望去，可以清楚的看到20公里外，那一片把天都染红了的光。在那个连路灯都没有的村子，红光难免引人产生无限遐想，想我们之间可能发生的故事。
&ensp;&ensp;从没有真正的见到过城市，那会儿我多羡慕住在城里的人，那里永远有热闹的集市，街道上混合着面包的香气，学校里的铃声不像电铃般刺耳，网吧电脑里的动画蹦蹦跳跳，马路宽敞明亮，白天有人来人往，夜晚有霓虹闪烁。
&ensp;&ensp;终于，我触摸到了城市，她好像的确很好，温柔与博爱。
&ensp;&ensp;她那么伟大，牵起一无所有的我，耐心的告诉我关于她的一切，不厌其烦的向我讲述着她的过去与现在，时而抱怨时而欣喜，听着她的声音，感受着她的情绪，暗暗觉得幸运，庆幸自己可以看到她的笑容；她也打量着我的前后，说想和我携手未来，凭她的温柔，凭我的勇气，来铸就不凡。
&ensp;&ensp;她的温柔如此珍贵，却又毫不吝啬自己的拥抱，无私的一把揽我入怀，像附了魔的止疼药，像让人欲罢不能的温柔乡，仅仅一个怀抱，让我看到了奋斗的目标、努力的方向、拼命的意义；可她难以言表的温情，又促使我自私的想让时间停在这一刻，忘掉过去，忘掉未来。
&ensp;&ensp;她的美丽让人眼花缭乱，灯光连着高楼，花火映着人群，想尽收眼底却又无从入目；她看着我的不知所措，问我喜欢她哪里。哪里？她的一朵花、一根草，甚至空气中的一缕烟尘，好像都是我梦想中的样子，如此真情可让我怎么用三言两语去表述，我忘了自己是怎样回答的，只记得她很开心，恰逢月亮垂直于天际，满城的灯火，都为我而亮。
&ensp;&ensp;她好像又没有那么好，喧嚣与堕落。
&ensp;&ensp;高楼的阴影里，也有着难以发现的潦倒，隔着弥漫的烟尘，仿佛能看见垃圾堆成了山，我不愿刻意避开，更不愿眼睁睁看着她被垃圾脏了衣衫，可我顶不住那众多冷眼与不屑，一句又一句的责怪逼着我离开，字字句句虽然愚昧，却又像刺眼的阳光，使我无法直视，不能反驳半句。
&ensp;&ensp;灯光辉映下，是无休止的狂欢，不思索明天、不考虑影响，也不担心后果，或许正是看不到明天的希望，才更加肆意的狂欢今天；我站在路口，找不清方向，几欲沉溺在这贪图安逸的狂欢剧场。
&ensp;&ensp;车来车往后，带来污浊与噪音，我习惯接受着这一切，并不在意。她问我是不是会离开，我想用行动证明不会，哪知迎接我的不是共赴山海的勇气，而是前所未有的激进排斥，我忘了自己是怎样收场，只记得她很痛苦，那天乌云遮天蔽日，城市没有亮起灯光，也散了车流，我与这里格格不入。
&ensp;&ensp;或许我才是这座城市里最大的垃圾，或许我不该那么疯狂，或许我需要有更坚定的立场，或许我得改变自己融入他们，或许我不能总是意气用事。
&ensp;&ensp;再回到村子，不见了红光，却多了满天的星光闪闪，突然觉得，城市也不是那么吸引人了
]]></content>
      <categories>
        <category>随笔一记</category>
      </categories>
  </entry>
  <entry>
    <title>线程生命周期</title>
    <url>/2023/06/06/%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[线程的五种状态：新建（New）、就绪（Ready）、运行（Running）、阻塞（Blocked）、死亡（Dead）
新建状态&ensp;&ensp;当创建一个Thread对象时，线程进入新建状态。此时线程还没有开始执行，但是它的相关资源已经被分配public static void main(String[] args) &#123;    Thread thread = new Thread() &#123;        @Override        public void run() &#123;            super.run();        &#125;    &#125;;&#125;
就绪、运行状态&ensp;&ensp;调用线程的start()方法会使线程进入就绪状态。处于就绪状态的线程已经具备了执行条件，等待系统的调度器分配CPU时间片。&ensp;&ensp;当就绪状态的线程获得了CPU时间片，将开始执行run()方法中的代码，线程进入运行状态public static void main(String[] args) &#123;    Thread thread = new Thread() &#123;        @Override        public void run() &#123;            super.run();        &#125;    &#125;;    thread.start();&#125;
阻塞状态&ensp;&ensp;在抢占式策略的系统中，线程开始执行后不会一直处于运行状态，因为CPU时间片同时也要分配给其他线程，所以当运行中的线程时间片用完时，将会进入阻塞状态。在多线程编程中，操作系统的调度器会负责分配CPU时间片给各个线程。每个线程在运行一段时间后，操作系统会将CPU时间片切换给其他就绪状态的线程，以实现多个线程之间的并发执行。因此，即使线程处于运行状态，它也会被操作系统调度器抢占，从而让其他线程有机会执行。
&ensp;&ensp;此外，在发生如下情况时，线程将会进入阻塞状态

调用阻塞式IO操作：当线程执行阻塞式的输入/输出操作时，比如读取文件、网络通信等，线程会被阻塞，直到IO操作完成或超时。
调用sleep()方法：线程可以通过调用Thread.sleep(milliseconds)方法来主动暂停执行一段时间。在这段时间内，线程会进入阻塞状态。
等待获取锁：线程在并发编程中可能需要获取共享资源的锁。如果某个线程在执行过程中发现锁已经被其他线程占用，那么该线程会被阻塞，直到锁被释放。
等待条件的满足：线程在某些情况下需要等待特定的条件满足才能继续执行。通过调用wait()方法进入等待状态，并在其他线程中满足条件后通过notify()或notifyAll()方法唤醒。
加入其他线程：通过调用Thread.join()方法，一个线程可以等待另一个线程执行完毕后再继续执行。在等待期间，线程会进入阻塞状态。

&ensp;&ensp;当正在执行的线程被阻塞后，其他线程就可以获得执行的机会，阻塞解除后，线程将重新进入就绪状态
死亡状态&ensp;&ensp;以下三种情况，会导致线程死亡，死亡后的线程不可以再次通过调用start()启动，通过isAlive()方法，可以判断线程是否为死亡状态

run()或call()方法执行完成，线程正常结束
线程抛出一个未捕获的Exception或Error
调用该线程的stop()方法结束线程

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>线性表</title>
    <url>/2024/02/23/%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
    <content><![CDATA[线性表的特点：

存在唯一的一个被称作“第一个”的数据元素；
存在唯一的一个被称作“最后一个”的数据元素；
除第一个之外，结构中的每个数据元素均只有一个前驱；
除最后一个之外，结构中的每个数据元素均只有一个后继。

顺序表线性表的顺序表示是指，用一组地址连续的存储单元，依次存储线性表的数据元素，这种表示也称作线性表的顺序存储结构或顺序映像。通常称这种存储结构的线性表为顺序表
静态顺序表数据元素储存空间大小固定的顺序表，称为静态顺序表，其储存空间一旦被确定就无法修改。下面是静态顺序表的实现
定义数据元素的结构体和顺序表的结构体
#define MAX_LENGTH 100      // 顺序表数据元素最大长度// 数据元素结构体typedef struct &#123;    String name;    int age;    int height;    int weight;&#125; Student;// 顺序表结构体typedef struct &#123;    int length;                 // 有效数据元素的长度    Student data[MAX_LENGTH];   // 储存数据元素的数组&#125; List;
初始化表
void init(List *listP) &#123;    assert(listP);    listP-&gt;length = 0;&#125;
输出表中所有数据
void printList(List *listP) &#123;    assert(listP);    for (int i = 0; i &lt; listP-&gt;length; i++) &#123;        Student student = listP-&gt;data[i];        printf(&quot;name = %s, age = %d, height = %d, weight = %d\n&quot;, student.name, student.age, student.height, student.weight);    &#125;&#125;
输出单个数据
void printStudent(Student student) &#123;    printf(&quot;name = %s, age = %d, height = %d, weight = %d\n&quot;, student.name, student.age, student.height, student.weight);&#125;
判断数据表是否已满
int isFull(List *listP) &#123;    assert(listP);    return (listP-&gt;length &gt;= MAX_LENGTH);&#125;
数据的尾插法和尾删法
void deleteTail(List *listP) &#123;    assert(listP);    listP-&gt;length--;&#125;void insertTail(List *listP, Student student) &#123;    assert(listP);    if (!isFull(listP)) &#123;        listP-&gt;data[listP-&gt;length] = student;        listP-&gt;length++;    &#125;&#125;
数据的头插法和头删法
void deleteHead(List *listP) &#123;    assert(listP);    for (int i = 0; i &lt; listP-&gt;length - 1; i++) &#123;        listP-&gt;data[i] = listP-&gt;data[i + 1];    &#125;    listP-&gt;length--;&#125;void insertHead(List *listP, Student student) &#123;    assert(listP);    if (!isFull(listP)) &#123;        for (int i = listP-&gt;length - 1; i &gt;= 0; i--) &#123;            listP-&gt;data[i + 1] = listP-&gt;data[i];        &#125;        listP-&gt;data[0] = student;        listP-&gt;length++;    &#125;&#125;
将数据插入指定位置和删除指定位置的数据
void deleteByPosition(List *listP, int position) &#123;    assert(listP);    for (int i = position; i &lt; listP-&gt;length; i++) &#123;        listP-&gt;data[i] = listP-&gt;data[i + 1];    &#125;    listP-&gt;length--;&#125;void insertByPosition(List *listP, int position, Student student) &#123;    assert(listP);    if (!isFull(listP)) &#123;        for (int i = listP-&gt;length - 1; i &gt;= position; i--) &#123;            listP-&gt;data[i + 1] = listP-&gt;data[i];        &#125;        listP-&gt;data[position] = student;        listP-&gt;length++;    &#125;&#125;
获取指定位置的数据
void getData(List *listP, int position, Student *student) &#123;    assert(listP);    if (position &lt; listP-&gt;length &amp;&amp; position &gt;= 0) &#123;        (*student) = listP-&gt;data[position];    &#125;&#125;
查找某节点在表中的位置，如果不存在则返回-1
int getPosition(List *listP, Student student) &#123;    assert(listP);    for (int i = 0; i &lt; listP-&gt;length; i++) &#123;        Student temp = listP-&gt;data[i];        if (strcmp(temp.name, student.name) == 0 &amp;&amp; temp.age == student.age                &amp;&amp; temp.weight == student.weight &amp;&amp; temp.height == student.height) &#123;            return i;        &#125;    &#125;    return -1;&#125;
获取某节点的前驱节点和获取后继节点
void getPrev(List *listP, Student student, Student *prev) &#123;    assert(listP);    int position = getPosition(listP, student);    if (position &gt; 0) &#123;        getData(listP, position, prev);    &#125;&#125;void getNext(List *listP, Student student, Student *next) &#123;    assert(listP);    int position = getPosition(listP, student);    if (position &lt; listP-&gt;length) &#123;        getData(listP, position, next);    &#125;&#125;
动态顺序表数据元素储存空间大小可以修改的顺序表，称为动态顺序表，其储存空间可以动态增加。下面是动态顺序表的实现
修改上面静态顺序表结构体，使用指针代替固定长度的数组，并添加一个size参数，用于记录当前数据表中的储存空间占用的内存大小
#define INIT_LENGTH 10          // 顺序表数据初始长度typedef struct &#123;    int length;                 // 有效数据元素的长度    long int size;              // 储存空间占用的内存大小    Student *data;              // 数据元素储存地址的指针&#125; List;
初始化表
void init(List *listP) &#123;    assert(listP);    // 初始所需内存大小    listP-&gt;size = sizeof(Student) * INIT_LENGTH;    // 初始有效数据长度    listP-&gt;length = 0;    // 动态分配内存    listP-&gt;data = (Student*) malloc(listP-&gt;size);&#125;
修改判断数据表是否已满的函数，使该函数不再return任何值，但是每次添加数据时，仍需调用该函数，如果数据表的数据空间储存中的有效数据达到最大，则进行扩充
void isFull(List *listP) &#123;    assert(listP);    // 重新分配内存    if ( ( listP-&gt;length * sizeof(Student) ) &gt;= listP-&gt;size) &#123;        listP-&gt;size = listP-&gt;size + (long int)( sizeof(Student) * INIT_LENGTH );        Student *newDataPointer = ( Student* ) realloc( listP-&gt;data,  listP-&gt;size);        if (newDataPointer != NULL) &#123;            listP-&gt;data = newDataPointer;        &#125;    &#125;&#125;
添加销毁数据表函数
void destroy(List *listP) &#123;    printf(&quot;======================\n&quot;);    printf(&quot;数据空间最后大小 = %ld\n&quot;, listP-&gt;size);    free(listP-&gt;data);    listP-&gt;data = NULL;    listP-&gt;length = 0;    listP-&gt;size = 0;&#125;
函数的调用对顺序表中的函数调用
Student student1 = &#123;.name = &quot;小冲&quot;, .age = 18, .height = 180, .weight = 130&#125;;Student student2 = &#123;.name = &quot;小华&quot;, .age = 16, .height = 170, .weight = 150&#125;;Student student3 = &#123;.name = &quot;小雷&quot;, .age = 17, .height = 176, .weight = 120&#125;;Student student4 = &#123;.name = &quot;小巧&quot;, .age = 17, .height = 177, .weight = 120&#125;;Student student5 = &#123;.name = &quot;小波&quot;, .age = 17, .height = 176, .weight = 120&#125;;Student student6 = &#123;.name = &quot;小良&quot;, .age = 17, .height = 177, .weight = 120&#125;;// 声明顺序表List list;// 初始化init(&amp;list);// 尾插法插入insertTail(&amp;list, student1);insertTail(&amp;list, student2);// 头插法插入insertHead(&amp;list, student3);insertHead(&amp;list, student4);// 从指定位置插入insertByPosition(&amp;list, 0, student5);insertByPosition(&amp;list, 3, student6);// 删除指定位置数据deleteByPosition(&amp;list, 2);// 头删法deleteHead(&amp;list);// 尾删法deleteTail(&amp;list);// 获取指定数据Student getStudent;getData(&amp;list, 1, &amp;getStudent);printStudent(getStudent);// 获取指定数据的后继数据Student nextNode;getNext(&amp;list, student2, &amp;nextNode);printStudent(nextNode);// 获取指定数据的前驱数据Student prevNode;getPrev(&amp;list, student3, &amp;prevNode);printStudent(prevNode);// 输出顺序表中的数据printList(&amp;list);// 销毁顺序表destroy(&amp;list);
链表用一组任意的存储单元存储线性表的数据元素，这组存储单元可以是连续的，也可以是不连续的，这种储存单元称为节点，每个节点包括两个域，其中存储数据元素信息的域称为数据域，存储直接后继存储位置的域称为指针域，指针域中存储的信息称作指针或链，n个结点通过指针链结成一个链表，即为线性表
根据链表结点所含指针个数、指针指向和指针连接方式，可将链表分为单链表、循环链表、双向链表、二叉链表、十字链表、邻接表、邻接多重表等
单链表对首元结点、头结点、头指针三个容易混淆的概念加以说明

首元结点是指链表中存储第一个数据元素结点。
头结点是在首元结点之前附设的一个结点，其指针域指向首元结点。头结点的数据域可以不存储任何信息，也可存储与数据元素类型相同的其他附加信息。
头指针是指向链表中第一个结点的指针。若链表设有头结点，则头指针所指结点为线性表的头结点；若链表不设头结点，则头指针所指结点为该线性表的首元结点。

定义节点和节点中数据的结构体
// 节点中数据的结构体typedef struct &#123;    String name;    int age;    int height;    int weight;&#125; Student;// 节点的结构体typedef struct Node &#123;    Student student;    // 当前节点中的数据    struct Node *next;  // 指向下个节点的指针&#125; Node, *LinkList;
不使用头结点在上面的代码中，使用Node代表节点，LinkList作为链表的头结点可以直接代表单链表，头结点指针域指向首元结点，数据域不存储任何信息；如果不设头结点，在数据插入的过程中代码略有繁琐，并且不够优雅，如下
使用头结点]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>结构体与共用体</title>
    <url>/2022/12/05/%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E5%85%B1%E7%94%A8%E4%BD%93/</url>
    <content><![CDATA[结构体基本使用&ensp;&ensp;结构体其实跟java类长得有点像，使用结构体也可以声明变量struct 结构体名 &#123;    数据类型 变量名;    ...    数据类型 变量名;&#125;;// 使用结构体声明变量struct 结构体名 变量名;
&ensp;&ensp;如下代码声明了一个Person结构体，并且在main函数中使用该结构体声明了变量，用结构体声明变量与数组变量有相似之处，即声明结构体变量时如果不赋初始值，编译器会给结构体中的成员分配未初始化值（未初始化的值是不确定的），并分配内存地址，结构体变量的内存地址一旦被分配便不可更改struct Person&#123;    int age;    int height;    char* name;    char* hobby[];&#125;;int main() &#123;    // 使用结构体定义变量    struct Person person;    // hobby数组已被声明，且声明时未赋予初始值    // 所以无法再对hobby数组赋值，此处语法错误    person.hobby = &#123;1,2,3&#125;;    // 未经过初始化的结构体中的变量 age，目前属于未初始化值    printf(&quot;age = %d\n&quot;, person.age);    // 为 age 变量赋值，该变量此前未经过初始化    person.age = 22;    // 重新赋值过后的 age    printf(&quot;age = %d\n&quot;, person.age);    return 0;&#125;
&ensp;&ensp;用结构体声明变量并对结构体变量所有成员进行初始化，也和数组初始化很像；需要注意的是，结构体中的成员不能包含可变长度的数组，即结构体中的数组必须固定长度；另外注意，指针变量的未初始化值是一个未知的内存地址（也可能是一个特定的内存地址），所以即使包含指针成员的结构体变量不需要初始化，也尽量将指针初始化为NULLstruct Person&#123;    int age;    int height;    char* name;    // 结构体中的数组必须固定长度    char* hobbies[2];&#125;;int main() &#123;    // 使用结构体定义变量，并对全体成员进行初始化    struct Person person = &#123;25, 180, &quot;John&quot;, &#123;&quot;Reading&quot;, &quot;Gardening&quot;&#125;&#125;;    // 访问结构体成员并输出    printf(&quot;Age: %d\n&quot;, person.age);    printf(&quot;Height: %d\n&quot;, person.height);    printf(&quot;Name: %s\n&quot;, person.name);    printf(&quot;Hobbies: %s, %s\n&quot;, person.hobbies[0], person.hobbies[1]);    return 0;&#125;
&ensp;&ensp;用结构体声明变量并对结构体变量部分成员进行初始化，未被初始化的部分系统将会为其赋默认值，如整型将会被赋值0，指针将会被赋值NULLstruct Person&#123;    int age;    int height;    char* name;    // 结构体中的数组必须固定长度    char* hobbies[2];&#125;;int main() &#123;    // 使用结构体定义变量，并对部分成员进行初始化    struct Person person = &#123;25, 180, &quot;John&quot;&#125;;    // 访问结构体成员并输出    printf(&quot;Age: %d\n&quot;, person.age);    printf(&quot;Height: %d\n&quot;, person.height);    printf(&quot;Name: %s\n&quot;, person.name);    // 将会输出 null ，因为数组未被初始化    printf(&quot;Hobbies: %s, %s\n&quot;, person.hobbies[0], person.hobbies[1]);    return 0;&#125;
&ensp;&ensp;也可以对指定的部分成员进行初始化，初始化先后顺序不受结构体中先后顺序的影响，未被初始化的部分系统将会为其赋默认值struct Person&#123;    int age;    int height;    char* name;    // 结构体中的数组必须固定长度    char* hobbies[2];&#125;;int main() &#123;    // 使用结构体定义变量，并对指定成员进行初始化    struct Person person = &#123;.age = 25, .name = &quot;John&quot;, .hobbies = &#123;&quot;Reading&quot;, &quot;Gardening&quot;&#125;&#125;;    // 访问结构体成员并输出    printf(&quot;Age: %d\n&quot;, person.age);    // 将会输出 0 ，因为 height 未被初始化    printf(&quot;Height: %d\n&quot;, person.height);        printf(&quot;Name: %s\n&quot;, person.name);    printf(&quot;Hobbies: %s, %s\n&quot;, person.hobbies[0], person.hobbies[1]);    return 0;&#125;
&ensp;&ensp;声明结构体的同时可以用结构体声明变量，在之后的使用过程中，再对结构体变量中的成员重新赋值struct Person&#123;    int age;    int height;    char* name;    char* hobbies[2];&#125; person1, person2; // 声明结构体，同时用结构体声明变量int main() &#123;    // 给结构体变量中的成员重新赋值    person1.age = 20;    person2.age = 30;    return 0;&#125;
&ensp;&ensp;声明结构体的同时用结构体声明变量，并且对结构体变量赋初始值struct Person&#123;    int age;    int height;    char* name;    char* hobbies[2];&#125;// 声明的同时赋初始值person1 = &#123;20, 180, &quot;John&quot;, &#123;&quot;Reading&quot;, &quot;Gardening&quot;&#125;&#125;,person2 = &#123;30, 170, &quot;Jack&quot;, &#123;&quot;Reading&quot;, &quot;Gardening&quot;&#125;&#125;;int main() &#123;    printf(&quot;person1 Age: %d\n&quot;, person1.age);    printf(&quot;person1 Height: %d\n&quot;, person1.height);    printf(&quot;person1 Name: %s\n&quot;, person1.name);    printf(&quot;person1 Hobbies: %s, %s\n&quot;, person1.hobbies[0], person1.hobbies[1]);    printf(&quot;\n&quot;);    printf(&quot;person2 Age: %d\n&quot;, person2.age);    printf(&quot;person2 Height: %d\n&quot;, person2.height);    printf(&quot;person2 Name: %s\n&quot;, person2.name);    printf(&quot;person2 Hobbies: %s, %s\n&quot;, person2.hobbies[0], person2.hobbies[1]);    return 0;&#125;
&ensp;&ensp;使用typedef给结构体起别名，用以简化声明结构体变量的写法// 给结构体起别名 P，在下文中直接使用 P 定义结构体变量typedef struct Person&#123;    int age;    int height;    char* name;    char* hobbies[2];&#125; P;int main() &#123;    // 用结构体的别名定义结构体变量    P person = &#123;20, 180, &quot;John&quot;, &#123;&quot;Reading&quot;, &quot;Gardening&quot;&#125;&#125;;    printf(&quot;person Age: %d\n&quot;, person.age);    printf(&quot;person Height: %d\n&quot;, person.height);    printf(&quot;person Name: %s\n&quot;, person.name);    printf(&quot;person Hobbies: %s, %s\n&quot;, person.hobbies[0], person.hobbies[1]);    return 0;&#125;
&ensp;&ensp;没有结构体名的结构体即为匿名结构体，声明匿名结构体时如果不声明结构体变量，那后面就没机会了，因为匿名结构体没有结构体名struct &#123;    int age;    int height;    char* name;    char* hobbies[2];&#125; person;
&ensp;&ensp;当然了除非用typedef给匿名结构体起别名，感觉这种格式挺好的，使用别名代替结构体名，而且在代码中声明结构体变量时也简洁// 给匿名结构体起别名typedef struct &#123;    int age;    int height;    char* name;    char* hobbies[2];&#125; P;int main() &#123;    // 使用匿名结构体的别名声明结构体变量    P person = &#123;20, 180, &quot;John&quot;, &#123;&quot;Reading&quot;, &quot;Gardening&quot;&#125;&#125;;    printf(&quot;person Age: %d\n&quot;, person.age);    printf(&quot;person Height: %d\n&quot;, person.height);    printf(&quot;person Name: %s\n&quot;, person.name);    printf(&quot;person Hobbies: %s, %s\n&quot;, person.hobbies[0], person.hobbies[1]);    return 0;&#125;
结构体值传递&ensp;&ensp;结构体变量与数组的不同之处是，数组的传递方式是地址传递，如下int main() &#123;    int arr[] = &#123; 1,2,3,4,5 &#125;;    // 将数组传递给 test 方法    // 实际上传递的是数组的地址值    test(arr);    // 此处输出 10，因为在 test 方法中对数组第一个元素进行了修改    printf(&quot;arr[0] = %d\n&quot;, arr[0]);    return 0;&#125;void test(int arr[])&#123;    arr[0] = 10;&#125;
&ensp;&ensp;而结构体的传递方式是值传递，即仅把构造体变量的值传入，并不会影响原构造体变量中的数值int main()&#123;    Person person = &#123; .age = 18, .height = 180, .name = &quot;haha&quot;, .hobbies = &#123;&quot;reading&quot;&#125; &#125;;    // 将构造体变量传递给 test2    // 实际上是值传递，将构造体变量相同的值传入    test2(person);    // 此处输出 18，因为 test 方法中的修改并不会影响到构造体变量的值    printf(&quot;person.age = %d\n&quot;, person.age);    return 0;&#125;void test2(Person person) &#123;    person.age = 20;&#125;
结构体数组&ensp;&ensp;如下代码，声明了一个Person结构体，然后使用该结构体声明了一个Person数组struct Person &#123;    int age;    int height;    char* name;    char* hobbies[2];&#125;;int main()&#123;    struct Person people[] = &#123;            &#123;20, 180, &quot;Jack&quot;, &#123;&quot;Sports&quot;, &quot;Reading&quot;&#125;&#125;,            &#123;22, 170, &quot;John&quot;, &#123;&quot;Running&quot;&#125;&#125; &#125;;    printf(&quot;person Age: %d\n&quot;, people[0].age);    printf(&quot;person Height: %d\n&quot;, people[0].height);    printf(&quot;person Name: %s\n&quot;, people[0].name);    printf(&quot;person Hobbies: %s, %s\n&quot;, people[0].hobbies[0], people[0].hobbies[1]);    return 0;&#125;
&ensp;&ensp;也可以给结构体起别名，用别名声明结构体数组typedef struct Person &#123;    int age;    int height;    char* name;    char* hobbies[2];&#125; Person;int main() &#123;    Person people[] = &#123;            &#123;20, 180, &quot;Jack&quot;, &#123;&quot;Sports&quot;, &quot;Reading&quot;&#125;&#125;,            &#123;22, 170, &quot;John&quot;, &#123;&quot;Running&quot;&#125;&#125; &#125;;    printf(&quot;person Age: %d\n&quot;, people[0].age);    printf(&quot;person Height: %d\n&quot;, people[0].height);    printf(&quot;person Name: %s\n&quot;, people[0].name);    printf(&quot;person Hobbies: %s, %s\n&quot;, people[0].hobbies[0], people[0].hobbies[1]);    return 0;&#125;
&ensp;&ensp;声明结构体的同时声明数组，在之后的使用过程中再对结构体数组重新赋值struct Person &#123;    int age;    int height;    char* name;    char* hobbies[2];&#125; people[2];int main() &#123;    people[0].age = 20;    people[0].height = 180;    people[0].name = &quot;John&quot;;    people[0].hobbies[0] = &quot;Reading&quot;;    people[0].hobbies[1] = &quot;Sports&quot;;    printf(&quot;person Age: %d\n&quot;, people[0].age);    printf(&quot;person Height: %d\n&quot;, people[0].height);    printf(&quot;person Name: %s\n&quot;, people[0].name);    printf(&quot;person Hobbies: %s, %s\n&quot;, people[0].hobbies[0], people[0].hobbies[1]);    return 0;&#125;
&ensp;&ensp;声明结构体的同时声明数组，并且对数组进行初始化；其它的一些操作不再列举，都符合结构体变量的声明以及数组的声明struct Person &#123;    int age;    int height;    char* name;    char* hobbies[2];&#125; people[2] = &#123;        &#123;20, 180, &quot;Jack&quot;, &#123;&quot;Sports&quot;, &quot;Reading&quot;&#125;&#125;,        &#123;22, 170, &quot;John&quot;, &#123;&quot;Running&quot;&#125;&#125; &#125;;int main()&#123;    printf(&quot;person Age: %d\n&quot;, people[0].age);    printf(&quot;person Height: %d\n&quot;, people[0].height);    printf(&quot;person Name: %s\n&quot;, people[0].name);    printf(&quot;person Hobbies: %s, %s\n&quot;, people[0].hobbies[0], people[0].hobbies[1]);    return 0;&#125;
结构体指针&ensp;&ensp;使用结构体声明结构体指针变量，并取结构体变量的地址值赋值给该指针struct Person &#123;    int age;    int height;    char* name;    char* hobbies[2];&#125;;int main()&#123;    // 声明一个结构体变量并初始化    struct Person person = &#123;20, 180, &quot;Jack&quot;, &#123;&quot;Sports&quot;, &quot;Reading&quot;&#125;&#125;;    // 声明结构体变量的指针    struct Person *pointer = &amp;person;    // 通过指针修改 age 的值    (*pointer).age = 30;    // 将会输出 30，因为此前通过结构体变量的指针修改了 age 的值    printf(&quot;age = %d\n&quot;, person.age);    return 0;&#125;
&ensp;&ensp;结构体的传递方式是值传递，通过结构体指针可以实现地址传递，如下代码int main()&#123;    Person person = &#123; .age = 18, .height = 180, .name = &quot;haha&quot;, .hobbies = &#123;&quot;reading&quot;&#125; &#125;;    // 将构造体变量的地址传递给 test2    test2(&amp;person);    // 此处输出 20，因为 test 方法中修改了原结构体变量中的 age 值    printf(&quot;person.age = %d\n&quot;, person.age);    return 0;&#125;void test2(Person* pointer) &#123;    // 通过结构体变量的地址值修改原结构体变量中的age    (*pointer).age = 20;&#125;
&ensp;&ensp;使用结构体指针调用结构体变量中的成员语法比较麻烦，因此可以使用箭头操作符，如下// 调用结构体变量中的 age(*pointer).age// 等同于pointer -&gt; age
void test2(Person* pointer) &#123;    (*pointer).age = 20;&#125;// 等同于void test2(Person* pointer) &#123;    pointer -&gt; age = 20;&#125;
共用体的基本使用&ensp;&ensp;共用体内部可以和结构体一样有多个成员，但是共用体变量同一时间只能有一个赋值成员；共用体的所有成员都在同一个内存地址，所以共用体占用内存的大小就是共用体中占用内存最大的成员的内存大小// 声明了一个包含四个成员的共用体union Data&#123;    int int_data1;    int int_data2;    short short_data;    float float_data;&#125;;int main()&#123;    // 只给一个成员初始化    union Data data1 = &#123;.int_data1 = 10&#125;;    // 将输出 10    printf(&quot;data = %d\n&quot;, data1.int_data1);    // 只给一个成员初始化    union Data data2;    data2.short_data = 20;    // 将输出 20    printf(&quot;data = %d\n&quot;, data2.short_data);    // 如果对两个成员初始化，输出将会出问题    // 因为共用体的内存地址中同一时刻只能有一个成员    union Data data3 = &#123;  .int_data1 = 10,.int_data2 = 30 &#125;;    // 这里竟然他妈的输出了 30，我猜应该是第二个初始化的成员挤走了第一个初始化的成员    printf(&quot;data = %d\n&quot;, data3.int_data1);    // 给一个成员初始化    union Data data4 = &#123; .short_data = 20 &#125;;    // 给另一个成员重新赋值    data4.float_data = 55.5f;    // 输出也会发生异常，输出了 0，真他妈的捉摸不定    printf(&quot;data = %d\n&quot;, data4.short_data);    return 0;&#125;
&ensp;&ensp;共用体的变量声明方式即成员调用方式基本和结构体一致// 声明了一个包含四个成员的共用体union Data&#123;    int int_data1;    int int_data2;    short short_data;    float float_data;&#125;data2,data3 = &#123;.short_data = 10&#125;;int main()&#123;    // 声明共用体变量，并在声明之后给一个成员赋值    union Data data1;    data1.float_data = 12.3f;    // 声明共用体同时声明了该共用体变量，此时仅需对它的成员赋值    data2.int_data2 = 6;    // 声明共用体同时声明并初始化了该共用体变量，此处对它的成员重新赋值    data3.short_data = 11;    // 声明共用体指针变量    union Data *pointer = &amp;data1;    // 共用体同样支持箭头操作符    pointer -&gt; float_data = 23.4f;    return 0;&#125;
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C语言基础</tag>
      </tags>
  </entry>
  <entry>
    <title>翡翠视频逆向过程</title>
    <url>/2023/12/03/%E7%BF%A1%E7%BF%A0%E8%A7%86%E9%A2%91%E9%80%86%E5%90%91%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[
  f1582c4d8589911904d4cdc83a3052df4f3c48ddbfbd05f1587654dd0deb895dc0dffb68607e98762e4e914acfeb69d3197f79f3096440a00240d2f801831f494b930b284c6e208caf2e6f4d014c37604b776ce0ade0c57a397b21346f9c29b1ec5972c4252a34c713a77ce1c41b9e27b6722858cb66b1a4340218246240608f142e7ee28309e1bde93a68484075ab6fe5d789f42f42c3d93d78755932baa38d12f7b867cbb1d1fca8b0a4d28b15cb8bece13951bace8d38321a2b5147107e122c8ba5e74e545133f3ae5fdf4e9db7dc3699e9192ffd7e114e3559f57659219d7614a3d512ec152df5adc6d94e49c14737e2af70d0e879286998f12ba97823ceb3d63615cf65ebb629ce6586d102e306037e7276923f4215e6081f47feb0b6277722927a558f8a99df750e559e30d0f935c56da169c5a2ea8a1189e97ae08a33525e2bf47a817f2918a5691b6d4cab0cf118bf99810ea7d6fe7ac88cbe96b2545fbf9184c048f81137d1501f0de8f8a230cb233239a0f36fdea1cffcb9deec6c8f5dace7a0aa47dfce8982af23c2e73ac04d0717ba4055567cc7a2e40c0abb31259b039bcf2ebf2cd946fb54a3aacf3afc2f8f22868dbf623efd0048e413c6ceeede2cc1d9fbb1e2aeadd43caa98629097fe0029109fce53b850187431223a582338cedd2bacc5e47f480efe31f76a847c37c12ffce2e5c99347e046e629453c58b405cb73a71b6f329dc692f48755ae3b6f36ed1b4a43587d79daf8b66cb1674c51d91b2136eada833fadcd62703dfa7f084a8ad784edd0a9ce75547fa18905efeef75c095065a02c418444857ae24896bfb0fe97368c6570385e5f5cf5c9c8cd5e7fa6a550425dc54013236bcee808287edec51af055cd2e5442deecd43556597ad03de76768b4ba63243ad69e2335c28bd8562e91fa06cf4fe179aed96f53027d828b0a957e81aef3325ce821c1b0e172e4c1bcce8680f98113d5b0083ea78398945d3d185c7503347cd5981cbcaf5fcdfd0991ad7d4666aeb738580efe19f3e540b2829ed50dd16b20aa891f67fe72f3043d6bce1f99db61e46816fb43e78d4f96670c19c7782de5d436526fa4fba9bf63daa051b33d06232940baf5c84d2cbf148d6dab964dc9adc0d59450433a0665a07c3f5a8112d59a9e37fa94d80df5462e1f90fd2b06453d0956509a4653c1317d25dc314cde9fd84d06d8ed99eddfd2d34ac2510ce0e2e58d9c0c4a8f29b1506b598ed5999b708430a44f08484ba0215f9cc9125425f0981fc49de4d97aec8aeabdb461ac973b5cd42abbd017e84dea47d96b95fb7ed49731eeda5a03e1b1e41f8b016a09127f65a17455949621ca240ed5e598f80e050d13089909a2b6197242b9741ac0e50a9358b0ed3131a66cd80d33ea63488294554870a41c00099e913bfc261716c7e6a55aa47ce6345e2425362112198a38379588b7d74c4411ecbe120d1d0051ab1e51563f7a3da4984e97567f199d421b45b1d542d56ed4d459088f4682d5e429dfc818308e9eb0a256fb460866c984d24091622bd2ed032670e8e1b69a9cab21da1d21873fda5620a6e9677b1676153f9255f58f629781f0f11637c67b52dc971580ae3454e939e31757a2fbae871646fbb54a5f70940fa742a2f23c8d3cb63210b65b794eb8554aa72478c29d28ca66e79989263e92f9858627b3b2ef3d7fb22e50ecd1906b5144002fd787b95b1358ff25eb8d571c45ba7ea7ed08262687fe2e2b3a51037e8bbd134709a8591d029d361c7d627326fe027694bd83b4ce9d9810ba17a8530ca363471f317dadf0dce3a05b79a615356936793797bb6df0a34a2e4fc1caff2264bae8a117dae3aaccab2790c13d7f6a5596ec96b44599602c5a4a4e9b0ca8efd9ea5dc69f5ee658ee4b52b05b3683f693a6092536a6a5bcac0282e6d55e9faa464027d683ada0baf5dd1c20b0dda31538ad3de1d17b1107f1589c504d8f1c18ab40f595cb1faf01e010d381ac81f2f0fbb7f991a6eb66506c9ae8f535c63ac88e0704cb5834133dfc85ae90fb7cac780564428b3df8e13f4080ba9475319ec2b5623d28957853114df6b175ba5965c73cf3646767aa4912d64b9877cf0a87c4a25419d67444a1483c08fed025b2bd6e418c63de5c70f9f1f9e26265a85435584710427769702301a4db86de94dcdb4348693c6e88610cc1f3d47d9fe8630a186f6a53731b9c5a66bda328ac4cd8df29a2cb43050937e1a11f5262b4c01b8ae23253ad11b0357a398b4791362e58232ea60157bb90e76142710b7ccf285f1c39cca232e6028337c5120ee6c5b8b35d5d12c6e17d2de33f2592223259d119eb46ac483e822a97f5996e9d19695625a18802497f804859781c6953317fc95d8b9a660b18375d90ee8ab1aec03c193fecf361878452b8ea2a916d45f8c4aa0435576d9d1c2c5408af5f22f5c26dc733c65d847bcdef97da53e11e60b2fbe001f834757246bf3d4f4a29e2a30601064be41679f95551b074e903bc4e067101b4a6c1f689ae6aeab9861ba1e6e1120cb365cff7ed9bd27f52fca6f510de8c1857fe105de3fafc019ac59ab811899208bb9864acc4c3702e52eb5f08e0d9350c051b60dd22853c7100a43568c0da622512aa286d1268002879c581ade7558398434838ed706599b546109d85fe94f999b9ce54f906f87e6d7c512963d1f2f35c0d0b6133466b52406598eb526d5897f3a9bfd27cf9e82522aa7e8bd2d68ae2387ff300a23df0580672c9f4e297d313a31cb4c7144125e130c0bf4ad61e40815e8813c0a3cfd2c39b9528daf3bde2e726cac00ec35fb23c1255ac5c7181b9c27c5353e95f1f1f5cf862132a8915c508e66adca97b5236a35ff1a39c2f6d7f550fdfcf37b798a8d00567d71b09c83103ef8230341d8b701b24197a9d281ac6c01f0786c1926c8bcd66da2d66ce9b93e6e4eb7689f53de13b081f06effe3d9461f271dccf13272b817c21f9e21546d21a45c561b1d00d08954e6cf1d4097c5f6554b8935a269edac826deb33b90a5d408cecf80857a66de98b03befa1657c9f8f5baf2e2e14ec863d37e0346c127fa97cc2b319f2914540a4f184a0bfa321d30207ef988489fe4e5fa0efe6e04c7c2db9a368fc728e498d733d7c6323cc2fdbdcc2ba2becbcacf1b1c4fbb9a34ea339bd7ac9fcafdfc2dfc4fadd6f1061b31f0ca6e81e638f486fd028edfefcfd6d86cc51068479b043a534257437fac93f0d87ffd7a13ab16cd899bf25ba3342f8d63949a15d4b62a74498afd8ca43f0deafd6a4640aded444d8e012635ab733c2ef74b0f2c1c99a5c72818d2fb8f2d79d19ea44cf04bebf46069f8c25333f80fa199a4aadae83e3909091d8f37ceeb30cfff666d9ff2323a6c7725e41fed71e0334ec52a8dc6dd812cc107a19319f92eeef4d4f04456046d1bfe21c7173d7cbcd06fc96388254dacb70b68857457acee2cbce84eab86e677057235e0ba25cffe37cd8f2416b195f2196a543037d925c959dd26cf2096c898bfecc22504a0904f4e71081e1d7cc015af595b4b1fa83382caf9c1f898302fd82f1f4014a9524695d3bba21395d96feab4fe590e990b710d1f9ad477bc17f2546b838f21495334c506be5a13099f7ee98f6227ad308caaa77edfb0fd416d62fd9aca7e2eed1f788f105a3d843fd943c6845a26cafa7258eea127e00a4cd0704a818e6513d4be31870abdd9215a3256784b7596ecf880d6b3a5978a9035865a5dda3860c4809132dbceef935a1e59520fecee999410d1e9724c2aeb881abd604028aac1854b495515ccc7f8a579702760e406e7421c201aaffd643cfed651117ad4ee37170bc82b335107ac6c1e0fc0cdedb36e754029f2c8a2b9f6876aff7ff116844d35f59d3eacdffd3f631feb1dc57235f469d3c6f7e4f9d5b49ca84cccc415452fbbeddd3bf194507a3c49b80d54c46b6eb125cef5a5e82307d23ed11ff9c87ad0dd07703a722ab1cac1209cd8b5d90e18577378f69b9360243939b2f7223e192ffa3e229e7a3338293c13401f15ecb7f6ae66bf227bc84794f2fe25586292cd11dbceb87adc2957a5afa6ea18004d1dd96a0aaae1f86966f64ab0e738faff6c89c70154da2e4b65295ecf6c091fa183fd3cd1b18e3b920601bface39b4a7721c7a76188a663c7afa57dea226657cdb254e0f8e42d4536b8aaee1ee0859e337999383a8f53b27f107a33b43f6520e2fd09e203ed0f71e39a57b1bf9e7fd0d2eb788c40fcefe94c3450cef1d43618146686e90e5545a4cd43497f4bd4510d89c9e3a0083883bc11a14bd4f5b6fc81ab660ef25624f23d0998b5678a043c3b356c4ab3d2a8ca719987a4cc6aae124c4f303c1f4e553b575cc9436ecada2b1acf2ea4a8aa7ead8dc33ea84fb4dba5b7cc331ad2e40506a9d55aa255e4a05cee1426dc8e60d8e477615ca961bc807e3cc5b23dac485d5f3f3256ef0df81ef4a72079dea95cd2d7fee5af8711a4bad554389ed840ba6f740a049e3bb0f2973b76fae7bf0767016f8c33639174ece9128a6af5cf3aeac2e788e1ebe8c3a60c98a16950ea841e01294a0ee7c445aeb468c100028e8c084fa79aad79065b76110418f8eed7ac4ab84132d73653cf770c2577dee67d95fb68e42defa85f8a501a10ac4d9be41ecbbcb2e1bd68585a568d696b249257754baa8ba8db3b31e6b7bb5a244e2fbb4d36234ad089d8531a0104d677df27e4d4623ad500ad6f7f659db5f77b9db09167ea3d69b74ab8cb9fc9ae13b72b7a913152df4b027fd98a282267e20060aa8c356ed4f180eb34ea87cac034ba13277036e7fdc27d14e9bb778686d4cb29696b2de1ce91fc534af9f3bad47634651ff497b94d1fcee82617432bf8d773d0f2989738a49e15a3b4e81d1891c7adb77f98de1aeaeeee247103b6b5c4eb2ae3cdedc4514c4f21f90d8efff5fb6c7f74cc963fe7302149172714c757cac095f08121d760b68eda3c784323bd846a1280acd754f528f994fc28ab6d55149d1a411c25b8082f728b9a1f8a08927b387fcade53d645f3466a08f75a51c6781cfc4ceb0cf66885615cd57fcd060063051bf0088fe312750312419357054e0e699e9ddeacc6eb23f31ce00d8e5ba44f49058c71637399277b7b8f43a6190342341b921c0484a48c2a2033f576bf817de5d7afb843e3b963d1612cf2bddbc0fd70c43941de6ffb08b9e669c6352c60754a1923043413534f4694fde66a56eca09aa65a03b443bc6bdec88a997a473173fc9c92dcabece55cf57f48533b210360488f70ba799d09d151a17e332c55003c7f5c827ddb43edd74e59a94b8a7c772bec2b0587de8aed4d448c13a5e019b6ad26f04481f674212f4d1b0d43b30265a3c8c9fb859b01784bd2092b8a2687b347a97a078af271eaa41b0bb450a4da79e88a1d52a0cc06683579f443393d28a37f7fc70662bb7dc7ff3afa3a5514ec575b50f338fdac4a6c05cdfacf88c4b2ed62885a431365fb40ad915393d724d431f631f5c0548d68940e786d1702364300cb4db2e020ca0ef29087736c971162d339dd8117dae1059f347ac0f86f154457edc835c7d0a34333ad7cf0eeeca85007b5431c828667e7f63c493c6d5341baf5fd9ad986f5703f655e036a03af87ca6730967f5a9336905b9539b34640e155fe3a4622a8f0f6683dfd155faafa804328ff3e0acdce8ea8a204b764de2fe4e022e097dcea9e49ae3c7ead639ca2a6eac22beaeddc65a28788d0af50e5314de551ee982ba56c7b7644be57811cc22a40ab77c9f0c66462338bcbc8ee72ae543105c555f1176b61f1754eae6991a374dcfc3a9f8a24a3d33afb5d9ff9df0c431cf06d2d1ddade2a316be8c82de0231692cd3ae5915dd8eb12a5629742f2a21ffcd6cb337078df0f46de38c8075da1dbe21d74d5251e21d9e3c307dd18c055846151bc5e685067c7585353d61866f67c7e0429b2f8ef6302ed164670b4296f8936eeacdd8732766a1eae1644aa68f80f5c4e7fece1ef5488663da9bc67a74addf4b86d3d405283f2d4627b3d7daeb425c702a7580a391a7ca3bd3c28feb0bb07460aef844b5a6fe50d9427d9f4683fd80b0f933dab7a8d19ccb67c92b5819925cfb31950d8fdcdf140f8e3ff37a0ff332e95916100d1b33bb2469ef5165026b1c23132697ae07008603b0620ecd15a1e8ae29957c4532f4fc46e2a39c3a50cea8f4a63051626ccd13334a04961c0e278b431cf855a513da7e395100fa603915aa13907b3feff88bfa80083d81e2e0ba25ee4b1fe8c4f02807d9abfdbf5432b09a1929ca2b823159b8d0a9f450628692654d1e3158f9a310c1b3202d305813054d8ed2a3ffc12f1cf84efc7dafa3d4fb494f1abd6ddba96f8915b6ae6d4159083020ca8ad6e97777aef9ca3611082d385b99b4369770723beeb67524fe80d2c7332b876ab78cbd3c141502edda744ee98ab68cb39ef636a10a352f352fcd7cf291a78741d1911d0c890d7464cd2abbf50a1b1e9145e8b684d51ecedcea5d84389c39a39f7791a905f810719913a3da95aef6c4ef62f38291397577c3696f1b89a1f6e827333271efbe72462511eaba977b13ea7e48ab28ff31c06fa0149345bb7281dd0f53a1ec6222de7ec9e323e5ed68d5291773f0b271b179b5e75001606ecf8b00ddb6e7f3a54ebc3e551ef878bec38e2c6ae11e53ba0810265d225b06ff06d3537919cfc0d0b42808c8d7bcbe2c94e87de721d79ccfef0f0072b73eba4586749c2180c6756d69d33d6dbe1a0a076bfb726b1ee0eb1931deada3a05f587475b9c2dc2b6973d23760f2f994a5971ce7230e3d892508e9ba46a509bfb9781cdf409a9841649c7441c5aeaf3029eea7574e5c7528732865bf53184f7e721b3c2d9df80616d4267b59ad458416c2b62018c1c316775c9f8dc46e8d929066ddff7b619d5ee95e19fd774bac727e57b7fa2f80df520d7161348b01c84cd8339130b8939704844b00dad8adb87a77cf20436760d1a59144d176192c02345af45263e44bb2a215109fca933f3bc8772c30dbfc86c01722d2c2e01f2124f3521fd4d5f6970b460c07c2b718b018a1687260cea41d8f34b85a5685e82779db61de309c31b1f731444b9f9a529738b4f4e40c61cff2fe12abb72f5eb42ab66ffc17afba2553c474971e12785dc493d6eabb2780d41f664198ae9eeb8737a99bfc80d1eb310e4db397776c05301e3394d128cc129f82d3aa8b5003533a942386083763a2c348275307bbde666aa2eb0b85dc03e8c167b7fb70dbecddf6e391e8f8cd80e0cf4278397985dc5fa23a872acde8bb66bd231bd7d65cc9838f6b7d4b0f71f1d0774d34e292e1508fec84b68104af351fdc91b19b54aa7fcdef2d6508a70b01010436659fd2c9da47a25e784a6443b487a377694e7ec9466a056f7e6dd05aa7b91cca9a5fde44f9eb28d3f43d89efa20fea147c406d1f13848fc7fc929142f467930374eaf5739256e65e28ba4a9648be49d29e111d12c61c16b9865260c92fd6b2c4858bd688c41b6c07935ea57146d168b4ad6784c72020b83e65c627c80054c46ac8dee92f3dbf79708baf474f59f4f8f8e948f370734c927b1263bb612c792dc2746b690c203b3f10d3c066dd01a61a9a6110ade8ee83662255579e27eee3308f03f6d512733872232d24851a0c146d855514d0b2ba837ed8c6cff2f81c241af8458a97e60920509d40a6344b36e90dc0efc81dc407d39a9ccf7bf039a055047c361f174c3e9f68e7ebbdee923e3dfda5914da387d53223986e5d1d3c64319763dd84a9fd788b9c41e5ee0401d7e8e0483745ef2c5103e7a44adec36f49d79e441db8e16b458a5120fded1400be8665e03f43c700c48169d1d350a48aaf30cae42c0e798b0399e75d6819443622141f64e4b5ed71cd319f696d2dd440f81cf184cd8c94b11f54d0a672efde6f7f3916cf2385608db6e07ec2623ee260cacb1910067700d0c954bb7c356637262607d5e230e16df77dea8277b719c44dcc537f19ae520e4e4f5cebb5b22b401e6bfd545f0f4e6a5b609db36a9138f60e1b1949c38be4d0ebe93359436cc11ec91704108cf9fc29ca288525d7f71ad438e72acecf1ef31aa9e2857554a4d22b1ea7c2b33070ce0b27041dccf8fb54cfbfad3f404c47dfa41ebc1aa71af9a9afa9f53289f57543e5f0fe61dd849f2f33ea17168207e3f6fe51c54fc6d7934fe28972a51629d3af7d4e026910f4f1686f679e6efff5d3b5c670f9408b519cabeffa401224f6dd0b3eaee77a86f99785403e658c24fa1deb75c26e7b4f6e2efb570d21e49b6af7f80fef902c1a59dde079395291c7e7212217d4df28e1dc50e6bc7e9111e064997e427706117c315bcc8b5e8c047f5bac64c51a078f4576ef78f7abeea721106ad328b0cb6cad4c52f9104370650392c6281278c1b04ef150e5bad06e1f0be2c479437601a2c39a8022697290f718a2a92f1cd9fb9f94d56d247cab33412d493859ed60290e37bf4d85ef4a1fe204172f8275cf5a2aca5c34562ee95b55a953c7119cfa1d60392ea7710ee8009f718cc7cab9347399e0db23876ea79ff98c5880f4d2d287b7de0573a6f931c1decb4aeb2007a22823ff368508a9d7452f387b8e01f998355bd51e5ebd413519da8f8d27f26ca313db334482f83e6a6c9340603feb6444bd9e00cf09f9d387cab0911b60e790515db67910a370f3798b5641d71229e1511abf96e20efd57e22ae832891fecd7db6cd096f800b4d3dcb8e775f5416e7aea0467d326b122937de0a0536039950d2412160c74d5b2cd0be5604fc3c5f283f284b047b29e41b6866ebcf56bfcb912f641821eee5890d4cde9b34d385d3128d4d5e84303fbeae5e61c171ee734a40c2533f824e369834184908ac8dd6d2d4207ff852c608c4591586775edfc9d73962a380ea9301e3326891e9e4b4f16c8cc09d3304aa38c29dd99746bc1e715c75b0776b8ec2ee73ba65a5a77975b26294aac1771580f6fcca4b5d10bdfb8b9335758d4811abe6cd53b8ca02aed83884728c99623124ed209d9d4399fc5ebe018df25a15422e32f28a4c41746840a938a5f9f4ac728bc9a0a440388c7aa53353b7f277b96cd991caa1c996fed38b4941b3209321928814633919f070de5801c7bbc77df36e5a2a1bd6447f0197b0fa732cd9358a19a394e3a541db5828dc84451c794df253fac15247d7400426ed10acc9b3757e44a0ab80788ba1accad8e6a4505a2c6d6e896214cc88cc76dc3d1affee4871ae86d7bea32558b40213af9b1d03d9c4d6bfb34a8ad5ba68f79c7380a7968208050ec054183d3d1cd56679fab586a7fdfbe5c0c3f33619382595c127301affb4a5e30b26f3ca81006f4ca1cdcf48ee6449c9d75bdf9a585411c1bcd84f613b9506473912a4ffe2871689737a2eb37c5e20c730d38f1de4e94bf151658dd43961e82b95229b1615e047dd0b2f69e441161b398e63afc7b44e7c12181f40e19867d04a164ba930e83ac3591bfa45ff9ed40a20734ec6be04b04c278f32b1f5126b8abd1119480bae0527d1a5cd5184c9a755d33109d71eaa364b65288dc460c78b4cd4820dc7c8476a36393472d570015d321128a4d9bb1cb44145ae223b6b03ca3b3071ee663c93ba91f19c9200eae896ee796eec698eb3d58ca9451981ae4abcb49221f0ac645a6c2f16074b6b064274c639abee87a6cbf1b286b5a01b25dc067aecad80308681ea1da68360cdfcbe78cea65ad2e9bb4f3373008923e0aaba90123a863d1d3ac9f8c41def59e3e6c58ad16e1326b9abf0870adb7b96193531d0fa56e7f8017ceda1d7dd604a688709aa9797892368cbc13984c9d9a43ec4f4b9d810d848a2189bf3dfdab47a413c44438dd7e5473e142d4e6742a6d164b63f59a4191749fc51ed8ff95d231be14293169559634b46b80f86a691fa16906064ab1b48b362e01e98ee715e2fdc551271a23fb55d9c680b298e59c0b1ea3a9a28e156924937e0c8982b854ec553ca7a1d1e6217ec9e443bad00752572149df682a41f5edc788f1cabd7ee816570f3c0bc2743d336033e0904a568a7f9d5ed3e0a6c0eabdf82d6e2205f13d1e6b888c3217899550608db9cfe7ebd050f05941d59aff2fe9eb0c1fb1c04dd5f11a65d1eca33acafdc3786f65b4b49cd54ec3ca496d02f948f5c65a6e7b6074c371875e71f71368f4fe7975debb7f46ecb5a8b5ccfce5825844909c031019d801d5bd5790ffbcb578956ffb68fc9b0b1c1e644824ef0662fe5c5eb0de173e44950e9b0fc9f5b2075af8fc22a237772ac7ba52a2c3e634dc479cb02a51a1d9c1317791f60cedd40adde41ba91f7afe58abfbe9a2a12e82bfae65a20a1f6ed6936c5551b849d3b57a5938d54193708a04b0fc046d9afbb9f3d5b203bf79987d0d33e8194bb2302cea3387eff3427e00b1cd7274a22a4421881c12bd7e60d208712b32115a425fb9b312e50a8da393ef298012fbffbf53bd8f4f3d9a2614ea89ad812761a390f7e1cf771d62d69ce14f2ffa13aa2e5e47a9d7dcfe5981a200fd824887c10315058f81d3a36d4b0b4c00ff3ceea8fcf02d369051a96c6e232d32c03834615d4682a70333a0fbb8e8e41e3c04123921e45aeb70a02ebcdc970b34400740abd2aa0625455d4cf6acf6979c4d1198ea1b2974c225ae0d08adf170b76f6f634e3511476db3831fa7a0083d82d31a0690ff2829625ae5cb5705c3ae5124b8cfe15c52a1c3d45b4537a7eba7706f75a4c8bef99a6f267e7db878e01233ef01151e85a43a0e63fe99726b06f3f84a48e11fbcaad9ab7291cd96ac38274f19f779f677093a99f3b7c1330bf540f042d691ea2f8b0219b2072d579b507a8261dec8e7d6363793acfe3137974b1c2c711741ad924d4cfaf5e15e954e95bdbac324bfe6cd8f4f74ebb6db357d7b9171d4d1ea2dd4e56d522359ddcf6e739c43620c5a32f5cbecd47f9a441f6b8244244e526585e57dec8f21c3bdf6a957e6f8c20e82745e353c30aadfb853910626342a38ecf34da45724d91264980c40d71e7b202af355e9e6c562073fd260138b3aa75f3172fc473def73035b35c2e05eeb9e3c7542e591b03caf4df5063cf0f9688b9d435b67c06cd298de68405c898ace8102d2adc68f9c1366729faf5fdcc444f9e67a43573c6cfbb4bb348ed9e0b7894b880eb62636882a69f8a555fb140a733a6134cbc5d9f98e28931c4781dfd4736045972bdabd8b3c0c70ea79742a19964cad7b6030a5e85e5c75a432bcab98f81ceafc07bfebfe5dc0dc282ac802abbeeda1f5d132441551c05bc395ba6305be3230c492b81afe76475938b2fd44f2f4e2279d08c3f9a13b6ca8c8b30baf1f211f80e359ed3db90b10a1584f4ebe21e05e210ed30b5088e6011478e731e4d442cde09234d8cdab182b2d14be120d56f400ac1dfbe5e423cf577753bc6dbbdc9b0e2f221e79a98f44979419fa78ae8ffd18fdb35c6178fe2a58e9427f3d494f16a003e867936f3f5d7e88bb207da3276623996f5ce4612f3d30e066a6c4e97f0ea896560e8500df115687105681563acc015a33dd9497150c4fe5a5668f698dfb46d2a6c5bc11a9143dee39535ca108aa9663bf281da381981ac5af7279722f4b0400c4c00508ef600d24d3c739d9eaf441d12f870391a3ede0dd0d248e0324e47e457c4a59f1b656a8ba7649e004430667491051c4400b135b533b47458ffc3c01083c94e0d44bf125957532d2ddaf1313dd6fd5f8f9e847952e99e678a53baf30673a1d77659f4f2818a85ce55fe505afd19b4e454bc1a997e40344a13a8d82f2556638baa6f2d89ffe07ab14aa5acfb07f297d2b929550bb04657350ce617de3716b1350e8dd518ef7e2aa3f49e8029e0b83d25f3da1205131968de9770e8a4c3f0065233e75fb9de348f466610438fa048a4118d9eedf68f040730ccfb4284017ef704a55bb5b37c5504dbac0af7798666a75669e143ba31538f603d6f7cad8f4318621280eaea80f0f6458813dbf3381e3234a80809ab18996ef5b074a190ab69ff2addc95e1206b0082374035b8a88a5aa4741cc900e07438d9226ccbaea57d54047204ad1da99c4a4e4ba90fc37b448c7fa7060ad76c2c4398ff10fbad3c48a4deb5b4b05321dca88e1b45a28c3e4149a559479174858a661aa7111d3ee1c005c3a8717aa4339a7b1081f1cbf9c78cab53c4b6c408b5a4dfe223fdeb9346fa69c8ba9ebe06070dae3916b55f5d1d57a41a27a26e673f560b063336dcb6e86413e4d5a1e4b37a8fdeabc2724f8a744586a2c8223d9d850355ae8ef9d6399f05faf31675b6ad89bc6956c069b3dab6a9861de31c5c81d4395abffa1934e0259a95f1bee2e4ce165d3cb083e51d57ac544c0ab84045ae7a229b670de66529f4939104842282b2a5e908059ae79f47a85c7a9aa98ea48ba13742211ca55c6809d85ebcb8c6a4c61665fe0c198aec3bfbc18343f1a82f704a07f6ea1fcac59f5185f497b68fffa5a4fc1cde630fd807f412607cc4ca44c86daa65eefd139673ad79ba4c8638ad609af4f315b00a8798c595fb873733e0468f1704a7aa2077ebafe71c649ae65a1bc5e7b0663d95ee83fda30aa14338a47de3fca7b895b993a6a486e154d8a1fadadc1af32b65b963a5d0037d2d1fc589783ac62c6b78a0418746b50717e401dc0001e297d31c2e05b6d5d2a8f8999c057b2696db691631b4ebb71db3caf88886471d53b309c2f2d0e0ad57cf37b6660e30d39f448d2f016ce5ac75deeebdb09b1529b1e9326220914d6cd35bf5828cde1b9a459b7811b6505a7e54b71b189b572b510019e52e61023e1ab6a80dfe12eeb1e6c96a35ef37152159c037412214e3f2cb291a1154fe7162fe8525230b4974ddf204523f5175eb5cc9693b631e07e2751ff58859a661a0223992a6ab47847d82cedc01a2d0315c8b55ad195d62c2a0d3308a5e80a73378f86d3ad6eea09fb8635a2baf49cbb05845a4d29924f69293f5aebaa1b2f693591510dc438728745d22c58db0adca29a423dde5dd9645034b16a68b7b4caa011cd4bf454b786345418a37ac8ec42811758aa5245ef0278013deeab724bfb9f16f4230b065c2352435ca73d56d71ec31043d147c02d5330c5bfd0a98eb193fad7555aa5766ced8af08d9a1ecb7594cd54132992d7bd8f4ae52752df93e20113b1f02cce98b8a93d14d935476b35c1295caf9e5fa2352c12045635bc7b02417b30a4131e26842039075324526ef491a72571ccdf36fe615641ded2d5a0f7364407fba224af0731c12207a41ebf0eb17bb976a1b0b5dd98b028028b8c07af1d8d3026d76bdd2ae81e181a165896bb37ff441f33ed2bb6474e0aaf5ba93361a7d2f2ee55001bf38c10ff5bfb5003ba47d115196b42498def4240e7054ec6a72f6ca8f8ef901d0d771e6780a55ac6f537437af0a0b6a310dfb504cbe2c3d1da387ec3b5f5f081207169d2ca551352c654786baaf26b19f2d6a89db1fcc4f1bf50b532fba863c6481159dcb93bfbc38ed67bf2cf0de88b5ed2b9a8b6c03ba089a9c7872d3c6bc0d1a8b20f41b04e1ee026d7eca5595b0d6d9516e3dcdafcc37b6bea1b21fe28bacbc004be2b7100aebf45390ad545160b8a89ce1c689027ac33aea4a4ab240fd3d5c358701f5cae029b9e29d3a1e51333032f014e19fec45d5b251d6f5b57f90a5c834fa0858eba10218100e32fd94c899a84dd959e3652b940b858042445d0710313696c8e7dac3b97c6d57f4c3f043764419bae2efe454a7d1c26741dbbb4b9e23ac3db20c08ff25def04d868edebca45cba1db20d17d7547cd67be79f9c039722dbff62045ea66773004ca209f6c2fae39becec93437bc55c18249c74dff99b4060943b80c9ee96434c90d0bad7c8564dece3591dd27bbbcac4653f8f4c15f3a7687b91d38529ec8796631368c8665f96d4633c0ee8e56f428cc80b1418f44fe80eb14984e923b06e36633328dac6177bbf6a7fbef65e7074e0df257519a4b97148b5e6ae1c94da8adeca0a2215907b57bcb5e4180b8850d428e0f32a2138f8d043a6ee66dfab8bdb60efce023bbff7c4bd8d270b81f336f97e9d789c7094504d3bdcbe503babfe73d66e0b72c9d1b7913878870721a5cbb865534b94efb4658a93808fa4242cb5ca9eb99073b320fedab5fea9feac3b8bf4fcbf4817d4154eb9598c61c9921e9435b906e74047108e2878d8084ea48280c6f884be00d28979ef78ee5d644bb4cb581f665b83a7077b94bf2672a20095992368d0bd46c4ebc8893521a3619fc587bdf251bfeaed3928e94bdd721187149fdde0020e999659418887033dee64a87ddc7a57e6bb890e1cfc57cffae9c661bd68a4b92ca134d3ca2d99603f823a1232af5fc860cfc92e18a2d0a090f4a9d7c241476f9c40749ff2d067cafae7b82f2db7ce47b56a9225327ac96fdc9ed1de967f09833dfd3d6b13cb94e2047eb5b21dfd70283604b55cff0d0ae9ece944c625e644b1e36895aa161a56e899410034602572f6961d372035f9db8e4d1b20bcb67c4958a756ce1ff56f20a99a02c5f8a0c2c4bbcf7ab884c333f68d95d247b8282a11edb4519df5676ff7c68892f7ddde01c165e6233ca2d9f84db95ec47bfa4996ea129d431318fe75592182d0268529c5383d3ec8e9195e36cf03d189a981757d9cde5f5effd6cbd5e14655163df5f6d01f72af147c82815f2dd1939287a4dde787b456bc9a8799728adceb66d2c57af4ea32297852d1b85b94f4be255609f59fe84595d6b8e1955e72680ab01551e7fc8b9cab11b687ed6efa91e69b643be53e99f2c346b8244a23bebbc20b6ef55413d4eac19a329663f270011eb850baa5f102390285cfbc0e1bc53a0fa49553690235925c1343ff75a0a680f33b39987c1a3339a1288ba0276bc324e3da76dca38e05e8875cfadf50934c012a77353fb98026cb030d25b9c8eaffa63a78c6095a2939b09f00f9dfa22311bd3cbba54c68f262fc3ac70155c29c6cfa5530e0f81ef33188fe996d8d042a42ba6ffff4cb1cd8b67b5d9674841e1643375af12d0bad68813d220a5d863f0d2e442bc426f5549afb2c739661eb44169ad86e490eca44df8ea06a348b62dd662fd257005c0a309a1cbc0efa7ebe8ec31d18afad95df684e4b94c58ec4eb288946a699b87947d5f21d14ef1dd5a3aeef2a248949396a62068aa02d0c00573dc2659be23d26c728e11c379904487ab70bb2d7157178354ca5f59907362bc437688ec80e08c0a6bfdd47c04733a887e875716bd3425558d78f1dc242745bbfd89d897620fda8f2170dd23af9288edbf6e91ff4c7b178f2087a0f1ec15fd70c7e518dda032a302bdbe60d5ba0ea07a401e6c5a6962e8a8041f7a765dd19e01c2d47e3664d9dc173d55ead5be4756394cb0df83b6dcc311d748db38500125adec8f82b900f070ff7d58cbd39e5054069e88b94e9e72286d5b8d725b473fbefbe87c61f00533abfdbdf49cb39c027063dfb96159c6a0c0edf930721c32c025099bd9a8f1630aceb32b44783e3ef4ee953d1c81db1413ee1bfe815243dbe6eced97dce0f4cde53b2843e5b874e94e94f10070a686d02d3be89920f6af19a3896ed586fb1ff5af62557023f7f4d010bda62298f36a5dd94b105957ff92267a9e075eb76d381ae895ffc36ff4f790b97f8e65164eef75cf985022f01957302fe63b825c63620a65445234cdb719045f20233d3527b104235696016b6238b6dd2be36b0b810a01675a83fabdee73fb4adf363797f42a319166d408131cda234bcb8f1edeb15011ba16705be1ab8a63456ee03627be62d4c7d109d79507a9bd2c817990604e872cbe0f507095b18297d408e8a4a0db2eb83370dc83874acfb687690b29600fd9c1905d29d8976780448454ad000a3e555b504b71b11190c6fb347f4e2af827b2d5d19152af6613bf007aed7b0f6dee1ab459e37b1e00bae25f5a0933f18c1f0b82a8e8b598f51ddae2a5748538dbd5fa70f6cae074978ef95fff75d37000ace19a299e19d1393e2c10a8081c85bab1e8f7e51894ac1b7546db837b6f1542a37ad7a5e57a85a08fa6386dca24c5d908cd041e748f9fd3ca8ad47bb00c663bb631a9ecf858bff8bd2c545e59e051fc77306e16da98d450a361418651d9347b5b53fb5b86d476ff2060bbdb7c6d0609f87154f4c1651138c2e1ee7f10e56bbc2976054ed310071e3650e0262931f587f8aef67c9f284c0a519efd6cb1e459396b30723343e3944d1c9f8ee7c1ead19623b898edeafe8a4976280251bace9379d37af2d346320a8ef37201cb7a3b3b1bda66a0535f6f6693efcb77532ebb18dae52be93f684c357eff34a52946e5683c7979a1d3010c52d8fdca53ff287e7a9c788cb318e2a1c11f5d2aa33818f578bcb127768ee2587068ae64e0be3faffad37f5ff2bb41f554028b6f197d305d944cc8396474841c756f15f6f2043e6025f6dc840a476417fc38fb8a97e420a5aa0fd0c981f9123cc0aac223d08e694ece1c61287f65598c50b8a3c82bb840c768fed45e5ed5b776bcad9f6c204f3978e5df03f7a101fabacdd7b6409da962ba4bc676289d775622ca98f413b00524ec39e46069b01e114b3599af5c80134266fd02beebd16f2c5470bb37e0b1e7f3468010befb6055f2d8756b5262827375b9b7858120e8291244a5a3366f0e4c84348afa82ce91d4aa198b6a7615e21b82039228c1f9f024cdd9d903546b592959081c69c91b8ebc3db1214674aecc222cae8ac178576b1b58ca75029bf74768fedc17d187c2c534cfba068fa91a96abab57a325f319d1bb20ac5fc85541d3b081f3aa4feb5a3e8a619b8240ceb7c5024fa918d4bda465e68e0c06d75cc4a67856329c23018601b273cf6c3ef8938043b18d8a2038a8d08bad9fbda3f56c8eba3199d827d7bb7e922430314c94e3af99dc5a75c35c1479405f78ea174eecd216b841282f27321bee446350e98242516cec4351c4b3a9f76f98ea2804f10f7d38352e2f75ae42cff296930264bea1bd5fc43ea96d0be0a49e9a0340b261b46610e5d10de028318cadd9ad802824b558dd7d9458a2baf94a440f49bcff3835bc20c256600e54e11c6eef17bc36d8bab2455526efab3dc041f1e761e6c5c530508b0bfc2e59780de2ed9ae41d52277cae98022dff649eed9828fbb18b655aca3b8f9a7aa0faca3d60ea1252c9a3d44c44b53745585cc6bc3e6f238c339969cf2d562660933c4707b4230f1241adbab8306013cccdb85c69d1240171320228a8726b4a7e6e0b71f379ca8607ac73bba5eaf8d58f851dbb938607cf51a29693f82a732f13b7101e0aa9ced26e9a36354f302678e308b62e8f677e50f199c702fbf0e3d75c5ee2023efd4aa6bcfbbebad23110f0d1bf7492af36b0b3ba30786d86df79d63c789c92172b605aa6db174d46f39c09d234c2ff35b81c75d9a0508ee77c3c28ed6f89660880c0cb3e960b029f4fccea52f307bbd7611f855e5e67e6a93436d8ef04d7800b6d6da9b47eedcab2663744c795deef430b2b29afcb53d1b59ec81ed0723c92b4760ac08870540e09e9f7f9100a6e52f2ded3d9703a32d82cdd6aeeddeecd57b4f851b627c18ff0576b2188c554d3bb6067f5c75a816cebcd1e45a87772821550c5f2b186e12872e0cbc34fc18493d9d542d85d367f6e3b49c21e90e142c0c65cf411e7f55036a3dd7f71ae82d82f66205fa5f02f1784d66bbfdede999196cbf3ba8ae4d4c198d81de1ca87fd414fffa95def27622d4711cb703af6ae8750b0b964f1a1cd9d5bd862681fbab15136988af7bd9ab1483937f2a487df9a60b7c2aad4720793ef3537be40ee3cfe55eda410835bdd1017972f049e865dcf5c8877f6ef127710f6c518fc02c70e83793c8115bb3e0910d082bf6f88cbeea293d70d34cc8f22db14c37e866f1e1d6be358815edf9c3112dbd6c605f1f9b1cce067009888a9ddd8f8624ecfa2b8c7b95dbbfc6bb6c0588c99b4d113b6248cfe7b891b79ba078fbc8d16615ec628fd98218fde262c1ab94a6e8aa40cf517e07648e4dd7c9f0f087ace7b81f3dcdc2fd5ea2ab33b290e27530f6e1f5eb4600987c7a4b9cf905b1be92008f4b2ff3277f192e3ca8e5e1e471f706eb3cab56bd4ce0656b901d4ba70a2da238e24dabce5d33d35ba6e223576529526115192524504cd93aba47018b41bd9acab2a95039c8cca2a282fe10ac49257ed47c9f013f2e4089b12a2e35ae34b6bc5705d2676897b5b270e0900b165d9606b9bb589f38e70e97ca85b989689fe377832ab23a9e9c323ad285adfc2ca606da4efa67f791dffcdc38c432ec16eea4a3c1c7908b278d01d5f721aad6c2dc66494bb146fadcdf124ac02a769c3d3982c53fa3372d64fd7dc8148b3fde16b519fc4e09cdbb8c5d6bdfdd9059754a24fc45f86c9f1d07d12e612500b11d6d9c4e803916de6498bdcba57a5574ad925c9a9de18f5255833828552cbc6c2d76e32a746664cc71943ab8a136d8565a1494cbc6eb4e1244787fc93e4a1877494fd3bfc19170cad229c76321c71555fb1f0002b97f2a6f2bf18eb4cf37bd33c07c33f6342c70ca9ce9217e4e17094bc25c4240b4c75d2d4960a0aa9a997f44b15ccc07dac930b8dbf43c75b3986eda821e0bb2822adef4bc95a20da7a8b775ecf5f884e32e30e69cb5f0d971e99e5c8cfb9dd43686387fc1a1229b848246fa364188695afa43f21619c8357a747d83e75fc2eeb20a88d369c2062926a293bfd62d0f2f5dac9165322f1c9c513b71e2ceb3ff75a0842b5b907ef1e5f646d8007f0710450217774671df813909bac7001347474a599748b6ae02f1bfb6ff3cd3f6f7cce5cd9c0b73f7c8e49cce28a82f8a768557ff932da29f9d94eb1856aa80144a4a56404ecc183a4ca48b8da35fc47657cca1777bcf0f1d584f8dc2213d6c1166826c414cd6b55edd9eb7cffc31083de7242f0ae275958eb3a48db00007388fc879804b1ff737f768b0c6d6c51bf73f7d334b34fc0fc4a63d587c6d7f90cf874a6b228edd7ac0664a3b5ad260df3c9e84ac4f40a42432891e577548a6a194e330295d2733a5621e2ee3d90b78da53863fd93beaecc9bc814da124eccbeca062f320bf8954b7dfca176357add7c2a35b282ca6b6a5ee8070cc9474450ccc811c85320b543b93bc98162cdcad83c1e4fb2e537186890458e0331fe9830d7db51f637ffac22f42c7ace91389e2117edcaa3f738385e8339c0544f7e8732f9c3cda298c60557fc06caf6b7a789bc130c5a924e27e9eab683ce6e7c6c46d5239fc85e47634afc7d45ab90e0bcd39793373a70bee56d1a3fde788d6d90a3326dfcacaaa05e176be5d7b2b69dc3abb488183ecbc78ac25b55083fa639c7ee9a07d4def6829d840e4bed38cbc29d6044aff761efbab0408942a1c7a6ac8046ae18861640a27cc8e72d6d7f0878cfde575e7a0db8a62f68400efa5664c4fa84ea4fab534f12e284b4d59ff164ae02e47cb8e9c8373841cccafb92ad0f9ee14ff52f9a3083332eef0ea24cc4feed4fcbbcc02367d80a28e5df62e58fc2b5443ed7f5759159f5e2c15ea54a78b6a9c3ec5654336c7bbf007999c0179267a802019585b07407b70952ab6f63eb7b29e2dfb326f37696e3f86aedf4d3072c55eac26269a0432b445f52b30892218a5b4d909748649f2f59709da46665c1018bb77498a6f97cecf23041f9fcd84aab46270d28586e7318ac2dbba78a5e4b7f25b6c3552e7e7684efe48592152f842faad4d9ce7fc258bebf3e085a7145744e22290c2a17902fb12146b90f9b7941d0a1d83a06ae4caa8567d9da11bb6316823cf1a3c6f01fdb1ecca90e834cc64a212247dee30d3cce7161145a8394fb2971fe85a9d5f9813e0ddacc6c6337a3d553fd6b7a504a080b12523690a6aa2cfc49cde30ea2f172f473ca971e1355a7cf368a463b28de7aa94d9384419a4b1153adabe0cec3ae58d1c122609d4f134f4e5a54b573694571cdfadc1bc48c8a9c913847d0416d0e187f6b0a8fca671d742d25fd3ccc5e862862557ad050e6361d9a0633be9168e103a304acffc0d66d40a3672f4d4bb03c2d46b620cd0d9babf648def198fa01b8819be820a80bdca0ede59996f2ebc317c146e8fa50e913f9ebc0729110d7d5ccb893541fd7c10bc3e48746e1ff9ba02e530107831df664cb03a449d88d9869e6c3178207d460dc08bc2e68178ad4ad816ea911c31449593279fd7a2d38d697b7faeded5f136149a1a5672fd2ed7b58d4702cb7f2bb548208d186a073f8eb5e327b0bfdbdafc7edecba8f89845579c3974b80301f5bddf35edf4ea50dfa4187b7fdb99127e05b9316786dfe997b0ed3034355f4a68aa126028f5b85e137a8bf0624830072f1391c7f63cfaa3dc6ac54d7fb16334077c3309fe2d67a76d2243a01aa125a40b4831084893140c4a005f9c973d102db8bd5865e655d8ad654d497fde2c5f40459dcac7340047c8bce7758719181400378eddb51b4e5bffbe37109b6f14a012bf973e4a848e75d1eb890210611f32c04382fe47989fb8876fbaf3aa5c487a8e69cad108adca49749300a4aeb0084ada1bb84849796c49fc7c7e7356f6a7d5617f77a6c1cdb9646dbb508e2f57c039dca9c972206a5baee36b4dd0c311f9c5753a8bb2dd5ee2315a2442d531684a06ba04747e1e2a445a605070d656902bfe37b6939d65f379462003c147c374905f782c0096da9f1cb378f668cda7102fe7bb965b9706b7138ed479d64f825f644ab784ea4c7837ee7914e9100188d7da739f583fdbe9c0b2d2a82d0e6eb406b0a7922dcdd04fba5ce6337dbc785c8063f06090f179f735abc244989323035ce69e1a86c4bab35c3e21ea119accd94bab081fa52b55ff6719928d8edb657314c99dfa2db78f5de380d33a1ab10ddfe4c1c90203524259a9428cc68723edf41b6602835eff1976afec5c3e26fb06efd06cac46a6a5b7f033d94b58e7ca9a8ebd6f55ab8d63c305b0d3197f7ad2d8a64a51345339ccdad90dd756e33562fb80a7b4c30efad3204dc5c0521776751da13a08fae6b24184da6a19ad7af80e95b10d485fbc363c4ef9d55249e96c47049e33d9addbc756d16c2381825f3821ad39f4cc55e7a01df7ceadab7a409ac71eec95257af0fe348fbcb217a4ff024457c92d86b70edc5113a40c23176b875dcdf007a1129363029506f821359448dc4e0619c333faed926f0d7166aa7319c5b64fc458e31ca47947177d1a90245cec51fcda91625e74b5cb495df6b31aa8936106c1e097650b1909e46a7413711480344688f5e035a70cbf9b2d41e0fd5894a1be939d3d67f1d4b96276f99944cbb0127bccebd1c882492884f485fccb43df6cab803ab02c0ec3936e03cc802789ae42579b0d8bbb926fe60938113d9565fe37fe2a46ef701667180c94f445cf056ebf34827216af410a14c65c266aba8a895cabeb2000638db87a4d9fd1610624919a928b7280f5c393d22fa61812bcb2ad06b18c6c62ed3c987ef3505cd0b15db0959348fe7659e2b2c21070e2c43886e0dd19c9d350156e58e68daf2f5606e7c4c9a1ac3d14e7597089d965dca8f26bb2e75fe392c9d44af5f20a663be685ba71095febdabfd24aa6c9c4907d379a812b9aaa7666ee6717cef54cac37e39630dd23f0de6b188dd073de7c9368de3f18958b9227742697217c2fdc90497b32909d6cb0c77b116b8d99619f6a0d5c1f0f751b583b3dbd046d1281508fbf8723d51f69adbcd2d3703e61045ce3e5ae079a371f69890206ff705da75a584f8da130793f5c1ba871bbad58adfe75165988144bd8e7143ffd2ccf2c37447af5d20f2222df4099b7edc3a7f1437838613d7ab1ff7c2c9edbeaaf6a0e68788c939db0b0c2ccffa3bb30e0f4948525fe6273b4ac96debc1efe275b159930fef89bf0d259c2da35ef124018cec94084211f02b8b838fe0869c9a51d61b4dd276886e1e58dcd21f1788be1e67a36b872768786a84bd4a6c724b00a35f0ec6f800d6e638035b8ac1ccf3b82ffc2ebe4a91dac3cf6312b26986bc93aa8b00a10034baecf339c1d57cb73d61f7fe13e59afc9168120317ce1c88e2d91402ba312b1124655a4deb72627f826bff50f64b3b8ac4d61e05d198418f2646ca34c0b847eada30f814a164e066fb89ea9f63947da684a03316122d99d6df0dc1c50d4528bbab2d80a4c69ce427c7e99b1f12a8ba47fd1a79012590969f89635a9ec586d5f6035bc0d13bca32688fd7506e1327192cd449290460ca25ae5477c183f5c268fad5ad91f59c0d9c34a3b9ac4d66316016223fa7149b935d0eddb03349ae430da6233d5c97beb18982541d3bef95e8e9dd97d0c451b6aea7a51373a49a5799b12e316e482dcb8eec2c0f22a691662f2b8e8adead0eacdf80b53d944b9e6baebbae41d47180f0d2cddd2f85c28c486da70bc0bff85a1276a1c5198e86a457cda8e59f5896613859eaf62a4fe1c0efddd160f16c385bb59cec3873b837a307833faf26392d496b01dafa00f229bdcfbc0aa4a2776ee6fa48a20d0a0f93e89bcb55f7427459315f23e749c0d4013c237cfb88fcab6acdfd9b8ad37c9ae3181be97f4d5e16f22ee267fe90e0c812bb285cfb3add7aee8b6cec3d747f691f7a7017dcf0daf14a8cb906d65bbd965ec0a72d2ad0d0f848fa5c8a3a5d159417fbe91a6863231d2505015317cd038ac87d45b3a24d4637f9df2f3bac04cfc0335d74afacc3677b2eba1a37c8cd07d3ec6f8cbe3efb64fbe477129931514ce8fc73e64cf4ca98d1fdc4d09cd70de501ff329a3b94114362054f765b69140dcc8aeba503f9a4e2bc19ee70edf6d3b74f273dbb07437d714d7b874bcdb4fb25c3d3da75270e0a511646287126d08cb1963a6e319d544a5080bb24b22ae1c51897592180e2f07e042259695452fc5c39ec5e987c9b60cd78de7b5e3bc9f791506927d2feaa3e59fcba0f5b7f22ceba51a8b10460164165498743d807da1d46713551ef005231c07cf552017f814fd3362bb4e2adfd4860079d26ba8726c0ffb10e3014eb94538532116258c0f1a7a98122f5ba1d39f33ad3b8372a76fb90246bc69030b445a9c3d30b5e5d804fda4c5a47eb997c9fbc3524a3a2783eb42d52f143e8a488699c37d7a51213539d42bdd064def4ca11c92e9d60a17cbe56b439ea41db66ae7ad772b2593bcdc927c72e5930a5baf6b4b2536b69e4f1484949ae3a87443a0009bcbae34bb477aa548d0aaad25ff7aa307824782948a01d61b00e20d05e5d6962313266a628b72451c09e91bc5f5b60e19cea7391b5926710169692feffe30c03904dfc8cc41a9cd3eef1e1e202e05945d82ba13a08db4123e7b2e056a4c42d297b230ca5c68ee2fa4839b45651a6a22ab76720c2c982c438fd7154059600c73f1ed281cb2ce81545e67f42c1d14e2ab4b015632775f74b7a677e605d5424c1e5678fd1a730c2e621a241bf5ad4ff37d8c69c87c08e8cdecd5e4974c9e20900ba0a2f297a3a1ceda3efa2e3c2fce532fe0083815b03cc541476a1a54a3216118a692ec0e1ced33dda3653c7712dfce7a44d282c18c98ed4ac4f1077fb5de5074d1c642b0f47fd96b524f2102e1ca640ff81658b6c272f520d2704509db9a635cc14b4c3261baaed6e8c68e5c04323532c32bb61bb2f86300e2e1f21cca37cec9d0fbe12729acea974609c682f1fb1872d4cc0a062b73ff62b6e79d1ff5fff72a4f1eec9e376bcfef20249214d465c5e869995eba1a875ac4dd54004dd5e8234a9034b42c233d8ada8d17fe2a69ad829e3189ff2203a097d0b5d4eb6b19318d8e18f6c0d8b8fbb6f599257c05a68865fa56486ab883cd1421c7fdef15cec68b5e7027c8625bcb599499289160ec3f8fcb4e5f826cadd54e46aac8ae98a8938b92f91b8700aff6b1add03418b8d21b8e942598f98a667d8503ee0c28c88f667a4f64f5584ea9ef8a80a3e27f4d4dccf8d4a60d3a9fae86cb240d9d8da85e5db0e0848e4caa83089693f2fe7d64cabb4a5af0b27e6a9f0df046a6582bae6a6043be3b28ee427b57bd9ed262ec999db9bdb3b49d7d71b02c96306ed5717aac3a6256a2696b6f59de4b7ebc82fa8036764bc047a25723eb3b3faa7fc9e5d1c0f871249454800ba87a0139bb7fdb246ac4ea468f0c632ec87077427aa79c20fb700b1c0075430b0b1055807673bd7131824ad7847cb09a7088f1aab41c2b4108f6bcaaf1c741030e4a63439d46e2546a1d6ed25134b824f7b5ab64132a36d72d2a9afc92ae8de6e105f597f7c39987eb685df4d036069e583ad61cb86ff500a5867a2a1757dead95a72bef6dfe403a52b7a5977fa39c5b0b5ffabbf360aad2d5ed6b064e03c88f92bc0979e0bbfd623b17c65b6560e5afaab01434ba521cf8aa869e22698b0c6ed05f7724e4564a3bd9ab6dbe41cc177ff4875b020422012f3725f204a657e4b862e2b3d56ac1f00ee08d14c4411f01b02320ae01168b07dc1c2915ec83f4c6c3b60b728476d5d3e90402e6a235cd5c2cda384c197b2229037243cedbcdb03308d8eda58d06d5e88a67afee26bf106c25bdeeaedc51983ffb5e1feb81c179535f55b6e2326edb06d8cd9073b2074e50f738f904a6d438e5aba1c6a46903d63f9dcb4be1ef65bafdaca31d881f120d10577616db16fdbabf249c404572bb59d555d528bc4df1f2ec50bf969fa3394bdad23a7ab0fc80f312afc61a7f21194fcacb05337b01d920d205c83689c15de0909f1c4dff722fa566026dbdc833153a362ea2997056d8fbd09243cd806aaaf418463845d88ea94ceae0ce3dc13633d9846026ab6450c5bc835137af5bb98c00ac774ddd1a7347690dbc7a7566efc2d67f33b577c6a5533d49916655552d3d3454873f8888dc409750d3a9f6d262b37d106cf52f5ad94063e016462679fd6ca198681ff782cab23ddab10d1957299c493ca010a991a72fbc276524f9a8ac69ead904170255a9a6cc017e7b3c03c302eda09c45eca58206dee79bd16ec6740521563f292bd202774b0eecc08385ed4ec72adad115cfb37cc5c7158c5cbad010398de8039902e9d3ab996866f2891c6cf3ab0b764876401f532bced1872132d58ad761f924fc815de1e8d48c29aab209e038b8c5f710d227bab83016c1856ec6ea8f3ef5f9caf40e3da4943316291e7be2b2e03a11b401a80421ce1b21151b549b5c260557a3f731885588e07e6abe533ee3ea5a4e544f772604aaeeb2e6bde47969451d4d2fdcb1756a8ab0cfa8e785e47876ad06a3165a572611d169f933b9f91b50e8ee13e5dc9716550103646a504132e95e95b0f5a06ade7495462d50fe9dffcee6f4bb39f2a5fee2680d46585e6066e7251d4461945916c26eb44937ada61280e11588d0dc236b4dbc46f0055d3aad9255e66e843ce96d43ab518df08b8a5057c1a9727e0651af779116ee567a522c52821b2796fd82d2a4d613af0ea6f511d5800d30079197af993ea1fe2846a3b42013f79fb3194d62e5db2250b86d4e7aa6820224665b7590bc35d9bfe9df28fb51283f3e6dce6cc96494e24f572f49aa14e2b16cced42eb981afeca5c81b2a7be28fe5f4f83243e8059b25208595aba5e632ec4a50d781aaabc250f7980f1648a239879484ee12daae3a65b0fda469b1d1d9c4aca6fb355b373677f5e0486a1f7aa406d587c7fe4368817523b0b6305a92adaa78f96640834929700e4ef590c2b0fc1f336fa2a25b957cdeff2840a2f0377ca3af266522768ecdf542348fa9d525087d93eae6932fa2bd6e7e922811fbd4fb915609dbfc111b9f76e92e73c99a13154fd339721d6b69a7a7b16bd80bd9389d8ead75188ff2d35befa2781e18a0dc5e00574c130df8dbcdedbd01762cd18ecd63a6a0ec32b63a5b6e1b21dc45e3825acb858e99b45a501a45987ee569753f0d488db19ef91851480fab07dea1254fef6a476d170458cce613cc62c643aab09d91bc64777e5a2c027adf51763832aa320ff1e0c3aa86ec8887c8960faca107a49a42b2c63b1f7eb35ce3e4c6680a9b3cd5b37e39f05f0822b6de36087fca4e42dcdbd991ccf55639e16e0e3809e5585c7a24bbf62c5e3c013611865d78530dca4e5c645accb2b34463dd171a29540085b654d0ca86df321d6361d2fc93e915aa667e5076848339498741418896dd52e555f44d146624f43fa912ad638c3fbbfa5a9623631ada15b8323d696a384a8cc83e6d2136a6d4924399f6534b80ffb3c484dca0c0b4d151df29e373a8ffd35d7a64e5d80b07cd3c1b80e718057d38e24d1e2115a4451a0b245f53add01fccb89cc73d40498b902853dac62a1d0ea8f932181a9577f0fb463926b6e7c486ff33ead87e5f090352d6f85b81a836a5a8d8ed07d14d03f35f3df7f9f851ea23d8891d85f60b7353e214fd2cfd15f32cfd4cad9004e007229cab6b579b832a6277376a63b5d994e19e5769123bfca217dee7284d7833ec8c5eda42b7923529de55b85bf255b744e7f0fd8baa52583cf1f62da3e46ca7ffdf177f5dc07a56b223b5885a8f029585bee29b98c302c1605fc08cf4b080b4e42eebffac363c53da070568b8ee9f19ba5bd048476585ac8a00e50460e4881eb083f8b5d7016053560cd2e30e230495433353514c0c8cac3a4bb2311641daa03cedaa50c0d7084d223f02b5821ae686266aaf7d157d422a0ddd12764b4682984dbff1f7f3b0453622db3ce79b9f90cabf3282c307b2b4b917a3e3fe222ebbf34bb949ecc0edc34416349b2a9243fa554229d037f93539035e14184fc88cb3d52e22c034339ff9564599fa1e1457048437b92844a0c62444e3f6316a2c14b1f8447803e28b6bc2e6bbb16ee1ade8b56dcd5a9c98718fcfbcde0267321a60d443ba6fb321814964e29aa00dba8cd537e7843654331752a768b8024a496cb713a9e2cb3d6a27debf138d0a2a3fd16787a34c4c74dc3938cd66645c9d2229a456c1d28ad63a46fc2bc425378dd4aede7b4e356404def5743cc99759cce6b4305abc7df3c55ccdc49f11f9d52565f0cb768294acc34fd1fba1faf9c60585d2409f3cf81ceb3f8a9da89e687bc6222d290a02474d24ca8b3c0940f007da47e950a00aa1eef7774f98b297846b01c7647445b894d21f166fa6eebdcefc34f8424ae21d52e67086833dfa420767e3447d7a90b30c2e480e4b90527679a6698b065dd9a5c1bd6f00505f1c90a6bd01414d80aa8d5d02a1778029131a042786b4a5a9b34c5114f83dd2c0a21e7264ea8adcb6fe3aa9400cec32cb48e7bf4d5db59a587c62cea7384833a2ff2ccfb049760586c0d9b74d94d5c02d3a347ceccae192b1f5b11f1d13fabffce400f15a5144cc13575a0c4c0f9d19a38362a91ef47b2729a201d7c08d78c1c42841949cdc5fa2b12cdf835734a7588b0fd6cfe6abccc839ad62d5d0cddfec3522c2394b95c17164177c94f1dfd12d6c2d3732080ffdba7a32636da271006b17e73d23bd7b653f08659236eddd3bb1820cdba840fe413a3c33a653ee0a48750fb66cd3a9f8cfbde08fbeef48913e8cbe57e9acab3fb09167da252470d17e2fd439de392da1d28a63bd63c865ec8033968cd3e02d416557042fd97faae318b5c5660419e67869ebc2844b6e369236cd3936c38db591d2ace3828ad2e2b2461ce8623ebd71cd7cf296869a5587a9fd63936e62bb0c21644777eacbcec67d51bdd69fedd346e5ef2258e563a8357a91eac32db5b74db45e3c1f3e329a33a3bfcc7ecc0725342700a38d6212aac6ac462117c27246da037f6ff7e9f771f550ab6314619388ffde727daf7972ce84ef86fd2c1d8ae64324e449e978ac2cf1e607d2d04c575ae203f824ac5053393c9352777e70134936dd8940f2b128c582af5a253d74f4dd70a13c6785672f27a5b04e44c9c394f4101e955a9882ff405db84617d5729378d956d06bac32863268f503cfd24b3c581c50fcd130be6b9d028918efba389ea9b396fb55e4522ea0daa7937c6f25b7e0fc867a4d71cea690d5012f7ad269db24a3c82a02eac9e972c557923d155ac25d5287b4aa5fbe8ed10f80437ee749ef9a43e079e03dc218e643c2784eaf11f80bc6f013ccb6834242c22da6b94a9dd5ffa74fcdde149efd4c84d937899776469538140d2db4198f387fc80fd28a01929d0706395c801c526acff58cec090bc9304d2c9098850f30a07b3cf5dadc9d633f4bb9a8f8e7fc94a1ac85640845909e346804166dc5948fab2ba090d591b2caf02d86cf8ac7a4381818d64b373e7967b7454ddaed7d85ecef0c65d3a9419381d74588c46fb921aafac51b707c9090ff26d538d63c54dd45f1f76effa390520ce81f21851799a652b2c232b689710c82ce741210802614ef0647c9d0ddbeb571ce14eef046f76c154eaf41809d853b5dca369a44cb49d7026591ec91f84b8fb4fd2f7cfab16057b892ed46f57cc5cdd0e48849047edb1204a4d69e35a7f33eeb3a89cf66887e3b4f6c75574f9e494d9835f27d264f5c49f7cd88c8bcd04d99140c155f55ab5d46191808fb2654ed80ab7e04c11e0198e59562d4ebd1c921f17bb05616cd523a284bbde6cdba30a0103761ee755f864622e61b33eccc41b2978adc82cf98d801ceea1d5e4cdb49a9617e2140b34ad6b1e49260d3661565001718a54d65dc777d0d793ad16b44520fd73faccbb2480947b788a270c7b6e4003f23816463deaaf2df3ab17702ac72beff754e72d8ea3e3a6894a89361d0c5ffbf9bf1355ab19f3325b02d4c8b054d830ff9d157f0b9609fc3a5d9bbaad378b0aa51c8889f5e62cd21341b768f63278cae6dbfd8bef3f7799f300a3a3c4eceab9f85a1e1d3bd2d6d2fb8a4b6fb0da62579f422303d6da591ec1b431d0e08fcd7bad687f6df197b84d94ee9d8d5a587d66bfdc84ca67e3016df4fcea218d786ca4782c798e4559aeb7cc6a8cd1d8452a1b40bcc508d31bad157c2fff1efda04f6adf6617434aec36a9b0f938077fb2c9db560598f3a8e5d1a87af17b96d94d31f358ad0c64a2dab259ee5d8fe7a2cefff8cebc12bc9efc3e21f8409cd7713046a339453443881ae5989395cf01b052af783a9fcf97782fc21faef97b309e716b158c56e8337427a90f10a81b5a448a31a450bbfb229e3d36d87248a130ab424f6d6e57c452e6b7f44a7765d51e4f11cd509f2482cf9a162d2f25faaae55ec6e647a1dc844b546236ae3320b9f2b7188b089bc777863ff825948a70660cb5a488e9edb2b96dc0954263fe48280f74dc21cb12e894e9a0b0615c92ba0bbde682ec0bb2d4b2eee48d37c9bd5c96ab34aaf43d6fdff34dd959cc18b2e6c09e9af7ddb55b4c4f7e82a643428160caf0e27548735ddbd6a32a84c2d6aede112d6737dd227a61b08a8e7c3b35c756c2ea43149d32180a6085074fe6517ef883d6c03cce7c19b14160178ba39b0ed6fe7071dc069d37ec9b00fa7e8d839ceefaa445b7fd5b3de77d010e461dbb9bfde40ebff36fcf9ca2d4552b56c0cad42b34c1c0fa2f7dc9aaedbfcb00a88e65d7a022db6c9f2041a477d2363819d91546d68974961fa5cfcc69f45645fa5a8a8ccb052e0ec70780dea70eb2d64610d9de421641e4dbd3dceb79a43d7c1c5ddfe239ea385d63370a723e2608a8b47bd2df46d284b74b702446833ba371b4c963813d06fad0b243527a2b6bd476aa6d227adb6537a8ed91888290fdbb544485632775d890f4e4de11b624642468d79725f8cf1b1184a46cd19eae64803afd43dd46d912eb392311b10a2bc628f8da55150ef70b0d6668c25d983ca7267c9b37d234305209116f315441aaeac5b1e286285c7c79e0767a8bb1131f43c7994635ab0f112567bd2e8ad67d8d8f0f9e3e0d37402b9c601329135383e3cb5130a032cc52662b34fe4029c0fa303af54b6b8a8b0fd7e49cfcc570b7f072eb3b0ce11ea36ee300f35d90ea4a0b26fe971225956ccfa5b8347a2ac8136eb6c3c7e9899155d416207cbec669be4016e38531ca047a45d9107cffd33be042d4e05c7d039817c8e14c28595a4e287abbdf1fc96b8388996f9d9e16d2527b5c1f217bea459d9a55adda2be54265cf3c10ae172cab7e8564274d8e87ffdd7be04938bb56b34ba6528804d52e19e9eccf991378bdd2bc027e746afd5d4b3b311780eed32a9c5d4e518c433ab480fa362631815af51fb660c5effde30c926e68a960e197ee563fcbc5311dcb6fe5c24df45a409960f5b2437d89a53577ca4ced6fd0fbf79b9fb344988a23155a458f745d07b17b2b857ff37e99808299058ab56c7e002e22ccef73a1fe5e676646b4a3c72524f2d63cdbd85915b3696bd0bdb68b6f3e2167aa9aeed40aef010ffbbff32ea4b6f37c056ddad87213fdb23e5e80e0ab7d16da5bca96dbaed2d5670a2a25a194eed20639c031e726761376c8459af92c97f22cba0695d1b8b1b40b29d68dc62586130188123f83bf2ba300d6cf18bc2f45611bf68c4dfc9fb824390b113381b5a8edd3e7e49bd4a3dcec8850fbe125a92b68af4ff3a95b827bc7f7e83c88067ddae509dc75ffa0c6ad69da9d61ab3aa8d8d3b08129f2d9110668386a9db0b3adbd61c3b10434a7281cbc7cc28a9e2c66e92f0ff6141e871955a1020cd98f934b65e368484d8939df723312388c00e557bf81825c7990028daefc4b780ecfefc86b0594ff492b107289829935274af30db3df9e46322fccabf37ea630ab583cd95b65ef5abddece9b6f66c49a4cac3a6a07bd3f7524bfd6ad09fad6a2e11859659f0ce874a185fb5f4d47a14467e989a9bae7cd5d96a04e3d4a3b4bc9bb768c6b57bc73bf064d9a795a6d060068ec55d89102c283fc4e060063b03db764f865ed7526aaab086b68a728cd55918ced9c449d0196d69b5be29c3bcb7ed41819068e7c1472cfc148bd8705ef7fdd0204243983739b46c97b772ffee8fc3af344c375ffde12c275c1d0a96603d79abfa7df89988b28dbdc7c99a12f334a3238fb94a8aec058c0c413c1863e7bdebef9290d367527b26cf88495370c61cb923d1f74946e3464f8411d40fd70cfbf1bcc6e1c3d91146aa16e3ba2985996e5681212ff38bffcc13422e23afa625f6859252af35f286825793ce79b656a1a327c243ffdfc46d798ec985d4d1f32691524580f0aafa16400187495987fe98d27568a0a6674171418e04e8c3b7dee616cd7374c3a4cea07892146035706883d8300e955b2bf520647007263be4f9a8763ea8961175554e300a8fe7f394742cb8fe5686f9f80a1024be4906b362f408ee61e0e9a7be724992e0ccee3af2b328ef8c19b3d98542900182e24252fe380b3ec7b2586d490c47084c3a0f0449e444367812325052707d2c5978d577b852acfa4642c605e914b8fce5518ac6d8e79393e992bbe0f3789f70c3903bcfb0fc8466471e25120987e8bc89e2285b067f33b3e07df974ee93dc3e704c79a652180705cd69b6ce35cab380655c2772164110071754393bd8b0de9117ba1d867b3c8c9a0a7be63388feef582385e1c6007cec74965cc536beba78f2c58b6b95bd992f4e907ae15b565638bad33eb0ff7f8f963e65488e2e2dfb16caa5f5a9b26e0d1399ae8a077678cee1c4ea730af0228988abbb70ff55f17820bf6bb174813ae2078451d0827f42debd9214e3baec12147ee2dad1180c915285ddcc5a97e3f70dfa10b3b46b5f0c0a5cfb54ad164f85096894fe60d7fa68005c4be0dc0b123a832f5058cd037595724167972d1d5419a27f257ccd29f7758d85a2370edc36e2a3b11733a66dcf58949d43873d07169af1445bae5e93dd27cbee255f725f353ac990cef18a22d3a01a1044bc5967d72a7422cd4da3ea16fd33fd86e213375e80b4c5f07b6f0ff09e1b5d8fdc20bfe23a6126ae3d4756ab4c24bcc544876f336cdb794c5c8fe01759c2956896457f0f14593d3756086420943414b247a6a7eadf08689a717991d4a264f90685be07a9c8207aa6f03c4a95ac1515dee20b1de521f0862d1eaf411d104b39cc498f64c4e95dbd99c99882d15f76e84c81bfab30074e3fa8a94b97f86ad3aaa9a7f3ead1d8d1b470ae24bf98bd00e7a95aee258be6fb23d0cb9e3ee8ee2a6c28829abef2720e330ded214a02c6b2a025b7ca75fabbb79f5fc7f994911ae0d218b147675f00ea43222bfeaf54d016ce2636516059a4d6434b3284b0ef731e765f5ffab30aa929832c1624ff3c4483ec882f7d42eb3b520901fddc9a95897d443d327647fcfb8c18ea16062b519ba02ebc75cf4f9c59f2106293522591b65c7ae5f37d26f6863ef57a1b337eded8867503e86ef30fdb640fbad75d694913869b35220b84b66715172e115e61ed09b98a59336e0c492dff4f7917c3446986ba9cb4f206fb75861b8d0d75bae08a19605d0fb3d569835436050d1f8a91f47f569c15eb3ae86d1dd52d4c4914dec13d1ae83716edee152c8322792b9bab14d66a14ee2cbb468d766c83095a6b4feac41da31595db0b20a0067c9e475ccfc29e12b5ac3f495b2b478dd20a086a30ec8f65a23af92bc71478281c09dd1add3fce7ce035a2b0c689f925e7239dbec73b4358a076dad66be6c1c0e9a2822abe308678e7a68b208f09b30633bde40648141b94937bd5b47510a429bbfdfb74decf94e1e28637e6e73346bc7d54133f078f93c7967d1e5e5dc82018b0a5b064b59dbf64319f4007738934c2077367f945311ca9844abd73fc2958a951b0914187719520423a0b83ea658b4aa4c7517ff7b9c7f60eca510465b5e5bd4abf8c1f8030d73d9660d160b13ad92ba99a62d714fc2576ac1733da1a646da4eb3f51ec08e3171c29ba0a76122afb83f2bb54841a2436949a01977cdcdadd80905fcd904f77d8a807c512a4a3155a252ff8a87b7dbdd08cd350a2dc680c128abcd5cd502fd9c0b33867c6286a02b83a82afb6f23125a343d136fab2d9cd1441a5cebc8321bec38fedd1f5d9aa2ab6d43723d528f43266b5f40a059b8e3e779a790571b4e0c0bd7b01892e366d085ec2986ddb792f06f26ff05b6082ce2ae308b72eec1c16e617bdda66a19026ae7eaaf1e9ad9f327f502b1d1eb465732e73b600449d4f55d08b22ae49cdba64d58d38c3c7c4e11ac6b26705ad94f108b5e9d64e50b9eebb1a1d90773bdcf0633496692c346fb80381a8b4f2c040a099f78c4ffcc617d10899b39bad0a2955b5da1cd2b405495c8ab083d36c71c1025dd547c9c5c13ddfbc4cf8a17e0e1b3304f5ce8f0fcf078a394427754344a8dc3f9506f7f63ba38488360eaab1a53a85e57389aaaa064f5b089dceae11a452637c8b5014839f0639a08b17fc25563c0534c09daf9ebda4cdb3833100e0ea8f4c480c2a3d73da1ca33b6aabf2af50305d0e61b55aad43fa8cff07c1db7f58d6123d0dbe5351357e91af2a80ca3a82bc9c0c65aa0ae25d74b2e503d7c82be838e0dc96a4d1a3764a2a9c8e72a76f8b734abbbf2ec8cda3a029b6dbba6f27ed36e785e9db6e60188facc32655ea78c7982002d5a62a691f318490f38d41f3ab86e3cc5793e330f385cac07a3e778cfcc0b5f4428e6a47dc59ac9349a3d8fbc5367cfc624ee1e2a53c34068ed871030304520347d6c883c1e9183f30dcd3eb75c2fec31442cecfbe45a322c2895257abf913429d72e5a05afc84bcc94286a3bbe74c433fafb1940460d558ed9f33e6481dabde5cc206a8ac761e2c1344379238f76fde4aa808f61d763e15fce5e36e1514a5497b08f208e2e05cf3464a8bca2f61a054a99bf0e7d88e1aedecdec62dfcc90a2aa2e43ed716a54c001f9da5f91b555182e3611b172eaefa85c63b9164192d7a5235890f7ce7d8d5f9be29de8fd3d05e52ca2eaad363fcf487135df8e3c69d6e6f29dea6a2df745d17ac754d37ae4d5d4e2516b3fd0577d48a88d8050795751fa1134d9f6332cbcb9e23fef981582d3b9d1215aa7ce3e8a58695388466ca61ae9074d2189559c7e04145f4666121ccabf887fa2ecf71705add08733c17225df77565af38b9c70e326649a8a0b001e6e50ee64143248472566bb44621495b00cd1b7aba77b634ee7b22ad8b71bbca1b0da6f84c3665d4e2bc70b733de0ae3d51148d4ab0959aa59e40d694ca3a7bc236d70ed329c08536cfeb9fd522a456d269d0fc5540e07758ecf0cb4831845cb32eaf60dcedc75ebc921c695d6f7b116b0f3971dec2db8bb913fcefca4c527f51a704b95d0ef773bf39e4dee955e4fb52611676b8626a29f2d72fd10e42c3256f196c4105dbd1c3d956d0df45862229b7eb76a2b47d1c952ea710184fe6f592a042bd23a02a020f41ce7809cd961ed16aa63834d1d5d1d724c1cef2f86b94d0df369e58d9ad702fffdd677d65eb02afd63f7b47fee5a0a01500da9d2e44ef94dafb2bda58505ba92ae9479ebbf972fc30a1907a0a9e7cc8a51356d0b5c413fed4734d1e9efeba00bc64edb68ef01117a8d0e9fa725b6f11fb3f4d86b2cc01983943dddf9f3810c7bda5230b828fdf0a69540682efe4ab703b7829b252e11d538008961f45257cd589eef8a42353003adad863ea25206d4e20a316152be69cec1654e2bee55f1376d7aa5c3e89483145ce822b7eae45ebf27336e632759851c89de098ceffafda53b854a959ebc0d34a5f30c94b232ca5f5db11a1f899566f732adf600335e4c0a8fbdfc5edab88be74192fb8599be9f3c9ae2db26ef23e96b1521af7980d684f2d2ee680c3b2d412de1d7b9bbb4603f444b0a97b5d62856ceb2f2190c4782042f56c78fc124f30e14e446fa1a00eb65bc75e5bbf9a3cd0754411ba2e7673e17b09a4bdb22dcdcc083a9b1bd4e93471288567d2bd22eec8d8ee67115bfbb92d4a512eff6c8a1294b8283a46cfc3c2cfafa5b774827defaf3bfb9cd32354849ce0e954a30a624d6a60dad23b6ab09732bc856abef3e7afba409d70a6279a887478c05e6b73e9ba88625610f0b6bccefe828d3f20a00e31119b42afaf59c911eee011105ebd98ac5d6a84f0ddd2711702999a00417fde2e085b7f54e87a10f81c4a9db86b66558b3b8417f4e24843de46b52df39021a9a7ab35cb2f716afc031c2a881dc9e95e886e71403fba09f1e91738b4767e97a88991c2112a6619dfc71970a72ed13c97f7adad49f1fce4d450508facb634c0110b65fe571236a6c5908f162a4952eeb32635ed730200af2c02c6699f0a47caa7591c3e0b63970428bce5b7cdecb34ae3f96af0844c367b80c3b97553fdbad8a7c7a46d46488e8c070e7ce0f55fb264f9a1fe2be64dfd041de824f79be2776be6203d037bbf3733374bd2d095d319d6929c08a4ddb6a69fa4e6c4b6dd4803634457fc6c2557aa2953e278a6978b351eb018397b5894c0611ae99d957568f7dc99fa1b3e8db3b6f3882edf62a49e65ea2274dfb1513e853a45d877665d1d11b9a39d23f1ef66a4f0011d39f51cf3e5ece1db3c36896dae2b9757d831f4e28794d1d817524d110f850a0787e8eb16b29682a34ae5794487de81e19f77d0c2ff43aed6d6f01f91e1d76d94f57ceae6bff3dbca9a11adbc5184b14d28a7a146f21f167b72d6049fcaff26d201d5f910eb7261d107911745d2db37152436f57afa9a43ff85b3426b52429ece448a512e8c7040ac057ecfc4587ca617478b20c6f5ad9cd6474c23fca2887336901d321a5206a841fef76e688b918812b4a580a72a6fe185ffd3ce82516387123f678b2d2fc1872a01d801f660b3075bda4e6b6105c3c4c9cbe58f2cf59f56c1444cd8f152c9fa233be44a5f4165f3b13b891d7de3a3aececa363409bf1b96bd345aa96962fc673ded6d7d064d3b7486f865a5a7071de2f7026a70f392e0856b3ce50d0ed0b0b58c7b64ab524f44a883b0868ef1a7d988814f3537e4a85d23c71c463f4d2dcc69fc3382fcfc0ee0b3ab67c947fabdeb1b0f8d8065a39b4287e317ffa5c24c3f730b28fa41d71e2b45cd6a5cad38077edee877a4ea3dcd79cb982cf143d735974baef540aee2505300bc2f75a7c7dd3f9d1fda6193f7591cb9e34899763687474027b1c6ab747da0e5690130b601a6548c1fa5dbff06e1cb5c546c78aab5bb0208c18b65e96ac79f1603a7c5724736337e867526dfb43c9623d54d5bfe92e28875e96f918248ab70459aef3da629411b73ecad7b411ed61518fa388c7b8c65b1195062c492115b473560c885deb6aca2f8562ce15449ba80bb6e7492f553b43b6d925406a93fdb205e2f51810c383cafec77de6ace9a1ae3d6d9a954779f3b0f7fddc2bf24b64dd1857252d20e6f2a4bfbf6679142d5b4f5c300f028487ea2b260100e3d11ef8c113be9bde451c05597649db348224284a7346d426aeea1094d13d4af4ef0681ede91c7db54acea7d177db874d56d82aa72bb9bcdc4b759c11b87e07b983de1a1988efdb64f72fcc5ba52fddcf9efb935c6bf297403ab5b8a2a54fb7c51c12225da64f70c7b47f6364c15c24ade15929ee6032cf8a87c823aa378f1d97c1d15616a0613383ed843b31bc3bfd6768ea6d7178b183735cb1eb2d94c347174bc8dae523a18b5dffdbac1fb24b8495b7ed51e04fbf0f3735a597a37154da548dd10f81dc1c57f6993f5c05ff475db55e52401b2988f7d34be91bd7fa363d70321675a985d066297dd010cb17fac56df67b6190d62614490f103552c41a1c51b6ae8e8e0ffcb3f6675407ab7560474bd4c4f37d2d9aedaa96a3354a16bd5c667bfd187f1584f7a98860449c74a7fc8b859b831fa1e01725da76881b18a155c998c4b0a41fe88948c9cfe71c912e5d18a5143c4886010fd1bea6e074d98dbebec62492fa0bdd4c8321b1f7bc30dc2697b591301ed434b259ee27070243c51122983cfc36dfce3828d4bb485bc6c23c485e503da48e19461c3f1f69ba56cb2ce887fabce6967e3b72acc10e9134c834fc202f68bbb33a0e2b815624afa85a2c0211b8db24ba1de0fe7ec7645da08a72758cac9ec8b49d85de8d5995cfc38ab1abd102060b71613b70890056d388902450a735ea2c18a6384c16329ba70c4856a2a11ed373c2342e3c887b0f542830509e5ff304c239b5f101d96adadd8c3c9d9a82686fcbd5d34d63c447a44a5c2261282ac63780f49cef146238bf9a4a3a068fbd48d7e3b74d1c2721b5750874220ad582f2f356c6be8331e3f3248f1e1ba18d4e15198288c7bc3ac3aa1012138decba1bd65a76cb26e8c18b237d150bfe34b1c5613f73e2b7ccb04149dc300d095e1cc7bc374235d16bb639813f825a18fc6bbf6e933e06fd857af882e2cba6bed12d48748fb1d87c94fafb17ae1721f48747afdad31ff94f481080baeaa2e5f913d1d592b4c9940239051485c0e779473020fd3824ed741f5203b2acde36018e193984861f43b0f284988dada109fa712d2e5cd6dfd92782ed6f6d05d0b61e484ab7c97beeb4774707556641b391084a404042ca7ca7ea96f4cc72c9c7ec540dd44b466a405d001be134e02e1a8bf4c259d6e9622667ae5e76623244facd11c061421aa9fee1c7c1985a1bc26677ad9ddd712bd66a20126f6653a5f1fcc798e9e3ef5b4b2206730df45cca0c0e40268c482df0a5dbb2ba074d1af5fc7e5ef71584a1f3f9dea8976ce504362dd1bd2ddbd1930f0e00090fc30d904152d30cf41be405b72442a356d9b40d1b3fd7f72ebae5cf4031ab03e7c47a3c96272d656c9c24a3a5e28375de69ead1690d0693d3d06273ac2501d11dd91f11607eefd57c976edca9c0f30c6cc30993ca50def4c43e8f88a5a2938561af6be918f293d69ee4581ffd2e6aa3b186edfdb4ad4af253381e118982c29ca5319d82dbd7b125bc782bac9597cbace529e5f2e58a35378395da63bd24b3b8bada2a21594763ee54871396762c5b71404c46e1a1d9737e3a9dbd0e3fd4ca3857b5a76e1fcc06ee6337e9e7d0ab091b758190a1e9e0c6902226ae074ef6f7eedee5fed401021e74836252c98b5f87f7027f978c3b700c0de9b4c2d0b95e826426611d28275f01837eb344378b50008dc5bf0f19df363af5e2b94da9877d0e9a53f6ca1f615b91739b709650cd6892b00170e5a28cdfef58d1ca3931f99e61bbb4e99180a3609556896b82ad3f8fbd5f97bff503cdcd277d5fb05e5d0ee63d370a6b3d85ce66cee4db2d7f6c1673e2f65a79d33a12c68e3e2c8229f267db8a15ab839f71f3e40ee711d7218ffc22eec62b25bad9cab46e3c9fa9244b477045a99e1f98273524ed58850dd1efc6f6b737bbf2797ea796f58aadb5ea82bb80eb5f3df65bbd5032886b9d42a4e080b2942e11007e35ebafd389dc270fc5307969d2850ce37e08ca99ba66428fa5d6a371598c1a387b6857e4dd1271600890ac8f18df27dac51273270d5aaabea6d726c247672687a8b712492c1bdfe663776d4c0dddea95ddad02215d690757030ad70c691a045ca6af397fab9eb11663a3a263f6c5e59759b60c4ae5ea2ceeb3e4c36958c9635d25c1b60885a9cf37372b1f0beedd17149a96dcb5b70b9dfcb16e15b5f2af14b1349ea437e0d025ed80257f74d6492c0502b8e9eb16128575d9c061a34e8199bbbd1b2eefb1abf5d813b00a34f138274e3b9690a7613fb10daecc4398ed756b7e0c260bd04b9ccb73f5c364a77e69d90e219bef898ce6e20ee4fce8062bbab4459b01aaed717d1fa49535ecee45382f6f7b505ad242902579014bb0aea975945bc66081f3825da7de41675981d06aaafc46c1c17cfb42de2a8d66949967410f1d1995361dfc429f2b6e61168ca0b6543966ff4f0eef74b6702521e7af2628f0885308e187411c6b3ed225c474813c91f6eab2075bfc0e311600d51f051bc71ce9c2a4ffdddbe63dfa5f8207665acc148d58767cc9f2d58f8d5e4bab46cfc3a185c74f8debbd12904cc6804ab49c55d9eb6027dc4657b1eaa781594468fcf1455096b8218ba4bc4e4a984ca5a8b23fc0653af8305f6a3ca03fdbac9f90f37f1ff4a518bfd391f8d927caf560c51c1dec15dd416f9ce49edd09cc4ed39cd4804fca575f3139f9ffc557efdee69e660b7284fd500f75962ac72194f3648d5caaf874c88d1ec3eae7506bb3b3c3e002995572ddbcda0390236069057fc6bdc9a8c7297363b4aa1c37d0bf765c9c44d146fc5937a970be9c79eb063ac34b2dcf39da63beddf9b416d59ca5308386078b17594a0d9f4df1552dbed9f8104017a0f691e583f8aae781d2fa39a4c1cf2e2f2030d8f6c016c923ab9fa7056bb6f54ef153f1b4c3a228b5b40098db9373ef98a097bcd281dc5c70b6836023b2630789a2c8a225fcec02f18b6faa175592e0cf867c64a680dfa32111ff3ebf323de9144db688091a9c3bd81d9649713d5578085ddd1609a1cbd8da6658669441e9f757a0d6aa4ee7f585b1451c9e03d74d377bc2e33f5c3c0412852ecbe7cb6f78dcc88b88f1863a2a125d5d0094cd4aff8d4b26a9623d7f76090d05787cbce95b83f080e7e58da4f20fbd7ae65eefd366bbb5ddde0edfcdfeded42655ed250fa59e4c449df20f34e257c324138c38f87d96270628a02cd05da2e055900a505a2fe88910b5c18a2668079405abd2b5f4ba91999b518acfd0a13f69976d29687008c74e6762eea536f91e2b438d8ec694240f0533e4b4f1414ba89453c2976888d5ff46dbe424853b9d3edf49a28ad7eb305ffa65fbcdabb69b240cbc1a7057ceadade4543df7603621114e7549f5b782aba011c1b6b576d6b6e270531c8c225a7376d9ac22fa517a84788e4415f15b9a21b23f5f59526b92c911e84ea7d3905da4da0d69498a481e7c13d27d9f85ec536506940f8fb892453add67ed412dd308cd7dcfa3fb6e998c314f0dfdb76d243f7d5150202866d8fc5c528d79fd1f07a583e1e0dbf00ca7a99ed69c51ad53464ae01be0ae6c966ab1139f485b54d6286497392fc70e1bd910612da5ef4a8c56212e5ff9cc2ced71096ece0f86f90ad15b2fab43a7e337bbe160468dc71f43443c6387c4262e4d7a51d17b872d2adca5ef366fd09c3003e3eda1007ae68bd201c5aad456eaa60ec243f21d8b2b7e508dd44bdd6bbe146b4176dffe7caecaec91f73c736169141d9c6d84905ff559f038b7fd421c9c26b62cfa03633192ba94e6673ebd1f10f42c4d447003c7980d5562770fbaf3eada38e827526ec2cb28a2471ea1da81d51dc2959acf6462834d96abf7b3f146e5795453a7769b688b4817de45ed47c876787838314c85f84c5fea2da412c0cab943036ae884fd402e361c07b3c99c52ca44908106ed72b41d972685a84258d99004bf4a9f6c7c2b02bebbda05b654255c483076894884b08a17c791718f24333e1eb0974df521575104b02b85b9d521989e0d5ffff43050731adc0c4cbb288103967f268ef4438ae3558c51d1e633320806a3693dd6c6124b906fa2936726acf17a5ab30c1091023024bdd3b75b71ab526e0a4750b2fe99150a6ede1ba7fec8a7bc1f00ab836829288f5c19957ccf07de6cf419d14ad65114dbc33ad6acaf8d1bd712e102fd0222ad53564818b53ad89ac09ed1d37e8babb781db49fa361550b857e09493b4a945caf3f41a8e5b93ee1110745743b782d9131202f1c778ee8cfd7a69469450e3a341d33e9c62ad65818ec785e0dc727e414d2705868b33002b2cd3619dfbea33a6fe93ddf75b533ad957c43bd2b7b156e45c9f8e9fa67183f34fbdf5a0625f3f9ceab7bb488ecd88a374be41d1759b961a6c6f55f7339aece2506f512eb9bb15b2094f02bfa61c1d0e0b751aaeb1bf26cd28825b132df7473b8659c70b6cdde1bee42802c736d37056cdeadf7226c29d17ba8699ba7fe424394b076a4aa8b2c3ab011b20904fee692c0076914331e55ad01362ef756b37700ad3f9a585c067d2d7f7b3cfbdf4e915338602ce38842c915fc9a6bde4dc9bec41541da67523ad79f2c2fb09a861094a7b9bf7df23efe07a17c3e610db7dea610d9a181aeeaa94f2bb3b47620c4cd4d154705a9f7a071b11ada7a6b9271109a55d14bf6af2829327589bd1717966bfa6c14a171a0fe47760aae6dbb105e0b189125672bcdcaab1775ed5bf1c342602aa4c995734f159916e589ace4a6582d7dd26e6909260a779319d42a493785fc086b3849efbaeecc2863c940d727b1cb2bea0223b8280e90bbe2ec35c419154da2783f54d66d4a6ef6774c0b27c0fe6d010b69a66735c76faf7b6dff9ee96491c9d9243c3cc5ea4201e62055564f7257568387c997a174d5cfa51c62bed79dc26bddb8069a1aaf036a4d327c3fc7bd350084935759af1d960e606df9b00e9f95d96a5021f2ed4d216eab6194e55fd8da97a375a085ecd4d5c73448376a6d750eb71e452001dee10a1731942626c36b7563bd4c30153f394f580ec90a8aeb39aea47597f3ed15cc8ccfdec827c0e7901d38a44c251b65d704d382a09b5e390a84c7c9f92517d5e0a22f36fac09221ffcd41c0ae4e46008e605f77f3deb28ae3145dfb240cf0321db97e8263f2ba3630cd0d4697001e70ec912f4e2bb7af4fbffba8a094330d2447e10ca23918d9971d2ff3b788a28117910594445f395a49af0706d6f55574dd98c0980228306d73561c437a41e6917ae21a72fa25fefd9514c4f66e37872827395a6b11f9c3d777459f37dfb644711aab360b86747c1b739a7ef7865d678d4bbc3024a96e629a5552139f7101a6bb6d609736c386d093ae9046dff6c2ab7007c9788e8dcaa95c4c5b69d0a1fca1fc6f2f8bb716a528e7aa7f5caafd10eabc257efafc5dde6ce2b2c19d8853458eba8d14ee5a8053eadbf4129da8ea0c17a0f1dc495a8a74c7a4dbb559250fd15bab7d327f752acce219cd1a5f5e6878bddefa17afdd2448f4be365b868c1a5bdda4eeffd50250bda4bddf5e379b31ef700203a5da151a0fb883b5ce0eea8f41b02f604c25afb922b41d3e90cf7bd09e669ee523e044b0630741cba3d13d0c0761bcdbc3335c2cf2f2ef5f2c229d6f16c5e4532a263ae4a124a3cbd351230d4b956c92af87544e007d8d70048be6cd909820056d73dae29779f3258daad426bc9c448f28c62dac2adac35133f74bf7f94f18d16ab369eccb73db2893915efda8c03af3424f4de2539666067a7b0361646502194d641c9459d6b8ccd5546944d7ae1de98057fc36c801d132eedd7bb4cc9f7fe142765092cc56862d0ffdfd08250f53740a2c973a256c536130abcdf51acfa5d5a2989b7a511db43d839c83b4d7f28c8e71fd280d4d8940bcabcb3c6f33a3fcb648e0f0ba153a85f7f69c5b9f38666192da2a22778a99b7076ddc05bff34833035f43435d7387496339d4d7bbc6e82b86ee660a4d302309ee03035557ae10aae386acf06c785ac43541911616b542ff54d1d9fae1e3102b4bf70dd8d79f8308f1a658046e1a3bd3c2e8235f40a5e1573790b6f78f57427b24011ae766c49abf6dac23680883b4746b59caaa574d4776dd3f8e0f67f35cf74635803178d0417e1f5f73b714b948101c28bd3bdbbbf4b9f1a9eae011103aeeac89858b138507d48fca6a2659c5ec3dc2831f2825999daab55cfc2b689da97695c95b2b56a2e2c12385a387d28bc5d47f841b20c369bb2e448f026b16584926c899b464a2d2ccaf49b64b145f3d0c78d5cadcb89146558082dc8dbee45245b64bf7916710cdd2fe3f8daca6fa60d0192bb9ff06a3d2182f9309b181dc195514ec155db9c0958f8ef0ca331cfc4b7f005dd32b8194ac7aaa699471b0c5f77f51ad41f2df27dd48178936c74538376358d974e850a457c9547b477bb4e15e9729ac4d945cefda319eed98c2b2ca96bb665e9c3ff9a735a5481d62faceb91bc244d2a8143e92bb841de8d0953f62e53d8f064086e084d95f9756d3090666eda8e6a2d9d1c8c4eecc9083985d5eb365bd7404da0bf1db219de6a72f9ac50b779ec89d57f66ea0f1a3dfa2c69258e2c7012e6e868618b038e516a727b020e5367f5435539d0ce16f5b4ad7d82dc833cbaade6a93d88a385c054300564e48a02b3eff5e4d476d91118739858197017d016c511a2b25454972ec0fad71d8c3ff8e12faca004ef84814e59ead63554e64cf93e63b374b69220e1286ba21d482501ea3108149f5400b0370e29f6f3ac4a9c2a611fa5c15fcd14b740d3598aa4d65ec8a577a7a452ac6b7d49d1a98800d5e45fba5e9f2afc8cb1891383635acb2794be9075cb3d19d6f03b9fdd6487e61a4232ed2c5c06208a884bfbb53c39859eb4fc389feebb125f7175e1c8ef5ae7d22782feadc5e930b93e9ff8fb02c3a5976da215312ca58c319bc75392ad56ee7f3e1a8a836b9f6988e78438245aa7097f793fcfb85e213365a93f7ccfa7a6ec03b2bd90d15c8fae2448b98473185c2b2e6b274b5e26d12f12ab9d473f37c338fb0f092bd3115bcdbd26a2fa275ee2308a10476c7cb40317fcd94e0e645e1e2b35aa89f2bef8931bd61d535caacbc32524bf85eae818026f2e2331281181868ac9c60634c3dd2d521e7ace67e52ff77d877631928d2c841aed90a4d9b1e0a90547a9229701da769167ff9576b6363da6cfa14246b9e71726dc42832a352597e6eeca3eceedf69e7908ee1f9b43157b64e15439388e8033b006e8532767fa2afdd002c51d254005e3392bcc9bdcc77ec7daa49101ce20cf6b9f6ddd9f759db03476e324c7e633d55f9fbf6bf1b10bcb15769736f3d484adc38f6c92813423fdab4eb7722bb368cd87db00183ad286ebee169d21842f1f33d53eaa0d9bb9d8a0435be4b9bd1379173747084ebdf853f918818ae967f22af3dcd50f4b35f21b9ff4f7facc82ec46459fbe43012938b4b987859db2b6d8e98940a8ccaa5ca4001c81f54923a471f5907b943dc71a549d6dbab7d1d771d61ec44862f8dad097fd1653c879e25d0b2925879c518fbccc1ae95f840f5a95ee8d9dd19e6b08093285fa695cf382afe772e63f1830eda114bbffbd3c7564a2fd0e383271ded8ccab820154c3c6cfc73b3000e4ad294d4056b8e9c8b5bdbf47c36ba501764b59c14491b12ee8fc28ee9bef595d26b066fe8cf7761f29dcdf6b6e54902b4389704969dc5dbd5e8aff55687bbd30748e8455d01a6911e2ef9fe6c95ff7d3c1a9cb32d5413cdae3cf09602275057d909dab053e6c431db84f3650eae4224175b5671e07a91549ab9cbe92143d865d7ed3c18c6b20e003179c7e408d81f202538ec52f64146cf8e7c9752825fd5c98166d3513899f0ab496ba1d101d66376d059d7851c8346a998dba947d0bcf8b9521f6ebda26e280168efc4afea653a569cd994937c89ed44386d072e5915367a205f0dddd9a0fe4e750b8cb6b4f8e657762631917a7a02153751d5e402d952439fec46a63484cb3746fdf439b83dc7e7b07aeeb192fe86c43615488eadca1ffaf6eabb7ebc4c8b7960a4be36eb2cad9edce34d1e24b32d4e19f10a61122c05e144e9f20044918469b035802d27c101457499e823f5a6a229d2d7cce4438537a72d14a2142a0149fc24685431624306b8919eec8e0f772179e7961904510905d8b2e7d6385718533bb01e4027f600c6ef806bac90e622b14808c29a46868c5bf87e720a75b2f0e55ec64b4bf9aa8e158ceb128a044ce0537e70ce2c2536edd17b51be2db45b1df21ff871564472c5d5229c8c56c2e6a5299e8eaf662f45ee31e73ea7025e81ca9a51a84af213372f18d1988bca5f6ee9fbd8783d267e2f9bd18f72233dd82176c427017250a5a274dfdcd04ba39382c929719525c94851ec24461a65ab94fbea98e5c306efbb73f06666e51ecbb84fc443b3db17ebc5bea08bd82135edf4dc3627c39dc60291e89427d2040ff317d3584c15a9771928236221e0adf87fd77db3b8a9796b3b48476ceb65907a74d13c3f178f20f996862faec364dc6b5a68bf8a15c1d363124caf4bca0a11a097641dbcc42f6278b1b73ad4073028c5f222c5458d858658ab0b78cdc39337bee5805f3cc75150f6c275499aa11c77d6f5726fed9e4ff56c375741e8c4f3885c84900405be8f4866e4ea0cd08eacf2ea27ef56806db7967108c22e5078b252f0d960e3fc0257a4b16c206259412a9488fecc87c71dbeaa72cdeb66f87e1268e8e40883436d49ec91a20a652579616a8fd0ce2aacfd6bdaf5fb19b86a37de234f605264a16a477a14b7b9d50e06020c2dc3bb9fef1ac0f066f6dc87059c2579fe9ecc772bed694f3307f343a082e85a934d715c41e3d625dbcac74bf3ae461d9ec0c0effeaf5b175b2f0e3c0518db2ca9aa32e2148bc8be16fd90ba2daf8b65326af08e08ef65b8b4ded99ab970dd86428bc8cae46e2d95d261f29ca9147b344ecc34c5a8e06ef17b875372cde2831e3999ea100effae3118526d96ded9fb389a4b036d22d11b270296903ccf5cf0e48d61343aef9cb59676955ff441f4aeeb379ac90e3f6cc5b2ae750f6028345d961948860345bf3f859fa23f1089c487bbd77f4342cbd98af697ad641f5a310d84c42fe77f634fe48ebd961db2be9af9f687a1c28148f599021aa483651cb424dc184e55a1102aae9cba83a54e2bc1493b452228025a6f64a7b3790ac3132e2930ae432922f678e2d7ccf5e0ae8e72f72813f694cb3ac997fc92e674c199c52ea0634e263a1fca11e07ca6d6db9d8e5e9a623e1093913629e9c6864016ce283738ad816b2b594a4a8f00d934fce1066394a641b34b5d273a9061c2524839bc49e47337e122b13376741291653ca970520d96046d84cf3591062be2619ac45a466bebb976e53ad015e4db030f38a06a3ea6310f7c88619684876c2daf1aeba81ee9cc5375deb1366391881f68cc970b9775655707de6b7d4d5c84751cc8d46d52494519eddf47c02c2df601203de51a9cb91ab52c66d932aad7e9b18f7972ada857aad91bf50542d776cdb939903eea1cfd1e7db546ae6c8d41f4ef5f5a0b83e83ea35998bc65bfef6da024e9c82d18033dcb9706433f0a25b52f896336fe05799ecd44b71a5f6680a71aedb91fd3e2c33ad6451d736155c2892d253749188b0be5075ea01e58b2b7baae595a6aca295b34fb79c2f4faa87dc03e6deef49a8d1701e1aad5d39fed6576faa8b2961148a128db77318ba8c734c96ab62c78f5693806eee0c95e70b63f42c053cdd766d2816bff23e40b848191743e182cd1711fa5db0b1964b3ba725754b74171794bf8fb4577de1edb32f5407004f3f870da290901e0558d6485bdcfaa2ced01aea571abb8316e125dd18a13e51ee43f2911debf6dc4d641456c7f0d4e23fa9d1acc9c5c94d4e24bc11dfffce9442723ade3fdd6ed010dc6477f90f599711c36e996b3926fb68da6126a7c721963de05252103de25c74cb231931b51e9077b085f465eead50f6f0b0ea270c8a20f23fc008b4d26965c4f53945a4391edc11ea6742cbcb42040c5e05aae53acc47d4bcbab0fbd48bcdcaf61b861fec40e91c74e8fd53024a6bf15d7c3328babe9a5eea81f33eda0485e2aef172982817eb0cc32b10f9cdda2382d072fe04258b4ad0dba88c125cc58160a98f9fd4204051d773b21419e6d5ddd676959ed238a1a19a5bae96c7a9b215ffd475352a780204694c372e8a47ce6e7565704d486677902e01de7f6ed78bc9028906612e8badd9e7ca4c7a67f7e75a8ae3ba03f89e33b6989b35e17b62d61f6d8d3422b76355095f3e0fafdfcfb003f6c0ec6cdc6dc42d77f021b950c01865d17a20685bf22c1904fc70bc5d6f1cbe324e087cf007adb88a16a7ee7f1b73fa9b86866cf14fbb34e36a90fda17176ada4048221618f2d8d756501c3321bccd63a15d403440c817af08eed7ba10eee6fbed2bc684602d4af5c868dbdd7d6d780a43904610f008ffe5e8d9516995808da91a762305fcd2711f29b7735b9c319d682621305a759cf991bc5868a1bd5aadaace6fbf811546fe1ebf618e3d9631b741b9e47d528ce7d1d1ac421b8802c335c6a8dc41f9c89c6408a5ec0e393682a2c7c3ab734861e1a23692417399f5dd81b59db0b50e2adca4bb261e9762ac9e35ad8c4577679829122eb0677f415cd2f7d5e7deec6d160b39eebd7c1dfd4a76b531a4850efbc7d6f551572172475a81e499ed38d750643db82cdce926b2605862fa7859decdb908774eb0fcb1a09eabc7da743b4fb03611f2a4fa8e98c9941fa080c103f13d659a6654dadd9436d79b37327b397af49227272762c7271e088b06e4b2ed36eae96f807b7495dc97259e6f62729e79e8e1a5a9eabd70f0dbd4acbf0b53f5ad616779d9c473463e8cdab5fb3a497d1e0e7bba9e800eddc068ab6034cba3ce0b743bbe194a187e2228fa09180b460cb0454a7f099db975c4e8654317bd93a06c8b0d0a30d6b2b9aa4463fad15398612e792553659583654a5e18db84e6a60218d57849f6a10c4cb19561c935a5304e1371a1253c2da955b810cea006cf629f33eeb2eda03c7dbaafc46454f2cef7be6430ec82ed45248be5de5074e208b7692663ec02b9d30825d61dc5173d5d417a2a4d160d24ff0cffa38bf71dd6fc8708e5977bc34ef0d8263cf7bd95ea68305bd8105e33c60ead36d1a3e531ab0c21c6dbd912bc5832e6020a767e5db712895afe020ba5a71b8711a027ed18f604e5811a3208ca2c3128b64002b3055af186bca9f6fe92296a28c2a4be26a56d14f0a2bfb1a60612c87ab23f4c580429cb9347969e2594c64faee995d5a9c0fbf6949907bfa235d91ed6e6c6371e60f5191879ac1ef7d7d783e5c0ef642df9ffbaf2054a745e4fbc1de0b70353ad91cd592272b22072fda9cd8bd4c04f3254089938d03bce0cd2d60064daad1d35899f5ed554335ebcee57f5cee49c0cefcef77bcceacef583fd74f19c9903945371994976d9a184ae4aa5167efcf456f9fd0435acb53b4e56a6837f4ef451e6f1195d400c8d288b47aa93fd4003a0689402156654b30e865221c900098de57479c2ef4988be16cd6bb77a08aa87e0823ba431f1c85dbb1b3349bebe93d5b963dd83d97920996106b42fdb024782047df9bdf1267d34189d10917154f5fbac781cb3d669bce0544040beb678c9a9c099077b1b88f06a20ebf5d94f0ebf91e9a03540362b001cee55bdd96a6ccc047c0cf97611a86ba575514ca4b79b514ccadd8e2ccc054f9c8f4e2fbea8e4478727431d0e0b574d601fcf2b509baf2df7f10ec30ee993d6b1517137ebce6f7520070e4baa1b5f1a567ecd1e66983d91d89e8c168f9379a4e5e04db46907042d8180342aa14f8237a8a35d6a94afa5f8438e848c4822707b7226c83366ebcaa481af50c899b3b118a8f478441fc5e1b46875329c1b67bc274a87eec038476df3a58a4265d54e5d6c8850272c5ade7224af4aa28c607dce1a12bb71c076c9136d609d06fe6b8ee08dad1195cc2b91ae6acbfeb2b947463458a3671f5556d411c757565ae22083d259d39e5da5392a14a0ead45026e4e992c39bb9acc75bbb2afffab5ae3d7b8c2da3faa124e047239807cc686bcfcbd07a33ccbba1cf5e41cf9fedcfc6baf06ba86e0590b869f7db955cedf03293bb5275e632cf3c16845b5e9584ebf67fb41cdb96ce9ed4cbd00637b329377a485c82f3af5ce4914e5466b0ef8842e34eaa22d659668e03eefd8704e9b6b41093646958aee0a8173b579cf072becb1691c73424cf25934d771d6ef606f26762cca11939bad06f62e7e55ca3e52b91bcde58250f071c46e484724adc4f65cc683a6a2deedc896c388cefe2a25ed0f8bcda826bfe8b51f3cc061bd9485e871ae65dfc2530724fc54196650c34056f9f6287aaa66b3f09c48c6799060fe0592d833da9673f8cdaa4c7edcbba9805840ba658b7c92325c558f52eb8defdfe92e3890c59bfd0b45124335a6ac36ea0c08dd0b5683f24bb5be357d93e10c1e3d789d25872a3c6a4e264ab7af76ef8721414fb33b2296d9887d94db7895de15e7e3da2788fc1593010fcd8b8ea0fa1d6c0577ad72e7e07cfff0aba748f9f1db5063997b12b7001712b3dbae04d8b578ff3d3de3d30d5d0d529af9989dd092f96292c24ac1cde763e45d8b2c603918f18dc5b321d32be3f4eed6ec61269ea37c7f5b61be7f79c39b2382efb399c334a31c4a782f751392341b29417eb590d10fc60085b76ec34edb1250fe54078f6acad62cb7af90c71c312d3bb3d4c910356208e2b90e62fb2294822883a85b984a196144a8db00b5b4c79d5345b88b1f8dc7d339548f2aff4c42b617e5b362846b562f471db3176d368e571048ac8f4c8cf73d5f2f4314daa367d5027f4b90eb099507f7a1c2a6d713acea2f3edbed5ad60f7c30d045c86e45346047c25ac9bf2166f93583301cd9db591684ac1da49045e4f89675b8153b7affb51af671a6d11f255a876fd3f6fcb5f2f08ec93790d6e4709b670edb2f8ab8b23b3a7fe0f0ea4c93df0ae1040a5638ef632c91fcf2343c593d006390420bc73125d53b3219c5fa471ff0f2421d287c3e1656b6924a8b5be6940b1b4c8909620a9c99ea7a8bea9ef25c9e4e69f46f38d45987216acc95584c757d0fc7b7d54997cf066a450a78053b6ed2329cc2839b874e6dad51458c34fe33ca9eda1a4b9325b0bb0d2db94551b719dba9e996ead04dfdca69ff04fc3871911ec0add2258acbf96aab2a6a0eddfbcc9f3330e3a7cc72d99cd5c2c24acf72d9306d0d6a9792deea37a80b785e155664e002c9172a5e92bf37c362d6489941de5b94d77283bfd8af3218604da2af392348deac0e0a856c464934a75c3417a5f39a302abc96d0418b4652c8db8779e3f4e625019247bce4c18348088f49f8b59affb15c5240f173b0e36552e02f9710a572f49f22422f0a37a90982e36b927219ba28a85f79d40e48ee61f51d5f6a4e6b119db8099dcfa1a6222f11f16a49d66e83fc94b7a26edbf4cfd2d3d43e1afcc573fab1ff91ce7f1fe2e0049b30b842eb515c7068cf927da229d53ee49e9063e9dc808ab2879a139ad97661cc75fe6acb82f3f2f1c70f310481a4e69929f41cf0274cfce3fba69e56edf4c24d555c74741427f5c8d66f52dca28a63e8a459706676f9ed2b04f1ea3b7eea50b1cfc79a5ccde05e3117798e75c80a66e03306baba33c2811c1bfebe37492dc63e3463174ed82a9441dd7eb0fe71c27ef70357d891b3af3de9e70f191fcbfd2bbe29d659c62683263c2a848fab14d2541a6e46efa07baa56ac937e43a334d6d8b96030f68e6e3b7a4c49e6d1ddebeaf23a08d298c02774cee6b86f61d9d289b46256001ce896967212c663670dbdc5311a99aae043abf54a43ae9214f8c3c77966f4a145dcb7998caa0cf5defbab9fc4b2694eea90db99993a34029c46023779539d1a6b84e176b150a61b29220f7382c1f9ce546d34ab4a2fd06b2e928640ac301537ac2b7c5335470187ed3c4279182e8e8cf137560af1c929989aa381d396b7994c25f12279bcdd5376bf8ea9a696a6266b35fdf924c31f10b531a669a142836d1fae97ab7362880dbcd896e328cb057bccc082bea7c9f2de347b72a22113f17f621ff7b6e63749a8e07c078e4d3dd5677cd9bb74de6ee63dd18a2dff435ab8c1686d42c3a8cfe8ac598f8f7cf8582b4371560c5d58a86d82aa0f12688d8ab04471bacf1fbaff9910138bf68940667607490ae5945c331574dd64073ebac7349d8e3c0ebe0e2438b385c92ce708877b8aa2541205b03ba70e1df9e65f071d072ec3ad10742f76dc275e7e08fa8b8f197ed34c1eb18e7fd948fc6a9a9bedf1880262fce897423efe456bc2e4cb8e6033e0fced4a3511d6d8938fd8bdc2c551f84519c305afdea6d5dc88d90d5c71ca47297e1ae390ba7ce3a3658b74c4dc2a973f2df81590500e04d17d826fa86dee004f56ad9ad7723b10fc1485b33b60f6f3cedede69be8acf23f64624a504a8eaac0abd70e25405f6f4d341d00f60776937a25ff04a2d2e9600389cdb472a24733ae1c0f31f1999eacc966acfde859f1a8bdecceeb6612ee7d55e5bc5b1b152d71ba960fe6337821b512e8ea3b16dd3944c1da5de9348ada32fa754ace6a0673681f70918102d86af33cc5fc8804ed6b7b6a1e10fffebf025a969467cc3e1662aee07d6c51be607b047f9d2ddf57c6ca3702962ad74ce8934dcb37227a9b8c167e8914435671bd0b164c3251fc011c6356f72e3e73b4456ae9d83b7863213a2ea49fa4ea4ef2819a2291a0cc927d1944b56359e28fc5d7c621def54066b6e2da758d65e393d9cb4c0abe6227ca8212e8d2ede2693da7c41461b27f91399a16cbe892a14943716a7b7360e0fa5f2186a7d2c5ad8e79bc2efebce9ab9552057c2eb05fb5e92bbff925c1ce3dc5b3c8dcb5c2a36a15edbce813996edea6275f921100fc1696fa35d86aa020324ba36c3ea47765c7940e1da8aeaed67dd7ba634310eb492ab3d5343c5971fcf89ca28f8a2e7f0b48c884661eaf4f28716e4851e04b0bb9de20a9477556b0890b4e9f793d7eabf26861e6669535058c30efaa9dc733a780ab62500b8f50d3cf9c78ca6f79ebfafe028c11a46873083c8a6cf1de47a8b6d4ed58d49918b4bf77d987663751587748fc0ddddc5328838020156d6add1fd2a61a8265d2dcb5ae48c275713f1102bda17b6f3e230881b4077c520f8d721d760e78cbaf75e0be5bc3390ce22f4c0911089f2e834ec10bedaf2f0f5d7bea58c67103f8054e1457dc8b8aa0998597669ce438d1cb4d24441e8f066bfe3773021a79f3c88fa5ee87b93e68f5520ce21865842f07f6bf77c4f2215e353ddff2c993b3300e04700dd8df17fc7a1a9e425e68c44ad84dc0cf7697fe0628c47953c52cd20f1587b1092956cf342d3684904f9d1f19e2391e4e5120c4b688516ec1bd236ff23395c6fd606a6ac85b19db8f7d94ed5f6bd33ced19f50ca476379d304262c2244e7bee774e585dc43a55b06af94d9c8bfa778ccf0c622a3380347a51186f3add35f7e19610f11171dc78244e75e305de73bce7b50602e2ef26034c21d8e1cc0764b3823f0d8031888edf75eff014adb1d0daabdc69fe2d452798c3e4d4e34f8642fe07ae2d06aba07db1affee5d7a604515776ae23a3a7b2183ab14337a135b6faba17688fcb0c5617a1cf5bdb998806679b80991371ecd7d3b4a3189b43fea19e51f5accc45f9405aae4f4714012e2f9416bf42ee159c180035e406086623a8d166bb48a6d5048008c612b9634cd1d8067515b48ceb248df0d128893934009a0cb81ea142b486b867f17415b982c3a8beb809967e491ddaf6ee937419917d66b950c1100ca3a55893d2ec3629008969fcc2286f53100f833e8ea7a7bb37e6c9819c7874f9014fac1b79c85f78b69135c610c00c8ab5c8f287d7503c25c24ace35d0b40b7ee95da31e1d892398a2209b4e25a911c0fc0da448320f1d0aba7bbad56146a96cbf4ffd85c192dfbd78abe609589db4787a17cb6080ba0f56c2eb7c4704a54a225340895fc0a664ba3591f0efe455a2db39fdebf802f181b2f81439b19e703456f11c5548c7361a9783c3718d348c8541e2f07b50864edd4b7575abc24a9ef76bdff021e1b416d07ad57d2066c3b5c523347d5cd76c5c53718988e30f2b8cbd9b1bdeb83c997bf760e77439ef631f00e260b7e3511b22cfa695784fa84828c26017333f7b5ddea5454bde03c394fb66c10be9157f8de6d4d9a400ac285fd4b4ffe4f403acffab5c283b11a17a8e3ab52d271970b089f4cd00306359dc04e8a395f3960aab4fdbef646ec45bd362fe9141bf0dc2479dbfd05ec20a377e168070889421cddaa4a7b3f08287a1b341a0f124549e7c45de53c7a3821ab7b82e2570b8db82bc7658931a3961c4588b771119ea7dda6177eef02e7e613e3453aa5da6d45d41e9aa5a1ee5d9e1d3e6017d7eb0e283379236494379907bc4fa6f638aa966aecf8b31e15561625812990a55d83d9bb583eadb964e1bbf3fd632750037ecdabe8cd22eb663b797c288dedf6f116f51e4ab23aa1eb0bef0a12060f6651f41747d0f5190a055f0acc2336ae29cb98c4909f39ec30b729a1a3b6cec816e128ca136f13c1ede4ea37c1468f108cb4c42ca9b6b70fbcabf40bc86221d2c51d4224c0aaaae4775e9c9cc9cdeac723781a2e61ab77527c98e037668c572a52f2707ed0defbda725804464e16953593bde03e46a9a0303af14f09211cf37ac9955eb7845a1a766c6e91f1efe440209289c58c019f2adf2f7b15721e772f15d5e3da2fcad0d0b9158f822cbbb43b57a41a68e7a880f1993354de1c8833677fbae8ede27ecb5eb813fd3ace4cda0627e31d5610038ab50429b03a92b79ea828268144cfd335fbd32c6b2f12cb845762889698b466d99fce32ee08c2bc04dca56f869ca9a2d2c3d7de2228893a40e8f853040d0e32c899ff9f114dafbd30b0deb7d6d9036bd629148ba2596ee6753942f8cc0a15886fcbbee3e257eff0e72f2ea916b342f5d350e523954e008eca670f016fdeb3fa1506d8a0b4324ae495e5fbb7fa31159f3fa67926644667add66c246aae940db4382661e567072a17210089bb87e788aab7d76411bb1cbc2b93b089a4fde435cd6bab7e809029c9e1c467877f800a67569d7104a37fb2db54262c7c312445b0fdd9fed0ea7aaa2386f88d55e4894a8a9f89bf321f69414cb2bb43f82ad7abd7b40e4919fe8a93a35b3c6d0424e5f036b7f95447ebf9c4d9b71b95d6fcf2e6f59cafb9ee5c172ced0d6222938fc0b16dbbc794db143e2b0330aefde5c205554651eb4bc521ff012071c7900dbd613803b50349c0837881ca53e64240272b3c2993739a956536383817b49a7f7ba24b43f83723993ee796a1a463be29ba6a2ada98e25a4e8afb6d0cf18d2daf60578be5c68a7422d93971fa2c4ce922e92767feb0c7bb665aac2c52ca88e5d2f7557e1c52902cee3430939bf80fff6589764236a3cbd862601d54824f58ae1d07676bbc2b0b45e8b5477da9bde481bf4ebd39f69cb776100053d0a4bae43b8dcf430f9bba4ad921c8a703dc09e05b37e661fa152f27c51987666ebc22cd0f4a24726d493b06d14d5b4341468799c8ab27c8a34f1b122211a583af21d6c89cc47fc6c846a70d0d14e6fa7608df404d964dd786f22ac63244205beb1517a96804e57ffaaab8f69b19e225791eb297ee21559d96a6bb7f3ead3ab9404a7a17d14ce6aa44d09bd3b95a978b04a79459dc95cf744e44c0f9a0c76b358e56805019f03d114f92c6d7129e767899d67c2d6ab8d0a083f68793305ea88b21d587d097f861fbf30339e1a65d66b22a7f971ddf24ddb9bf5b11a482104712c2249ab1739f45741a717d4040f1a73c0126e200adcbe370563159b89a6dc6bcc88653ab3281b404039e63f9464f2c25ba2b9dcf083b2ef8fb8888a09fe99f098f9190e7974787a1fb363f3b05325cc3aed3b13fde2767d1a5b1cee1e78c7363cf090c76f76bd492bf6a704d4e2fdf5dd61bb279bb63d9a073b15d8dece12b29fc510018204ccfcd67b18609c0549117f500fc9ad3a49aec4318db2385f4d0ec5451b524dae6f91f93a2ad40e392d66550a2015d6052ddb96cdaa56ff5254c99cb0e1b5af08d9137e9fd8cea6a114e9fcede2b5129acdb4693ac6675129c810a6e18da9b78737669769059a3dca2aa6b17f0e75a6b242e28dfc259e1016858b2403036651ae6c8ce5146e76346f5e498eadee58649e8168081d713dca64f088bf4834a690748a98a83fc4e490837d8648689e5604796b835192cdf07751e00e558ccb9effe24b0154107348865a861fb213ca0d67ba76b632237499311774264f27125b48b7bcca933ede918c19defaa965c55142a1eab86e67fa8a9125a404d46f66fa1df3b7dd65d50ad1f2556e454cb1c64670342c6262a631c3057791ab0c9655bd883b9cb2e4ce363a73ea9347f2b04572737b94a57f1a65e5c8b32483b1ea654b5162a6903b8d052897d3c87c6dec355b50f3451f73211b4e6b4b36622bc0cb366aa2af51ad8bb16cc245e72fadabba803c959dc529372300fa815f17f29c4ebadd5e9b865b2679aac18dee51849dd75ff01dc284d83eacad166d17e3be66714ce6d9f2376e0b69f93d1917902a260d2b5718ad78eee44725df2790b97af65ec5ca782868199a0ffa1dc7506e3ab1d4673c0af46b6af93cab623ee7612f46d8168aa3fcbc20a02aac6c98db91c96781bb22f8c8c1de5e88046d30c16050ef8891b3b7f4b2a9379a481ac469b83bba004e630e536b788f651fe6ecbec0bd312b43257d9729bd970a2dac55f17fdc8494beff52410c6ac4693c796cea5ce84a039137aed8d8ec5258f737ebe11a02703245cabd37c95c7e08824e98d21825e4eb726b29393fec7971856890d7547114df9d93962a66caf1fc7178cc2c87a877d75a8d524949ba2369c64d8726889f7dba7a92181784a7fa8b5f12ccdd3d60d6dbe4fa0fa274073f9b06e4b563d12bfdb943078236059934cb659ffe8726dc06b76419b591f9dcda6c8bf8375b86ed2c3a51fd367113f7645639b713fa66f6a1c102409b5b3aed5bdef71d19327553816ceb1380dfffcd3fd0182b4b9042e182a4f26e990db7ef80989e6b401d077b571b54e1c12003328d32d5369537e880be4de55c037b84c9b5378e1b564ac137369d72a86b8d0d60bdf6da26570ecb47ff4e1d5d499a9ec8ecfc989189610154d7c611de59732158609907ccd7e5ebe4358b63bcd30663d7a8b4374c2fbfd4b7eb3debc78d560c57c23f8313c3db2c8897c566c702711e8baa1b13968e35035a65d98a7d5ced61d23f588ca35591a2c37008b66406a678d34e0f05a88db9f80a5a516c33bacf817f281b7f8fc7d825f8776692aca248639459ce152f977c6e84700fd0091bb325c4f4c095d2454d16ef3cf3b5f1f87b3b8ce34f4d2304840620bb4c6dc74878e6a2dc8e0b6de1a484caa3924e80b3752df37ba8dc38abc2617b399c047bd6fa0ca6af56af21c38b9e3e819b75f6538766c52d421d8cdcc908c23c6f1169f00ba18ae07b61c8cf547173eccc817c8473d9bc55f96b47f6b4a3a8d33f5a532cbafab1fbae9b19244b2639ffa007a4082e46f9e9714f32afd94d89d96283aa4bdaabf7e9c78ed79c6fa6fc0a4c557c8f6c60eb9171c291ff2fc0b93951da318622dd2db0f2fdaeecae919f8b5e223a473fa34cf36be9a2f5a90c55301ecbc519f2bfe980f367e99e1de8948d38a46c2e2afb190bbd9d932c644c7fc42918b2c125ac6937d1db80d35c6bc3b662c76d15dd68525ce6db09e06ceec3c3fdcb41935fb598abe9fd5cbffa6ba87b7dbd5f1bc795471784d57012a8c4070bec8a39b1e4d0b350e48ad57eb101bec7c8de62e38259e9887e4873e4d4f196a56bd783eea6fc554467253bebee5eeda9e1a87b8a57b0f82e56a11e940aefb60a63ca328a07b9dd4105ec5670b0b1ed947962b64d88b0f19fcc568e6924fc3529ee938cdc4541b88a25ab3cc7d14eac5c40ce613a1856a33463423556f560d302c23d0d65fd2f34f5aa5fabf4b53218e602e79012c4725272efb1c09afecc328e1b337becb221d65ad297a5d2f92fc89beed466283c65e47b1e5b1eedae064b0ddf008c0f3027228a87d71036b7c9866acdcab963af2a63da3097c3ab2b9df4b5ecb2ec527aaec0ebf36c978c9511cb6eb6e4797e2bdd18931830d07cf0c3a50493c0f584e3f87514e4419a541e9d6616dcc9ca7a5b3b01cfc32cd91695f241190a41305abe51395c4970ec4f3189badb9d29f8084ce7dbf54b9569ac531a8151d30bf4926c94372ab5cf7e6d6d12bc09d0cba2361c499bb48aafd0de9e4721cef05e6ae2211cc0b5ebf9d24c23074231824e0415f66f5d30f8112cc263b572773202ffa675aede79e49eb680000c4016d04fce633e2a0d6393b91db27e39faf78b3e7eb5512e9501bfbfb4ca202bcc1d69c064862637949818f26287945bde0ab23d5499d63a585d92f4b40a14acb175dc74d2749ced4aff730a43d73a5b38ef80d9519fd7bce7b2198c7b70aa3bff3ee02c42efc4597c707344b1c5781867afa6341fd3b92018135c64d23ebbfda8d2b5984eac265b2f223d4b3c67a652c13b213a00bece2d87ee9a69c40665a5c7b65ab62b6d4f60596b3ed042b898e356bc080b3cb3303fbe6486c0ef0813b61d796c7a15a22b61762f0c7a2340403e567605a3e9186c77cee790fc0c81a77a666ba579c08bdcd8161be71d46b963f9a2e38f6a92da7fcb330e6362a2831a27ccbdc996cb44eb34b03a3b6d589c6a34d45493e077a76ae5fd7a2b09d8e5bcf3d3e6e7845bd67bc21ecad36d2941f01fdf6f9fb10fcf9dc4edeacb86e1e3deb23e1d1b9b49edc9f06acf1369fcd95f9165aedce9c786b5829e6099abe5aba79eac5a73c14b5d964eb08288d8f10090ddc4d91a0087ebed3930489d06c1e0647a271090004021d875a6dbbc275af170be16127546991e39466f610ceaaec9b09f832315641e54705b1edad9a75d8bf3a6f28aac144495f2cb9f3c5d271be1972d63106a8513c3f6a918ed091ba0445397e4a26e1bec3bffa9af99d5fd04e927c0201afaa7e74a779722d31a54e3fb3435e936b76a2e0f3a837d1b77e95de6b1b20432c9a0162c5ccf3d96a6895a099df0366982848b70822de79857f6be85653422c883688e9c3a8493aa21076f17cc5dc2b7f326f3290638bc635bc03bf718b7cfaefff2d1ed8272fae490d7ff1e8fa6682a24f34ecb235dba7703d6cb2ae39a3e6451e446e49218e1cf7eeeb79cfbd186b07fb7070109cbab637986827e47e5d8b4e72f7a18811a73d64bd82adbd7a60d6dd1149467b03bd94aa95f60aa77d4cfe6c4a95ccdaef2fd73de1fd8a4a2546c78a0c6b30aba3bf50e82897d55c9823ee7735fbe0c5e6ccda84de6f6e226e447745a292cb1b6de7540d8b85ba9d8216bd5da509a89cdb97288e7600c587cbe971a2c866c70238665baf4daffe42aee9abed1af29d0f9806e51d6df104f74b59c2c1ab49df89b6b424165a6b072bd3b12b5a7cfd439a17621dd5c31f68a61fe5a6721f0fba44cbd433dc9317256eb7477e69923b082c5b0464850415f92fd561b0902ecc88fd1f4d4340f5200b6a17d709a536b38dbbf69320735a7551175deb03f3314cb4d3d4df5701082eff92f06ae291a6377a0462a425ad67f33328c0202f8a5272e6b06e1aec3d25476f6884fa48704402e35366f793a8a5ac881e6d5a5b3b2b02c06bdcfa5256741b0f86aad401ae48259c5d84131641cf48000adf34c246c071cce9f110eb493345e799ced2d47b628cf2d668fdb39d1216887a146a6e22bfcd491a3295ac4c342ea614e480f6318aa53ac951bf9fcf4b99830ab64af0419fd36eb4dbc5bcc342dc09ffef3afc1c04e3b48d054c660a56450744a203a283369dfc9b1d0712e1ca3f662f1f9edbcef64f754f7fc597ef5d15f9d6fb6f32cd07cb90507d8ab191d1198c3ad24928611fa4823367c0629149ba34eb03636c02ab9c5e42f3c0460d1ec718c8fe80765fa7dea02805ce226e55bdaa0a570d370bdf4ec331db7e52022405937bc33e19e453e678c5b8640bd83a56c3aa3fce831291d8ff763f0a8e926f257d90e5657a5e3d3e6373150eef8b6a417101b737d205281845696c7126b92c859d7544f2b69deec289d2117d4a0104e0d6b466f474373e47575f7c999abc03a93ac726de482ce382eadeb65ae53be07369e15b00b49e35302ff173deaa1c0c85f4771b55d7ffaf8c95ef6860d6db157353910fac8f553b3ec72baf1eded3e719f0a24664057452178d15b2b608e5b2e6ff08202df75b78aa4108e029880c2904dc072b8a526c51717086cc221d25e4fb412e24958f04bd098bfbc824a4e3e33398d6b4d333cc8a077cd686927d22d70c8e8ce161835c7c9ff03b4441d583ce703c13cf84f418a61edd568d37275e110f83e3376c8f2aacb929fe9a11f3f5ed0fe29b5d605543eb2114e8790e25ca881ed8be90a227d251b32378f2b9bbda78af2181101226c2093703f75cee5e08585f509452f8550dc8dbffaf36848e4e3beb181496871b342258585f9ddc80128fd45be0bb1cad53fe1c57485a0a64da70cfb0552c77a73f3714494ddd8dae318011bdfc2e0e50303a1c383eba4f10e77d46f23a3349e4e75ff7f4662647de5719ac11be52de1e7d2d629f942f70f47a8de6786c3168aa20063d20ad3e6eb915a06c26ddd7810df17f6adf1c9eae516fc32cb393b53b18e717a39d58e7d20372100ab78f402a498bebe82922f790625031e6bd35fb96b4dbe9bb7a4766a39d6cfc3992989f82d6f4c38b6e6201cee260ed3ccef449abfe65ce746e306d81071bb60ab7e9ecb5f9bd22a749706126eeb2970858e95435696693bd084ab2c7818fccf0e99bf6cf7ee5cc596a52aed3f9d783632f2872078b43cb1f1fd6be169881d885d9fc8e0b99ae088a482b3df9706641229d763cd7bd6effa6c3339c601ea7cab74b2c0041f52c5e7b73cb9b7e9c0ac62d361e169a46239548c2fb2d4b6bc8bc7a1646c2c90f065db42cca52d63070094aac1c4d4059120fbe470a515b0d30398a58ae65257315d623e3d327026c07f03cfef29fc56bfd8502213b729785929cfc563306d2a8deb790706003ef79bfcd83e9217e47350cbdb411bc69e3f4b9556abd6d9c346a3eceec08ba80be782350b9fe2ec487dc52e3769c36ba0cc2faa79d47631bfb5f27cedc4abed7333fa2ca48251acddcd488a745cb3579a5f7442f023b960943b9643ffca2af5a519edd2f3921d9fb7374f8437d0047d3f957975fe9f514a7ca7eb06f6670489ceb4fec234a452086ab7ccaeb10ff9f76c668e2c283f42d4ae92809ad16bb79c1d4e538dbfee08b39da8b9a5bb2f1e95f1441a2dd930600c63889685654df484b25a30d8bfc8db2dccb9b6076bafe7882f0fea8c91b7241bfe43a9ab874073d2c13abe12421b91dfa0b3b03b50bcbf2611a1243f5e338f0144894890c283e031d6e64e62fe39495e31b09efc6ce5975f8f318c75df2a37ae6fb4461fc28effd13600ab5beb86a2c3c3fc691af812694f0c0a1be60db27863c7036a6b8e5a414644e77ea1907194e4233275414a194e2699faaa9179f7a6db8dbc48bfe811a1b4f7f5e926e6857d6a07e90bbd4fda3bfcc1eb3ea78fc81894ce972e3b7b11eca22e45e5c55a67120a10ed088908c26b2d8251fc93d86502eeea5cd8069735dfc5f116b10c9603857ddd18d5dab2c4a76d090bbca08a52fd4bf89162ff33a296e8ed4c11d24265abdbfc293b3652662c3f569cf30a85c7d181978015503ac375b6adf07c9d18ac300cc15937f4eb84eb048e651ed6c70311b5dd4c2badb7ea0b3fd758389d67d4f6b57bccd3cad1d26a0ba53a55b23c0eba5d5a039de82786cecc1f17c640a8b24f6d19f53b1b5aeadf4c864073161b466a5fe5e4b7a62606f438f78f27e31ac80c1f2081f4fcce093e2abc481c5f6af8fc1af146757406a33dfb532b454997345262c8aa28b304cb8c2a3cbd128ab6153866f7806f3098f7fccb438a012b7184f2ddf7b97f7ff3cf16e859b27dcbddb478e579d17c99fd48918a547b294499e9eedb80c7d0a805a00c8a7a17d67f4deebe2d07a7b96a77c8c7cd83f891dd1827640f2b384cc6d5531e9cd68671bc97ec18083a1ec4fc404097081b2b3b1d872dce957aa05e3b4d2c16ab45390b9cefb6985d4001cdef6969da5ee7490d70c47bdfc73dec872060a1c0de4f5512f0b3ab6d7fd4303f363eaed62744e0dafb99db02fbd216e22ad8df0dece1694cb6b0bcd08ea8b6701b3b6c8aa8f2ea8df1f347b2309dba7dcfc7b6ed029da929d740d71025079e23547280c6547d7788dbdc2335892187931f4001ee5dfe3fbd7c79e821e0e98a866224ebce5eadf9a8ac93ae831e97601e8b546beb02a9ee9d4264ae4083b4a230af1acde0c90ac501814b88a921e1c4dab3ed9c3e02a250f0632449db300592e7dca9e22afd0aa8eec9a61e8f121ca0362756b8cc1b9bd44c7075d34fa93ce9edda2aa78773b38c31317091c053913e1c1d1b975b37a64ff05c79fd76e113996193f7b13001df18cf7c15523168de6628efb3ea47bd54e9126d84f8a5a7c739d6e1f1c3eb6f19365189252703bd33c73e535973ba3006c215f5541fdaba28b2f7e71801b6a31162d1c84ba332177bfa720896ac3931052ed2eefa650d19463347ff4649b3fc2d36d8b8a4ed237d7217142af9761d3659d232a9218ab7e45d47f2e99d695355a6442ae97d10ca148d910e8343149cc004eddd0c9b62adc2965f6f73b77126589050e430494c33353074aa19c2cc50f0e6dc9fa4776f23d0c06a2c83feb06206b0727ce29686811702b540048f98da06b9d190ee14e9889c2fb7a8b680638fd0319fb50f2dc9f11a96048d58613b1a213f7fa31812e2a769cf2d3c251acf86f0d1de601d799baec518c7e3ab449549b8781ce40601e9f67c60be442dedf4fda4fc602a8ac35285684d9ff46fd8d435201e328384df0fb3eccb3d1bf07fcaaf792821b6fd06e07c6583db401c7dc90de4392cff8e100d9d42962df1c23235142c59e0d38c4724f71984acd498cb5a56cc19e1874f59b17398a4f707a109cefbca234033ce19749d2c3102bfd746d796bb5af8de91ec82d4904d91fb3de5fa1eb17b9ac7206206ce99ca186e0cc2199ecb2635e9c450a6d266d792f92eb02f9fda187945df953a554b83f9410bc9ef3354622810b46de255d409edf36d2315adc4b733130ba3f40a321d5abd43027facb118731ac78b4967950329ba7063aeacd5be05b40b3edcf53d074777527b77665bb34bf249306aa94942cc9ce230305b847538638e1724225a65491a89bba713cb999fae1574eed9d2b5b172a31d675a753863bbc79e31e8efc4191b0d24f3ac4fc971d270a98862174b5b387f9feeabdac7aadfcdc15c3786c642150a66cc38e93df6c26a8d4b71fe7c955ffa3cd008cded04a5020ff938ffc223c0341fcc01605811a55af499cb6bc8b056912cfa19f0b6966f871fb6d4bf9fed4b8a85ccf55190ef38d84a92ec563c3d7c4a47f2b0670ecfcbaf2f9ea6d044ba11fc033e4558f51ef961c6f072d24b1bd2d8c79d5d757c4583f7180e2cdb9dad4b04b88cc24a8351f5224a79178e784ab5d2903d6f52de6f9fd5d52902191cbd162da7232ed9115c3f07a92f5aba46bb840a81f9a9968b7c2cb1dc573b024b893db127c03e8581b5a9c74c0d97458ea655efe2272fc5ce5a538844d5a4dee97a72c098f54a6c3bc253aafe6193865e8df6834d10729c8d2920a89822a814745357a83caa75c55fba3f61c849223409ce5e14eb25f63c200d5522f7b1052ccdb847410c94ceafe8c0d9a235366aa21b3de9391ec8bcfdccabf73846788d22bde7aba83a1d25ca617b2e26f8648b89efc7d1a0fc421f4b4af67f2b48ae7d9ac45ba94ef0ae5c07c51d868400b2f35775c563f3ea6a6efb05392af0640eb786ea7cc3672baffd00e4446a620071f5a3417b8907447c342d19bd5f7b3532ed49129618aaf4f478ad6100fc7e695b7323eba135a787eea410ecb62d4afb936a8baf9211ba9a02643dbaa9119e042ac32b5bfea7a67cbb285c763a9bbfeed3981f413a48bff07a4b1eb1b56c0b81297d85f41e79f214385f26415818a2a62756048c0225892db0a31e76bbf4c5b02f96fba796fdcd8544e9998ebb896389276a21f0e705d5879d3c4f375f367bdcd8e450b3142f65cb5d5285a6c45eb38d198a692371df358de170a6c588f3678b017419e19e42cf2baeb628e7da2a2330028caee9ec6ce2bc9d8e6bd844d657541eb5b13801286c72086643bda7bc123153f9a6dc9d396895e0c0aaf2c6d43c6dcf8ecefefc7b74ae6212da5a7f7c2fb0f9e2592fcd439cdcc1ea9cbff0a830a7ee4a6396c3c646271f2a03ba8756488778780d395d8991f45a5f2665e662acd0fe92ebef04594fc3bb442c6487ac60db349252b55f0fe6d196c281976c75d4c0932a26acb61f88b8c4b703a11d935cacc5eb2f991afe92185663e9fcef0517eeae867800ba0a27022c8fa4fbc901b90133ff61c4d6fdb1e7d52bea9c8770d6b8b196cd602f91dbe52b33fa0be0a0c3e333d1a9b175a8fa50763de25a48d69c62cee3436ea8fc2db78bea4c30bcea66e0cf6d774de3b6e4f543f5976fec73bc6aed9ca769b8e1eaf97d15e40aaac17a0c35660fdf10c46030df80ae3594574402d960d24a2c5e401a6e1ba67d71627eca9a8272cf1436df98a86e69cb6e023ec55754c4203e14895e54cc70756a21a006673338591adf5eb8c147d18873e8f49e75b4325a1beebc9affe3b4d787ba2675294e08cd2ac189657d7b01c9fe3d1db0c1e71d2a2311169d2f2600edf9f1b19ed39b219f2a205db744b524988a6c75beae6eb6aea0cc493f390254d4134a63c1890cf2661546ed1a30d23729e147b405a09095856c441dca5bee64b22249cab0628e6f5482b8bbf1b962dc68f3badea9ed87a1a089b36f04a5bc091cb3a8f628ef7e237f39db5aea7951dab6c1291bd83ca376911b29823a9bd4a01fb9991c30d791e1fbfdc16a8b221c48689b201ba7389bb8531f3800d24dcdd8cd664b620edc761d41e971042160c57203a20328fc403c1fa927a73d19c9ea92e1e171e3f4eaf6ca4d965c13de01ca101ce5462c15cc14aca4ce4b546f61b721822f8fc1a84c3f4248337b37c2907806df5effb04386756d7677eb12984c836cc3e95afdf6a8a3209b40bb7186fc2df78e933215399aa77c0e0e4bbf1b04b0d53771a0c331630d18b9c6aa7311e38b7467559e0c89ef965086eb108119a7b3709f4e47d6b89987a1b67f1d9b16d9a7acb0c58658d75c451c928ed00c36af4389c39440f35c44f24801939bbd521c21584af73676f73a20df68dd219f874a257db11a9be883e084e40d66e68b96c6f5ed75da2d9dc6a5f6333e29a9460ea2334c636b871b3c47a75d875bf09537422ee492c158db54f5ce536eab84cf12c255226f6797dea07434585f72a5d519137e9f3f18f325e1833e678f73ba83ba4fa9d1d70925cc60b0f0309aa7b62c7cb9d2316e2475136f33d0a22d6891b1f8a87ffdddfdcb6d65de6d2604292267e1e2b872a6ced288c667422bec51db0094f46b95b6b195369cab678d2bb637deecd526b74111863e1f39a842f0234f5f7abc77c3c11659e4207409c8831c5f716122a4312c64a7fdcafd87fbde6c5149af6d8d53de207a1710ce7323cbf4f111aabb500a9d74af888da980b33415211f21c945fc1a800f34bebc75edc52ed5bd70960cbafe5344eee2650b6c5f90b363cb25a717cb305e3efb81c232e42d0ff3505f618e10dd512e5bdac5e81a1dfdace912bed4291bc6a1a48ca077d9809a6a2d8f10cb2471185ce6723d17ae7dbc3138aec405c2e7c39b0860c6802b16cd51e0bd921eafee6f5b263db94b558c3d7d7b82185
  
    
      
      
        请输入正确密码后查看
      
    
  

]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android逆向</tag>
      </tags>
  </entry>
  <entry>
    <title>自建VPN服务</title>
    <url>/2023/05/08/%E8%87%AA%E5%BB%BAVPN%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[服务端配置环境服务器系统：centos7.6外网IP：38.6.182.74内网IP：10.0.40.175开放端口：1194
准备工作# 关闭防火墙systemctl stop firewalldsystemctl disable firewalld# 关闭selinuxsed -i &#x27;s/enforcing/disabled/&#x27; /etc/selinux/configsetenforce 0# 安装依赖yum install -y  vim wget lrzsz gcc-c++ openssl openssl-devel net-tools lzo lzo-devel pam pam-devel# 下载安装包mkdir /tmp/installcd /tmp/installwget https://swupdate.openvpn.org/community/releases/openvpn-2.5.6.tar.gzwget https://github.com/OpenVPN/easy-rsa/releases/download/v3.0.8/EasyRSA-3.0.8.tgz
安装OpenVpn和EasyRSA安装OpenVpn# 进入安装包所在的目录cd /tmp/install# 在根目录中创建一个data目录mkdir /data# 解压OpenVpn软件包tar -zxvf openvpn-2.5.6.tar.gz# 进入解压后的目录cd openvpn-2.5.6# 安装OpenVpn到根目录/data/openvpn目录下./configure --prefix=/data/openvpn/# 编译make &amp;&amp; make install# 添加openvpn的环境变量echo -e &quot;PATH=\$PATH:/data/openvpn/sbin&quot; &gt;/etc/profile.d/openvpn256.sh# 加载环境变量source /etc/profile# 执行如下命令查看版本openvpn --version# 输出如下内容说明安装成功# OpenVPN 2.5.6 x86_64-pc-linux-gnu [SSL (OpenSSL)] [LZO] [LZ4] [EPOLL] [MH/PKTINFO] [AEAD] built on May  8 2023# library versions: OpenSSL 1.0.2k-fips  26 Jan 2017, LZO 2.06# Originally developed by James Yonan# Copyright (C) 2002-2022 OpenVPN Inc &lt;sales@openvpn.net&gt;# Compile time defines: enable_async_push=no enable_comp_stub=no enable_crypto_ofb_cfb=yes enable_debug=yes enable_def_auth=yes enable_dlopen=unknown enable_dlopen_self=unknown enable_dlopen_self_static=unknown enable_fast_install=yes enable_fragment=yes enable_iproute2=no enable_libtool_lock=yes enable_lz4=yes enable_lzo=yes enable_management=yes enable_multihome=yes enable_pam_dlopen=no enable_pedantic=no enable_pf=yes enable_pkcs11=no enable_plugin_auth_pam=yes enable_plugin_down_root=yes enable_plugins=yes enable_port_share=yes enable_selinux=no enable_shared=yes enable_shared_with_static_runtimes=no enable_small=no enable_static=yes enable_strict=no enable_strict_options=no enable_systemd=no enable_werror=no enable_win32_dll=yes enable_x509_alt_username=no with_aix_soname=aix with_crypto_library=openssl with_gnu_ld=yes with_mem_check=no with_sysroot=no
安装EasyRSA证书签发软件# 进入EasyRSA压缩文件存放的目录cd /tmp/install# 解压EasyRSAtar -zxvf EasyRSA-3.0.8.tgz# 将解压后的文件夹移动到根目录/data目录下mv EasyRSA-3.0.8 /data/EasyRSA
准备CA签发机构环境# 拷贝EasyRSA到OpenVpn目录中cp -r  /data/EasyRSA /data/openvpn/easy-rsa-servercd /data/openvpn/easy-rsa-server# 准备签发证书的默认变量文件egrep -v &quot;^$|^#&quot; vars.example &gt;vars# 编辑vars文件，修改默认ca证书以及服务器证书有效时间vim vars# 在文件尾添加如下两行内容set_var EASYRSA_CA_EXPIRE 36500     # ca证书修改有效期set_var EASYRSA_CERT_EXPIRE 3650    # 服务器证书修改有效期
创建CA机构与服务器证书创建CA机构# 进入OpenVpn目录中的easy-rsa-server文件夹cd /data/openvpn/easy-rsa-server# 初始化，执行此命令会生成pki目录./easyrsa init-pki# 创建CA机构，nopass代表不需要密码的意思./easyrsa build-ca nopass# 根据指引输入CA机构名，这里我用了rsa-xxinCommon Name (eg: your user, host, or server name) [Easy-RSA CA]:rsa-xxin# 如果创建成功，在pki目录下会出现一个ca.crt文件，和一个private目录，目录中包含了一个ca.key文件
创建服务端证书# 进入OpenVpn目录中的easy-rsa-server文件夹cd /data/openvpn/easy-rsa-server# 创建服务端证书，同时指定证书文件的文件名为openvpnserver./easyrsa gen-req openvpnserver nopass# 当提示如下时，按回车继续Common Name (eg: your user, host, or server name) [openvpnserver]:# 如果创建成功，将会提示如下# Keypair and certificate request completed. Your files are:# req: /data/openvpn/easy-rsa-server/pki/reqs/openvpnserver.req# key: /data/openvpn/easy-rsa-server/pki/private/openvpnserver.key# 并且在对应的目录下生成了openvpnserver.req请求文件和openvpnserver.key私钥文件
签发服务端证书# 这里的第一个server代表服务器，第二个openvpnserver则代表刚刚创建的服务端证书的名称./easyrsa sign server openvpnserver# 当出现如下提示时，输入yesType the word &#x27;yes&#x27; to continue, or any other input to abort.  Confirm request details:# 出现如下提示时，说明得到服务端的证书文件# Certificate created at: /data/openvpn/easy-rsa-server/pki/issued/openvpnserver.crt
创建交互密钥./easyrsa gen-dh# 出现如下提示时，说明得到交互密钥文件# DH parameters of size 2048 created at /data/openvpn/easy-rsa-server/pki/dh.pem# 启用安全增强配置openvpn --genkey tls-auth ta.key
OpenVPN服务端配置# 创建openvpn用户，使用该用户启动openVPNgroupadd openvpnuseradd -M -s /sbin/nologin -g openvpn openvpn# 创建证书存放目录mkdir /data/openvpn/certificate# 创建日志存放目录mkdir /data/openvpn/logschown openvpn.  /data/openvpn/logs# 将服务端证书秘钥和交互秘钥复制到certificate目录cp /data/openvpn/easy-rsa-server/pki/ca.crt /data/openvpn/certificate/cp /data/openvpn/easy-rsa-server/pki/issued/openvpnserver.crt  /data/openvpn/certificate/cp /data/openvpn/easy-rsa-server/pki/private/openvpnserver.key  /data/openvpn/certificate/cp /data/openvpn/easy-rsa-server/pki/dh.pem  /data/openvpn/certificate/cp /data/openvpn/easy-rsa-server/ta.key  /data/openvpn/certificate/# 添加配置文件，配置文件中的代码在下一个代码框中cd /data/openvpn/vim /data/openvpn/server.conf# 内核转发规则echo &quot;net.ipv4.ip_forward=1&quot; &gt;&gt;/etc/sysctl.confsysctl -p# iptablesNAT规则 # 这里的ip就是server.conf 中的server 10.8.0.0 255.255.255.0 ;添加转发规则到开机启动项echo &#x27;iptables -t nat -A POSTROUTING -s 10.8.0.0/24 -j MASQUERADE&#x27; &gt;&gt; /etc/rc.d/rc.localchmod +x /etc/rc.d/rc.local/etc/rc.d/rc.local
&ensp;&ensp;在配置文件server.conf中写入# 监听端口port 1194# 监听协议proto tcp# 采用路由隧道模式dev tun# ca证书文件ca /data/openvpn/certificate/ca.crt# 服务端证书文件cert /data/openvpn/certificate/openvpnserver.crt# 服务端私钥文件key /data/openvpn/certificate/openvpnserver.key# 密钥交换协议文件dh /data/openvpn/certificate/dh.pem# 安全增强文件，0是服务端，1是客户端tls-auth /data/openvpn/certificate/ta.key 0# 分配客户端IP的网段，不能和服务器一个网段，不能冲突server 10.8.0.0 255.255.255.0# 运行通讯的内网路由，访问目标是哪里，IP就怎么配置，可以多条push &quot;route 192.168.0.0 255.255.255.0&quot;# 客户端之间互相通信client-to-client# 会话检测，每十秒测试一下，超过120秒没回应就认为对方downkeepalive 10 120# 加密算法cipher AES-256-CBC# 压缩算法compress lz4-v2# 推送客户端使用lz4-v2算法push &quot;compress lz4-v2&quot;# 最大客户端数max-clients 100# 运行openvpn的用户和用户组user openvpngroup openvpn# 状态日志status  /data/openvpn/logs/openvpn-status.loglog-append /data/openvpn/logs/openvpn.log# 日志级别verb 3mute 20# 确保密钥文件在传输过程中不会被修改persist-key# 保持 TUN（传输用户数据）连接状态persist-tun
&ensp;&ensp;如果是访问外网的配置，在配置文件server.conf中写入# 监听地址local 0.0.0.0# 监听端口port 1194# 监听协议proto tcp# 采用路由隧道模式dev tun# ca证书文件ca /data/openvpn/certificate/ca.crt# 服务端证书文件cert /data/openvpn/certificate/openvpnserver.crt# 服务端私钥文件key /data/openvpn/certificate/openvpnserver.key# 密钥交换协议文件dh /data/openvpn/certificate/dh.pem# 安全增强文件，0是服务端，1是客户端tls-auth /data/openvpn/certificate/ta.key 0# 分配客户端IP的网段，不能和服务器一个网段，不能冲突server 10.8.0.0 255.255.255.0# 给网关push &quot;redirect-gateway def1 bypass-dhcp&quot;# dhcp分配dnspush &quot;dhcp-option DNS 8.8.8.8&quot;# 客户端之间互相通信client-to-client# 会话检测，每十秒测试一下，超过120秒没回应就认为对方downkeepalive 10 120# 加密算法cipher AES-256-CBC# 压缩算法compress lz4-v2# 推送客户端使用lz4-v2算法push &quot;compress lz4-v2&quot;# 最大客户端数max-clients 100# 运行openvpn的用户和用户组user openvpngroup openvpn# 状态日志status  /data/openvpn/logs/openvpn-status.loglog-append /data/openvpn/logs/openvpn.log# 日志级别verb 3mute 20# 确保密钥文件在传输过程中不会被修改persist-key# 保持 TUN（传输用户数据）连接状态persist-tun
启动OpenVPN# 创建启动文件，文件中的代码在下一个代码框中vim /etc/systemd/system/openvpn.service# 加载系统服务systemctl daemon-reload# 开机启动systemctl enable openvpn.service# 启动服务systemctl start openvpn.service# 查看服务运行状态systemctl status openvpn.service
&ensp;&ensp;在配置文件openvpn.service中写入[Unit]Description=OpenVPN ServerAfter=network.targetAfter=syslog.target[Install]WantedBy=multi-user.target[Service]ExecStart=/data/openvpn/sbin/openvpn --config /data/openvpn/server.conf
客户端文件配置首次添加客户端证书准备客户端证书创建客户端证书# 拷贝EasyRSA到OpenVpn目录中cp -r /data/EasyRSA /data/openvpn/easy-rsa-clientcd  /data/openvpn/easy-rsa-client# 初始化，执行此命令会生成pki目录./easyrsa init-pki# 创建客户端申请证书，同时指定证书文件的文件名为xxin./easyrsa gen-req xxin nopass# 当提示如下时，按回车继续# Common Name (eg: your user, host, or server name) [xxin]:# 如果创建成功，将会提示如下# Keypair and certificate request completed. Your files are:# req: /data/openvpn/easy-rsa-client/pki/reqs/xxin.req# key: /data/openvpn/easy-rsa-client/pki/private/xxin.key# 此时已经在reqs目录和private目录下生成了xxin.req请求文件和xxin.key私钥文件
签发客户端证书cd /data/openvpn/easy-rsa-server# 将客户端证书复制到CA工作目录，并指定证书名称为xxin，证书名称可以任意定义，复制到CA工作目录的客户端证书以指定的证书名称命名./easyrsa import-req /data/openvpn/easy-rsa-client/pki/reqs/xxin.req xxin# 当提示如下时，说明导入成功，客户端证书成功被复制到CA工作目录# Note: using Easy-RSA configuration from: /data/openvpn/easy-rsa-server/vars# Using SSL: openssl OpenSSL 1.0.2k-fips  26 Jan 2017# # The request has been successfully imported with a short name of: xxin# You may now use this name to perform signing operations on this request.# # 若提示如下，说明导入失败，CA工作目录下已经存在该证书文件# Note: using Easy-RSA configuration from: /data/openvpn/easy-rsa-server/vars# Using SSL: openssl OpenSSL 1.0.2k-fips  26 Jan 2017# # Easy-RSA error:## The input file does not appear to be a certificate request. Aborting import.# File Path: /data/openvpn/easy-rsa-client/pki/reqs/xxin.req# 设置客户端证书有效期，这里设置的是90天sed -i &quot;s/set_var EASYRSA_CERT_EXPIRE.*$/set_var EASYRSA_CERT_EXPIRE\t90/g&quot; ./vars# 签发名称为xxin的证书./easyrsa sign client xxin# 当提示如下时，输入yes# Type the word &#x27;yes&#x27; to continue, or any other input to abort.#   Confirm request details:# 证书签发成功# Certificate created at: /data/openvpn/easy-rsa-server/pki/issued/xxin.crt
准备客户端配置文件# 创建证书存放目录mkdir /data/openvpn/client/# 创建xxin目录，存放xxin的三张证书mkdir /data/openvpn/client/xxin# 复制证书find /data/openvpn/ \( -name &quot;xxin.key&quot; -o -name &quot;xxin.crt&quot; -o -name &quot;ca.crt&quot; -o -name &quot;ta.key&quot; \) -exec cp &#123;&#125;  /data/openvpn/client/xxin \;# 添加一个客户端配置文件，文件的代码在下一个代码框中vim /data/openvpn/client/xxin/client.ovpn
&ensp;&ensp;在配置文件client.ovpn中写入# 指定客户端client# 使用tun隧道传输协议dev tun# 使用tcp协议传输数据proto tcp# openvpn服务器IP地址和端口号remote 38.6.182.74 1194# 断线自动重新连接resolv-retry infinite# 不绑定本地特定的端口号nobind# 通过keepalive检测超时后，重新启动VPN，不重新读取keys，保留第一次使用的keyspersist-key# 检测超时后，重新启动VPN，一直保持tun是linkup的。否则网络会先linkdown然后再linkuppersist-tun# 指定CA证书的文件路径ca ca.crt# 指定当前客户端的证书文件路径cert xxin.crt# 指定当前客户端的私钥文件路径key xxin.key# 该验证服务器证书的有效性remote-cert-tls server# 启用 TLS-Auth身份验证，并指定了预共享密钥文件的路径tls-auth ta.key 1# 使用 AES-256-CBC 加密算法来加密传输的数据cipher AES-256-CBC# 指定日志文件的记录详细级别，可选0-9，等级越高日志内容越详细verb 3# 使用 LZ4-v2 算法对传输的数据进行压缩compress lz4-v2
继续添加客户端&ensp;&ensp;因为首次添加客户端时已经复制过RSA客户端目录了，所以这里一般不需要再次复制# 拷贝EasyRSA到OpenVpn目录中# 如果OpenVpn目录中已经拥有RSA客户端目录，则不需要执行拷贝cp -r /data/EasyRSA /data/openvpn/easy-rsa-client# 进入RSA客户端目录cd  /data/openvpn/easy-rsa-client
&ensp;&ensp;如果不是首次添加客户端，pki目录应该已经存在了。生成pki目录/data/openvpn/easy-rsa-client/pki# 初始化，执行此命令会生成pki目录# 如果RSA客户端目录下已经拥有pki目录，则不需要执行该操作./easyrsa init-pki
&ensp;&ensp;创建客户端申请证书# 创建客户端申请证书，同时指定证书文件的文件名为xxin-test./easyrsa gen-req xxin-test nopass# 将会提示如下内容，回车确定即可# Using SSL: openssl OpenSSL 1.0.2k-fips  26 Jan 2017# Generating a 2048 bit RSA private key# .............+++# ...+++# writing new private key to &#x27;/data/openvpn/easy-rsa-client/pki/easy-rsa-27870.RaCSZg/tmp.0a2NSo&#x27;# -----# You are about to be asked to enter information that will be incorporated# into your certificate request.# What you are about to enter is what is called a Distinguished Name or a DN.# There are quite a few fields but you can leave some blank# For some fields there will be a default value,# If you enter &#x27;.&#x27;, the field will be left blank.# -----# Common Name (eg: your user, host, or server name) [xxin-test]:# 确定后提示如下内容说明申请成功# Keypair and certificate request completed. Your files are:# req: /data/openvpn/easy-rsa-client/pki/reqs/xxin-test.req# key: /data/openvpn/easy-rsa-client/pki/private/xxin-test.key
&ensp;&ensp;签发证书# 进入到RSA服务端目录cd /data/openvpn/easy-rsa-server# 导入一个证书签名请求文件./easyrsa import-req /data/openvpn/easy-rsa-client/pki/reqs/xxin-test.req xxin-test# 设置客户端证书有效期，这里设置的是90天sed -i &quot;s/set_var EASYRSA_CERT_EXPIRE.*$/set_var EASYRSA_CERT_EXPIRE\t90/g&quot; ./vars# 签发证书./easyrsa sign client xxin-test# 当提示如下时，输入yes# Type the word &#x27;yes&#x27; to continue, or any other input to abort.#   Confirm request details:
&ensp;&ensp;复制xxin-test的证书到xxin-test存放证书的目录# 如果没有证书存放目录，则创建mkdir /data/openvpn/client/# 在证书存放目录中创建xxin-test目录，用于存放xxin-test的证书mkdir /data/openvpn/client/xxin-test# 复制xxin-test所需的证书到证书存放目录下xxin-test的目录中find /data/openvpn/ \( -name &quot;xxin-test.key&quot; -o -name &quot;xxin-test.crt&quot; -o -name &quot;ca.crt&quot; -o -name &quot;ta.key&quot; \) -exec cp &#123;&#125;  /data/openvpn/client/xxin-test \;
&ensp;&ensp;创建客户端配置文件# 在xxin-testd阿证书存放目录中，添加一个客户端配置文件，填入客户端配置vim /data/openvpn/client/xxin-test/client.ovpn
&ensp;&ensp;客户端配置clientdev tunproto tcpremote 38.6.182.74 1194resolv-retry infinitenobindpersist-keypersist-tunca ca.crtcert xxin-test.crtkey xxin-test.keyremote-cert-tls servertls-auth ta.key 1cipher AES-256-CBCverb 3compress lz4-v2
连接测试Windos端导入配置&ensp;&ensp;下载客户端所需证书和配置文件cd /data/openvpn/client/tar -zcvf xxin.tar.gz xxinsz xxin.tar.gz
安装客户端https://swupdate.openvpn.org/community/releases/openvpn-install-2.4.5-I601.exe
&ensp;&ensp;将xxin.tar.gz解压，并将其中的文件放置在openvpn客户端目录的config目录中
&ensp;&ensp;以管理员身份运行→右击客户端任务图标→connect连接
&ensp;&ensp;访问试一下
Linux端安装客户端sudo yum install openvpn
导入配置&ensp;&ensp;将配置文件和证书放置在目录/etc/openvpn/client下，client.ovpn中证书路径的配置与以往有些不同clientdev tunproto tcpremote 38.6.182.74 1194resolv-retry infinitenobindpersist-keypersist-tunca /etc/openvpn/client/ca.crtcert /etc/openvpn/client/xxin-linux.crtkey /etc/openvpn/client/xxin-linux.keyremote-cert-tls servertls-auth /etc/openvpn/client/ta.key 1cipher AES-256-CBCverb 3compress lz4-v2
连接到VPN&ensp;&ensp;运行如下命令连接到openvpnsudo openvpn --config /etc/openvpn/client/client.ovpn
停止连接&ensp;&ensp;”Ctrl+C”或者查找openvpn进程pidps aux | grep openvpn# user     12345  0.0  0.0  12345  6789 ?        S    12:34   0:00 openvpn --config /etc/openvpn/client/client.ovpn
&ensp;&ensp;然后杀死进程sudo kill 12345
手机端下载软件这个版本是一个相当稳定好用的版本OpenVPN Connect_3.1.0:https://lxx6.lanzoum.com/ixPa80ywom4h
导入配置&ensp;&ensp;下载配置文件，例如通过浏览器下载压缩的配置文件之后，在文件管理Download文件夹中将其解压
&ensp;&ensp;下图解压后得到song-phone文件夹，包含如下配置文件
&ensp;&ensp;打开OpenVPN Connect，点击加号导入配置文件
&ensp;&ensp;进入Download→song-phone文件夹，选择clien.ovpn文件，点击底部IMPORT
&ensp;&ensp;点击右上角ADD
&ensp;&ensp;导入成功，打开开关即可连接。首次连接如遇卡顿，关闭软件重新打开
搭建参考
Centos7安装openvp-超详细
完整CentOS搭建企业OpenVPN服务详细教程

]]></content>
      <categories>
        <category>菜鸡手记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>记录一次发布jitpack</title>
    <url>/2024/01/29/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E5%8F%91%E5%B8%83jitpack/</url>
    <content><![CDATA[&ensp;&ensp;我超tmd，这个gradle 8.x有问题，我使用的gradle版本是8.0，gradle插件版本是8.0.2，使用./gradlew publishToMavenLocal命令根本就生成不了aar文件，只有一个pom文件，jitpack也只生成了如下的一些文件，但是没有aar！
Files: com/github/xxinPro/FileSelector/v1.0com/github/xxinPro/FileSelector/v1.0/FileSelector-v1.0-sources.jarcom/github/xxinPro/FileSelector/v1.0/FileSelector-v1.0.pomcom/github/xxinPro/FileSelector/v1.0/FileSelector-v1.0.pom.md5com/github/xxinPro/FileSelector/v1.0/FileSelector-v1.0.pom.sha1com/github/xxinPro/FileSelector/v1.0/build.log
&ensp;&ensp;jitpack官方也迟迟未更新gradle 8.x的文档，所以后面我把gradle版本换成了7.6，gradle插件版本换成了7.4.2
打包arr&ensp;&ensp;最一开始，我无法使用./gradlew assembleRelease命令打包release版aar，只能打包debug版，并且在右侧gradle操作栏中也没有assembleRelease的选项，如下

&ensp;&ensp;关掉设置中的这个选项之后恢复正常

&ensp;&ensp;关掉之后点sync同步一下

&ensp;&ensp;双击模块中的assembleRelease，生成一个release版aar包

本地调试&ensp;&ensp;在模块gradle文件中引入maven-publish插件
plugins &#123;    ...    id &#x27;maven-publish&#x27;&#125;
&ensp;&ensp;指明在本地maven库中的插件的引入方式，指明后通过groupId:artifactId:version的方式在其他模块引用&ensp;&ensp;在from components.release这里，grafle 8.x根本就没办法调用这个release，只能通过from components.findName(&#39;release&#39;)
afterEvaluate &#123;    publishing &#123;        publications &#123;            release(MavenPublication) &#123;                from components.release                groupId = &#x27;com.github.xxinPro&#x27;  // 用户名                artifactId = &#x27;FileSelector&#x27;     // 仓库名                version = &#x27;1.0&#x27;                 // 版本            &#125;        &#125;    &#125;&#125;
&ensp;&ensp;需要注意的是，引用本地maven库中的插件之前，得先添加本地maven库的支持
pluginManagement &#123;    repositories &#123;        mavenLocal()    // 本地maven仓库        google()        mavenCentral()        gradlePluginPortal()        maven &#123; url &#x27;https://jitpack.io&#x27; &#125;    &#125;&#125;dependencyResolutionManagement &#123;    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)    repositories &#123;        mavenLocal()    // 本地maven仓库        google()        mavenCentral()        maven &#123; url &#x27;https://jitpack.io&#x27; &#125;    &#125;&#125;
&ensp;&ensp;在以上的配置输入完毕之后，点sync同步一下，然后打开gradle侧边栏可以看到多了publishing选项，打开该选项并双击publishToMavenLocal，会生成aar文件并提交至本地maven仓库，默认的路径是C:\Users\.m2\repository\目录

&ensp;&ensp;然后可以在其他模块中引用，如果在本地引用没问题，一般情况下发布到jitpack后也没什么问题
implementation &#x27;com.github.xxinPro:FileSelector:1.0&#x27;
发布gitpack&ensp;&ensp;通过项目根目录的jitpack.yml文件，可以指定jitpack构建项目使用的jdk版本，如下指定jitpack使用jdk 11
jdk:  - openjdk11
&ensp;&ensp;将项目上传到github、gitee等仓库，如何上传不再赘述，上传成功之后创建一个release&ensp;&ensp;打开jitpack，输入github用户名/仓库名，查找刚刚上传的仓库

&ensp;&ensp;点击Get it，将开始构建该仓库，等待构建完毕之后查看jitpack提供的Log，若Log中无错误，则说明发布成功，再次点击Get it即可获取引入方式

参考：https://blog.csdn.net/H_O_W_E/article/details/125208062https://blog.csdn.net/cmmboy1990/article/details/124382540
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android开发手记</tag>
      </tags>
  </entry>
  <entry>
    <title>记录一次小米刷机</title>
    <url>/2023/02/14/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E5%B0%8F%E7%B1%B3%E5%88%B7%E6%9C%BA/</url>
    <content><![CDATA[目标机型：Redmi Note 4X
准备工作
申请解锁bl并下载解锁工具：http://www.miui.com/unlock/index.html
MiFlash下载：https://cdn.alsgp0.fds.api.mi-img.com/micomm/MiFlash2020-3-14-0.rar
ROM包下载：https://roms.miuier.com/zh-cn/devices/mido/

解锁BL&ensp;&ensp;1.进入手机设置 → 开发者选项 → 设备解锁状态，如果显示“当前设备已锁定，手机数据处于安全状态”，说明设备没有解锁
&ensp;&ensp;2.先将手机号与设备绑定，关闭wifi打开数据网络，点击底部“绑定账号和设备”
&ensp;&ensp;3.下载BL解锁工具：http://www.miui.com/unlock/index.html
&ensp;&ensp;4.解压缩并启动miflash_unlock.exe，并使用刚刚绑定的手机号登陆
&ensp;&ensp;5.手机关机后，长按“开机键”和“音量减”，进入fastboot页面，并使用数据线连接电脑
&ensp;&ensp;6.在解锁工具中点击右上角设置，点击驱动检测，给手机安装驱动
&ensp;&ensp;7.驱动安装完毕后，点击解锁 → 确认解锁，注意：整个过程中务必确保数据线的连接
&ensp;&ensp;8.解锁成功后，点击重启手机
&ensp;&ensp;9.开机后进入手机设置 → 开发者选项 → 设备解锁状态，此时可以看到，设备已经解锁成功
开始刷机&ensp;&ensp;1.下载MiFlash，下载目标ROM，在MiFlash中选中解压后的ROM包
&ensp;&ensp;2.手机进入fastboot页面，数据线连接电脑，然后点击“加载设备”，确定设备成功加载后点击“刷机”
&ensp;&ensp;3.刷机过程中，千万不要断开数据线连接
&ensp;&ensp;4.成功后重启手机即可
解system锁&ensp;&ensp;开发版系统刷入之后，虽然可以开启root权限，但目前只是半root，并不能安装Xposed环境，所以需要解锁system文件夹，在红米 Note 4X的设备中，只需要使用以下命令即可
adb root # 获取root权限adb disable-verity # 主要是这一句解锁systemadb reboot # 重启
&ensp;&ensp;注意，运行上面的命令需要ADB工具
]]></content>
      <categories>
        <category>菜鸡手记</category>
      </categories>
      <tags>
        <tag>刷机</tag>
      </tags>
  </entry>
  <entry>
    <title>记录一次接入Sophix热修复</title>
    <url>/2022/09/23/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E6%8E%A5%E5%85%A5Sophix%E7%83%AD%E4%BF%AE%E5%A4%8D/</url>
    <content><![CDATA[Android 统一接入&ensp;&ensp;打开阿里云EMAS新建一个项目，填入项目名
&ensp;&ensp;点击添加应用，添加一个新应用，填入应用信息
&ensp;&ensp;填写完毕之后点击下一步，下载这个配置文件
&ensp;&ensp;这里可能因为Android Studio版本的问题，我将配置文件放置于根目录之后报错了，移动到项目根目录的app目录下解决了问题
&ensp;&ensp;这里因为我们只需要热修复，所以在配置文件中关掉其他功能选项，需要仔细注意配置文件中hotfix_service的version，添加热修复依赖时要确保版本一致&#123;  &quot;config&quot;: &#123;	&quot;emas.appKey&quot;:&quot;appKey&quot;,	&quot;emas.appSecret&quot;:&quot;appSecret&quot;,	&quot;emas.packageName&quot;:&quot;packageName&quot;,	&quot;hotfix.idSecret&quot;:&quot;idSecret&quot;,	&quot;hotfix.rsaSecret&quot;:&quot;rsaSecret&quot;,	&quot;httpdns.accountId&quot;:&quot;accountId&quot;,	&quot;httpdns.secretKey&quot;:&quot;secretKey&quot;,	&quot;appmonitor.tlog.rsaSecret&quot;:&quot;rsaSecret&quot;,	&quot;appmonitor.rsaSecret&quot;:&quot;rsaSecret&quot;&#125;,  &quot;services&quot;: &#123;	&quot;hotfix_service&quot;:&#123;		&quot;status&quot;:1,		&quot;version&quot;:&quot;3.3.8&quot;	&#125;,	&quot;ha-adapter_service&quot;:&#123;		&quot;status&quot;:0,		&quot;version&quot;:&quot;1.1.5.3-open&quot;	&#125;,	&quot;feedback_service&quot;:&#123;		&quot;status&quot;:0,		&quot;version&quot;:&quot;3.3.9&quot;	&#125;,	&quot;tlog_service&quot;:&#123;		&quot;status&quot;:0,		&quot;version&quot;:&quot;1.1.4.4-open&quot;	&#125;,	&quot;httpdns_service&quot;:&#123;		&quot;status&quot;:0,		&quot;version&quot;:&quot;2.3.0-intl&quot;	&#125;,	&quot;apm_service&quot;:&#123;		&quot;status&quot;:0,		&quot;version&quot;:&quot;1.1.0.0-open&quot;	&#125;,	&quot;man_service&quot;:&#123;		&quot;status&quot;:0,		&quot;version&quot;:&quot;1.2.7&quot;	&#125;,	&quot;cps_service&quot;:&#123;		&quot;status&quot;:0,		&quot;version&quot;:&quot;3.7.7&quot;	&#125;&#125;,  &quot;use_maven&quot;:true,  &quot;proguard_keeplist&quot;:&quot;proguard_keeplist&quot;&#125;
&ensp;&ensp;然后点击下一步，继续依照指示，在工程的build.gradle文件下添加阿里云热修复仓库和emas-services插件，我的build.gradle文件此时如下
// Top-level build file where you can add configuration options common to all sub-projects/modules.buildscript &#123;    repositories &#123;        maven &#123; url &#x27;https://maven.aliyun.com/repository/public&#x27; &#125;        maven &#123; url &#x27;https://maven.aliyun.com/repository/google&#x27; &#125;        maven &#123; url &#x27;https://maven.aliyun.com/repository/jcenter&#x27; &#125;        // 阿里云热修复仓库        maven &#123; url &#x27;https://maven.aliyun.com/nexus/content/repositories/releases&#x27; &#125;        maven &#123; url &quot;https://jitpack.io&quot; &#125;        // jcenter()        // google()        mavenCentral()    &#125;    dependencies &#123;        classpath &#x27;com.android.tools.build:gradle:4.2.2&#x27;        // 添加emas-services插件        classpath &#x27;com.aliyun.ams:emas-services:1.0.4&#x27;    &#125;&#125;allprojects &#123;    repositories &#123;        maven &#123; url &#x27;https://maven.aliyun.com/repository/public&#x27; &#125;        maven &#123; url &#x27;https://maven.aliyun.com/repository/google&#x27; &#125;        maven &#123; url &#x27;https://maven.aliyun.com/repository/jcenter&#x27; &#125;        // 阿里云热修复仓库        maven &#123; url &#x27;https://maven.aliyun.com/nexus/content/repositories/releases&#x27; &#125;        maven &#123; url &quot;https://jitpack.io&quot; &#125;        // jcenter()        // google()        mavenCentral()    &#125;&#125;task clean(type: Delete) &#123;    delete rootProject.buildDir&#125;

然后在app级的build.gradle中，在apply plugin: &#39;com.android.application&#39;的下一行插入apply plugin: &#39;com.aliyun.ams.emas-services&#39;apply plugin: &#x27;com.android.application&#x27;// 引用emas-services插件apply plugin: &#x27;com.aliyun.ams.emas-services&#x27;
SDK稳健接入&ensp;&ensp;添加依赖，这里注意一下热修复依赖的版本要和配置文件中的版本一样dependencies &#123;    implementation &#x27;com.aliyun.ams:alicloud-android-hotfix:3.3.8&#x27;&#125;
&ensp;&ensp;关闭instant run，在新版本的Android Studio中已经没有了instant run，将同级目录下的hot-swap关闭即可

使用android studio打包生成apk时，要关闭instant run。
使用gradle plugin版本高于4.2时，可能会自动开启资源优化。开启资源优化后，资源名称被混淆，会导致补丁工具在生成补丁时一直卡在”开始构建补丁…..”，无法正常解析apk包。解决方案：在gradle.properties 中新增android.enableResourceOptimizations=false，重新生成基线包和修复包，然后再生成补丁。

&ensp;&ensp;添加应用权限&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot;/&gt;
&ensp;&ensp;配置AndroidManifest文件&lt;meta-dataandroid:name=&quot;com.taobao.android.hotfix.IDSECRET&quot;android:value=&quot;App ID&quot; /&gt;&lt;meta-dataandroid:name=&quot;com.taobao.android.hotfix.APPSECRET&quot;android:value=&quot;App Secret&quot; /&gt;&lt;meta-dataandroid:name=&quot;com.taobao.android.hotfix.RSASECRET&quot;android:value=&quot;RSA密钥&quot; /&gt;
&ensp;&ensp;混淆配置#基线包使用，生成mapping.txt-printmapping mapping.txt#生成的mapping.txt在app/build/outputs/mapping/release路径下，移动到/app路径下#修复后的项目使用，保证混淆结果一致#-applymapping mapping.txt#hotfix-keep class com.taobao.sophix.**&#123;*;&#125;-keep class com.ta.utdid2.device.**&#123;*;&#125;#防止inline-dontoptimize
初始化&ensp;&ensp;这里我创建了一个TickSophixApplication类继承SophixApplication，将，并将清单文件中application标签的name改成了TickSophixApplication，原有的Application通过注解的方式添加在TickSophixApplication中@Keep@SophixEntry(TickApplication.class)static class RealApplicationStub &#123;&#125;
&ensp;&ensp;而初始化热修复功能，官方建议在attachBaseContext()中进行，这里请注意，AppConfig.isDebugMode是我在其它类中自定义的一个boolean值@Overrideprotected void attachBaseContext(Context base) &#123;    super.attachBaseContext(base);    // 如果需要使用MultiDex，需要在此处调用。    // MultiDex.install(this);    initSophix();&#125;private void initSophix() &#123;    private void initSophix() &#123;    // 这个版本名用于在控制台控制热更新的版本，千万不要弄错    String appVersion = &quot;XL.1.9.63&quot;;    try &#123;        PackageInfo packageInfo = getPackageManager().getPackageInfo(this.getPackageName(), 0);        appVersion = packageInfo.versionName;    &#125; catch (PackageManager.NameNotFoundException e) &#123;        e.printStackTrace();    &#125;    // 灰度发布标签    List&lt;String&gt; tags = new ArrayList&lt;&gt;();    if (AppConfig.isDebugMode)&#123; // 当前是否是调试模式        tags.add(&quot;debug&quot;);   // 调试版    &#125; else &#123;        tags.add(&quot;release&quot;); // 发布版    &#125;    SophixManager instance = SophixManager.getInstance();    instance.setContext(this) // 传入入口Application即可            .setAppVersion(appVersion) // 应用的版本号，拉取补丁时对应控制台创建的版本。            .setSecretMetaData(&quot;IDSECRET&quot;, &quot;APPSECRET&quot;, &quot;RSASECRET&quot;) // 三个Secret分别对应清单文件中的三个参数，填入后清单文件中的参数将不在生效            .setEnableDebug(AppConfig.isDebugMode) // isEnabled默认为false，是否打开调试模式            .setEnableFullLog()            // .setAesKey() // 用户自定义aes密钥，会对补丁包采用对称加密，暂不开启            .setPatchLoadStatusStub(new PatchLoadStatusListener() &#123; // 设置patch加载状态监听器                /**                 * PatchLoadStatusListener接口                 * 该接口需要自行实现并传入initialize方法中，补丁加载状态会回调给该接口，参数说明如下：                 *                 * @param mode 无实际意义，为了兼容老版本，默认始终为0                 * @param code 补丁加载状态码，详情查看PatchStatus类说明                 * @param info 补丁加载详细说明                 * @param handlePatchVersion 当前处理的补丁版本号，0：无；-1：本地补丁；其它：后台补丁                 */                @SuppressLint(&quot;LongLogTag&quot;)                @Override                public void onLoad(final int mode, final int code, final String info, final int handlePatchVersion) &#123;                    if (code == PatchStatus.CODE_LOAD_SUCCESS) &#123; // 热修复补丁加载成功                        Log.i(TAG, &quot;onLoad: sophix load patch success!&quot;);                    &#125; else if (code == PatchStatus.CODE_LOAD_RELAUNCH) &#123; // sophix预加载补丁成功。重新启动应用程序以生效                        // 如果需要在后台重启，建议此处用SharePreference保存状态。                        Log.i(TAG, &quot;sophix preload patch success. restart app to make effect.&quot;);                    &#125;                &#125;            &#125;)            .setTags(tags) // 设置灰度标签            .initialize(); // 该方法主要做些必要的初始化工作以及如果本地有补丁的话会加载补丁&#125;
&ensp;&ensp;检查热修复时，只需要调用// 查询服务器是否有新的可用补丁 如果查询到可用的话，首先下载补丁到本地，然后：// 应用原本没有补丁，那么如果当前应用的补丁是热补丁，那么会立刻加载（不管是冷补丁还是热补丁）。如果当前应用的补丁是冷补丁，那么需要重启生效。// 应用已经存在一个补丁，请求发现有新补丁后，本次不受影响。并且在下次启动时补丁文件删除，下载并预加载新补丁，在下次启动时应用新补丁。SophixManager.getInstance().queryAndLoadNewPatch();
&ensp;&ensp;整体看一下TickSophixApplicationd的代码/** * Sophix入口类，专门用于初始化Sophix，不应包含任何业务逻辑。 * 此类必须继承自SophixApplication，onCreate方法不需要实现。 * 此类不应与项目中的其他类有任何互相调用的逻辑，必须完全做到隔离。 * AndroidManifest中设置application为此类，而SophixEntry中设为原先Application类。 * 注意原先Application里不需要再重复初始化Sophix，并且需要避免混淆原先Application类。 * 如有其它自定义改造，请咨询官方后妥善处理。 */public class TickSophixApplication extends SophixApplication &#123;    private static final String TAG = &quot;TickSophixApplication(xxin)&quot;;    /**     * 此处SophixEntry应指定真正的Application，并且保证RealApplicationStub类名不被混淆。     */    @Keep    @SophixEntry(TickApplication.class)    static class RealApplicationStub &#123;    &#125;    @Override    protected void attachBaseContext(Context base) &#123;        super.attachBaseContext(base);        // 如果需要使用MultiDex，需要在此处调用。        // MultiDex.install(this);        initSophix();    &#125;    private void initSophix() &#123;        private void initSophix() &#123;        // 这个版本名用于在控制台控制热更新的版本，千万不要弄错        String appVersion = &quot;XL.1.9.63&quot;;        try &#123;            PackageInfo packageInfo = getPackageManager().getPackageInfo(this.getPackageName(), 0);            appVersion = packageInfo.versionName;        &#125; catch (PackageManager.NameNotFoundException e) &#123;            e.printStackTrace();        &#125;        // 灰度发布标签        List&lt;String&gt; tags = new ArrayList&lt;&gt;();        if (AppConfig.isDebugMode)&#123; // 当前是否是调试模式            tags.add(&quot;debug&quot;);   // 调试版        &#125; else &#123;            tags.add(&quot;release&quot;); // 发布版        &#125;        SophixManager instance = SophixManager.getInstance();        instance.setContext(this) // 传入入口Application即可                .setAppVersion(appVersion) // 应用的版本号，拉取补丁时对应控制台创建的版本。                .setSecretMetaData(&quot;IDSECRET&quot;, &quot;APPSECRET&quot;, &quot;RSASECRET&quot;) // 三个Secret分别对应清单文件中的三个参数，填入后清单文件中的参数将不在生效                .setEnableDebug(AppConfig.isDebugMode) // isEnabled默认为false，是否打开调试模式                .setEnableFullLog()                // .setAesKey() // 用户自定义aes密钥，会对补丁包采用对称加密，暂不开启                .setPatchLoadStatusStub(new PatchLoadStatusListener() &#123; // 设置patch加载状态监听器                    /**                     * PatchLoadStatusListener接口                     * 该接口需要自行实现并传入initialize方法中，补丁加载状态会回调给该接口，参数说明如下：                     *                     * @param mode 无实际意义，为了兼容老版本，默认始终为0                     * @param code 补丁加载状态码，详情查看PatchStatus类说明                     * @param info 补丁加载详细说明                     * @param handlePatchVersion 当前处理的补丁版本号，0：无；-1：本地补丁；其它：后台补丁                     */                    @SuppressLint(&quot;LongLogTag&quot;)                    @Override                    public void onLoad(final int mode, final int code, final String info, final int handlePatchVersion) &#123;                        if (code == PatchStatus.CODE_LOAD_SUCCESS) &#123; // 热修复补丁加载成功                            Log.i(TAG, &quot;onLoad: sophix load patch success!&quot;);                        &#125; else if (code == PatchStatus.CODE_LOAD_RELAUNCH) &#123; // sophix预加载补丁成功。重新启动应用程序以生效                            // 如果需要在后台重启，建议此处用SharePreference保存状态。                            Log.i(TAG, &quot;sophix preload patch success. restart app to make effect.&quot;);                        &#125;                    &#125;                &#125;)                .setTags(tags) // 设置灰度标签                .initialize(); // 该方法主要做些必要的初始化工作以及如果本地有补丁的话会加载补丁    &#125;&#125;
发布补丁包&ensp;&ensp;在补丁管理中创建添加软件版本，这里的版本应与SophixManager初始化时setAppVersion方法中传递的版本一致
&ensp;&ensp;下载打包工具，生成补丁，windows打包工具（其他系统请自行下载）&ensp;&ensp;选择旧的基准包和修改后的新包，在高级选项中取消勾选“检查初始化”，点击“Go”开始生成补丁包
&ensp;&ensp;将生成的补丁包上传EMAS并发布即可
参考EMAS Android 统一接入SDK稳健接入快速入门SDK API
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android开发手记</tag>
      </tags>
  </entry>
  <entry>
    <title>记录一次破解闪照</title>
    <url>/2022/02/03/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E7%A0%B4%E8%A7%A3%E9%97%AA%E7%85%A7/</url>
    <content><![CDATA[妈了个巴子的，白瞎我两天时间，气死
闪照储存位置&ensp;&ensp;&ensp;&ensp;首先得找到闪照的文件储存的位置，这个过程相当繁琐，不再列举，直接把缓存的储存位置贴在下面/storage/emulated/0/Android/data/com.tencent.mobileqq/Tencent/MobileQQ/chatpic/chatimg/
&ensp;&ensp;&ensp;&ensp;在这个路径的文件夹下，有许多的子文件夹，子文件夹中的文件，就是闪照图片加密后的文件了
读取加密文件&ensp;&ensp;&ensp;&ensp;以十六进制读取加密后的文件，可以看到字节流以“ENCRYPT:”开头
&ensp;&ensp;&ensp;&ensp;推己及人，如果是我开发这个程序，绝对会在读取加密文件的数据流时，在代码中判断与”ENCRYPT:”.getBytes(“UTF-8”)相同的流，那么也就是说在smali代码中很大可能通过”ENCRYPT:”这个字符串找到相应的解密方法&ensp;&ensp;&ensp;&ensp;果然，在com.tencent.mobileqq.utils.DESUtils类中找到了它，顺便发现了闪照文件的加密方式，DES加密&ensp;&ensp;&ensp;&ensp;那么可以推断，查看闪照时，程序读取加密文件的字节流并删除掉”ENCRYPT:”，然后通过Key进行DES解密，先编写DES解密方法吧

DES解密和加密&ensp;&ensp;&ensp;&ensp;DES是一种过时的加密方式，不够安全，不过用在这里好像恰到好处。。。
&ensp;&ensp;&ensp;&ensp;解密方法，只要向方法中传入需要解密的文件路径和解密的Key即可    /**     * DES加密文件解密     * @param filePath 加密文件的路径     * @param key 密钥     */    private static void decrypt(String filePath,Key key) throws IOException, NoSuchPaddingException, NoSuchAlgorithmException, InvalidKeyException &#123;        File fromFile = new File(filePath); //已经加密的文件        File toFile = new File(filePath + &quot;_decrypt.png&quot;); //解密的文件的路径        Cipher cipher = Cipher.getInstance(&quot;DES&quot;);        cipher.init(Cipher.DECRYPT_MODE,key); //使用密钥解密        //加密文件文件头字节流        byte[] encryptBytes = &quot;ENCRYPT:&quot;.getBytes(&quot;UTF-8&quot;);        if (fromFile.exists())&#123;            InputStream inputStream = new FileInputStream(fromFile);            OutputStream outputStream = new FileOutputStream(toFile);            CipherOutputStream cipherOutputStream = new CipherOutputStream(outputStream,cipher);            byte[] buffer = new byte[1024];            int len;            int i = 0;            while ((len = inputStream.read(buffer)) &gt;= 0)&#123;//                输出流中跳过加密文件头                if (i == 0)&#123;                    cipherOutputStream.write(buffer, encryptBytes.length, len-encryptBytes.length);                &#125;                else &#123;                    cipherOutputStream.write(buffer, 0, len);                &#125;                i++;            &#125;            inputStream.close();            outputStream.close();            cipherOutputStream.close();        &#125;        else &#123;            System.out.println(&quot;文件不存在&quot;);        &#125;    &#125;
&ensp;&ensp;&ensp;&ensp;加密方法，有解密就顺手把加密放出来吧/** * DES加密文件 * @param filePath 需要加密的文件的路径 * @param key 密钥 */private static void encrypt(String filePath,Key key) throws IOException, NoSuchPaddingException, NoSuchAlgorithmException, InvalidKeyException &#123;    File fromFile = new File(filePath); //未加密的文件    File toFile = new File(filePath + &quot;_encrypt&quot;); //加密的文件    Cipher cipher = Cipher.getInstance(&quot;DES&quot;);    cipher.init(Cipher.ENCRYPT_MODE,key); //使用密钥加密    if (fromFile.exists())&#123;        InputStream inputStream = new FileInputStream(fromFile);        OutputStream outputStream = new FileOutputStream(toFile);        CipherInputStream cipherInputStream = new CipherInputStream(inputStream,cipher);        byte[] buffer = new byte[1024];        int len;        while ((len = cipherInputStream.read(buffer)) &gt; 0) &#123;            outputStream.write(buffer, 0, len);        &#125;        inputStream.close();        outputStream.close();        cipherInputStream.close();    &#125;    else &#123;        System.out.println(&quot;文件不存在&quot;);    &#125;&#125;
&ensp;&ensp;&ensp;&ensp;获取密钥的方式，计算方式有很多种，我只不过是为了测试程序可行性临时写了一个/** * 根据参数生成密钥 * @param encodeKey key字符串参数 * @return key对象 */private static Key getKey(String encodeKey)&#123;    KeyGenerator key = null;    try &#123;        key = KeyGenerator.getInstance(&quot;DES&quot;);        key.init(new SecureRandom(encodeKey.getBytes()));    &#125; catch (NoSuchAlgorithmException e) &#123;        e.printStackTrace();    &#125;    assert key != null;    return key.generateKey();&#125;
&ensp;&ensp;&ensp;&ensp;万事具备，只欠解密的Key
获取Key对象&ensp;&ensp;&ensp;&ensp;通过这个输入流可以看到，它是在进行DES解密，并通过SecretKeySpec创建DES解密的Key对象；
&ensp;&ensp;&ensp;&ensp;在this(a(paramArrayOfByte),”DES”)中，虽然不知道a(paramArrayOfByte)是什么玩意儿，传入一个byte[]再返回一个byte[]，，，不过它一定是必要的public static byte[] a(byte[] paramArrayOfbyte) &#123;  byte[] arrayOfByte = new byte[8];  if (8 &gt; paramArrayOfbyte.length) &#123;    System.arraycopy(paramArrayOfbyte, 0, arrayOfByte, 0, paramArrayOfbyte.length);  &#125; else &#123;    System.arraycopy(paramArrayOfbyte, 0, arrayOfByte, 0, 8);  &#125;   return arrayOfByte;&#125;
&ensp;&ensp;&ensp;&ensp;然后去找a(paramArrayOfByte)所用到的paramArrayOfByte，它是方法的第三个参数，向上查找，发现当前类中重载的a方法调用了它，继续向上查找public static void a(String str, String str2) &#123;    try &#123;        if (!a(str)) &#123;            long currentTimeMillis = System.currentTimeMillis();            File file = new File(str);            long length = file.length() / 1024;            File file2 = new File(str + &quot;.tmp&quot;);            if (file2.exists()) &#123;                file2.delete();            &#125;            //调用            a(file, file2, str2.getBytes(&quot;UTF-8&quot;));            FileUtils.copyFile(file2, file);            file2.delete();            if (QLog.isDevelopLevel()) &#123;                QLog.d(&quot;DESUtil&quot;, 4, &quot;DES Encrypt filePath:&quot; + str + &quot;,key:&quot; + str2 + &quot;,costTime:&quot; + (System.currentTimeMillis() - currentTimeMillis) + &quot;,fileSize:&quot; + length + &quot;KB&quot;);            &#125;        &#125; else if (QLog.isDevelopLevel()) &#123;            QLog.d(&quot;DESUtil&quot;, 2, &quot;encrypt had encrypt,file:&quot; + str);        &#125;    &#125; catch (UnsupportedEncodingException e) &#123;        e.printStackTrace();    &#125;&#125;
&ensp;&ensp;&ensp;&ensp;在com.tencent.mobileqq.dating.HotChatFlashPicActivity的子类HotChatFlashPicActivity$5中调用了这个方法，不过依然没有拿到key的计算方式，继续向上查找
&ensp;&ensp;&ensp;&ensp;在HotChatFlashPicActivity的A()方法中，发现返回了this.t，并且doOnCreate()中有this.t的赋值this.t = getIntent().getStringExtra(“md5”);，所以可以猜测，key的字符串参数是某字符串的md5加密值或者文件的md5唯一值，如果是前者还好，是后者就凉了
&ensp;&ensp;&ensp;&ensp;然后又经过一系列查找。。。发现在com.tencent.mobileqq.activity.aio.item.FlashPicItemBuilder类中向其put了md5参数
&ensp;&ensp;&ensp;&ensp;在这里插入log输出md5参数的值String paramString = paramMessageForPic.md5bundle.putString(&quot;md5&quot;, paramString);Log.d(&quot;xxin&quot;, paramString);
&ensp;&ensp;&ensp;&ensp;当点击聊天记录中的闪照时，LogCat中输出了它的md5值“5AB73AA4439EB210F65D2115C887A191”
&ensp;&ensp;&ensp;&ensp;通过这个md5，也就是key参数值，根据上面的思路，编写key获取方法/** * QQ闪照加密的KEY获取方式 * @param md5 key参数值 * @return key对象 */private static Key getQQKey(String md5) throws UnsupportedEncodingException, NoSuchPaddingException, NoSuchAlgorithmException &#123;    SecretKeySpec secretKeySpec = new SecretKeySpec(a(md5.getBytes(&quot;UTF-8&quot;)), &quot;DES&quot;);    return secretKeySpec;&#125;private static byte[] a(byte[] bytes) &#123;    byte[] bytes1 = new byte[8];    if (8 &gt; bytes.length)&#123;        System.arraycopy(bytes, 0, bytes1, 0, bytes.length);    &#125;    else &#123;        System.arraycopy(bytes, 0, bytes1, 0, 8);    &#125;    return bytes1;&#125;
&ensp;&ensp;&ensp;&ensp;调用key获取方法得到key，并使用key对加密的文件进行解密public static void main(String[] args) throws NoSuchPaddingException, IOException, NoSuchAlgorithmException, InvalidKeyException &#123;    String md5 = &quot;5AB73AA4439EB210F65D2115C887A191&quot;; //原文件的md5值是DES加密文件时使用的密钥值，妈的，初步推测这个md5值从服务器获取    Key qqKey = getQQKey(md5);    decrypt(&quot;C:\\Users\\30335\\Desktop\\闪照加密\\Cache_-f5ed123ea2f6cdd_fp&quot;,qqKey); //解密&#125;
&ensp;&ensp;&ensp;&ensp;目测解密成功
&ensp;&ensp;&ensp;&ensp;打开看一下，确实没问题
&ensp;&ensp;&ensp;&ensp;不过，如果多点几张不同的闪照，会发现md5值并不固定，所以它一定有一个计算方式🤔
md5值获取&ensp;&ensp;&ensp;&ensp;从上面知道，md5值是计算key对象用到的key参数值，key对象是解密闪照的密钥；md5值不固定，不同的图片的闪照有不同的md5值，但是同一张图片的闪照的md5值在任何情况下永远固定，不禁让人发起深思。。。这个md5不会是原图片文件签名的md5吧&ensp;&ensp;&ensp;&ensp;妈的，是的，这个md5值是验证文件唯一性的值，字节流不同的文件有不同的md5值，并不是通过其它什么计算得出，且这个md5值是在对方发送闪照时一并发送，作为闪照的接收端只能从服务器发送的数据中接收&ensp;&ensp;&ensp;&ensp;说简单直白点，要有原图的MD5，才能把加密后的图片解密成原图；只有原图，才能得到解密用的MD5；话说回来，都有原图了，我还解他妈的加密干什么
&ensp;&ensp;&ensp;&ensp;当然，也可以直接问对方要原图MD5签名&ensp;&ensp;&ensp;&ensp;A：妹子可以发张照片看吗？&ensp;&ensp;&ensp;&ensp;B：[闪照]&ensp;&ensp;&ensp;&ensp;A：妹子可以提供下闪照原图的MD5签名吗，我解密下，谢谢。&ensp;&ensp;&ensp;&ensp;B：阴阳怪气什么啊，普信男真下头
&ensp;&ensp;&ensp;&ensp;天无绝人之路，也可以像上面那样向原安装包中注入log，以使在点击闪照时在logcat中输出原图的md5签名，然后拿来解密闪照。。。
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android逆向</tag>
      </tags>
  </entry>
  <entry>
    <title>记录一次逆向某校园软件</title>
    <url>/2021/11/05/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E9%80%86%E5%90%91%E6%9F%90%E6%A0%A1%E5%9B%AD%E8%BD%AF%E4%BB%B6/</url>
    <content><![CDATA[
  2523edadd49f81d17770eb2b5527d6f30757b1fb8f5570946c02731e9bd8b0a8e573cacea93e191516f50e90b80e40f4184c4effd3045e8be4b20a7646234b4e9c16a706cfb8c2a7c90c412242a9983286d394f51306ca19d47d23058edb106f46f1889e3335a703d793b8a0519ed25a23983ce7ff6770cb8520964f635f15e238d529ebedb2cd23d5709125aa33522aebd8494608124934a979f4358616f4777e1cb8388287074184a7103dac0f6e0dd50188b530e203499b65cd6b246992b4ce47cca4f374f271788b59c6fd95763b50a75c4660dfcd9305aeb1d891791e6aed4ace3c71f2d089d3953ea0088650e21ddc72c5f9e4d6c4ff1a371d445518e8d0ff84e390123374b6bd90439be34d96400d6590bdf497a12171b6a55b27b37d7e34c9cd90ba17650f6cb37bb3d0dba7f8b139928fd099e837c2462cba4455874635895ef23c9f2fba60335297f708c1b3aa7f41587eacc91866082cb1cd464a66fef85ce2cd8eb32c16db14278260683c6dee15f3b634316a559961c3c6db90feddeaf8602a86092222757f8b6231a4dbafb1e9a5f0878b884507c71a457e878ca58fea83006bb53e8de9c2cabad164dac12280031effca31148724c003b047ad6d5796fa36352cb935f350bafebc8fada775431527af2306b44ececb0ca5b6490fa4b7416f143e8ee198c99ca00b3aea1b97e5411acf040a3090e12b398ebc0cab74fd272efe65d1a27b8cbdbaabd2eddbdede8fe6f9eaf4a816f5e1c0b8028293725b1c8e799b103ebb44d1e803bd9118acf34ea3c89a601c8fbafec2ceb144a0439b1bed32df5567fb4e934dd46310fa9591e06c6f14bb75ff86e2bb8d06de209389c7efcc6772954e5d8f5ecf4de978a997db11747be7ba36f4a60be0c7b05a1c48887d901e7af39dba20a2447474f12014a62531a4ac4a16b9d86740a5a34977d2b28e8041073a3ab40d4eab79830406c1f34f1ea115baaaae51dc232b74904c4d3c3aac90a2d24cb41309bab1c61fdaad6bdb0a852da1985ef2d3dfbb325344d923352a0affe1c07bf32d5bec74ee1c23d52131828cdf7a3595753732b1db5535e420d43ac8f8fcda6a7b72e82a03a12665f984e4c9c8380ceb35cff5934ac710336206bad68362322ca1a4293764764b20eb543608c3abccbde2bf34885cdac9b61b64d0e9967ee3376e70b46b45e50d79224edb4b5914c3f0fa36905eef8400a8ee556e19b1c9a77c631b6d3d0f079c71436013fd1465321d9f77f25ab9799b98b6c99e21a8c7ae1104d8d769f3b93eff3e7093b88233c8d9512115296a62c0df9a7573afabb2bbf625764072fa7382623cafbeebb48b8bf6031ad039426dd118e24945d0ffc5590d9d7f6ef6e7a3d08fdab77b9d6ef14089698ed23bbbc25573c7ec0c46ab3b002fd9e648c9b57c85842e1cd3d8be025ba787f683edc0d4b312d3e9302a2c2421c0d4f34806d021556fe0283f921a9776590f6075dbe967da67e7ffde1dfcdb364dcc0989731452ba433417c796c58ebd95a465552ee714592f2089effbf1aa5544129b5b0812606ad6c7d8142768e1c83776835ed8b6ada529dcbe04fc9af95d1451f07ccb345b149daedb72f009afa544c13e5d4501030e7b6279bb4f7f4968a61796f957a9adba2471adee67a862de81933adb18d34a2afd379b81a53a4d8e6a6738c63cc96170093e28e5325cda8b0e9adfeea19b60abc9f0f25b1a54243014f2e44d58551b10dfc79395cd50cdf8e67c52f656dd3e14b5264c2d68d11b44444ab078be09451560819d473e5f5b6ef7b20a3ecedf5f94f4917b24949f3874d7b4f75cb876b39fe0eab7246ad10c85c1a7138035bb8ac090d984011beb8598063d50ac1ad5e566139b47f39ce1e0d2ffbd9672ed2bbdb274e521c9282fbce70dc1bac11977aa9412d339520c1b889388f8fc6819efbee657758109ebebd1c78e039a8900ffe06abccee305795b9d4c53a7d022b6c42cfbbe1b82aa04a5c4f93a4a6814b9ca99812e899f83d69054e8c4600e2ca980ccf4b1bcffc1d21fa54d35237f5967bb4cd5079c6cf1d926b5d605f5c50084f873c490da3f031f80bf77e0ca9fdd6bb4459cd3e39272cbdc45f037b4a842a49b58c3aa601f851bbda0df1df2d136a7c2c780a4eb4c21214c7076640e98e89dde0dc760f2bd306d58d8edabe1425476c3137b3c39b535f73a8a86c283126daed90aaaac3cd7b491d7a8134efb194c2dd04c9674e38484118e9eaf4c9473617f50d11291f3bcfe73337c22a0a31ef8f8404b1ee2934c019e62ce8602493486fc4f2ecba9b9a7c21d21c21afebd9b02295c0e512358929f7ec052513ad0d6d2e486717555995921b151f83b2a74035b5b106215e476557a7ecd12dbed4225a57088444824658b5e8c4c9edb26e8e3e4f658f92b7686143dcbe9ea6e801a510e55b3eeb55803dedad874c0a3ce28d3444ebbe5522ba0aca9338de3759e839a9556cb136973ea188f6ce34cfe5511cad1c65259f8bdd7b0d63c1a0a9e234644b78e0311e1c09df810b35208bf94bb11502428e7f79236f68afde7385c4cb3fa8868769c279da6688d4792451d7a26de3986d334a01467c029527e3dfb22bc110f1f1ea5791ded3c4a4b5a21c7b6ff5e108ccf9e29db47b7f6c217261e4d9a9b97540a146b94fb1f2fa1ab1d0110f8a5aa7791e75be76bd3dc33666304d4af81b95f072fcc41b975f484ba8200407c7fbc2b7a9cb43430d6d53fd8c317805a69464415de295e193eb77f977420e9b69a9897321a20f80b16c120057fee4f7906de1ec13e3f343b0e0f3a05a1011d699cab623a5e7ef23adc01b90a01303adb48d6ba9f6871f07949797fc7e384436267e946bf456bd171d7e0dfb3908dac325b82d2700155e3267cba0bd3985b1b93e44e8cee25b162aa9ed85c5e4f66200d451616d7bb1e49009e1b71c14b39a072eb0e7507eba3c7023b7a7e51a0685db4441847ec3377bd36fd449ece19961c87564776acf54bbe0ce8cd7587349c28ae6220ae670d52e1ef7b53c74b4e9aabf9143110223bc8e88557155066992aa3d761323f5cfddcd3160d9952e6fef7e9a7443dd2d12c81a91f92c3e6bde0f578f712f48b032478d9e675739187e0cec6661cc5261c8b6b9539ed3463494ad0467e47cb3a1ee67566eb433d99d2ef59643bdb6f68b52604956db4c31baa5b5132becbc05655aff1b0fea15e13e107a6e815b3431e66002669a7ebead9900e469d7bc36b51255989815e7408e2a023c500b0664051a9ef85b802fe4221f30ef55a0c47b15981645477410c251983a8d7eaac575258abaab6beffadd1bd17847b70a1a04030bb32645f844b42c0d9fa07582d6ec80a67755119a6e7a02a7f3694cf6d0b66bb3d0d1c222613c6b9cd78a4c6532c55d4c64b30a819cbcfeb4ce7446851dfda54c530b8d996502441530e079b6ed40baa8a337494494d977aab874a51123112f7322c9348051cc0f3f2bcd8b2968286fb1529011b3b0165fe35b65f48025c4f8e89bb4751e1bcf75cb85d555314cbf4aedd65c414415483b55057d5be433a77eba5a29f2f5abd626c1800274f5b428467badf09d7f8abb1268b6c0383c9ad33787ef2ec43ce79600c336aae117f013eb7632afa01eab5a288201761852dcd4b53d5461436d3cf6e2a5ca38bd639d29939e7f55a919b35bcd53665a0d45a1037c6b9c138fb6aeb98759acb9b5b4db638292235bca363c419d09f4f4afdf59bdaa1a356db3b12d11ac408911aead85059d7f30b764a3ff19aa0daf618b9230033c1105044a41507e1927e81acd42843b1ab8edba2127ff39a31eb395f261ca5736b16e639d697eb76445c6efc2657e3c3c34127beb99c21397d5f939d4a578c8eba2745a3d1a2ff934e9d98983336eff7255332e8bce225bc806b22860e3772347c191cba2c2d054cc491b62624f21a8f7b5c7f8c3513041275db6ad53fa027abff8395f48ead173856e11bdde067db3c81759d1307633680c427780a4376797fd51987f3e55f7d9ac134192f367c50cdf25f0f9961632c7557ad465065af4cd4ef1eb374c1f12402e88480ab529d4ef328631ceaf4b68cb067fea1343ee156811478192110a48ee34e2252d28deb113c1eb09d30067de5193b895d7d0666b50e3a4a5a309dd506aa48df2b57060bd20b9584f83042b517afe4804543bd9a88a29abd4cbd2f6edddd18593e4b01e576c3f5b2a35a1b4592792fe02acce04c19794af2a127e8cc4c5e13dca231beec26209a543e7d9c01a7a29b76bc7dabe643e46ebfb7239e215f64dbe023fbb04fdef8f2d43118651967896dab56ca4808b1cec9bed65a8b3d44a46ca1a93ed021012240a1034d677c7b108cfee8f71a590580e4ee6bc81b5bb1f087b5ca508dff63b95a6e01099f80872c376078587214463b0f000cb82f5f85673d9230e16d5411905749a76cd56b96f6e724af02b462c389092b6f5993102e872a3baf6e24216b3519a44cca86e14658b02aae923ad548d275b575cf9c55150f880221a6e99919aaeba7a0a0a747de5b8a63640aebbc080a6ab4e1d6c08f87968bed290bfd888be4ad6fac9bf35eb48556d6b56494ba089858201001a69023ae7a2b353f1d911c9bc30d49fc78b6e2bdd21f65d7858b1301bb2d97d0693e0bc1db1b9a23f3d33dc44abfe74145d1695d6b947ebcfce97971d2f022b7923f5669bfd3f9fc8f95eb5e58c56dd90384b119641d7e2cebfa6eb64e501b0f2fbb14d4fca8f5f1fda2272654bf45c70650ea7097ca65689cc5e62bfe04415a9eafca2b6ee98d3859679079a5beb36463b6f8ced3728ae85854a9c4bcff9a48b5722d4b8c0f61e41f9def93c5050f1a04f15e6483f0512852fb95610868764074ba9f51728ff26611ebc784b4d15e4e2be936d29997d10ce233540cd1d5a6a491e2ddf2a8366f37ffccf0fca641affce19cdcc4e79c18410f171eea41e6ab793dcbf708d87309a683f1103c9e80d87e0b59f4fa97947aa49368ae40abbe6afe455e1247742320f1276145ca4dc0eab4f7b87176a0725ac7dffe4660d55e81dda4dc2e6c90ccdbaa532bc6a1cdc57c19d51488c03ae5bf792ea33cbe298830b28c309cb6d0f550db2723a5c72acfd2d305267fa99edc3cb46afc2839de80ada72c4163f9cf3d171262d02ba0f41daa86cf837492dcd0f45c544ad9c546af3ae80d19d206449818039235a0635fc31aa2222ad88522070923f657077727f922230f49933bfc30d2457cf19ae40e7d4e551c2e062351dfb92c8cc1e5238d1d9fe82b668220c2e4521574143eb8841ec4a82035dd4126be193bbc07f8f5ca2d8f8fe88ce20df31f2007e247e3609fa49dde1487000092b2e324dc99eb7cf47243795503e56325d3112e5294e229603d6e47606b398ebe1df2268a75b2a7eabcd912ab5539d2e4c467d072d889e3850cd175daf586298ee9aef8348f682041976d8f85e301be9c57b679fad9e46d027ace959fbe53260e916ea019962e11998b4ca00393947c0f95cc6dbec9b597b166396a70a108b3c85bab49422c7dff003c579e3920ae8e4dbe74fc2dca5ccdd4b88a67c993eb2c79abc2474cd73b1d6bb626b3a0a59d63925e8ab16e0bf4cc7a9305893fc63e404e664d3fc57f8aca80787ed4d46a5a7d62d89b70860d819e15bae39c349b3796627145fffc1e1017a14a75dd807521d86c1a2ed56ae18fbfa6bb9892b03b1e2188dd91243712b6a8a1bcac8d3fa578e75de9d238583fa34af66984f35d749f9335bbccbcbff758d31f1cb3514c4bd27c2f085e4bf7f0381dce5d6cc2c3296ae8af2d9189d8a369754b5a54540dcc5692b593baa443ba9abb48ca7e0f2462e195a2b6ac3dfbbf96a783c46550103ab041f1c05c3acd7de2fe0e7cf39504d91a4ea3b1e226548d254ccb75aa59c5212c0f17f8233f5e4e33a4ce916d93803882302af38d3edc094b00916936855693aba827a048f4e7b14e9b310c4db51f8351335302dca2955a2f3f61ee189c8787ab6021d20588f2143c5f4792114e4cc3999c8e63004d731c5ca4ea9c48080b89de10ab4574af42ac6e88674ad8269e7ed75c3de7885af6a2feb2328af22b973b66b268937c7617ac3c60b514caaa9182e53482b3cd34c01bf02f7e37544273ba0084877dcab82a88dd04d35cd9c61b04d2c4b81e54f4957691f7af68fc7be9216ae3d3aec35f297c788fc5befe3e7bbd918fd610df050dbc9d1ed9628de18e1b5f59596c3d3adbb28655f9d1cd2b2047a9a2ac4a26ce4ab271f8b919f47ff4cddc9df347f49278fb6f08e0a71fda3380f6883d9369818059eb281a94c2a0ed53fc2688af56ac836090628b77a4eea9844ee25d7205849142ead75c8d626b29e23eb5c2554d6b15dd584dbcdbe720ac63710074e67f789da86ae2f02ffae1d0b3526573d92ce41991f75566747d5809ee5cb3a1e60bc2f30f7304ddeab32503f493a2be0e922eecc6f595cba666fb49a6c636a7cc80ebec1afcc4bfbc3b07c3ef2a1b6645189d3083397f2a3d03c193ece528308242f1de7494d8fcfab0f44a64ef703ed02891ec7fd6d21b94c7b925ac23ab2624c55373e643d40223c880ab5203f62e983a00089d5336b4162c21ee09de6fdc2a16e871f0eac560bf5ad63562af52f5045563125dd9aac17a7581cc05e280009b08493d55b46186d273498e0c0ce6fc3f27972538e4247a670de9309878746b95c330637436f6988d702fb91900812faada4b75df3cacc85bdaac112c56e344d53ed3abed6a594f2be10dd9dfbbb1ee55d26598c72d585c32e2540b7a09768b8dbf973fbda8a18ff4b5921f3c431824149d42373373a1e9aa31d4ebd3de6458fa88e9da661deefc8a75d818508892215acfb1487ebc4360cd2ff079afebc62e440b362d42c6881e953c3df3206ef64b5c949387a97a31903330db65ded7c188a32bd5c7cb32b43a99395ec2c5b05923db7fa3643f777bf9bc1d07ca2538b51e925b6f2ad71ec8f9f0c45373581ae46a409dabdb42fcf4ed65ad820b163387b9893e2b58cf8d3f0754206c15de24889a833115461265df36857bb43a23dcf68de1ebc579ff3c091781f36ca0b295b4e4b811414138d69f85791bf0321869cc064de8ce404208622186f1b9d3973319c51348740c84ca7fff2bf85be060fd5eb56b9e4ad9254b56a91c88ac57889b935fd665c458ae7a6af15d3bbabe3948c1c5b2e04dd5f9a15f4c639e2368abb096dae29c3984457d04d8e8c433f3c4a10fc589779cc3c858ff2860074e6c54f55978169f9c0c1d3614939c8bfe3b3d358f0fb556bdce9584c12ca527fb71383c9d961a59590089eabaddb6d9299c11ce44123b47595fd4f64810946d6927ef9317093748a4b693611f65fb017215e91a9386e9e9b142951c7ea11d7d91e6d102d13e071bb9276f04d612b7d8465160cde0515749d222e460197c717c01ba28fced4ecfc828cb0c6d94c8f71e6a04cbdefe9866ab37eae5c1bbaf60019a8412484f73febb77aab5d91c8d14308dc6025fa22176edca5ba059f12599c90f1fa6156a2d82a4e7c23e43146825b9b03a42db952e154466dfa82b25a53b56ebff3d993268054723d36b7ac4402aa7095fd2284d68e24563dd84b8d918cb20bcbbb29a19209bb73ff92b0736569f2a7446f087994266ca345770f1b4591236d76a20f4d0545a7ee7a51a135c14b97ce45e7a72f7fa311ea3b6d2c545183751bcd32a95b6d749f0cc0a53933cc0fd08bc0f4b593e3c54af75d7b1d9180992906d6d33f2a318177583a4f1ef1882ce14158dff00c42fbb853890cc389b4bde4113645ad23f08a1cee16b3e3084760e6d56408f9a798fb726aa811014db55db32ac0077abc69e4892f6b7c771d7f7480f5d04cc961640bf2b7213c3e38ffaa99f28c2c7fcefcbc881f2e757312414d6946d648fd4facf8ce549fd8921a2b4f81b029a6bf0cb02ebf3faf3548810e98c8452ee3373a769b19b2178d352fece68a1fde25db02b4ea29f9f18d9162c466e6a094c380ca2415264febe5e7096eb582693070ee4925bab7e08814c2bc654d54fcc76fd8d532deffe32245f3dbeba14a780218a3bd5f767a438e1e7d26c6d7bab20cbcd14eeb69227c9f97814cde30c1d3f3a0ac5a68f93f4c4b2ac5722c2794d91c0b9d1c0f3bd422a82b8670bd54705fa16014301dfe0476ddf9ad826cddba43cd8ddd5cc2e38330ae452daa896cea372748c78d497bfe724448e977cbf5cc3e4ea6b35cb0fec74c7298d9817b0f142d45d0994e81b991a2c84023f5a41a116c60e7a0e0d434b9527ba2c10f8cfbf9e009eb558cd8e7e4358f1d36499b6861dd53c1f52a944494548ab52cd194e70516114c6cd8300019d18a26612b4985cbc05e9fe59518e500e5045815fa31c3dc96099d790446ce464d1334aa0b5a42d50dc3fb9df79a09f6fd574f76227fdc4eb9e10cd12801f4ca73ca0f15a7fa5bc729d957ba8618cbb8cee8ba20a71e6da3068705764dbad88730a8d9edab13b16d89bfb46a50933130bcd6bd94bfb8cb93bf5f4bb65127f680eaf81ff9c894d98017cb1996fcbb210b818a761f67ae6978e94552c4e2e8a2f716448513b48396319d5deaf25939d5894acd3014b35ff14611abecad70500ac87684c857e232d518c4b677d63f56ea2ab9e256cccd4c95f8fa331908c6193f02c070f3c8f97684731b8cd5f22300a5844b2683a0bd2be89645ff7eb626984ea982bd79a5b8d3c861ef1028971a3cb9f202c3e4122e6ff05e0e84f885f610d94b5052bdcdb70fa7181b9aa0bb01e8f5decfe539143921ab363395fcf6c2ca529e009a17259879ec8acdae7211faaaf7c286daf8134ee697f8a66fa45811524183e4e9e47d7ab3bf44e0f8de4c9c1b7d5b5808ca477ffa39dfbb9ae784a024a1e640e42ff20f1fcb595f1a22eabed7ee4bee15b4ad11800e58ab5a4380c2755926d3e489330ca6a648995908aca12416591ca036ae85498b1fcb8a3fcbb9a64a7a8718e1b16293c5dbd27d2a2f70cd4cce159f05a5b1247d791c1c49e54307da67c0dc46ba3c9da082a6761aaf571b4a7166b664f8f4137889cb2d97161c9832db5577fdb393db68b4a6ebe5a6dd8fb6e12b5bb46b2fdebae493b3635440a7be2a1add8ace6aa1cd95c76e1335ef1be3fb1ee494267f772fac6f94ac66662821712f7fe992baebcf50ff68a10f0e9416f65518062d7dfdfe3e7b43feab5259241be0966337b3cfb80466aa6d107d8b8df9f59720e6ca16246c761d58c4907c65768f832ca635658b7602432b94e9775b562818e02947c8679938db6f04125def1d4cbf8e78bc85f5d96a8cb1f5f218b518c027f8b6e27fa333246e8d59736cc73f9d52c6775dd297200dcae4ebb4dc442ee917191c5fb15b4efddaf2c3a11bfb77e476479402acbbe1d8498ba5cdf1d355e2cd75a4cbb2ab8c35a328c0ca6b6902c806a3d4e09bb00a8ca7f11d59535e42e6bb56bdf061d1ce360e0b6d27dfbd4e1571aa01cf8b56de55d5e08bda791c7ddb1e1bca511882722124903f799812ae406357006cd6c6c0d9ef5a0e17668a5fb00054171f4f49c763de2ca207bb1a46ae061959d28a41fbfb5d41dc5dfb0f0fb45bb9d8c3adbe03493d9acc82643cf8d015b3e3ad3cf258ec32d24148647b0d81c15f037852c954a9d732fc5b5e70f441d2cd4a2f1eadd12e491709e9b0dc72177035e242fe819dd60a5852af32e75d287caf756495e3e72e7598368040e74a916f9e47d32b97ab4eeff822ef859330fd3f71649716b643b9923ce48b32a2090c53b394f342fdb76326d8fd3f374ab749149d7d3d660a1a2a238f3c1ea7a24b634d47cb5510bebe2e92ef7105426727c932dba513a73a0cc4aed82c63819b76438d0ac68bda73f9fdf8093717a752cab996ab9b573ecba892a69e16185efc8e4d98d2cdee09003463f8125f75bb35a45ddf38b0371beb04d96b2037beb1803aa830bc3ac36bb86de42a3564451c7daf44d02bf8a0ff7acf366a915b9b40aee162330e34f2a2fe37db088d5830a956806adad267a3508e92e65e6c85101cb89b14e72587963908dbf00372196cf60e691fe73d8c94857aa9dd67f1d1b6300e5ccc92ff595a357fa7403394c4d7ccc08243b5e95a0d3919bbacf387d2d5e6f555061120657dbd52c0e3b543afd927904d00ad26ba6fb77d85d1f9ab9346433ef4f93fab4e2bf59437e93217f6d881fbf5e06f0dd6aba88c43984ded8f420d6f02a4b6c4447c38efe1180f5efeb47f7b9c0b75ec658ba4be38d2e2bc0184ec38e8da8b2d9cef6314ab425dfbcfcef5b21f006fd635233e17fb25e402ac2975b83c05073c0a12a58aeeb40d4905affa889b77d3e274ed958070bcacf317a8505797b550973fd0470336b35acdcd9d49d770df44004867f95f71887a48952f8922330a2769bbc37b210574ab02ebcef38f1f24dfc002bbb92a5552738e57269017ba05b3afbfa54e73834a2580faa8ef23e7bd6d18d9f0d52ac3c0eac75a48668d7b953a32435a63e69a6ab9b7a8ac5f9587b5d2dc6b66d477466d42ebb151a770bffab6068e6e3aee80a0ee51ff1c9f618676bd339d1d5b58f6d8a1e8c76c4d6e8ceb1ec85bf4b4d7288108b5fd9b20652468543506b9f3cfa472759ea7b598f3b80af2d7e939bf2e75fdde91ff9ab2196b079f5f987623e99fc8f0bb8829214d07fbc847978f703c1d377f6d8eb08c7ab769d4782cc55016567e004eda7bda454114cf4babb9fc347adc6632b5569fd08089524a0352365acfd62fbb3e95b4fcab234e464be7263f76c6808a1c8b782b79a7fd5bd9b8143de2c50123594a7c28c68d30ebcf2fce50e55a7b7569d395b1854406c0bf15097320a0b2e12cbcbadbeddcb367eda635360515617dae1567a90d7adecef6f4594f5f859e45d083886166760c76f4a553a6ad40a981ffd38bf4b7fe4bac450c957b0260d4fc710686ac253c4eb30dd084c34766e294b7b39501438cc97d7c5a0ad4d63d7566f015c9128115a01f73b098c40257f56245c188b7d7657aeeda16df55b5e362cbf29c71fc4ae52fb328f043e22ac28b9bb8d99f8f363ca7fde05fccb237a5a49c8a63b93de4ab42bd2f20d1fda8600fb8197576c63be758e9e822f51b05f43148ef9273997c29f09b03d4c518e3e0e2f93005ba17d23b33e66290f8800fec389ef2e6c4736308349c6d247d2244564938089561e78ecf8c5fbcc3ea78d0d37b07bf7156d26701de86ed5edc9dafb169cdba3364e4ced472a94226ca4ae8df9f09566f0604f259711c1ad7ae24a740f1e30aa4f7e66a2dc8722514274ca236c45652b71b82dc94b374b60b1072c1b89b355a0909fc848cd5e220955139e1e236591d43ad5d22a8f541a0f25c0be23c7914a2b7e6f06981a4a40f95bd86b58de2f7e913c70f313121223f2693bf9cd69d0984b95ef1ec36c7fd3d08e279b29008b4d2ab75c83d143f8b1c53fa0a63f0f42bd805f16c2d92c26121b80dbcfd86144fd44c598376ae7616ce21cc71187f0c7810f88f047f74d35d1302a897b09ab47b7cf52e2069a39ed88e08e42a8364f4e057a70a7fa35d75bc5ee219c4371924b5c794d56f513db42f6e269735496368307cf926b93788a91b598eb6ff26cbdbd54c25eaaa625140f95fc31605e5df85b578c8648669b556a6f49d40c0ab70de2ace7b4a91670d562a4c72ed85c127a7d623421aac20a144d33fa87413b7824e02ca0b34f399f39b910fe1ab92b87b35e5c89da53984644dbd8776b7b6d91130b586f3ef5c7db0f08cce2101ab060aeeefedb7dc4e1cc7535c652b654df26ddd5b471e34ccd13c65ab1299f09262dcb5d30cf61dc96877ae36407a5e75d053d3872d53a10154962213512118de1614955d06359b019aac2742f2aa69e201a5659ef16f489b99f3159e67ac2a6c2fac0309b8a923c5808d78a3720fcf7031aebb3db3d55496ffc9418f1d65ef01f7efb473793b8b40c34e1d61398068d3e46fe6eb9424f168f8e3473061929d606ada9158b77072a7d60d1fa47b28d34784eef0a135862130644709af22c3eca1184d3cda5ed76e997e437af237424bb0fcc8abda0032358cfb51e5b01808bf2b4af5fdc5c52e81adfcac708fafe5e9ca4f9786fa9b51faf426ec1bb12c27216764e8eb2434f0a85cfe2c173d327287f54f71a895acb01b119d61112f19560ff2c4fd6c57cda530045d5ed4a5ed11fe4ff8164f9f0842573fba34c32691f44846d33a916355b5f29228eaecdd1d7cc9329c217dacfa2cdd26f278cc1decf16ba91d3fd9e4c36a136612e9e51ec1e3924588a26ed2f35624fa29a3f8bc4359f5d2820f107ad390a18aa93198f952e33dcfbb46a6ff588b3f6d65f9b5923be38ff2ba6d16482657f3659f21ea7cf3ba465a18f1703ff28c38ac32e4157a65b2fb49f5e0ef981467f4ff20b6e16051018afb487e4c19df213c3d1dcebcf94c816c69e2e8596df0e9b0f659c917c3afa090cf0b6a3168d6f0f1eabe7fb33e14b20ecbf58555406ac2565a8bc19f665eb4238b38efa7a7709f0ba036782a0c8e6d46f4189fc806498b5e9f9ed05f492c4d2e43c3db12c3c3b5a715cffe129ed71a85727d09314bfe060e75db8d6b2499aa40a07a83e41bf67ff8c296fef1789774ab33dce61638433173a69e57ea0291f0632fee1b6b7131e680789c1f611651e512f72f1c4265611929410c4bb22f181e6579328372e3801f2815ae30eb0d09d4d6ca68b415b5fd322a53295d884ea9b3084460a688fe5055a83e9bc1e3b557b25ea6fc88d0c7a886aa28c7121bf6d3e0b21f2db5c0707bcb0e6b226cdf62ab61f09c2358ce4c7b33babd55de916671b5a6ae7d7e2679518dfb026dcae7e74e0edf57d08e69065a880659e4dd90507657d8c86df5335f2d3e414307c6d1e6834a5e5404a01cc624c03d11c6d6e71f6cc78d11cc0a93627bc6c28d6631cec6aa0728bfd3dbf1cb71cdb5a88d7f20f9169857d6065536838a7dfcdbc295a76d70392be1920afc8c393db623ddf83c1448fab97fc59eae37610c87bbf3dff97a692f18dd606e97741d9737b1661a59c770e57d85313363388b8880ec353277f0a01abefb8a610c71175d51265249b1e56b9f92e8fc660168992129096544342e7e4da8a13528b453cc8302390b8ea7b27bee0437e9e7891e3a10ab632581837b7e44e9473acebafe5dedfc1a8499cdbe32c5ecdda3d1f8cc32fe7da888c3375244cdb7662e3e06bb9383715b846fb09f2dda093d0322f5ff5ad24ebb21636dfcc1d7dd46038c30d80521e4cd76d171cb4d5db3fe287cddeda73b30ec504deeac2960560a8c0b0d3d1f384787469f4f299f881569c50cc819288584e9ec8ccf35cb3fda812ccaace7ee6cdfc15fa2a4d488ad85efb05fe230d29c4de2e86a2d9dcc01edf0abb603fe026361c26be22f38ed2854bcb2784782aa7912e3072164cb8118bcb7e6ac513379fd9bb431ac1fd20467c4c435a41f9eed2de655e7cf6d5bce1030e4019204cc539c4fd5ca0878a69a0af26c4d047b32fa44f44b8f1d0776d1ebc04fb207821af5ca65059e729d575b2117918932e3ece53b8f6714be5983c6febf7ccfad5a689f12b96eff049bec413d1de7236885dd1b4692f29647ca04b9d75157f312aa26b69da3f91c653a9e9fb5680c226452454d204c22b6804da8978631cf4b5d4f3ccf14e36c9a0931a7e1d94cc52ecdfaab93030ad26432f9b74f1fbe2cafadf2be7c232ad5047a3e02b61917847c6f2ac45fe49341739f996f5736227daba79e5fb7ea97f2f437c7588ba5f6e65052d1f5a5cda75775352266cdc25a5f513ba00ed47c4ac1603477d4f10d05a222769fe15aa1ac9823ce51e42289abf7c2dfe886b30fe1fd952dd97fdfd470c992cd03ff56393ed3bfaa8620a9b0622daca0ae7fc1eabd86a1322f53a66875e8b396473ac67c2a66ead0ede2408374ae9b121d54ac7d1b1d1d5afff6b12e602debf81f097f250854586e668fef4412319c95d655f3dc63df688e4a2e6b6952b174f5e7aff16e932bfe96b45276e9d97e935115d0e5d5cb2ff6a10f59b1ce25ec92bfaf37252c9099e4a56b7e06d9193b8b0767678b3b346733be671e0708a2f81121351536963d242f43156d7d7828205ab0890cb0ffe00444ffe6c655dcec0d6601782d1db23beba015faa9b86ef2bb2740c510c45154f3b6f2267bf7d0aad04e44ee8232e775a56097103baa37967bb22f7edc8861ff309de4d596a936278275ae7e37ca1f38b0a1c56c70386ed3e50715447c197041522821126d15e887708a126508a6c55aeb8315cc630c13a414d07a38fa8305288779b1ecb9fc5030d4f66a8e05d3fa1748f577be193d282223418015db3571d3b28d063da39078d269c93a8d468073e30694f17dfe8cbd7e041ac06d5cb8cd7e15eaf4afa2b85ee7f9017008f050a7c0314ac5a91419b008a00a9e25b50351f8e388bb859f9a6bced439a1ca2228a74bb6d0d3436c93157e9636e174abbcbf31ed27b2c30f7a413be3be7259de2a5db11752877b98a1264cf778dd8c15de6124dac10f8ce21934838c5aaf4db3d897020ce27e81b4fdebe446cd4b04a155086fceaa28d3cb942a6afc0a0a4a71cd4de4d38646d84476eac65fbd48b04014daf1da3dd31e90c9276a0cce5f2932b0978d7aa900d463c774b1947854ad9165a07ad7281afd85e3d3d89982f0295910e144db80ce4cc60335b1503f588ac27523942df09169c87ade5502c947870852c349b9d9f513d5ae3124a56e2e0651c310f49047f07de628082be35a882064de2cf5ac85ce8b7aeb345c53bbf4c5fdc431bd815d7bf6f54bc45e4c2a4784bf7a1b4a65fd10a42f866fc08640f5e0130eecc82f13bcae68425a781561daff0282343413351f99569621fea4508f02c91a7d316dfafda776a2f1562caa875018ef7fed5fab70f3f8cab88754acd337b455ed3c7efc98413644140014415ea86ce9702a4262d228086a1b5ec2ec73782c8d3cf20ac0f402bc52803bef2784f2399ae9c86d16e8d00dd86848f72a8217adee7e9dc90e13f783affd714d84f46a45e2ad56baed3dbfabaf161ba78a8fb98b7326621d3f5f41907300580d361c502a17cddd4eccc4658820fa2e50bcb6a9653689f47adb480ed36b9baf0ed86aacb64a83729d1949744fbc6de7f55f29c5fbeca41dda498a40dc0eb01a43b559fb7ebffcf3765747e30b50708717d4e53ab6c024e1af8230f6b54e0ee9a832a8f5d3c4f152f6bc44f69fd0bce7f851dd5502721098ffc27e09703a334b96e25bbd83f01c7557fb8cad34401e9f1efcdba30bfc5eba9885ac7fd35b09dacd5456d2773b38fb1a3f1779447d9fa10c69065860e369b1e5bb534b3c56571d3700d835d9280736709af34650f426a6cac34692e27500dbe697b85972ee5f6026c16ca340a7039d568370e6039639d1cd3124b72d92abd96aa619cc80b7bcf9244f9c05d8b3cefc7f9e4fef3f7d4f7ec7b81fd6399e831b928ce8c236c40c0cd70250e199330da859b9a80f593043ede9cd7fc9dec0676e53cb93488ae17caaef76e0b3679d41617d04bad6cf9132240a8d4db12651cebd7d2ff634cf646b7a87e14f115eb369f30b776ba279008011fe1bdd1317c2269e84a5f9ef9dfaecda7f08bf5a0e5071d06f88bc0da38600b1144a31f0b5d1c386151d1ad99629aaceb5104e9ff21a12128fe10ec9bed5851985b880eb7969b9e6208a4eadb6bef3f9ae31aa45a1ba88905a6aa4614867305d9b7d4029be9ad15a10d3802f39b2d762c3737e39536c7af5295be217838173e599c6023ab4451a9666ebcde8c75fb3598128dd3beec3bc4016e0688e9b23f5233eb2d68b07099d6461ec46a66b2f46e2b3b10dc955cb2e12ea923fd1d659f9d222bdabc124d52541a5ef6055594bd747aad1e4a3b46f231a4e7ce849e4cf7fd7188f39e8527c7b8ff54491c6338da773538ceb70f8c9833441050b40f25a7ed7eb1e9f7720127aa1080c120a29563a6b36fdb459c72a60bcb57d9237ec07e41311978d7c00d3df71637887bf3c9e31d420d6b752df25a5b6aae9c1b03fcedd219497b71af55710355f61d1b99822af94ad3d84bdca669bb6d049fa155701895fc60e14f2addf5b2ed02ef1b2dfc3d0b0dd3fc670bf6b26741d07436e2981a37c1f9f5df24f5179ccf819347b827a0447875cf5a5b458793c8ba42c3542da534895144d5e250b6995b914dd27df0d1b9d99183e8a9c980d9afb5fc3044ca7213acbd75e6a1f75339fe82b87cda748c8d25386377e9bd4c2ffc4121291f756b0aa3a46b1ae55dcb6dfe1709ed503c51a8db0f1d2afe5709da9bef04b4e8747a31b3d607549cf8fe1bb774d891d5e7c5bd0ce43c5712cc9dd781125ba543b507b0609d8c4642556fb41f6257e8ece66b899db1c1b329c3d9bd54c63668bcef5d2d491a4a1569b4d442da67f5de7c99b0afb7f0930c86be3e55c1852f7d75e2b5a10332c8bb91a78907345d2561e469a3d6a4d7520e8d9a12f21d071aaeed0576c8a8a9752e7356f94807df12b0af180782ac7a44e3173d7c9eaf0c7c128e7ca88111d49f3c0bb4076a5567db3985c84db97d3cbf663f65d2d56d5f3ae9132659af5887aee7a779e66826c50a97ebf19ac2d3e94760b627494fd2fa3c5450f96c65c1495961a548421fe4f7fb0a62cb3fc7f54ab4ebe23565a5acec4fc11f4a56d2d585e00e26c68918371ce05037b789a566b2925f2ba75deeb3f2eac9f603d18470c20f9137cb6ab18acf5f59739cbf2c8db053bedbfde1a74412bd6bd31a98a70803050d34f1eb114a951301c0b5e7b11b0ec4a7e22dbd77ffc18b3a368fa9eeca660b3126e711c736c6407190dc194e2515e210c60698fa5bed5c19244c198a2f048cd5dd9dd25a0b491f5fea8623dc5a38315bd70b719ec148931fe72355568610a0900a29fbb8e3389d8bfeb227c928b54b463abe7e5b1408dd69aa876d6a6d20d0b08bd73e2d5c5ae03a674bd826dbe3b5275bf7481f305b35d68df467754b420f3bd2c1810958564894f3c493b4125cb1af90f440821c45a7ce512f626cb583e986a5000f3b7a8270762de906eb3b569ea33e38abf6013ee6dc4dd2026022bdbfd3bd2e6d3c6cec9b2895fcc0ad76e26382fc835e595755ae7a4d22fe5b7dfdda60b91bf22e817cb8b91ea94afe751a7d15f5449ecbfac936ea569733ef42f308b0fa43288dd26d811c718d5a2690e212db6218a21b13726432b4b4cb44bcc0dc7e77e9b5966fc033e9d9f6aa716590e7d4db89135aa4ae1acb91cc08a4c3cd014bafafadfeccca8912d7a7ad0fefa740d37a33846653a01ec952e4fa228304e05a251567186af283cf691fdf876024784a1e9bf181a08e8370de3b1ba22a65226cee04a1eb99fbd1fe0b5fcf075482a163df2bb8b157f8468afcd382c10cf5c0591a1e7374e8741634499234f5cb27ae02c29d5892d6d4200b45f7672ecf1baf1873cb88e3508a9c04f0740476e0f5039694198896b2b501334ad128366286e061d17dde7526d2e89af943924749930849cc70200009357c36ebebe9f4c63ef4d1d3897906120ddaa27aa6f2373e80f4e2d939eeb6c37bcb61ac15a173dfeeb32f41bcfd4bf46917d82b85f8d768cbe8956a7754c3f068f87f9b23fb17aabbf84d715e9bb8b091564d8d363493994bed0fc42a595587c57ecf0ca7aedca42149464f69da3697c289093e56d7668a16fd177f8615610cafceaa8f45bd89af838834244578bc46a2780022abe02eb7e34bdcfd1367027b671f07a11fcbb799eea06ce20f0ca4f5ee44da0b47ed126dafcc6e476b5bc24d7e79daf5e27b1254fa9e4f612b46dc8f7a6a2dbd1eadb092720f076f8ae1959e81f566caff06e05c527aed5711b7c45a2676e71b87842611e90d13eda84fa988676946f39557f2472b757f813508d7025feb95d9108821f802058b57b928e6bb919600c31aff83073ffcecd7e86d70ef2ea84bf5903565e04bbaa5c4baf2178c54eb98ed944c94861de49a36df7e9108f32c0c3b8a823cb36ed301411d61bf51b3ca9bb420a0b381a8ff13a368c41b2e56e3c82bc0010425ee524db3976b5ef05bbddde8183f1dad276b27a8bda0d9f0dab75b2a0acbe5892f9cf9e47ba3932e0573be23f6f284ee17a4e9207ccbb5f81a8245c5016cd014489b73ec2f56a0a916b08fb9463d7bed2c48a2648aea56ad4d2db9d8881f0151f12854edf65656ab87d4e6c965860e06ec005df1500c3c225800042832faebb57594b760b96c9a05fc695442dafc5d408dfb35a1a5d6865c316622b1324d5a2c35e447f54d29be39b39a3f2104081c5fe6eda1a35a03a80dd9a817c7676a1b0e0e0cce0b77ce073f524216db8e7266d0f3e24c20db394276c8a1a0cc6fcbd63de88fe4875417192a4dba621553131e4c6b11900d70002357dddb38e6f6ce752b442d7671c5ce1c7bab8ea35d6921223edd29376e89881d7d1168a60c00a306ad7fd5256575017b232bae17e43bf44b51422ca4f90d879ec49cd0dd9b7959453eec46f295e0b544758230c265b9927d2f476378b7e0192e8c2734ca1ec0255fb4b70fde3e7cde32a93262033a410e8594ab01a646f4b9c6eaefbd4074cb61710e0475abd9d383fdef73b8bb214d792cf00063624e25f794612e42cc86a7480ea9a189ea8299093d61bb72b277e5442daf5c03ecb1041aa7c64c4ace04f1e7775dd3389f2e8b0a4d86508ea7093dc1e76e67ec0e65caad3b9a9ca3c19d6439362aac0b84feeea0bb50d054d450facaa984ac58ba249ca34aea5e12f0eed9f83c660e6a14ebc5b289060fc27c7a4f78bb9850798f890d7563b8ca1c4fae0a4e381de7e477a7b73966ca5445cf074abde2f03e30bf9e9a7dced5a87db56f37e2f173c089c8fa8f02e7bc8a2fe660f94cc05fc18d102123e33e0839885d0d1773f0da4fe9f9fd6ad0d31e9b74ef1464308b61633fb389f4b1e866e1aab741f601ba3e6ce36cab84ac1b70a5f90bded3cac66381be8960613161bc5003e8f32b2c9c3d573798741d32927d3c9630e59847af23cb89bcdbc0e85d2e932ae084e9561f925d68ad514e61912f60760a2f59127f5f83f0769018ffcc9f23377d38215ccf1ca8737feaec9c7162f6cc4769d885eba3bc3df6824629b23069db85235aaa29f75fe0f907fbc831b2f4503be1eb0bdc0b3fd5248d471d2d8b93058ab0d2b6e2d1c8db466f8c4e395798134758139c503c936cd9792854c4795a6592fee7d1dcc9c4ddb72ee68d9c02f8a7c50e64f6e95e3520e314119eb9c15b0bb267d71f7fe866811dcf7d9f850ac5bff17fc61d2a106033a098412662543a532bc2e1fa4105d91c7dba97f9e694ec1349ecf050a0c3c9493bc07d6d238ff999c8978e506c753b7cd0c84e0f994f6126599c2cd3d85d6e5c2ab5a816195ca3ec460f6cfa33db28832b95343eaa45abff705dd1d24b96d5d2fb2c60bfcd3bb1c68738ba2f14e7f36b133d3e50980eb49944e39aa891e209b40c9ea824865a2cc199be2e7b4f7cc5fd085c419b171c8f5179696a218134ac82d290fd8a5286f8f283d98ee975d22ee039028846d315b9cb73eba565ecf9a723e6cca4b6136bbdecff9ce5dff43f809531d4bf834244fb2f0bd30101f83dce011528c7d7bf198c7558bdd388822543940d910cf91d14df50c7bf7e01374943de22b0360c19257f19684455f779c8b0f665fdb77ba5317d6358d63e3d40bd09fc98408a3ccadac3a6d9b84914ba6f22c23b3a7c2ebeb603a127abbe2eea5f6417fd5c95e480ca9bf3b8df258b68adc56ad2ad8dd950860e419eebac6627aa954deb9e86623d1dede65b3b1906d8c7290aa5995e516cb8b1e1e045f13dc370006301ebd11ecf04012478f16ee25b98b3256f4d91526aaa0b299f30bd444dde6f890807f70946b607c3422c67de16e8b7dbc90a2ed1f29f2437555f74d883b3467628782774d146765fcc1b42d131273519ef64e7bb488651a2ef37a0d4a422dd0190bfa4e018a5a6d416b9fc67e11a399dc629562cc9c83200a39f2e4634c2e9a135a05cd432dd0e3663d8cba40293a48202ef36c734115248aad796521920fba68f7379da9e576ff217bc534f37692450e7eb08d78b4ceef1b7f4f473c458332a3f076a4cfb5abea86e4baf5c0b63f08312a0cd1e7d49f6f7a9367b0dd03eda0a15b7d67932544428748cc16ce758f471c8660838d662d9ade16234e74d20fe58d2040a7ec8466a6af7ff289a32d9bed1bb949295b86f52d59fd0cdd50c0634ae32f518145216816fea3cb404b8199a7e39202847e3f2d3bdbd41ae0f77236b5972c5aa96d20ad5876af464be367196b28323528bf43c242aed3aeb2d6cf0e3fe48eea401298fb167fa6d6767420a94748c90bf96b6fb88f95d8771468c56a097eeb482ad956e51c984ec2389132fbb0db146c9a11564bf6e7d5e72b5546ac5e5efb94b953060a683545af8166e047200fe46c964f596a38e4d1bd34000bc3c4a8230b4df10b7fb68add1821a018ed18ad9a5049f5665de1606746d52b4cf239bd29285b5176fce79a7dfb67be425382d4f1c6379281633cb1a4d5e03f3451cd24a78a8f9bdaeb42b4fe781337f93262172e2d072f0a31f12257aab146a60bda31fa9690c921a4fd55e331bf6244df6c10859c2d43ffe1467a25f42fbc20c0cbd64e7a1082078615fe3368442c4275fbaae6a59feccab5218f05117a52b1ce000716285cc28e6d90acb9bb59b8a7533f3cd02eac738a0aaa333461281b1a825ef7dc5980250492eae02eb9d2e623cf7b47b87efaba97f2a8935cb6e61a01f92247873a059a004f18eaead939d1f97c9cf29c4376d87d5d06bfca728e0a62b1e96f898e1aef16932cb19642e7e1a7f0a6feaae7cd8bc2b61bd644970af2c803d3c644227633d06b2c66ef0c7d49ba9b79ba133e364b55de7a8b2fb8d77ccd4a14e2f9822d36311a4b20b0a6846408b7faa4a286023bbddfea13f5dbd772a67e52664dc88c0943560e3f4eaa27029fffc5e22bba5126af1dbff364436a25934ef3da52f3f677a863c347131db0f482c3e8d8cf812102c1821b0c89f08352eb84f29a164200753e7a9b6bfc7aaa62d3681907c85a4caab992947890c4c80d82d178b0e8d03af9f96523d0dff1672daf6214eb8c3a1af05a83f99c236c78b13cd61244beb699a0265654dfadbf2cf593f3eb84012fcbfcb604befd56900c15a206ecab5a907ad69469616b59833fbd6da14ac80e1c966952a3cef2914718cdce818d690fbcbe1568737444ac84e08747a84dc8a9e8db383bb90bdb77fb51f5a122eed4062580266acd0807d01eec6858623dfeb8b0819b76df47b4af4ff305eb509ebf1073057efb91e39716d1ff59f183e260a8c3364c7c7d96804aa300689ef479d66ce78a11d150315d575a2171e8b17e82cdaa21bd255da89f475fe937263264a45f9c9ea3cc3fad41c5fe64c67a6c602ca55bede271c0c5563a2989c537f54bc9b467141bacfaba605f7964df434aee0013beb6d5bc2d6783867f101e64836faba5f3dd8d2806a19bf935f177013056deba2f1b6df7c2373b45971aac3a3dbf348c164e9015178bc68ecdbfbb5087463edf107084a836df94a1253df90dd48b68de71f551987586eea32525e219a369aa8ed903b9400e5c66c41c22ef6181b9fb951ae6b59e0c8949570f68c7f8724230c2ef65669185e6bde0c5163f6d5c5b78dc616a15953a9d80c9cc5a7d892916949ccd3567d7ee77c97c40c5fa9ac4a277305c8a07334e951e4a406a607c0d2f39161076c290e2a715e068bd30fa8f98a8b42cb6e47ac90b490e230ae4a43a1e7548404f4596a2d19d25cf879045cd943761dd696cb698556adb52f51395435fa5ab62487fd528aeff2f89b08c4dbc8f6284bfe58e4309e9e98ce19e4cd972dbfd27c3557639abf63894eeb30c1da36ae3d01595f64e6a9b66738bd8e9aaea8e929c63a1c00c6ae77d93fa1d2dcc948254bb54601733ccbd08cb6a2e59782cb1cfa304607f2d6e63c0d7381e113f1b4c7fe458ccc89c395e3180c69b5842011087e229a93eb65ac708d696390c28026dd5294304fa4a720a60f4091381b2be1251413f63392ccfbe5abdda2481359406fd409144bd212359e157d8ac486af55793e419f077d312b2083ff69587f0959b2fd6abe26ee6f6a8cf9a018914adf4d261f84c501f37901a8da2078e8455a7760181ebe362b8de9a88ca9466d0dad42d93b387d17a98499f66f35ed9b42b2126ac55fdf7f26c77cb58d037939785208f1c679793e6fb4edc92d6569817ba2f21a707b0f2e6be815af3bb77572a142e959a4cf8b2a754069d11ada4a1fc09b5748a0d720e9d6020489c172df276b750db3a47a5a2a0aff1aa3e8b6b7cf2d83d8b409c02b94db8a872e822ce328f86a03f47654bfa70ab83e1c5a6dacf7d078c6423389ffd09c1508eafb6232033ff8f9c469f59fe726ff46cf3d3ac7523587de5200a04fcbea809478063ba213f0beb5fc8b158844928419bd83a878de4292aaf2bad5cdc9547a610849c952fedc9de8795e51e24271e28e74fd312a7e00573e50254538086aa41f9b69cc4182bbc233cbcb8166f185b8df9688169f6b648e7f6304470a7e7399569432f5cf680026046dac6231e422c34ce8713f26de05e8aa76b72dfb14af4d3bd79afe49518f2a3f968efb4507bc950142d7823d7cb5aa68b8f0866207b0592396614f0cb0379373d6691d2a50797dc8b9f29d0e37acd7c3af0624b461932548255350addc04ce57349f21a573a20e4a04cf488764a4ea5512154fc6e61c34def4186b866794d7e697482bd095ead10072b70659b669591425c77c10ccf658a4a8efa83631f7ef266490f62941c7032648d47827e923f5982516a7dfd1564d99d33710dcddf01496e3a3c9d9ea5db94fcbdee5a9a7f555f60c3c1edbd5538c3f2a6148c2f61329e00afce2890ad852ff5fc6d3533c00b2caddd46cb421e087af1814ee6c4f265da788a6bac5d7f5e25f3569383e3a7f48ea09cd90b1f48ec8eb3b1bf89d9dbbd6e613670b559d9f2f0801e68cecd26ee0fb2c81067ad860fbe904ac533f42bf5100e037c9e68e15f49224f8060a809462b94c2583367236e471d1524511b7082676f04183a96c4fb0a02da481a3f0364ead4e2c4313be4b7487ed044a2a835b5c41fa62f3681f1adcc48b39b5bd03320a82c9cfe27ac22b9fe89a048e20df7b6cbcbe83c90a5bba026254b2df38a85a19822930f991fa68679a05d6035d9967dccf50c167f0883a8c92477bdfbf11c0ec91aea95cb116ff459ef808c9aaa599b0cd5487e80a1c9144edf31b94f28d70e6587d80a26202d4d4ff7ecc04f24004de9bbae80c96f179ad1cc5dc604139aaa9a8bd7bdf2546c52530d4f627f4ab9d987fa7d83e68292557653ff8ac4ccb22429fb5adc74ee1a810f177a5692455dd30f26481ef3c76956a69221e71fd69e7e08a3a53d0978ebc1c7c17f5748085fe5bb2c027acd76947728063fbf071d4b99f318ee86ccdd297c0a8071b78a28963000d9f0741e7d984d08944c7a84042362531c9fd3a45a405608629a2dd597ce0ceb3b96121aab62cc53833b38152278443569fa40f971835dabb08df56c38136e1d1b77a06aefc334cc2c6b847b4ae8cc4ac5517a98e7a1507ef5f3ca996cdb06c33bc603dafb4adcdeb43a48c5eb2a59062c0f17b40503c75b47eaf2a09f41ccad1faa553f14504fd6c4604a55b7d5886d6d7c7e1c47d06a892a7a819e0d413caf83059a1a69d4d56ae835872155eeab3d68bd99450c426088eb78fd5c441d6a6f00342e5554081ceadbcadd43d0c9e36a5a7d17e640e3184891237b89f9d099b31d5f190d8489cfba5aa8327005bb2cac058bba154915c978d49e9d213c0355b2aca6f2f78933f59b0dfdc3faed049190109bfa9026364bd5806fa8aee4614c93f2c8ed02c9549f94f79dd33bda3e7005f17037b15886bcc7c856bdc1a112f06484f2af8bff61480c279bb7c7b744e08684b7c70691e6766814fa5735803e2fb4c00edbd644bc232282781f5a80adc51dc103bb6e709d337933aae9ded4d79eac8e6fb07edaa915b45a31ab509d77691866cd194eab1e9533e130a240f50e023f926a2a3ce59b42d93b3dc97bb53659339a73469c7b6817dd195202d51e7ace10108d34367bda66beda96c7f9ad54e7ccb53c73d99850212023b152be901cae4a2d01e312f43e20b6e1f8ecde75cf40375b22cab9df935773999a0309f0643fb23b432172346d78343932d39d76a64ec016e5268ad4d362422f175c50034bdfd5d36c6e9d84f5acaeb569d4e78d242696457a3e1f07af496cc2250322b283c6b9846b80d9b3ca8049551fa3e883ba98b0a972d5ec0b504b19d9a08754c006f2a97e7a19f931ab6efc4964acbe4142ce8fbe062f79c494ba5d92e19f71b1d1c1e49af498776c3b46d5170ccb083cab053c2a4a88a46563a99bfaa5c628cebb2983f4edaf5d0bc77bea029687404691add13275eadceecd3396263efdbe998508e8a90254e6f289c9394d0dd384913f8ea7cd2e39dd4d2f0c3c181156575584557981d1c7c8aacca2119a03b827e808564ead74552213f8a0ba00191f88689c574bfdf7a5f0ca54f67f56faab2df7b974a9213c8c46562f6b598798d4477a98a546f60b7ebf0e01709717a60125bddf7957f8a3c6d6ed04502a4c69c88b7de88312a7bbb448a53fd2cfbc4caa56a12b59e7af83527f89079acb1c1053f9854b582c1439fabb2e918fb7d1dc7eaf982d98dbcf56daf69cd9a48d1182add8c9cb728d770d584781a71ec40bb0735f4bb54248324a1f88c392264b96afd74d67f2060380ab80a9dc79376b9b6261dd11eba6b8bc3dc1ad4b2d8638f7014e5fc8d459681ce28f141de48346bd560c9abe6f2e77a00d92b85c2a2b28bb9c36dfbb43e10c602db0bf1ffffaaed816d050f7ee426d8e5163440fabb6765a39033883aeee877198afcc56c0dede6a67351eae28e1828b31f4e4d7d38e5198ca0e79be0e850352b882c3f13dc323e6541af75eba388a24ec98155d56d15056275d546f4c27c0cc982d505c2673e5b05c4a3a1abe72a1dce2c06bedae9249c9d46ed6f9c4da9aca134b612d17b73b5985b9db401875bc6831c32774d7cb17d256e3aa5a8f8008926c9c0e92b868c1b034742474d05fdbb647f7434b9ee33dfca9332e5bfccc8d05b2afb77226839ec384a2a031fc434d0234ef80c297cf4abdf77a26b12955ef8d9e639e71a2cd3fb264506ed3d1456c5650fb0a013edbb861ed6f91154cd2676ab4f425ea9022cecb10a83874ca35c6c48f9459105e43026261b04352f5fb7a56241f0e1d79666e4b6eaac51546aa43d0cc292ea04cd6a1ffdc955a359ecd282ac890d94c61f8cbe9656dacee819b476cf6b80cb21ae9ce3c78a7acb7bfdc7cc2e97244b8a6756a02bd20c07930653eca777ce26a14b7d02b9e661dd954bd13aa50fa072764c5ff6be695a4c989b25112093909d3f18381a41697bcf0f2bb0a2db48b09e9e05217fcee5add992be203c40dfad1def4af7570d67b1572fd91658c7a5f2002528bb5263b7d9807287074b9df01bbf9b2d752757c8a07e087bd3afd1980237ed3d275846e54c3c88e67668e7f4ac0278a43c4d0e129c3835aa5985b5d01bf1cc93d6f9e0ab2a4e29ba049707da7d2626cc88d8245443b9a6b9f5dc0cfe720a71e6c0160a6336a71a5340b3e396c9d439651aca375b7ac0e5949f910037f0d0c3a5427280dafa2733316462abaa5c7b6f8dde53843d23dfa9e2713c913a2ee9374676d6ddbe65c5ee14ccef674c55c7eb65bde52712eaaf3e3d0612ea6563590f6997b2f1f5632a2d6ba2a8cfa1865881e218b267b1c044302d414b4bc4bc0198bf4739f59cd963ee0eeeb8d9fedf129b4f5a5a5fc85b889de7baa206a7e2a0963005a57382ffd3e5b9a4b7b66ac7abcb7abda0032df40f4dcdf0c67cd89c84be347870a229398dd30b7373e24c8772501b40585beec39dcec0bfe60b4f72782d195f54c63923b845cad3268e06025fd3d931a7bfe44d2fac6174a8a665f6feb4b352d3f4e03db8f28d0af7bf5933aee5f68f7ba82e521c7070a26f2f4a95e2ca573f593ec60ca584161abf6245bc95e3fac33595ab346c4d26758bc3315e0d840dfe3ee341979b104ebbaaf9f8345f5fd33815827bde090fa989be5dd08a18d5d4e847392de2e78da5654be93de973e6933b633a49ecaad2d8a3f748afd43f9e2ac729c4a3ab559767dd50a6916276238f6d8bf869acc7903a6b7685ed1b3b900ce9f43861d8854ce7f431cb517aa755a4f70f29ff8b60d45d3e90cb02b913130a5a71ee24df87867ca2c2f74c9c3a09bd4d76885e27f0ef477cfda77f5800b2b90b36658342c9617a37bd3b5804db59419366e93d4d13804dda029e49dccefdbf13fd5abd8fa9850b161210f008d2cce1a58a6edccb79095fd641bd412186cfeb287d97fc8337eeab3702d8b650389465fa14bbdc2601c7375c9d078554a71c0896fe3c42833d78456e82d604b1c7ded1a6e02ae6fddc2e1bd37e00e304943bb6d0951b2953828dd18073ef8790e355766177d41eb008927a670096acb99bc06306eac5fc3e1a89ad899f63222ea33a5c20d1ddcb0dba760dc9470dda7866afdbdf4eb9238380e859ecf7354df21d051572964d9140b20fcb7a9bad1a1321ab63ca3b0407be75d4a9c8d29cea7c98074fae83bef40cd008a70dfd9ff29c93271e6f5f1a2e6bc2f6b17034b247ec4039a8b9c52354623c4a1894a4e17dd594ea59dbf2e0631b619a667d7e593148f4e7fea27c475f47640ed6325c3e0a9ad0ea2c55b546a1f5b61f331f72a3c9b067a809771e8bf62c6ebb7c745fe0fddc0e578097c2bf166e041f7c23a8dd30b718df40047d27c3e02c94ca3ae8777c834736efaeb0ffa337bbb36202d1f6e2358b4ed5e56c4a6ca652149c10e4697d4b7684eda677bce8aed6f6d5e19f70e5956190b063eaa65aaa0efacd83308cd76a570ef205f5106f492163cc9b253d076958679270b7f09e006b4daef671332fa33a1a53b7ebc21969885dc2593bde66eb5590f404b57aed0d8e13c00990cf073d3befc4309ca38d7481db1bdf1fd5363c510248960da81be28e53ed54445e8c4f2727840efad5d372187bd0df0f98dfc37dcc0a48b4043e3517c0371dbe7108710f88e9ece174d0a036216ff1d590545bced157243ddce73b2f9df45afc2045ba5f8340405bf7cb4d2848835a7bc9817ae2f479a75bdf39cec5df3ba6a211779f4ff3c79401466a1ec26ffbf4ebed4fc66b268d0dfec4822e6c132e137a58fc5c82ad1a29c73881f0af240684321eb472b1887dda20e869f072a48c72aa0c1581e1eb883891f69fb8bc9a30bc25c2f2ee9deb4f148fbad21d8abce9f5eb1d5352bbab27ddaa010f69f2f0a986375a810c9986c14d2ecd4001b0e0fdab90cb8b280d243bbae6b2c00a7bcd295e1f226b15be9efda30a9dffb16ee0411e83695c785ca7c48d123d1e7485ad54fbe85cc2617cbb226b40c143bd77b62a3cf748937ebe9013431f0432fa9fcd559f71c00c65f4ad2d0ad3d610d20eb65b8d1c81a13c19b033c8c8829dc420088a82b1c14e78df0f2991af2fb189bef0b2ec1be27459d26d2c31341def6cf77200f5b41d563fae3ca28f269a9d6034f4e5c37718667e66c2be9fe2e323949e27338411ad242649d23120265f716f618c68ceeea1d351acb3fbfd09683badfb8962612a7d3cc157cfaf904e17b5af306f72a46d82ff937a85cf7fec867bc9bc886b35dc281cefbe0f9908ba7baf15e0c265f47a1d5810ce23936c5a194ed1ccdc7aa809e1f11d2dff01715c6fd76ab68c4b2b070735ba275e432e2f85a0672e021036eaa2281370784777902d33b2d270d618922fcd540b34a99c19844a20c32e60938c20471b4a944e24ec6a45c7c60044b6a75157546049c663dabf1a111ea28f79f7b7e118f09c4d73d66bbc85e913d52a710d3ad6f23fb7050d48157a1bc7060e7ce5fccf0d928c4c8f23759f852501d81873d1fb643ac4fc7cc0d2ba4a859b8ceac0f456b2983a3bb439e222b2ae3feafd17d99377341264a5040ab4f1541469ed945f875cc274a0a1bfaebcca3def0bfc0aa30f26a04eef2f21650b0a16f77e7c56fa25fb25146b05b32fa51f2ff125127754e4865568f238d8bd4761448798c6c28974590198b5835f0959c707aacbee2e63a5f709b1b791a7c3637964bee32567809e0839946b1417d96b15d4e5cfb46546f3db74c2f44a2106a167f286f942a2800de67af45b224d7127207121d63059dbf58166b36e76b3e59c67180b6856976c71dfc95509802024b835303212ca3d7f5e7ac4632833dcce5f9a621632065ffc9d78ea01d1ab91005d920b779ffe6c8cdad210e22ceb1a39274312f22e2d0ee532f34e3cc8118ff7f4f5ad02d4b05ff8a5b020a01f18ddfda0283ce866d730f8b592508c3fdc9ae0011ad6c2515681e13a637d5e6ac522834ca746774c7293aeec11a4b72fec54e1834f0e52abc883db60b6eb9923c5584b0bb91890a2b99a755880da5bffbed90f7979066798baab74df3efa21ea481a2ac64bf3cf55627321bb6ca23170896f5073e71e86956a583652e96a9d59194cf888d37777ac400a38673b4e91c550e1540ab81c2ead177a0531fe38475a5036f3f9cc9975104bd76cadffe9e8d6f0209e2d38b13598e386a291ab11a900fc5f163442fd9c08e4b090ed3bc781fe838710e291780d8395369f76bb965d3b4532ca48011aa06d8c56e81166a00f3932bf67d3708d693442fb0dad2fef43d930b0b35bd4110aedbe374ea49c10721c7de15c6526dca86afb780a7de2a33054621c40f2aad0dfb538a3a32b91528066f6fe576f1ed619e39b15f7ecdc258dd8516ab295e867da0cdc7bfe1eef5ad8bc36e0a232d26dbcf57235192bfa685455a34abc16d3e8bd197a03660224df7ba41c00652ae7ef42bed96439a730fecdde8cc9a2d0835e00ea4533a200c6a80aea07f76bdb12d3d1aa1061f1e482c5006a2927804994255f103ee16f8d086f07b8762035794fcf0a7264186baf27b553c956c6c99d5eab1507fd30c3a664cc735d7e98fd30b918eee4029d205bab4630577120517941dee228bd714d6001b2fcf6688b45813eec30cd0656b4e06381c07bd4adeae3c4894ca75c9e44ff3eff275418cd080fb8ff6a1b8f0b9f395ae379ec0165041ba957096c92b716cf1d7e488e823b625da39f9355901575882b2bc3ecb5593189099b107bd7a2f4b55f0b6b26f989aa6ef6a2e734122f6cfaec60b70a0e7fefe695d33e73ec92a4caf0d5a99fbe93ce837eaf1ef54c2108db70ddf4231cca76b889048c4bc6c69dcbd2da6acd76fa0b0678f3256085c0a15bf443240e60a209a921844a9d8493c8f7313352d8cb433a28ce6edc5c94307c8677440c7f27cfb620241eb3231ed6d2f8cf8b9975e89d243a9b308fd219ee6945a94b47feb9a11082d319f838f3f5e3ca9350a71bf1968a3e7503bebd8397a50426fffccca486aaf314c6868a54a487c5dcf51bac9124599fe6c70d8b8ee7ef25613303467a6b3f659d596cd8dbaf72ba970f3c6bf27b83b25a55000024c0e63daa26e5c1d3e9ea0e99b5210cc73a59dee0de8711a43e755ae6315e13ee43f29c6d61a610b407cf4eecdf11ffa64399f06508f4952d9e0309c924ed0fad5dc749d5c3dd90f564d999025187c21e4cd7899250996d5b5281dabdad7dafb61a7bea81746510a1760004951680daefbe3dc6bd263b3ca794bb61f2717f0ed9545f4504b2d759cd1df9a1d2a61bd5f2ada4991ff9048b62e102bd5538d28a8d407718085df8cc7f3ebc64c1ccad13f6f5c5bc542bba179e1f69ca71af7bedcaed66cb1ab5b808e197e4f0d1b0d941d25398dc94b8f4eeaa4c52204852b6efe7c2010393296e2147c9187c9933ab3a0fabc0f226212bb3e509c86c6932929dcd2971a37a85f926a8c10e585c6f70fe7f0447a51bf6f75071fb5d46fab0605b011a9a14256ccdac81e8025cc8e2dd4e3b3d7683d9e10fb44da6e5efa6f9586c97a409d4522874b134ab9a37e0fdc304ab19a6534b68b217b773c7ab1e3184a5b316653d5070c86af9d1ee8f4c09dfda2aa02440d9c8cf53ffc1e03ec18d0834769f4581d49c924a2673bf5b21de115303ce64250fc4caa6264a73e66c6a29d1f69b171e57ed756791506ed9a1d7253eb361cf108d255f77e621df3195b5ffa20e394f0e2848a0e4fffbea4e3e3c23a2e4d033c7fea2b370f1b98578158217859425ca131437872e7b6490dc5ea820181508b211201d91f5c21f5ed2e4014d101476791b3d4a26d684d8b143e12b321b7b8b8be7204f3ded2c054967f21f56a25cd9e4bbfcb8d5ea1a06501cf08264c69065e7aa58f2fbdc28534cb82c9f1485a217d3e394b4c52b0031788dc39ddb62cb4a01f9acbee11440e418ba60ecb085e9fd9d1981c7f2e6b239d2639ef70fe393222dd067889aabd2b838c37e4aa06b66ee1ce32cbfe484a2b563b45d8dbd9e4c14f69d73768df6331a3c925c60ff79222270093802969f7b4dd51e1baec383c9cdbd4b1ed8a067f84414527a3647ff424e59141d2e27b6623acfdc455191b697a699bc3f4aade4c2e2396c65ad1a192d4deff261d1aea76e1494d8777ea6c30f392f95295c336fdad443f0cf9798d671e715f1547cf570c5b1211627d7d0f7b9e6605a9e16a27470dc47a2bcd22d0a49d0796ebbaaee7d3bab897c779e1fed7c0879d4f770f738d6b89ecf36753ee26b4f10d22f942f6d526e0dffc5ee14910036dfae02ca5a4bc4d78d3d44eaa29af22c64c41653fa86f3c6e498d89a2ca9a2514b01aa73173343d86208ae762d13a234d8ea9c14ba2b4c69364fd587c032fe21efcc43a48f067bf0f0f8bebf4ce705b4ae94bb8487de99c437b6b45e7fbfc49ff765b490b0818280b8e407dc863c36f3c54fd60128cd8029759fdd00f46daf282151d0dcd832a2419bad34788f5155ffbc7ca79eaddbfe6e29fcca94e34dd657ebfe2edac9cbaaca883914806bc2e1b270c74df5eb50977aa61f5925a21335a49a96cfc59f2d00a65b3e65ec816034d853c01ca89dd19d9ee7854e31895f6febbabb2c086bd2d2aae7b6bbf4037e3c22008167029a71ff364b6b90849b18c947d2641a6f55642080f4106e70aa8b7e6f2cbc2c9628e9585482f9957c4ea5c91ab75e9b657c0b6444d4cd01dbd69b9a28d3c36e0da582e7aec9cd030547acdcb6116adec7e8251c62257a0409b04d1db1fcdc032ad56894f4dafade1152fcc3b23e2b3a6fbfea8a01e10e4890e3423bc4a787302604eae673595f0102e584f63638f0ad8045ee59a8ad3f20772f95282df45899ee36d0300a14a8ba05df348937dc6c7a57a189755c41ea4ca35c7ee49a966f82b4bd571c3e20f91bb6183328fd20f0bf9d325de0db306377967ba28d45d0749ea04de4ed442d0ffdfd8cd15848e162a85aadf1b4c33be3e32f4f0c13a4011c9043a34fda8e798963ae0557f477a23b16567b83bb1449ecc57c5a5e87d0d0fb6f72cf3390ed3c1ccdd7f7c796d48417bde8739a741485df62f5fbe47f9f570d34cf3f22892c91a01994bcdf757408e8fe19f0b5ed7f91d76caf8a4c20304cfb64c7ab76a8292c08ce548418d41f0a6ba28a25066b6ae8a99600a70008ce12cdffb6659c7de718061aa856ae4e15c17efa390cdfac710ed4ea52d11754fcc68a38878f214b66c8aeb71572bb70a974c07be8478f37b49ace21dfbc1e340cbbbfd3920223fa312e8668c5ed28320baf6784ac8900fe6568867bb7cc22060777bebe1103f1345af9cd68e313bfa615d1a3d5d149ab9a0ccb6cb5932e7d824abee4dc11e43c98b4c93b3e493a838cf9a9943f8ef856c5d51b13f871b6f327fa63fa0779de5136af813db17c9a6addf38ea6297f9ff5ab251acc12d07325afb594b0a736d4ed4e8ed8c69778f68c7959b0586b6ba3e74fb31ba320f40a8f8a560e03a8b405d392dd88754f9067ea0e1b761cfea8ada99cd3c3d23a4e0ad454c1453f5fb2aab7ed4b57e992bdd7ec28192b59851ad151b83459afb50034bcd86c38bd51926721578c7c18c83ba8fbde318d791a0c0d6be3b2deea9815149f1c9f203aed9a08bc30ce723c123e475ff3c1470b036badcf46b6020f8899b4ca6c81522217d9a7c759e0394f9e882718b56028606ed0b3b306997b6d7b16ce0c57e40d3bc4b6b3944daa4afa1877ffd4e78e21543bf57c0bbe7d8ea6f14b6109b93e37705613efdbeccf7550b5cd9f35b9ce5c4d2d83c5041b20a8eb36f55106eae626298d47458f18ab76eb908e342ce91f6f0c9133c64ac30b227395003ee44d41ad473b9d5662a24d717028ef660efce3cba79af13c9a2ec057df91887393f9568beee6908108700cfe753434f38e01704da5200043a1c10f996b826bb4add3509ea70dc37ae787e7827e5b39a90089cdf0acc7939a453c1903b057083acdeb8704655e240827aae435ca177ba1247f32923e4b1c09e4a27233275ac413e2d33dc5d0d1926ffbe10628a4917bd9bc56be42e782c32fea3980acc8e7ef3311350d97318e3f4de1c21978e84edf1c33757de82c60b300a7a85d3721ebc328b8317af203a6b4f2bbeb8d2640f7b46e2c4e5f3925e3cc5791928990653b856542b33687631141dc6115f89b594ea3764c03f659e837e20acc6db6fca3c707b93d8db03551de9471c1243d2826aa3638b56b5f372f106bfb1cc434a12e743ebfb17b1af393a5ef01fef47664a60b0c8034307dc4496bd6ca57baf28f276ac9dddf7193b54187e48887ea45873ad0d07c8286531977e90672fd4399bb528f97412c3f073e9cf4b21a46b92174612ba78c8f01cdf0a47b9c18c18b0a2faedc1b296d313f4a6e46eb1dcc2934eb7b227fe4cf65726c2fa80e753c5b355cb2981d6300660f8edeb0b3bdc056464d1c79edc173eb2a00890c1947083d684870bdc3882bb1dc7d4fe85e9cd4d0c48629bad3d170bc993d1b23b8e833711a02a6bd40d3f12b01543220aa01e95d79ca58d6a0bb524a4c9a177cfb9fb4c3a64dfd97cb1e39fc71e8d9d99aeeb102361bc53441782a1d0398280c8172a4a169954384b1428bd082ff61b2c964f3967449e7c50106c8860f1249271a5846eb513972119f4a056ceab222feea035f2601029e82d07d107b1c7664c3ffb140195619fa30af5c68da0f5c75a3504b66537e3b68c725343dc7c0a32d75c0d11e141a1890d5dbc491cb8920827a334388df832264730f946ff411039f41de32ccc568e2034ebf430d5032760440d7fcd34057385fc853da5779df00deea9c15c68fb4768dd787ae65dd9eb5699228f33f65a8b9d0b5c35a4dfb5edef654e27eebe0fe874e79e430c305c32e825aa52bd66b2d8c64fd9017a11f69bcf83e4aaa17a410e6f337d1570fbcc24da2086e3b54857fae3f8f9c2078bf94745e5108785bb2faf97252c071ec14fc95e676304506c7114d2c6cdefa173dfa2f71c558e8a9de116ebf3c12a481868b790c9f5d78e603f9f5371eb700aa9040d6d2b78e95ca28eb408b8a7220124dfee1b2b9fa1467077ec22bcd2529dc10b3a269c3b29f7bcf323bee65211d332041d233a99658ca406eacef76ab141fbe5084bf8de6f5fd302a9582225bfc1034132144443331adb646e60d36b43d6c3d35281ad7225f1973fb6d16e97853119af991e11d404b0bda1d2c8ea1aae21048d1c4f18c7dff299d507ccfc9968a8c2058e8c44a8a774c2bf9554a1ca458711d27236add919bc63cfb3af6a1c307e4533d4c72b6d0a9765789fa4c61b59a3b81acdc9863dd40d52fd97587fa53ff171e471ec4d479067d2a0b0ced7fba5404152f40c7ae41ff9a6bbd069733c4cdc1cedb6c7352f6ce2fc2db55940a98cabee1778bfeb0ee448766482aae82e7ec9fab9238c8a8787807f1b6c31cd57e91a97f04127dffcba1ba52914daf9b1e06a22b6b0e0fe14e319633833865298d920d9906cc177c1cbca2704a5e62e7aabe886e576bdb6b9545079a69611d4639d15685e3c5b4ee58f8f9355d7fdd9469e89a89a8a56983ffb6a6520847a03cc5fdf29b4c09fbcef13d07ca5b0099c5946d04c580d17739df6b0c3d480676038f1872685fdb5921084052761d479cf403f441a33a38f02f23006cc0bae26dda1b6e45fb750a807a6d6d94ec72670bf6fce47056094a4df111b887ba9da516e04a7f0aa86f20fbcd4384fabe3ae9ea82d9c2ba2d00b6e877d1091b267f9b1dd903e01679dbc73b32322ae2484ec70bec1b54c4f51a0f053d270c461e779f5da1476df0e24d954e3583c368e20c9ce7b893514ac806894190182cb225a2c398f9348dfef269e5a8c6ec1cf58438dd65e77b586edc562c4c4d1ab7658e9d08f00bfa96ad818110805d1a176d2906dc20d7ccf11d105124fba51f0f2eb99988808625050c7d6ceb7bd3e764218b58ad7884e67077818ef709516fd8023241507df61d7aa7469ac7d4e00bf821dba0cf34eacc1d6e8a18026a1fb0df38c9d98ecd3bd1048ee5cfa23735776e656ce8dd401897593e0ce9a935d295af0304f3cde02bad56b93551d914b0e4283f69ac136a4581a66a9dc4f6b28e33823d20c578a95d6112dae7654d7f35543c74353022baee9a821455a0b976f4d56ad9405d31fcfb0029105f97287b12eb554a0dcb6cce51eb98319c14f2a6ac6d57b735d3b6fdefb4f996497206312f58f8cc31a2e6baa56b92b469a1f5e9fce07a0e83ec513b86992db451ec6ed04826619edf5234a1aea5a2880517f3d0e27a4f6f52e9a16a24eee442280f951711847938ecae9f9dc2fa1babc4d9772966de38def5b32da03956746a906868272529d1c9a1cb72d3c671b8e859b739a0bbc4041ecf4bf2d019acf566fcd9c3bdc6bee2e8064e0890441622df62e854691a70883d0f53618a315f77136e77b0c8b6a6a8b5f3789abb2b477c266acabb5ac399d795ff844d57e0e95c80b5941cb894f179bf31bdc58ee46bb158ac9b3f69af7ebd8743802c640c7e520675f46b91561d95087b1963601249431d58dd13694d09cb615f949a75b6e84160b2a5b585d7cffcad66bb8160b91ed5f2ba3cdacaa44036abd4adca5faa9d3dff0f30c91abb797e698508e48e316f25044898602ddb91e1ec4034aec284ae98d940b72c114c68a625bf0ea32847ec21057b4faf7acbf22a3c6034add00449c18bd20ae65a121686755bd45aba94d929af6ff49181d2a6c2b19bdb5c23cc16b8e04d1ece522b77dfd7384fa9d51b57b78a648476e0225d67b9c59ac6af13f91761a924df79e34cab20f67a44ced21ef48cfa8f0292bc92583cd68471cb6aab34eb814c40f1f07bcd2e78304a357e99bb57cab73f02c37ac7d45d8f2efe20265110f51be24f2b4803c8da120c02b33840edb9eecbe399e30086c5675dd83dd263fcce403df708bcacdde4eed1bc8b28ba2c4fca802c52cba54a207aadf9c768f9375bf668a13ecdf79f34a3cc658e863f0490e5a56003f57148094c58f1307d5fff0e78381717e69796e2fb499a81c35cd1516423da131a1c518336f4bd6faed7f22e322ceb979b331175cb7cffcb542f038a16eeb6ca258c3c00471bd8cec3181faa9b310360eee87b85436dc28a1a403497802d21ad58de964bed6a4423886c259305613b78e6b8be3ac9416ef963d83aed1e6d6081f1690411d603dced22220df1dc99895e4e7e893390df9c2bd08109b778def05adf10b1b1416586c81289185edad700a509581131435f5c4136d88b3018a2c5e195f79f21ad387183a29863fc9d3443202a1df266ff492bcee77132ab53e4d08a71a215fa9a8497155455601ca43762bd78d924c86901046111b10ef802306f230df80b247ba816f2edf0c477d8cb3e648a4769916cf76325c6f79cda87ec48a3062daba92c5d0f118a1b82a05c78ef62cda1760290aff2e81253dd8723641b2193c21004be4aebc8d3b7af541e04d13a8fc3c2c17bb2653c4a080b3e296ed1eb7a137e7bc0c911c38926890b99205465bd4d7c1787f35371702087611185ef2b7dc31a174f6d67acc6362ab89f2fd23231cb4ea4537eadfc5d3efc3612fe685c6cff46b1a001e0ce532353cfab7d24cfd1be4e0469648854a8ef65776218f02d9b3c9e53d4bf54a6ec2b59c0c18f917fa411bc0278a65a40b62d3c14ec65078e89fa6747ea1d7ab71ec994e48a4b7426e81b8f42fcbb143d23d9877aecdf55af6492f8d47a8b60ecebb600b896e126c16224c74da82ea9cac464efe0165f35314e90443059eb85eeb7ecedc51bec2dbbe30ef9eae4d09a9365552d00fa2f58d1bc0153af698b7456b96b14ebe5950e605df8c818f9277906d56d2d00bb0587013c83672de2daa46626be6312968dbe3874888b7fdb55fbf9420d84546ef155c3165f5803d2a948618c32b687f7970655b06061f674db5e0a66690ff10d98b98c970d9d903875669320ef773e3c645bd80ad357257a0ce57a9dc99070f6f16c78784d8dee92d5765c9dec939791d1d4b09a51e4cd6c7d436faefd030ed266c09573f0620b2f91f2b05000ec497a266b889e699a934af2bca41eae075efca5c2edf412829027341f81561078b043cd10cd571c3921936d5f095f1b6f2eed4139d9c3947daaaf709f6aae82b52f85af4c6f0784212e8808ab075db04a296183bb032420ee0a553c45b4da40a83ea1cbd574c14daaeab4a99583e6f2580f0db3c17103b8db63b5ddc17002d2239cf90b21cec2501dc8b81218ba79385b0bb439d87923dabbdb7ccccd5fe1e42b4630c344ed818c4d7efcab6db5b9f67c7eda4a935af98554b8dfe9fc005dad5ce27435e85259f3ab36fb792844ee5ebcaedf2c92093eb5ccc45e60053df0c35965b36fe573538c2a50ffaa2d1707a862d018a6ab4fbe894a44b03eded6b8752fd11163fe70d9c24417047d42fe4b37a2e4f76de09a8857801eb10758f71586ddc6e119bdab5bde5a5536d144860997c2663d4c83d556992773c60d73d4c77d3fc5774ebe4f59ac257de088d70222921a53a5a0ee589909ba81214285fdc103a0f2cd9f2423aba585d99d5ca34b9d5404cd7c85460b4ec81ab48fabde3c061e8a0356725e5bacac2055d9dfd3ce9a06c1dec38c412cbb35baae5848744a5f36d13206e5ecbd4aa22415a5e2d08a4d2b7241547c5d95136d15d4ff0d32175e4daafb7843d773399cc8a1ea20376b813103631e0eb74e7194be447caeff74195c77bd30f6416ca4af327f6848313d034f6af9bc9d47b8d4a7e390f42460332815a22e606dd507bf1e9d2c925d34dd2df22a46b8fd486f9f5e73976b230ff28ab6dec42d8684703c9e4a2d2264e80b7116e8c26a998df4040d379d3d60c9715bfb6a5c1d139d8358b5b68a1db45e0f69dff75d63ab4ab4260da969ba7567d2f0be98cfd8c20b7a0a5161a78a82e26da2c86c08a189e9a4787cf85126a5460446fd9ccd9acfe714af3a4f16104db06f165c41c8bb5ee65583e684f035d209731a94fde94b7f537f1a77ffd956138945844b3c94df2632545db141f68bf59a4b62401565d550b985ef53a0cfd9996120ad33488804712eec062b85f52754bdafd69a3cc90301f38896bb9313e869b30b3138acf81f8ebcdaf74e3445aa4e5f557157daf5ebab5f46ca1cb2bfeb28b64ec5454d39052e25e493641d9f98c96479aac6eec9a4605baa536b3e9a075f0c3c31bbce481ec9c9f91fd17c45eac1490fc0f0c4e00d5b0035be1026369a7a3032a1575ee2e2eff12196a4d6c43e50482e7d6c9a93799dcee90bf5c9ca4179292cc3e275edb87b37b00850c176404545d916a696720d0fa554ca8a6d48f72bcd55f0d6a32e2f10382aa96754e7b7cd140d46b083d23d686d6a0e0fdbe0d06a24663002da38a4dd2e122e2c523b8f56026f89bce1490a9818758a7bca901429c125d2d4bde1074fff601c0bf49cb5a184ef0a63d4a3797dc9a9ba00760f52a9ce3edd29739f044a8867ed91e6a33a792e39e8212d6bf6608cae685bcf36c54502439ed91479dcae6409c9926696e2c6a5641d95f5fbbc15831b8d9cd0b063aff9787a22c9d5e4490a1099ac8d728bfde05348d152b0ff4f50214876d858d70107d28a1cc41608f410d4b81f03a913a650d903dc3e2fcacc361820df8438a395f0fc80edbb12c9ece0edad8437d8a1d270fcb7f9c1354ef9eaf7b871175d889e7cf8b77d2af5d85f0b386efbcd073a606330f8631603e6ff12c9a5521a170f7d659679450ae48a5625dae6f281d32980536e41a52e2d902b64c910a683d8e3cd6b47dbd6a6a5b09bbf6c14b643a3ea1eabaec0716cc0645b848c315425c42c8f0379687b0e4263d4f60ebb23c6f6884441a9ac4a0eed0c7fce6b20145ad0f1caa4da38503c5f2b8ca370c4a98ad6bb4dbbf2e031c8385353322759fb2410a4f0b5781d76de792dd5524226d61bfbf8189ca33e690b7d2e48707a76fdfec4d5f4c62d7660fa256d393d966e765c7496bd62b403e16737bbf2acde72c50ad768566b8dd77ede683771a99d561d3850bf4eed2f913bd74eb267b7ba62c3166c22292087e41d3172d2c07a967149cd6eb3debe0ba8b84b19e5cebba9aeade4738a14ccf31bfbc125b7f601e7c258c9213f334360ccb7776c502076290ca101ce5d2968e888f92fb44219f95d1566a1bae626f5c997f956d4ffcb1095aadea611e23d21982315e074fe739ce9d0d993edfa739f61ae2b375e6ebb382fb95288ac352064662f743923f217c3195ecb5889687fdf3fb0bc7d52e65b3c3d0faadc4503a63fc98a69e78d7a246ffc3ad16a9db6fb8a022239a15612766b2ba3c310edcad89bcb99e471c39490467351ee1f5646e30782ee32affbfab443db90b94d36167e70c2be6cd18deb51ceee0f932210c8f352d342a27598159dd1624e4132d49b58afe208c93aa773515f4f3325a94e7c09c556cc8db38ffbb4d38121465dd907469bbc6346290de7f868d065f21b9149b16e470608e21280f6ba60060def9625363eab4e735aaa84385c4aa3299a3a9bfbd43a0888d6cb1ebd6ddbb417f53d169b8b5f605cbbde23b86aec70f473f59762188a304e9b8fdc7dd252be0a8581cfcfe6de62680df2cd1d76c21642e8661dc29c18bd6a471ddaab17a7e671275f1bdc8252e10518536c03237d02de910977db369a595510e8fefdf30de94aec56fda69c24fda29f88f439bc48ab514debd821f7e5af46c56e2403104df5abed59c8c78429bf0ff89b5f88596df8488a6086d463fde1de66791e1796c70a17eaf7b385f38f9b31513b57826f9ed03738c6e954a142d4dd11c5febf7aa2ab2f847063e16566b2587caba800344c88501a879b1e1beebb30d1904dcdd3cbec969f4bdeca8eab05ea1ab8692d896cf04e90f576e1cda4080b021554e67d60d64e7029972bac3cc96018fe9e991a115aa3d74b04fa110b714173fa6fb6a02c0bfb06b0cf89ee73f3994a2c4c127e58f34e9e89875e91dc34be6b52aed3075f5e7d8eee6da7230c0aa518d115bb4aa72b617685529e8dd3bd5493cb0173d35e8c4db96d0baeeb99a6f1544bc5b45c30af0d46d6c9008d85082dec4ca86091d7d3e5c4eb088d4405770d92df3435f99487e27f99a0c30babab6d52b537fa2cfbc44c60a964d381d86f23bc92838d9483e8a93140e48268365af7ef44d5c27567d796d461c28044b642e943467471aa8c08abc84506bdd3ab2e895117ff7e209eceab561e13a029dbc32dc7acea79d684407487714aae9923f27f6a929dca0d14b125040d892c3d7e4b51f1756a2a9dba53f4dab160a688620d6a9f568001937016bd615d349c594191f92f2f745e90d5940a3b96f1ae1e51a720804ca2fcd176aef84da7ea0aa07090927d6f0d5a133a56b185443561303e52409d5ca4bad529959706a14182fa99dd8c6d32db17b57052b05776d88e47317938df334b0df9ccb6de97535c5cb285f41ef54941bd9908ebfa68a8df516f661b9cf11ce4205c42a1abf48d275af9eb0c81c12537d06f0b9d4242b8c61eabe9b30c124c37a1f503ad13280f393759f851f14c7217b3a1960152d0fa38bd8c10da4e27110a81533d6b61c38ace9e92b3bf9e31373601bf0b2e474850e5db029296eb8c67e5ab092dc5afd956d28745c02b8dc4865d3d1a94ff0b84f782006289b3d83e43bf378115fe5f18bc7a3aa5be36448b5258dd5629c9dde5a69339e863d21c54be1d0717d92f555e8602d05cf29cdc367d83c9b0772ccc60b8eea0645c7a481825db4f6246e18a8487c1569f10495447898ab7e2705ee9af7aeeb894390a9724788360e42113e5e218e250b86535134672b1add43e3767a8f72404c70e24df3f60923b457e74fce4909f9d024888be2d1ca3ad570a10ea306c7e8323e0530d7033d618095fdcb0fb4984284379a7158cb877c240a0e7603d9700037c7d170aab5be0f8095cb00fae75593d01fdf9c9f1c39b5624b0e65461501b724c99d38465f925bff245f40c4c44b04f557e83ed53d46a2458b25a4422e9265ea32f5c895c4e6e97d87e043eb9564ed0a01413cf4046a087e424fb69bc33d481aa51195c46e18f6bc8bfe47171bdf929cf6931912f12c9a147d2a9e9e5ac55104772609bc1bfae968a4cb82e0b466a64d3e896f01f4acb4878e0cfa29a9461b8bb92681559885e54505fdd1dabe739d9f8841f73dcf97085af57af1ef2c30b2509e989e15dabc889dfc7dd23b8b22c4ed44c88b85bf54f27edd069666a43ae8ec36d09efe5b6533253b885381aa7afa4365a386de64caae3cd100e5d9358c4f9c1b4600307d0105a6519a0d78d5c92ef63991ddb162c391ae9a4294cec43f4d4b52f98aadac13e9f71227c26e943acaaaecbb3d04d620c69e224a68aed8c6544b7e49cf4b8c35d8bb295fb924becde212813b1fd454d5615b3cbacaa5c5c9aa60fe41007540030d8fb2041a812ed77cd39993c5830be9aa38b863b388b7ec98149c133746684162108c32e62415e12bf0de272b26470bd654ff5f1238406de65d2f1081b3fc95e2043f619844679ba88eb66ed995fc93866c5888fe52a22c533e9fe7390d6d212f60f89c1520f9d384218d8d0089387e12de0ede96ce66e0de03919381d8af71716802da15c1127152d2bee70ed3d96a29c9f189551d4ddb6ad80fb5bd6e8590bf99504cc3819393fd8cd9680bb1f2d3409d41ff2d7fd6b1c1183219bced7eaf0c7e691eec013cb86eb725995a1fb522479f76e651936fedc0ad50d37af0d7569eb384d872555b2e2fa947d2da3f5cd2747d2d98affcba70f6076ef9023cf9b267f7f929167c9118dcf194fb177ffe0daf93218a139ad86d6eefab69ba2543a0adba1d6487401db6337939839155b4821ad9a37b8bcacfae6e1c948224f2dfb1fc43c2ebdf0a5132351cfa67eb7ef3eb6f73cf729060098ea7519f92ef7da16990ac878f0e7aac160b8910805942dcf6145c1bd821e46e3ee5e7722b93c9c55390caf1344feb6a1ab1a4dd1a1becfd20922c6979272b9c4e1475c3d4422052f14949062a57c95cfd25298e9f932ba061f8cadb5b841daa100540c84cf363d6a45cf98708166a319375fcb7b975a04fa47b602f40a99366260d779c244b25d1c48d1839e6276108bcba0bcddd0dbb06b25091730d620b6127f158f09882d1f499ef7e7860e03880fa953efdaf62b0792828d4ccb553e27bb08c6cb799d61a55acd00e6eb50d63f693a1c96050dcf2b51bb8bd1d02092724cc798a0544cf5e0386f87d708039b7dc0bd78b8698a7596354fd9e45fc26ec4e721877c4463f0b63b8adab643d82d0a17b5baf4506691466a1eb16d2c5b02b5fb8b54210983c27aea82c92c77bf76c8b42e8450f7d9ceb0b53235056e8e5aa4c6e90e9d1a8e37af5c344c39106a361095f8498febd5346b85924f0eb85c42cc31850b5f2c0d40e0bd334e5c5171562e8063609c044ff0cd25f9e7abd7753f92542d163f73bec175d11cbcdc82752fd507c00e8ceec79de68eea2521af40861d83230d18afc623616709906f0b97dcd2d024449440de45c381a5291d452a8ea4dfebc1ac6dc93e5d63f0c0df0be03b982c648b5a9e88f9553668f2b313f4d8c43cb3f216df45b741dcff01da6493a690187385cad263d1dec27c8925e455510337437df54031e14b5a78fcc828a8eb7d7bb77cd2aed5b32cde53256f64c9b0e4005633b3b7b9c6a601e6bf78170808ee9f168680907efa8fef70d7ed92ef2eeb1f798711f98b0b79c59d1534abf7a62ee459304998fe0b8313c0a83955e938decf7a621eaa54e9394c6df72c690e6af69234650dd2560b38f6e9950335430cb3fb49081ea03f239edcd4cf57ed9e836823d586de72c8818196b07dbdeff489e3ec49c53eb090c2af49af8f9c80a4b6308ddc902e2fa14f031a868c4ad62668b36d187a8ae1a21c5b1e87a4a4575e86afe1f40f5455871c30307d207513cabfc3d79ed1148d1a710c5c7a358f434d11c4991269ffc919af3ebb86b5f30d49dfe137ba81f9fedb83594733c7892ca39b2d714ba1f0129c1df533491d5859217a2e4e5c865681db74c7f879e642fdd38df8b17b3830b6121da3d7053f2403a1583579536a716165fb91d066d8728e04162ddf4573f633a699efbf7aca0867fa87d97f167b1ba840f47c91560d8e8a5111aa4d0e020fb8103f5b604be3ab514d72e98092d66f2654caaf7ec084ef6ee94ccd0aed9df9fe2027b132157ea1c14555af9df4ffd33eced7abda7e3b22c086e336e756b1f9d20a67dd1340c0156d0fcf1b87ef8b27f3723b6a92f1ae6c62ed08857224c245033cc963b03e14b2ea72e8e72207f60a85e9a3765935ad1280753f81b8661cae359d5662338c23701cf2a856b39bee5d6b55e84cfa6d2920810220bacddb670daede15fdb9bf183c71cdb3e4d4318dec89bdf5d02a8d4f561104e2d89396199843990342d5170d231a104056e12afa1e27cc03a4b73e7cd303f5487e77dc7a1da95659e683a6c72d014dd19f1913ab5d9c9e2c984d9508f2ca68f42cc28be191818fbbcf6fb61e06c68409089ec9c27ae995819bda0468e66b6a42346969740a1ac270f35095828c9cf40a1a3797383cba9b75cb8e49fc0dc8fb68b1ffd105de2cb1c11452078848bfbc7131ff6dc63b5eeef740ee686ee3ebb9a306d4c6dca6645fa7598cda73cb645c7bfb4c372b0197215957ac7e87fe735c6e11d2876d660c4d7d038fc5ddb92deb50495d8a5a576b68862ccf6aaeb0c2702e8d0eb0e14de988448a023e2a91703d4f4f70a5de56ecf8969876b5cde64b10f5baed6cbec63a6ef38b20930b6180f3aab363f353a424977c5e6fec00bd74f1385daafac5139ef7729518e656c3e3b997a3781c19b30c1183ed9356c93f6308e047aa2352759bad57554bf72ded9d9dd2e8d7737b6baa80b7e9b44ca53727eeddbb7b400f856558f913f2c7dcbb914b92a4ce7f5214ec6c2146054f678cf7e93fadee0ea8d457d46636850541749d8f1a1a097c9ff04d62c1e2fe46707f67b02400cd1d770a99a972c14ad25e0dc0b8d612292347289a6da87b62cdbe7d37c100c1a413baa7a8b3b9972a7740bed81ce55b24c63fa9037be85f20f0a8b7ac315c61bdc47f9bfe1a735d11b254a1224e258c9a82538845f816edc1817cabfa742f1744b1ac12c9c55693a55eec6f28d53c4d74be59e7715eb62f8fdf054f89c21ea60b678769c2670abcc42c316cf382eb0ef29effc483a316b046f8dfaa52919f1dce6bad18c463be9c21910f6faebce03d97e8b1c4f6713c56c04efd47bdf189e3fb2859ecd2bdbe04fe57e1f182c31ec8ad38e5a135d85b80f83cef563082717e523526cabd5f2a950121a05bffc58dd06b75efea55b67183d5ba57f45138ec466bd8b4e3e5662e2d28f8909c6df6a9fb6cb9a5a14e8f2f8cfc2c6d8dfdb092c68ebfd0385a8d4a3a8d6c09504e943a4e16d4dd7d2e432e69216c54891e296fe2025a8178c57b151320340a11c2f6c8343e5f726d83a9b793738882affe755b5093d16f6075e60e1298df3b2d3b3e3249e739245a930b1c23f3c684687a9eca1ff38a8d9e30cb62f75a572e040cd4e1294d8523b702cf1f09979e90de89e7042e43967544537a09878312460ad7c5ad30f27161d9918f511e273b2a992f3fa4eddf699201cbe5a78c5d487b2de804319f1a2033ea8602ddc87da62ac3bd713b870f4c636a8e3d36ee7b413fdb01386f47ff3a56c12f74d7ea40e141a3521c3162827af1880e48c93180285e27e7b6b8edba63a4390aabd3792c2499c8f45fcb9d3299f705f514e3a0d67e72ef020276e35e7c42cad5ab5f433791bd814eae6d3c4bcefe2fcf3f234355d0b93675847b6ad8cc1acc606a8d21f263ae67233cf084c5ded3502494de4d43abb8cdbb614f4d8e018966291db644973395baf0c253b8528a7f5cce2d6bbe94ec868a5aac471ab762d0b77068e274a56695d2631f5d73ddf7c77aedfe09bc53a68efea10ed175791af45fe38054904302a7548a9fb625e20c8535b3235f3af8b8c7a6a1c716d602528222bcdcd5eae5d18b3f5f8f9d3f8b992fff45ba35f70f426524756464f6db116f5b55d0cc7b4533e975a18c2bb4da204367f5b03ad3d6aa81946821f188b04a82f6fc66d58b541a13b4485efe50d78fb49b2fea215c5e9ee6c2c85d938d5b334b1ee299ae45c8a597076de095bd52d4848a7c0631adc99d6e88700ac9adb511fdbd9dc4525e00582c8220264910c09edfd7b03658b177dd312616eb323ea5adbc245bf8e407400bb8b46802fb3a83198a7c62f68b4d4dd09e9b801b95269d923ed52b3826130c9d8a4799b580597a5ee0ad9a471722825edf58b149e2b74b99a6e2957856d8f52d6550f518959cdfb345dd06a0f18f0bceae385dc8a98aebcb62e69a42dda42dbc5bccdae259366e51a9aae5c583a37370cf330cec9ab27a22f0f667ecf425e94834257e2597e0e6cb41cfa556b4126e47d02a39a0ec6c42b3c13de500301ce0f2672d782fc8abea9fdb867378bb05e3c4b3f3721de00e743bb41deacb277b9e663f1425302c3c9e4a616e5cce16c24b8be69836414283c4b824afe1b76513b22649d21e1c93d79980a345ee2c8e7bf3f1bc2eab2fb21f7bd6259b8f1ceaabc68364eb6a2d16a8a53c46e5756f5b0dc87e462747b00f3784380838c2a4fbf4ee5f19284fe43b96b2b3e432edb578da1a35d3dabb99de20f7f34a50028e059ceda8c54f78a10547a7cd8944cfac4770f6ff6f0deedb4c8a9213326044e994d1abc367d80b14a3e7a77c7bc836e6a2ad92571fbe3b38d8437868c95e367e7336c6856145c04949df0da11b7b76626f1b806525be4708c37c1b9f45e1f64633dfbb16a6bae0d3723cde955cfce5ce29f10bbb8bc0396d160a5e36485704e7f76b16a3ae3888e1d21912b3ca22a5ea8061a33b8dfa24a540490c582a1718e3d32e3955c2aa0ab0ad6177249ecd69e124ee6da07fcdc75f4f6780844db98d320edba45a6601d5ce795d5a8bebf0e24d0be9fd79021d1a47dff36537dd2aa903ad7ae28638976bb700d9f73334880c982ddaf233c052e8af0e7bb499fd0a3b2648ffe9a0568f790db96259cebefb3c976f9a205b13fb918bf271514fd1867f2261946810fb379cabd9edd51c15847593eb7fa1666f6cdcc408acb99aed1fca8060c661f239eb29a9dd94209e2b950eabada68279ef437a92aee0d46bab06dbbec0e27f61972ef53b58eaea9bf1429ac1898a4c0960f706f528ccaaf4fe582ba47ad892a0b8a458b70c07d61f5dd7c7e856aab722bca42284ddfab0eb36d0f467e10d2c25de2e8ac51e61be261c34c7defe0581c946a30781645b26c2f3578dcaef1b8a1db1e4b21f3a156f7b07df25ddd85ee4d19638d6630364d48d5fbb35d4afb86755bccfd36c5fab5e93b7f2cce68dc72cc6829842d001830d8a192113634e5331e42cbe8b5b9b3227ac2638e85df07ac482ad0469c15b7d4cc5de3339499ffb6a4d31c748f7411e590eb15a25a22fef57a467d0d26c9cbea96846f47f2fc3caa38b45afdde63f9e2b43273e1c0bf3e25f541b77a4536665ea5bbd801e3236ee9353c8f034ac0992af212e84b9eb6331895dd7536ed2b4069b422a19d5d4d785d8d43cf678418b4c8eeb6d7bca486ae7d7e848c087d866e8bec214bc4674180f61a69835fcb3bc4ce92891dba345c4a3f9af215f6a39059b222616ec20674dc07f6ccc863c95d8292a4f77ab687d9ef3955a16f74f6f1a735842192bbd18b96a4b50d2b9d7adaac0b1b01509d5f7a846a413a4d9457bc684fdc773da6eadd3bd9d6323fac889bb76ef77b939a3e76fb5c07e1015edbf744cdcd575b3b251c3825f8bd588d6bc6cac48cd52bfea4214d8e6cc1ad557a07f461bba3704cbcc3505c44168e6bf2b3d4ecfc2ba0cb51478884762d6fb583fe0e2d60e2ca76cd886b075600f2ee49a8f0525b0ba0d861465e1ee4a7f8486d750633a49d34d3115abab393c2ef87544879e2ad14f39d5b9fa6ad1c5429dad70dad1a40bf0f6c7ea37e25927798a4d9ad35a892a4fbfce5cd4c3868589b5935f258c1617f3d8857ab976f3a5e0eb6f01da4c3e4e4d66fad53b690320160f01bb7bc6fff9119ee3ce45e8e0df7295498bcb4be05ecbcb6eebd5d968582dc76f3f0ee7b44ffc611a2944805e54f4932f17d3034cc37e0575859b4872c255ee20b9642359b213210c2f3fcbe85eb57d1f7f1d83a01204d7b3391755b9d6c5488629930366832953b4118e4c8ced4e7e335368c766d789f4a4e4cbf6cfdc34f726ef84188983e68b6717b20ffb8b247a17c1dce2060e72a06bfd2d741dd81a893703fa1f7f61be335320565273d253ada1a2281f701fb8c4fee9ab2fdf2a6d7ad0d9bbb007191dd69430723d33149f3b4dd202881ab8597e103607387b8c45224a9262c748bc0e986ee502f93a13d475939201ccf18160da545e20b3780a4cc3af2a323c2172ec1deb3259cd6535f381ab0bf592d16ca78c1c08033a43b437737da4bd7ac9c8a8314ee8f44eda97e5970f326e388216e0d5aa3d2369b3c5542be3b06379719cf9cc90d9a9c80de7fb8052646c1bf216d47baef016ad8487f09cdd1a36d358b60f5119ba61f705ba73e953b652bb7880c166be8cd0e24cbc55c8115b3c5a627862548d9e61b2d5dae24d93a8fd6e614d6c38af809a531498514e4045418b64c4857ff17e98b0487670909ca971e05239b186de9c466fad9c2ca4d07953841c0b9efab664ff8229f9cfe00cc9b7c06290d12dedacc08d9b6fb142e5a54e9babaa7bd484a33f570a2d3a7821a69d7b43db3032bcc78e1cbe770339dcddb8ab03fb8cde52b56a19ecb863d8984bc4b0a98d25068e3784e5ef479b84797233f97277642d33ef3af0b1026e4dbf1fca8a82c6ade4fa5ae1daba27d8f3e6baa62343f547b3fefd84325e9c89a1961c441f911a8279153316c32a8206077f221cb9affab281a6f1296637e4c8eb1bee569e5c513deb8118636565b27e9b36a14a444975d665d3d7837e905b59b8c24612968e850483b81754ae08d33f31b38bff29444e5451a2778abb89721ff08d9271d369527a375ca2b210ffad419981fc0ad2c52b20df1f831e85b711569f7ef631e9a27c5a1e8d84f97fe85ed83eb927697f6e5d95beec9486ad9e284b97cf22e104769a535cb1ae4cb9055cd619f09d9df158d6a3a9b8151f8d13eaf65bd237f775e5bd898505545a359daa581bba756dc871d248df8e67544e29f9381b9c81e099a5c575087c96fec8fadb3353b505b1bbdbbb043e063c64ddcc5d7af1bee062d669f39f3a560a63169c381bc27392d30e5f8e9420e43002efdd9d0a6390fbaa4865bad032a0706efd4e73e675e1debcc51a7ded9b48648483d2b09892f6558de528b16470021ac79a09d6361848d574a656b5a99a75ae64fbe1a5a0bcc87acb4b23ac1eb088f4e5fede2fe4c64103e15352c1a342250f7e07aae83be9a85bf5927f4249b56ff4ad2d634e6ec3c3bcc76fff086bd829915a5063c42fb6c7b8d30f56742b1c531281720236c14eee340df37936bae58ceccc9b1423314f2478926db95d621a5506447cf207989db64739a55478096db86e62d76b66d0fd09d39596e5f7d16e42006f0e02470f9161cd06575055c6a694e2bd80438af509f85f2b60c16a771fe8b98e6bc7f179f44562054261dfc744d9e92c3f7ae50f75c81bbddf96ae516c83b1465728ccef563a9c4be3ad11a1aa50a43553ed2614d6461c7f4f64d219809308ccd04e68668e4e4fec65bf748eaa93e436f5c7cf5ea08dc03a882238ad8ab6e6f77b521c6f462564184f3adebced46b1484d24846e689668fbda53d65939e34a451a523bee141dd491ac67b23890743077aaab8ee5afffab3e34410874a9fbfefd1d8c2a084d613f423577f335ab8708df630de0d0034181e507560cd8d3febb5f9464ccd0292e0aaddd46a99777df6fc858aed1536096ba4ad7dd40c5e98c79a11452e4720cbe52cd11155e0971fae3673844ca44f1dc2e8dabe0a9f032fba680baa171178ae6640363b284666ae6bef215b4b504bb19c6383e6c9db694c1bb2aac2f8caf5901e374adb2df60a9fa1cb2d3c4b11ffbf862a44c63c7eaa25d4c10b3e07cb7820ed041f6164f7825143a73dcccf8e7129eb0331b89dcbfa6f62baf964fb74ffd782646c7dab72e0ff91501604c75e652e4d6bcd5b0897bc7e571ef3f2ee21abdd06ef0cc61362a4acdfcd01d3145f6e454ceb205060fb843d47d2efcd06e79e5d2c607f479303f5191a6a2a7179f5d81e1ec27e61a76b008c30f3cfd97bdabd7fc709fd0bfd0a59c1e9be1c7f6286ae647f017a3a5f08f1bda0974ea23896eb07525cfd3ae7f0be84e2ca1961cfae5c5d2243c9507018d35f3dcacce3598a401ffd720757b16825e4f9f8a0d9fce4ec0126aad6855635bfd3568d745f92bb9563b7237eb41fed36e334b25c85af4be03c0e385d83fcaf63619e3dcbd63852c99452a48d696f6d0f5ed37ced0bf90e0e422a06e26b12beb6190b82781ae1d3c779c4ff7dc6f7ec449270a97a532aa56adc020944a4df92b2cfa2e745d103bf72eaf178138ff7ef897f1d3d6c2d1db23c302acc5f39e728b6b11f6346410b1c5d5ad8e5e14fc63401d9fd7569e2b6919aaece0f51701a09d7503765f7e50130af286f6f1494a21b58ba0a3e501bd9f190975e16a975ab8341a405ae52bc1f5b275be3bbccd7d6219ec329dba017c52f65746ea58612a74c0c07603c4092a9eaa1a19259d8b00ae46ec8505a5b334b53ce3191fef3cc082ce7d81ada95bc6bdf02cfca8da95f503aba6d4c8f15c16ec9e795fafc674c5d5fd44f62bee492cd26ead526d693825bb6cca4c66e93bef4bdd82720bd2426fb53a65ce95ac4a7ffb90f80c758ddef559046217b9cc441d58c0ccb7a5b6cb41d5d7690acc07221c34677fff3bef510002a602ebfe0c4e19e22f3e59e5a9d3400abdce2090cb4aceb2ed70865365bab0dac2126a293efbaeb0f121e17674b4d92627ae7abc47abee6e2cda618061ee98fba088b372f2e77d67609e3e07b1bd89455561b6c411632bd37bf91857d5f6d41edd91b7328a7f0f329626eae96f1f102a29ef4ad48f462bcca9662933f5f92c03d5947a18b20bbc62189b2a39067e98b6547b4d08869030b11babe099c6892bfccf3d44c652bd19f63a020753370b241bd7b9d4269411bc61778e24571432c57f80c002b36d3b85f8666285b42755e9bab6bfa0187ae5da78cf9afe6562fb4553e2161391f69bd08306c67f9bd459eeffc5f037294de10ee3cae4a63379ca6bc46ebbe57bf2b81fb6453ecca3988717c44640b2366678854d25dc1611a8833eda6f80452bf56092898b1a627f0b7ba71e54dd3809dca7883db1d262129bec9b7ebc4740b0f77245959547678d97167b7b0fb00df73ef692f28a4d15229ff71a6fa123f0371301e8b0ddc80f762017955b2f362462986df5af6714064685864cbc0ce060dd09a0365666695672bc869e7cc8455c43549b4c347cbfb07a42b61adbaf526671472582afb8b93cf7dbc50f5097b4b40e13898f200e5a6599f6c653f6836592cdd56b46140a6ae5f78d9ee3b9c909c41de21cfeb97e2e3773dc1e36deddc1a94bd2f88b91d4ea1c8b3412608dd17fc8b2fb08dc32f712ff262aa35b1d6ea16b163cc492301afbeca4335408622506533cd820984aca54d301e03f92cda2e3905cfcbdce5ec8861418580f57420eafe3b349aae0e02a3df228c13bc6c5aef46651792e012524a7070e4fb81bf94442e6b9a57d379ef9b1aa406b8f1bc5ffd3615b038647f08549b9cea22f5334fb2e242fdd845b1dfdc03fee2e025cb21aaab39eca21857cb2e01326101efa8e6d12a98177bdd59eb8b05963b2d5037b2da97a5af1d54f7d88063d914cc8b8526e40117de19f394913c5a89827d59c70d5a807f50dd129d940edb87a44573d7dd79444377cc2d96f1d0fa097db2ceb214f2dfd9b11009a1a9baa5bff422f95efd3fdaa342a2f0dfb965200bee4f260b1e369a02bf5437bc97ac451ccbc18d72022ad2bd9730b611d142ed1eb902e8c01ab81ce39f367d02e73ba2e95bcbe8765fd127e028afbf42d02ae06393ae55c3fd59d529bbc8de1d18fcea102c7b00d439814a38d64fd1fe209b9a8d5c350afdaf9b4fc1300ca7a8280df6af0d59d947cc9cad950317c3516369055af46c77f524332d3775c64881b40ad7b14c471e9e56d91c001712c8900d38881b8f2ac906b8ba9e7c49bc5d8f0d01f318ec77a5c45550bd6053d642f9998fb6ddd272a6cc3afcf36fc4bd6d27cea4471469c89b813f0e8ab687b0d86dde48f6c439bd332b384d3aae10a774062d3eb32a81a1148a3faccc0a4f689516e0d1581769345a89c6d8f8e57261cb62e51f678eb34a139759c1c5a12bc9b8fef12e11673bc114e7a771e74c7f52591e4ed8ded0ad0341c71137a7b9770c0e69e4076313a77201bbd66b78f1f35095599388a0d5d2636b5c378affe90bb885dabfc741c94ba93238c438b2a7c539d3eefd750eba21790d4547ae2c2f113d6cfb8692e3e498e8a7956ca2dd7fa5fce67b4fb38725f57a8e47c92706d973508b9ad9fa2933abd526252951e79ae465c81b0e18fd26401f8a7b1607a8e1419043951db9203ea8084b18bbf205b0d5948905793429140ff0f52ea949e3adaf9f8d9fd0e4e45e58b28cd4c38e06adb4b03ead728a7f98855b82d79dc6f907a198c71d1d8c93565567bd49bfe08b4b63dca76344822c357e017e00413a285b1d7c114e2e1b6e89f24fefd56ab9fd3db3984503f70b06c3fac2113a172e3c7674e0ccc973435975d70f6231a05752e0738ab46df758d78660dc377b5fc0fa18c8faeb04ba56a1c89b1a1261b9efefa7c9ffd201e11c6565ae60377deb9d3d91608bc316754ce98f4fe270366213cbf3845bf5dc50bf8633652f77f07fd8a9252ad8f3f099ac1406a231f5f1499b82df9a5b83140dc4f552523f82492b78a8554fdd822b431a6e0e9c4ae0f31ede8ec57ec8177cd9b9787431d612801b92ba3a5cea563c737bcf5cba7568b1c1846dbd22b2f0ffe487d33fb7adee576ab374277ccd1b8230d7a688f0882dc20209932d05b41eb71a1c883b86482d09ccde9317c0dcf185345e7b1b1f17669551eb61567146f91b11e13f927030045b9fb84d40d3e20b883be4b9afd04e4f137f7040ec934eb5008ddd789c1de8c8a452097c73f9e6c5fb928b49cc1abcd728030ef476e2d5e8b3ca023326b4b709bce52f70823519de2a4cdd376c7b1dfdf84d12b9ee704ae81b78c565a49a0ea74906cd38f938fe09e3e9487c09c619ed053901ed574971da63203f95ce90e2f3d7d8b92095195d55ab6f1ab70d0ee770d4ac75caea6f0dbbeb1dbe013fb57eb70788c55edb6cde4e86822619f4908bca52e13ccef24bec3a8c2fdebf53c5d5dfe5ea4540f03f022273c58a9e4abbd0be19ed253d181c11281b6d6d8b23b23a0a170ff821ae8abbee634fa61729ec7e2d38e34b4dd62eb7b42ef3ea429d9f4a08f5e4bbad10abc6f824f606dcc9f8bfd826938c3f7c395adfba6bef774b6306175172b5b53bdfca46b53e22ce4ee72022d33ec8882827462333f72be6ccca434eacb7372ba592cad4bb732823a7b464b848080f1f5e55b3f9e94e5320dd23b16bbffe92ff94ea42e97ddb000967197448584479324bef12ee538f630f4da9355640036b338ba31ac23f65d33ebde5cb18a343261527a0a491dfd4cdd636938f1161c474e438c1c0ae86c19bf533648ccdb637a3d05d84c94b1e9a9b92d046b35ab55e6406c986653945995f4953c74a2d8b773383bd7342fe4ce09ad80b557c1727833c3dbba390370fbbce1dd3685897e09bf9c887e1a0168532df367de07ca51499e29879db1b098bbef1691c32aa790df6f3a3883b9aed20e639cb722bd9623ea9f1a56fad64b85ed547f8f9615b5ef403481fcc26572025e9e6c394cef31f61a0d4d24095dcf40027d1f6ac6370456a3d5014e087a1e621209267b48052d6b5dbfd8280e0473b188b643b8605f426893c2144236febaff1362046acf5eae0d94c0c7567fa75c48168ec3f8f1bbbe28f2ea612bc148fdbfefffb31e954684627c5acd8b7e34e10ca5d1201201c11fb62334ae55e11786cf502dcff304d3d3052e40759e627933a31195d36fcc40d912ccf3c851a25ef40a968efa47db348ee9fec15e7ca8c6930351c350c233bd6cccb8f59a68d2fc2e6079f4af0f3e49f0caeb521b12db834c25c4638c7b7f257aa8ad63b3a1d510e397cf6204ddbe2e636a57354bfa9b6f18344166675542dc3d6433f09e2709d7cfd56e30d840f435857ca13dc6e022a9c2ea14fbcf917297e8e46a653bae1bdb03796fa71583660b1a341a49dc3df626c7e981b5c851e19318048e434a1af734bb3f9cc9692383a1e7c4d10333858b8b1b63433322127ebd82de899be0510c58f1a96b19b29d868bc43f2b7e96ea18bbddf05df8b1e0a4803371ba83278b1f9e28617724a01fb3569095a6517982b4527f0a9c4f1a16966529bca1c8458655fa68950bf3db62e09c3c7ada238649d92c98dee40756cbb320599216eb351e1cf064cdb021f03f033aca50ccc52f5dad4882d0f0ae05952c205dde67ba4030a737e7737f6c36b227a512c260441dbdb40286e4baf23d02b84df0d34c10526875081a7a80af1945961051bc7983265e46337919bc26d95b56520606712caa40fd6f7d2001e2c4f519690dc019d38275e0f6d6e8e97184c2861014d0214b922808a019664d4194a6cb704f2cdab91825188742128ff19ef48a2b879ddba82e48096b370abc6597674c59ad8115aea7bf88bb0d462ffacc1b57f1ebd9966f9aceacca40417ffc3f13eadc511bc7003e9745df297e6624c3145bfb0589b58f4d9731c7a43c3fbe5c8ce19ecc33b5b27c935ba58cf5b8b50eb33569b5e46a54693a515c7a1ef2fd029522be8363ee58cde8f8e76ccf1d8737dda6e4e65692b5eacaa1f61bf2e49f5a9e4e16b95edcfeb3debbb2a3bf8b1491da542d477740875e7d4725f6fff6c5d4c437d738737d3d7b8cc5d118a4af878ce11780081aad1930dcc85092705a5bd57a154b96a576665175bc6f5c67caf2a1585cbc5ddf4fdc86f3d6909a1d388822e759d06e1e8b8d7102698d83c9ad02ec4e315d20faaaa5fcefa70a104283761ccabecb02319c6705cc4a4d167eb683109fce669abfa0b85ded7ea730d17a6ac6c12bb569c622c37bb7cb734c666dfa3351298ef966ba12ff3504d816d0683fd0a625b1e177ece13674cdeb327144ae0de22c92bc4d2bb717d9a2f9e110b90bcd70c1f0c99a72d07c29c5c1646746ab2a2ede65439c3b6d23a6cd6a20465af07e32b0310955baae4dbca68a0edbea78d8c635abe94890f801a3682addd3d0ff48a831ef7dacfc59e8dd224c986c26bb0b31b185966f3e5f951b8ac058c37ca82bf655b57893d7ad243e135783591cfb2f5b022f3a9756a98885ca15c7706ff6e3f4fe4d809474a8f21ae985711a0f542691509586e5685376a7c2f4ec19a0b2d20bb8e2e0f28e0a460cbd88f272db1aeffb29ea5b0cdee96d2672436bd39522bb2338f064b99f668160e3daefe4cc9b5f899957e24bc804c51b7f8997f958e640d38c3864315852aeced23207fc0725270a32408455333ab9f3bfd974bfecca814ca1b4f2c1d0f0d60dc7a8318303e55bca222b9479e18416cb9755e4fd222ca2d1d9c592d05d1ef104361e7f8d054ed1ecc7033c43f021336f4a64b726752e60c243cfc99d77d05f576671088707731989783446f43c0d626171799ab585a906d121f939bf048bb494e6e13528ad6e517fd17d191ca6efc39344b56f9b28ac7e88c507fecbc8769c1607f32cc2d8563835b6d9548330fbd94a061f9e508daf76e8c8c93fd943302a191b3bdbe87be289054b140d95f0d5083cedd1c83da91813baf57cd084820a9a136cbcf7a202ddf24d91c3375374df2551af56b56560cb428da1cfb187250a55654e7a33debb1cb14d246102cdc8b3c2680a45c158b0e81c6e79e01b65751fb724861820632f907cd19a34c9d92fb456a009e1bcaf4f06969ab43e173ad6ac3c2eeaea80273eb0ce09bb43bda1147465b17ec40fab3ffe01b86c7a739bd804ac65966853db172b9a18f2317bf061dcfa7c40e90c0cb3419280029f6dc9bcc40d41debdf21a0adf4cdd88585df2d461b3055e30c8a5d1b422142101e32525e32738ed6c453390c184a224c5d88a32798a38ae3fa6085fe94865ec0d069a81c299b78c0d821c8cba72c9b8fb113228ff5451bf525f82c6d26c0e1d984af8adfc04fb1f2246545df3e721c131724d843c8971e2be09696af127dd0fe49715929cb7d94f3f6be5f5e68062d0197920542772410d31eb8dc4a53a5dfbf5e74f33ec473151da55506f9caec554f285bbf6ebcc5f1b144493485a3a4167ff3265683e6fe8911b3494e0b1188e2a06d27433cf8769d3cb775efb6266ad43f262594fbda0aa746da616906fbc40747eb3123168497c33dbe0d31357800c56d626df713114d8fd1a29e8ec8917e91119da808eb38b537c4d5e878e3f5fb31dd05a9080ba07e4f677ac49308c15d3e72e3b5f606a0b84743c5b8e42a47e8ff5d32e9cbacca8d0c95b527a283d2c7befcac7150f2218f6ad16002cd5eb4e938477ef7f4f11ae0b157d657aee4a79d1e4140c442641eaf688b24a1382eec43163919a4e9dc670863f1a54ea498036eca5f25c7a77082730a867732e4e3b0009eb0fe73875b410cbdbd1d98e698b71313c93ca536919b923db9163df542f6c96693b2802947eac1ad8a524535b8062ce941a685f401496254018504ee9b8f2e7e34a4946f2717a41e569c81870314ac0cc4e20987dd214f9d74e3e17ac191f342d9c42592f9b081ad2b0e7061d394319f09120f7cc31048e90eb58bf8689571947b46abcead4d40e75661b4440343bd26f170a4997c74f6105b5c1ab795bae0654173dd7a39181339857c91fc7090cbdf6fc84d67d9ccf8e5d8042aaadac7af0ae3f4766aa0ff0e3fe60988a61bd78d69821bce9fbfecdf8c1629d7ddf3b2d1057295f32822da43363b0fbdf7a507f9ece616d2a8fd8854e4dd392342897935f15d137f87fe28a746a235b82cdafbf6d82f0f98435536353196d8272adb614a0de8ff5ec29691aea68a09405c46fa8db593a67f08d17c294d432ec1389e4c6e641817504517088323b696e6cae9f975721db3623ca0ca7ffdd8bebf056ef4bbb5961516f3084f4e0ac623cc01db57ba6ab3c346bac703e36f27995a601a209112b98010b398994a965902f34f8cbbe448f4ff17599d06e317266a0d2bf4f873e5d7af5325a132dfaeaa6c25fbcadf958054cd6951d102770693cd797fa3fed58228b86a3743a41deb5a07da8b8aaf09a634ca73c30b4fc44fbe2b3f625250cf259599a88dc27949fb9d66414516e418c30f66bad6285b1d0ebac08ebd6b62d8d96231747707664167dd844841c927265359c991e394df657ac44751efcf3431d4ab5cef58a309df98c553f0e8350874b808ae9939aad3983fef7c5ce070c317a6e6b80ee665961afa470e0747e4074d68219633790f80843f84e0b535f7b086bb9b88d2f9db8275fccd414032e0301229f6e2e71ffb9b6eab599cb0da22dc38c2a02e3c705367f1873fca37fbe4f9f8afdfec67dc7ef0b6817bf2d0c2cd5bc3e911fbd4b7dfa6b54c5aed0d4f923c42784e66cf110ffc7a8fc72503a773d2d0da3230bb56e5dadc06c66de8851599df3cb4ce912fef21dd1f8b7279297c42e08bbfc82af0312a5472c5a869f90332bb2b8973f08b18f27ad484642e22e293f6329897151885a62215370eda0d9a4266de545d9f221e5e961bd383877dd02aca82e78930ebc58f0dba371e8bf2031a8ce5b1267dac5e4174c775932fa56c1110628a4a3ca25a69b653e9bc99c322afcbee094ec24cb78f875877149a0d75164522401fc1974f0a1fc3dd128944037a3572856585ea5d8690cea206547998c373991b00a5b7f38227dff03df6bfb1c70d88c73d5aa107f7eedad14bfcbd5529397da96b332fb640d306e21088d26e8e0413237d6a87292565cb6879c212664a1a6c61a982aa3a44d28f4ae7f7d2e0285bc414c5549bef61c31e38d664a1f27db4534d10bd774908a366c37584f002ba763510d78e353a5e2a74d07de9a94e8fe8639245672449aa4f63f2e45a832fac4377be261ec25f6b3c98e5569d0b29952297c1f48f9b91eea926cbe4d3be87af64080a474f99593c8246a8fbed67c3390df72c898535884748abc8f16d901f939c495292f5cbc44fe89b5abecfb3ec5e00f42a52b2c1007f67cdf06c64e354acfe83d561df54a51f3204ba0b8b57ec9733aee4f6e81963b884e066bb3ba00424cc2a2f1fda372858c1e20afbedb4546f676ebfb87cfde2c9f66deb132a584fbd226601d252e0a84c381d3b7dd4d09103dc9b852d31daef9f0e99d404b9aea47762f35a6255f37c7cc65f4bf5ea51775c9c6ad3b48c1f7b1b98061463fd414f62b3965f10c400bc004b9a8a5974eb70b3870224e4ac1c0978e731bbb900df6cf25fac8dbfe9c9e93abc0f79e8404c00ee5dd6e62474b16a80234193e48c44c6002cbab68852654fdafe3208e959c4324b7ceba6b29eb18abf7b12954aec5c9a0097ba87ff4b7c71042c06f4e52f4f48df76f22b924b0aeb2e5433d6b8870def1c654122f27d3c303b7d3a0b68fdaf4350794b2921382edfdc102abd98d32abdf7150c2103c39d6d61ccfda91e2de1a040165020027d41cd53f2ca546ded7ed86bcb8ead0091f67ea7911306e1cd9e507b96f1e15ae603527d045b5c720225de5eee1621453ed1037639a688ac314f333b99ddb32db972d33d63a1d55725fae72fde28210a6766998c4f0feebc3322b566e751fbd0b1dd8bf0cebeb517defe5cd7befacdbcdec3ea59f4867a305294be61c72df41eda15f5ad589926be572d40c47d7b7b624bcf5e5e97558607d744655c7afe4c2fda2ceea9dcf303e468b53aba48b5b133cc443338ebaf371f2caf6b35813cc68e0013b3cb7d87236017c94816f45db86a63f43dd72aa469c810d9160295afa41140cc62f5f1e925b6a6164a7f86e9de0f9929564b6b6fbeb7daa6de48264ee948b24106ac9447e6df34d514de18b5dbb081879efdb4b09c44f8bca9deca863c4e5f66fb8de023a56a94775f265b0e4bc17b14d7ee8c024c6e13f4ed7c534a27481b23cd615f7479754f82c147a89c3a6c5af9743618d2a15005264544a1127ccf592a4aadadaaf8d56c382135c39b97b0f9b78b5b2de5960c39688826767ce1a6631454158ef4fa48c6b61a4d5f83b8c1b22d764171bced1a208b66d9530325b248c2d09ced5891a770e38d3ef730401a2de92df88e12c10bbc9e4343cbb22ca25b5ef8ddd25b4ec0052d3c3df7b4d796c7027317d58a04b4cf96c15a9c592f3442b08a41970eee3d0493f277645f97021eeb75d99d543163b1ec9e4a8741a0f8175040d11cb39f351b41dacc7b8da2158022a6a067ca2c5838200ced29f7b0e432f08a7aef02e3c6f45d14e347ab7864144c5fc6aa96a5e363c38db43df3bfe548fe32e3a68cd5908738cfc745c5e614fd10982984da44b46412b37047b8c5f15a8351845246028927a9bf744edd1704134b5a1ffdc9c4b9abbd8f71889b5e7f7a97e9c05fb0d88c4444427d91086ac23d5967c7b756afcdcd0dc7433c4dc0d8da58aebdac824dad568858029cdfb074f69292ec8f317271a9c579fda8ff0f108b53c3ffbbfe5bbba6ef69a9aacf93f9d648d3697952815b1be073019e11d5f15110acde59925b3e89eb6cfbecf5b4c587ab74e48259489541a03ab3ea76522967399159a09367b098ee107de06e4152b88aac0218a3058c42f16d35cdc26b3955965536db43fcf2ea00bb0b05ef36b8a21e514220af181ff52da68512ce14a445e8bb0d45e98ac1a785183966008b6475b568c117f22f2573a721b8560b3d8626749318c5bc42993877b762a0ad8d40d41904e05f1635aefc188a604971335051ee054570d74a33c51c19de1c11a3040c03bd6bcb63791c78d90f356b115fe77f3717b3fafeb2819435ebb37694fde6a62e2699e80511d6138fc5b6943bdff8394b1baf7da2480415f43064b5105151bf1ae4185a1e522b82d9347385a7376cc31d11241d9a34662e3396862407f559737d4b50103dbc4ee283ac92c3da86c9c7cd4a660258bc2efe945f0b53d59e8374846a008305f6b1206472be3238f82e575f658592c2add4fff3f4d64a1afce772b79f4e9af8d958d00681da372bc8b8c9962db08ef6b1f4ec39d7358d3db15831ccc67749f1d9df1209811ca79865d94b0f470c29ef9f49a61a39821dc4a2a2779dbb38e23092567d417503d26230cead985005741897a44009f727d0cb361323dbc233d2d3bfa56af2ff2b1135a28b4bac38a95c42c976d0b10faa65d753733ab19d503c539283ce122e1f447e3bc8ad0655f2ec13912f42e0cc8af1a9618f4b9593305c9fac8431f1bd6852ec6e09d51dc8b227972bd516478c8eb8c349d3730b07b9e404d888ccad32f2f51c4741f9e50d0194571ad6568ee5c6a2ef951fe1b240cc529599d7fc89dc49126751217715caed1d6bc82ffa843987b4a120a8257897fcd1d6c8ab66164e1ac2768ee9d2e19d84aa67126428c016255347ec5c2dd5668d1c667b05f83e626187e253165e269948eba4a8f403a5e26fc332f22babc9089a7e368e7dfccab48452b3c57452e50b9181f04a0ce3b0761b5f23084ce3de588727f86847c47d449d2a7d46ebb3a9bdc6be6a5c8f92300c284b10193e47118b5242de50af4fd1d288c144a02d293abccd9c019530bcb074f3811536e6aed29fe47155dcc9116722f81846edd64ca7eb7e903efa5afb35f141718edde87556c2ac59168192e9cd9a323d75ad499b06394c31736e88039cbdc413dcfbc99a6b5f43916b1b1b8bca73a62bdd5609420ca02da5bf18ffd607bee6a4661ebcdedd6a721852ef0de6dae56a41264d17f0f287a9a731cc6928b07c854f1dbb80ac141055b585fe118d90aef69961ec0b0edd10b426b8afd0b42f5f4989a7e4766f6a7f8b3d16f91ac3a6d0cd7a9f2e380b04b3a463d5d7bbf5c5c30a6be5da8c3f4f0abcd97ed67fcd9e6e1543bce86173add122743924d92b279a6ab438a76b52574250a22b4df1983a124ddf5a6e4794306bafba0b4397f64c5a7572bee3a5118a73e7a1d1406659cb76072732c1d3a30904870cb692ad571280f2f976dd2826c323faf4f2eb2cd8cc5ccd9807cdd7119133d5e1de02186b99fdae37a5a3307ee74c4429b298420e6f21d0f4d68b41a6f0a8769c0529331db5d1d8c6354a0a1980d3420bad43fbe84edf38388f807657c222e458a13a6d33936b24fea64cc4e6f42b4aacdb66732f373e1a6c108c71d23ebc5417f728849a429e3a80e1d8b299eb0caa694bec6017b3c6dcf0c2da4bd2711d2115cff7da2b27bea903140567846661e157c4f43879697b15a140fb7037b5f71471381576aac605f70886a63ab1b2b04fb5f6a2e812c5ec28dd1cc730fbe256f5a89aaf890de0a508b5a1abb7fac347c3b3be654b09333df3647353a96f5d00b8eb4211db59ac6f7697c29b8aaeb0793e89221162b06d8ae261cb8e358ec79414a08fa3793eb8d1584f8aad3b2da6db355decb884a533a5576bfe5fe954834fbd35b23b9848f01b8c246dbf114c08cfc282c029a89cbe67b660834694dfa4aeff12785646ea625b30ca329d462f7560546fbfd31da7c23a6889ec6598fa9457893340749a6df0088948a1c039ac5494cb1ced4ebdc20fc07d85cd2f9bd5c67b196168a859f86d581a8f06527511ea97f21172e299b12707b80d47585b00ab887a4b07d911273fc7d2d304458bb47fdb5c427961b1343d37dca277e21a43095eac65b2b2adc845458fb446e42d64d36a858c85a8338fc5f358ddb5c90dbf0c77d3faa850cfccb975a270d8677ab5e90752677f03c09cd8951302f2af61008a35240d8fb60597534fef14ec454dc953983e79711436a1f4e3318a3732e8377011a27d9da478e2c1b294f1b9d84da63485131d9fbe74c62c8ab022f6f050a2bd6df5426a8b974ca50a32cafd98e35cb74f70d2bed6bc6cf3fc4615455e8efcb326d86d08e31c4f689cc120f30de203c608138c7f80d7602ecaa7b6f504fc131ab2197ae7b087e07aa9c038bd90c40378bb5afc99a3cf23b94805b38e3eb945d96673b69db6198afa7746ef1a2e3fab525302b5d8bff6f468b214fd619bc58c71dbb4aa2d3e3986e62a403ed8f142d0163a6389131eb6a71d5f79c32904f7da2ff2f44bde16e59e80e1e8ecaec04239f9bc6901d9e75fcb33bdc96dd897a9fb1a791548c43d975404dbeb2b55386b4c2b851ad438c1d60191f1b517effe2ce08384fbb5ebe9fb1395be82ac252420adf9e4113d1758570691509d6005c9c69587e40a8929fd01eed4db34faf40960a129aec28ef15cdbf68b6d79ad37be56260bd22b16c62f80a7a2e2f83e11c4e1fd9ddbd1da77b7af8917d47680f3dacc1ca680cb8647df5ea1606d544a6a9e81280b87996b701b50b3d1e46e4fb197280fe8f655e2f50daad8cb47e4be0c1937043bfefacad27878ead28a4f787ccfc5aa87a9bd3e281ef4eeb0196e0db084e156dcd8524f0b15630c320a0c11260e835a19bd3d6e64b20e3e2ad61820c9d8cbfc0a0312b20bb731cb0f29db71d827a2059c6cab80003c09d41f907814432497aa76368c6bb9338264da4e5fa427f2d5f4fa48c7e893e0e44a060e7deed7697642b304e852251945876fe56a6cc19b84e20ae7ada854300c79fa107c220eea11d173d5a493741fd570edd5bee3ea2f7cb804f45ec1978eb7f2723ec132da4a34f4fbfe156222c120a4f9cad78184c525a2b07a8c5c2a3654c6259eb0aa21b81edd8bb4d2cd2a6429a04dc2404b743705eafdf9fcd06bacfa5ad6800bbc9290a55f8283be012a4744dfc8ab7ddb9af6dfa365405e2ded08614fe257c97863f72091e9e5e68fa951334b1aaf45d9f8c3abdf028a837fce548aeb3372f736e9df79889e69593535046d20a92ed1d73daff78bd2e83c84fbdfbf20ff49c155c76ccb2b1db28c1e7c38a7bea85c3eaeb8ef9d54a1de39b3b315cee3527c2f49a0e1dc1e3988a0f0f7ca78f530c2d879342e6e1a3d9246271f1207a7ff1eb0e79df5fe662f2ba96dadf57dc58a46dc3e170f4faed6a84680125df5282e3ba1bd866b1b49a6bcb3830bdd4d0484a43b7ea2806fb8090227cf15fc173896cb8bfd4f676cfa684830eee2ddd5567b556906c5d6b14898f0bfaa6de3fc5242daafd136857062163eeeb78f865f852f75e7d09a2019f7afa51d1754cf4018620b3c5e7431f00c73a65af74b6ce4c0a14e5a38c569eeda0d80dba3956f2a55533972cbba4d44d1708698aa4599f19c54cf5a7b0a22bb9d3f85762f6a387ca43a4b795fd9cb1e7b7bb4043ecec6c4a30c0d845a2755544db63a607b1b12396357443bab4d3cf60b720b890f3d6a260fe770ced8ce962f08b78282b8b6c45a9869e89dd03cac90c9bd573d66a512b22ae80f6019ca9f8f499def9315016da246c1868f57531f8a73cb981bed3f9ff7a72280bfd4cf07a3b8b1b3caaf79cf1442f8eeca13fb83210988d6cba1c688daa49a09166726378748be26c9193c37c8d1a54a808266eacfc359d32001664b3a529915e19817873b418e84bea6bbe03ec89ac89a82df3d30b1c8eb6f15cae2ba2691889bac0c2586de72c73d434ff79d5c95a066ad8eaf681e26ac0b06c65c8ffbe5de3a0c115ccbfb2f75fcdea0666e13fa705c470a3e7648be31edb94387ab1eb5a67d45747d825f29eb7312a159cfcb370028f3d451ae988eb4e26fd920180d1def012491fa0a1cf4e7617f3653e6d2f133ffb647c5b13ccf349bb0b1a323b7de00617433f6bd14dfe7f1a069563220b80e3ea7a4854cb6982c6b3acd4133a7b16eb47393254403434dc094bff1422b657047af484dd2eefdde650539e3f5376168f5160a7d75d48b8323d4f9e0d28807f353603c1c8e1155c9e75a4950d302733cda718fe0b121bb9c7e1d9cdf8841cbc2ddf36cf57d9b4e027f66c47a4acd22f4003f6fd31f9f405913ed95149916584bcbda5fb58ea7fdebd65ea04f0b7f5b8ccdfde63219f73df3514c62ee50cc01bf8ea5ae90a06f5f3886f7e964251f3b326ef70f9550e067262176dc3dc219f642e3872021d19490649f2be7f545c399f9a0b2d0b990ba74ed621b1cb972c1f506c092f63b83e7abe7be4eb7f53d888b2a59d2c88fbc969f38a7d3c61747b32913fd02cf8a6d9a37b58e8958fc1e81205dd80064a27d6b73715ebe4d8efa7cd376bc7b6ec763dab0c3cd1e0eb7d0c7b3a07a3a0ba597ccc513fe0e4f461da212cccc366d8625bc299c286a6d7ca82af51bc4440afbea099a8a6058e353504b33fc1edc03b211268da18b9c5a12ce08246fbe022ce9aa9a70ee159c4ab95781963f39d0ac4281c8ec5ec34b42c44b08232700452e1f341a23263b5a6f5a5d98a0032ef528c3f0e13218d4593f3916c08331407d4d4568395452136cc35da6ace2ff9ce29ad1f2205899a5457925ee75e3a752e05b718fc52aeb62a33b45e98eb65bafbbd92fd78dbb1d18e87ca0c7d8337354d330f3cda8af55835e32380b1e95056c22e44938b0d0a85bb81a263b2c20e94336e460d2236f50534d160901804662a9419e08b48475926e4bde8b16fac114d874cf457f3936652a001be847635318f8be8389c72c2d30b7c655c7e97d374d85e8bdb4a52e4310e7c406d79232c16ee31208f12cb5279268358ddcc11339cbab5a5ea07321de385b33793b56ddb9e65734695364f2fd30358cb208d157f829922eabaf2d879a724120a27546848fd3ca014b6c79045d9fcc228d5971b5857e0e8d8d4ce0dfa733827d02ca68941a21571a39c62ffc56ea7ea06fce95ede6744e83a22bce9e6797c9f99705f2e001e0c5eb6160e9b2299a0dfeedcf0b6a4adca72551e3221a56a9500f342c179d18f58091f9d283462f1e08863ca4e994a7275eae1f58799cde4da9f9841633360535fb636b61e16078619930dad2d8b4cee560ccd6736efe9a6fd32ddf4838331fa0dcd19903300b705d621eb71b03ef7b4bbae57474300a18299bdb306d77b9ac19c12f9ff8fbf412ff402ac1fe15f102c274bbb503616cdae3b9a2227e06fdac660e52b1ab5822bcc59d53c6b6352d0eaaa736ee79c684064e2053a5f985f853ed9af378548d316ba8147433b9232065cfc031f952d35b5525324c7a954ce0e527679973d31ce726a5c6912a7913581c2d1133cec49b0d982d0b545834d12e9b8be73ebd289e9c509b683ac0a24a737b0b9bcde7c2d50645f6aa10c1714f0df0e37028aa934d1ade60809df118e5688890686551f8623754bc9093e84dff859fc13d6c16e44734e43e21d569690b596e7a7bfd3a9729cd948d8665c3b6cfbdd170a31481600bdaf770b53f646ced526ad474272743881e8b5afc5b36c1c9820d3b1dad7866baaa2c308ebdc5121a65c6e276c4a4c5184f87bee69050ad2ae0d6caea9fd605bfe063b0387fef16d842f4cc3c341ade8bdd9d5f4611f4a984a9719df5a1ad291a76e4f46879565fa7b8b301b38a295148dd98472b1d3258b2056439ab21bf46b392dc92a3aa6db122d49932c18009ca1bb1a83d1efa7a4ca9a7da755e3e12f3ec5b7fd3f882c014a994ad33f0e789397ce206819401a41af6eb5049089c98a7d0485742b432f26823a268846bcd6ec6584c12df38bc20c3df4fda6e9bb0eef5508717349c03e7f3c23fe6786f9f4c4495b1220764b7b9eddc528ddf8a3a2e6c0c784e9e240e4c5396f0edf15b0eca95dac8dad35fa899f1afdc6abdd7ecf8d144705096e1e3fd0ac1e0705fa7a8230787033e56e142f000b98be7a3aed3a91a1e4036c4d5d7e08629db88e346152b4ed016fcaef4f05f60ba8eb33109befcdb964f8a27aea767d8c8bac59f149d8a3a858366a3d47d2411b212c033f36d2f6054a31ac15312a2893aac41d849cad9f14eb2abdab10296e1a50b0e926c1320a6b27d7dc6a3c5397fe78a5a4161b7aa863a1a1eb22198eace1d4809471d530605cf9fd46bc593f1cfac607e34a5df097d7b93d5313586c1f4441a55d56da50625e2ecd8f9beecb3b818391ff92cce1166509af0978e8e1ec259ef1136f6dc2dca06688e521f8506969b015239fbea45c6e79774e9089faa9d00fe8341ecd98908c43c6f259def18a7195a604d3222d3e62ed385fa5c502c622374a0752d4afec350cbb210ba00606444718ede42bd1bd47468ba0f1791e186edceeaa06920f3cf88e4a18fac0544d426da1d96d92ed9884366a4af32057a612
  
    
      
      
        请输入正确密码后查看
      
    
  

]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android逆向</tag>
      </tags>
  </entry>
  <entry>
    <title>酷我音乐完整逆向</title>
    <url>/2021/12/18/%E9%85%B7%E6%88%91%E9%9F%B3%E4%B9%90%E5%AE%8C%E6%95%B4%E9%80%86%E5%90%91/</url>
    <content><![CDATA[
  ff1e32adbf55caa91082832c5ba17bbf7726dcb8abe111e8e95e4bc84bb182cbb1b456c99e100af325c174da70e9dda164b17c9ad45de943a6713bbc08da0fbd1d22f29654ef29e0e03468f84b5351b5081a04fb8aebf53e8e89eb0afde5dbb986599a35c32bb530b1e227630532420f36d85ce95bfc9f944de96bb54aca81dd25aedbff01cb28586f7bac0a5ec7879e180048880a0a704fdba170375d93bfa44558fd0fd0dfda726e716c5fb808f8759132afb08070cda57397adbae1cc55d2bf7873b10e39dc17b11313993c839c007979a39c6da961ba671a61801be84d18bfde81568e497b74eb3bc0f928364e8f50de8fdaafb40e4f02d13a05bce018350cf9f42d762b3c7cd42d7ad51ab45c475684d83589769adf4602e300ecda8c2c3ded5338a9d1029fc39395753a4a9cc62972a9edf98cf9817c0d2fda76a7bbff7a34ac5eeb85fdd708983b2d497bb250c2a463f4d34d3c49b764031bbe732e028fe85aa329469d1d3c1b67b156d070f79b440c2d36d7f895e4420300f360fa6e90e039d31e8f6c13ce2596cc5df67a9d96f1638931c26b9a272505539627a15691ba58e09ff26d21031fc9bb3dee984f74c29a7f6c692c45c8dee8d8b7b5d983c272c021318bd14fb8dfb359d09b2cee57bccdbc4e5ec1f383f7082e95cdb8b379fba27f7213c3fd75fc274be5d046c81b407b0ac5faacfd2912332516ed4eff12e8f370665524180063169064014ff8a5bfa56d4a01500f15aa19123387786d2866cf4c5abf4f19dc590c8eae88967d0292918626ecf4c11437cc7a8776e4c57b525d02a0f1c24fdc47022d20fe4304e16af867e557d0d987e38194a73e5c81be8729b5f3b9245dedcd03588c8b53f747452777bf71ee79a2443cb38544f4900e92887228645d0761c9db1d3e18f1987a2ffe93d89774b0584e9a8e36c4e6dc07deaad043e791228e45577cd9c492575b725dd33eb41f33b4c5bd40eb9ace0d57e7e707826eaead78f284ff4f868f15f9706922025ec855ec90d4e89f980777f1b0a2827c5ffa51a1be0bb7b70a39f5798e0669d846d65ecff8492e8cd1234a0336e60fb672723936ab0502e5a9e5154fd6cb4c77d58cc35bf6f2cd3cf6d6ae56f7ec16f833a7ff07b12dfe04a309a904401319ba649cf51e6f0fb7a608b0d1e0e17a10fc26512dfa51a5c56d9017901d93772cc202cecf8fddd2ffc4bbce41a298818ec39fbc4277d060055699a24b67c5eeb87eda8f5960543f94a193d9aaea88b6c14937e2f1eb766b4a88462f54043e62dc23712e0d840bdb0be7cc9d4ecc88788484471fa124995819e939c0f35dae752d54e54a6bb2642f82ad8e94c0dd394a08c17ef8ab1b0719c6cb666ac4c3cb4157d8063e1a424e73476686daa1ac1e3ad2f046f8a2207dea96417fc9025a322e8cfe936bf49e265d7015e86657cdd99b338d276407b307628d037878fbc6dd3acbfef3f3f4e3a02c5910e979e285bc484a94882e08abfc35c7d6da783d38de7f5cf99d814eae94d5acabc6a8a54c9c5ccdf388086569ad179b9ad56c43dda809a19e4bdc96fd91e7a5d2477719dbd237faa459be62613efe2f12aadf393de2c534b7d9bf042af5df6862dcd32f7cd00064a29d718dd0f36e9f54ecfc2f60293e597d3434314feb3fb59c6edc31d2e6dd4afaaa06cff6e98bd72a49a9f396cf960bc36c1758136e1de38df19a04e5199f655f9facbe2cf5a271ba9069113804b892d19e7bb3556dced835a07382d51b5bd20fef3ce8824054fc22b42337de4005fa59c8d585785c099d169c589c6594c4c59f66b44ee84afbea0be34104934a9ec6189a76cdf5febe20ee93a16a8b7e8e0cadeb95bb383edb1f1110121256013a89df39e15b55d12d9e5afecef16d735b7c355e548ae88b724e9e5276b29542a8855b953d6a6287f4c1ea126f783c799c20752d76b46568e94efd4e56365629ab73b06f4123afe2007de0d0c90f2c636bcabae4f1ff6cc6a2e71a3bbc4d4a46f5c1aa3e42c7624ee8b5eb6e4de93018acf17d4205273bf750338593a4470cf59aaa96c0c3439450132a1e7b26f68bae982a7cde59d8f3b948d3d96270a5e2cfffcb9ff47d47d356dde0e5abfdf00deea7be9ebf8dcb914c715cc91e5df7f8b09cb581514da62ed8b4839788b2b55904f71ea6b97527f00f81f3e6f456a7336563f5211327cd3804c097d6c90d2ad74e0de818f822643ba5331987f05782fd665e907f2bfa7fed66df8450a63b1ce11346bf183063b5aa5db2969497cfc1ff2d6e0f103814cd54ed8e5ac6e6aa75b0444ed394beb2eaecb545ad9d14e18dab4061e6bd37ce25cf330fed7e336f3ba0cfd34d49a58afe378612f0a87bb6afb12819002e49f843611378f9d2cfd96cc1740b30293c5236c918d706a50a075ad68e15f69336de56f64a7575e9a73cef8b1f519f3c733d225fc08babc6d26159d4109a5e3be4cdee6e1172d1de6812e37804824c91f83357d56c9dcc693e87735697e2fbd61bfbc1ecfb16cfc6186cb675f8e1feead52b0c4b7676c5a27857ce94d7e89ecd0eecb9e5de17ad387b6af70ba20bb2fd35c11dc8bb7c67b2e666a9f049559d6d47b5cf0bd06b58bad31f0350b8eb506b146a20c4f6d4e8e84beb92044c289694fde09aad84af582e14702dcba2b75daa97c59b4c1f09c92c5378c926d25f071411df40c57a6e78b110ce90f6572f3aa6884b417aec7d4bd0d623bef0de41815e281882dc7223c78373c82933eb06add3cf89bf341196515644cebbd17455be1085592c7d8f2df992a62277c77358e863d1e07c96d3d673d30f927f835b690850a51dc29975641cdefae0557d522a6e5eb01885c35bd322af45d1c8c7005fd89e59c73eb1f687cfa2aaa6ea6ac175122b0e2442ba1b23ed0c7fe7dfac40028019d71fa33c2b991524e8e4bc3164f6e5031d8ce7f67bb9766e3946b60a2798e9c09dde201797fe6cb5445a841049cb6e1b32209a860c7f9eaa9e4044f6d4f3d1f85aaf7b2d73b9eddf1d379e1ca7b3b4d791993a973089ab67ae6b895fd1e6175eef4aa0c3a8557323df16834f3eb8725bbfd271c0be95bab2b66e3af9abfcbb409817db9b079684b6f5893a713b3ad778924090eb7833816a898d7a8041ebf46f0719e1be2943f64dd70ba6fb5c6a17cba72e1a0ddc9285c319b453f64c3a238ccffd7f5f103ff5a8d9804fe01a428ed4d8e8c0b946684718e9ca932a641282ec97884eb6ea848eec89a65da5b106274fdecf9d1833826fba120690e473930eda8661ff297a2aae8135d7e263ae6293adc0b6151778c2b62e3f06b8176f2ba9d0f9e2be6e55ff0fa11e007abbc34ec91e7479e4edf8daa4e3754c20d3a2d6a7bf770bbba14b8cf91e79dce11026713ee91822aae73cbd968c11a6793b7c4789e2ca68d7e010fec62c85c39474a9a2b496b908e3c3e327500ff834ec5c6ff3f1e47fe96b7bebbabfec76379d30ad401b1989ed06463a204ba246ab1b490a6642f5e7cab5b4c527b50bc966574743347b88fad16e791470ad0d8c61ea6a75e1d11d88842ce3c49def68e54a1e66c4c9e9b8e49f1e7ddd2c35b50ec14146d9610a65ebd2d4d39db95ed615b5943f5fad93cca9eac8a19cc08f7b116e3ffe729a385de6f7290c9fa042208138a959cfb9fbcd35887b12a281083fecf024968769d1208508e8caecd53f83130c52557e0616a2b84373158f6257a694c222a3fe914f7bf459137956a464980a20ded853b9d91c3c4597699afef37bff70856fe1a34a56a35feaec4b9797b81ba0af3388ca1666d1a632135267af92324302b912b5ddf3c845460fa4abf3455a670c5d829882cd737bebbf82fe5da1e87daeae0ec79db3ac04dc0786183b294297563aef4bcc563254860d6d78a5a70a774c5e0785c2b21b820520b822cda1410eb681e3ab1a74d41c030fe89434b1540da27197d6081c26884b0e027fcaa45a7345d6253311c74e87c122bcad69551d53850465db2144dac1fa830791d600b908b49f591c28789c97acc78ed2493be9713b0012a659f2d34d69cbc81d6b3e922ace50b070d97a93c03351081361310d20a5ca870388c5692a6cae5a30b7da1e9b1d0a6354f044c358e9660a310985fab985815c22cc0549bb933151fd2ad6b0c733f47cf786b0ea639e26e45357f41d22c5f10bb88c500e836d18766271a2db6046b084a0bc98fe8267a39dc9e600f67a79de514fedd1ac284096872cf6102635e555b200a4a4f877fd8bb9f8208f0353d0f78e1380642de975c76100a7b3367d72235b09291a4379fa7cee025ff32996d708aaa0e40842e4318b97da832963265c32a29db3181ee6dd9c98716b1b22f901b096d94ac28407b41a811888d3c3b059250941941a3b347ebcbcf9c41321280f79408699124e58ab1862440ddc1c8edd8ff7e25005d58150d9b7e20e3dc5e3c1497608c78fadb6017634f23544fbdd512abefe01838f0ffd35a2cfab2e0c32748541b3283cf1f9d4b02bea0658ade70466c45a6a970723c02db2d1a94b1ff156a2ea069f237e7ab66de471dcee4b1843ece6613ce74cc0c8a733dc6f76b2522a527fb5b86e716a4d2702b15038719a3621e387de097f5bcb5cc6547ca137def7156fdfdc287db1d1c1ca3493eb2fc59d22000722bd29a31f0cae745362cdf354395fa2d5004bc6aa18819db7a995fea3d689781932ea9f3d59d13f89af7767466c595c2590a0f657dc2302502b3bca67de25b676a5afab342059b91ac47763c79368ca7463ecb8e8b9b45019cfbda2ae2a85afc08268b1770b1e347f0a7c31508baca4d5e8da2c40d2a0c75df955fd214e1478ff35a74db63868320bb48ce7a91b90267fbedb813a9a885ce368c584adc4297e44385915ed991e4d59242ce09a3f916576fd3a95b5b6886857087690ff32e885dae80deb264205e80668e37de970ba100edfa1a3f1169c7413baa623c15e64aec44eb274ba6b6de9b4204231def0a9a7c92ee67882b689be29eed9698c187ea4e615d4b6332b9825a125dbe8d96015360b36268fdac5db48d8df8a9048374c7d1ee3e631c406d1e1dc7d6a569fc741bc0289d206e645ce9e22308d3e37e796574978c04ba41c89def9d73e39d5fce86f84df23cb5b19137308056898ecc870aad0712745afec2249f2775f1af39cfb4bed0b9ae690e58df1f5ba6983a32a4608124022b099bf0f41d5877093e38fe1632a89bb269bbc409ee20407652e4e9cc04bd8aec35fb9b0fef781a5f2285b48946d2b536efc338d8556d4858472abe56722bc0e8cd7f6d899913b06b8170ff140c26bd733665b19f4c4169d8d681a2c3cfb9cdc501b838f50b28b99031f9f37a179e5c6f027bfaff06b8559c4eeb5021950472fd2c9ff234ea563546b4590dac9f0b5ffb6e2256b1025a773854e448c4fe9bdfc160ec94871c16d39d4e21e3d3e6ccd862c549672332488b0ef4fa5a270ee952e61108743b2a0b9386b30f8675862138be10421db8d01b913e047570d154bb41dd018a3abbc50cbbf45e6867cf6c1a40dbbdd740046d0628937e85d59efe514f576a0b45b1e0ba0254617fb744ca7b2d7393b163946b8aef6d234d31586e1d55b12ac84cb800b7b82ef1f7ba031522041d59c326cf0893e4cd5c34ff812005804b6a4b85d31f570b80886db72516e83ce0ce6ca852e4cda732daa6e8c0e3aa82340e5e93425288f3f5437db391fc92e6522973f7b98d14f14899e862cff05f7d21fbbc28cb24dc1a8ffa8f7959a3945d74350b41b8e1aa31885e9dd1ecd4c1c9bd9052b18f1c03603f2bc4b4ca0c32e4f9ac2a37c35ac199a66651777b44a6c8249f959aef039816c5136a619de5a4e170155c3ef12a009113af07e43ab8762b10b37ea58310bc4943f373c89f20e063e3b4b4be74b1bd572d6c82cc473d36392c1d77ff5975d54ebcfe66dd20d4b5a5217303be3fb0297b82ed1e06c819c5f70d2b28ad6f870ff3154808e39b71adef26f536dc104afe1aaface641d5cd42d308d8e389ccb0ee0d20bff40531b44e907aa17509b5efa26bda5449c938d00b598d75cec51c00f634bb045e4862d1964283b6b85b607428c497eca198fa38a1547328b9f50c9ee03a1781e74996f1ddfea8d00c504c08663fc42065d25f19c8299a604465996d46ebaeb627c7e89d6f9cae27bc08eb2e3f9892ddccd59ff6e3d848d213f96090d47023adb83b858eacc3e84b86279addfe621689632ceccba315c3fa3ecd0fd7c7cc227cfe3ed14711827007735bf88741f603685dab1267bd5de365973d9378c787c179e7ea4db93d03a5439674a989dd19b29614dbc27c8029d240163efdbfb1c868f3955362bfe4bf5316093822d93115fab52e4f256c0ada5c343e3a021c255e3b809026a051fa24df62372852fe11843816bc5713fc6afa70d9509f266e89d04b6a11c516a05f159f0449cf33b2c9d062215edda5819bd8f56e547ba880fe9e3648b068bbd300e182f29fbb5e48b94586c992fa1c463f33b7a68121bba244b993109b5b9ec520bc44ce5b8551e3b55f451e7041705e2c8769d43b87e2bb81f79f98314f8063eebda9232185034bee015aa96f825e5d3d8026b79eac8513670b6e864f1ee6f15dc04118075da34e90a993dcc29f7d559215f525d0537007bd27fca4055a5fa3eb0c7e4a46cc501deee8b23d4c5b01aea9a77293d050addd0c86db4f0a32f0748e740ee3fb988fdce6cf73baeb688ef42c554f1f1a19d06ee1a588c52c2f391316b9917edaeb18092de2273157370224898375ac492bb99039f01fe84a45306e8ad3c84f59192f2b323c5a64c29298137853da07e8717fc8e966bf17e43ce43babe7eae95407b8f38e906260b31261ca152c6ffed1377a419d3f1a3f445132d4ba2ba874fc4955036955407090b6464153e95c1d5035030873846ea9be4e407e7f7cdc22c91ff6c088b875733ddc65b3caa2833f98ae4c6d99df8bb2f5edef9ced3aba7c2a25ffaf6d10bfff436b643f906bb772e8c3ac4ccba702d35fe55bd10e42e9429944752953f0a601cddd19faef144916c54f11234eb77ab17d9c679556e80337a6f8515e156c65acef372f4f3dc6e63cb4053274dbf3b989606bb5cf85bc7ef3b89b9f9393c2bc1c41ac3db9fe8a89d6d9b5f2a4a0b8813f5fdd1521d52e5174070e8a3ac8d40f341a387f076b6e1c36b92fbf8b39b1f3ee9cc2568d7c65c3cb60e8e7b69672ff580d877c58bc0027074c4346783e00f327fbbfcdf924a9a64475268b20fdd4aef8b7ebe6597331d07fe3dbb0e498506fbf00bca06d0f259d006d6f8e0f078deb5a9a78b4189153e26d1ad82fa9382fb53635d7938ff6b7cf09b7261ba304a03c89353ba8305f811190d51eaa91600809601b96c287845b8cb8c7f35086702de03510f7079317213880d0ce22597291c98c7294ea90560e983e6c4bb747532bad48cd078c1c17ebd925294e5ad17b20064b330e8d7dcb4e450cca3b785e80a7e66f3ff85408c085485952e5f60063bda171dc2afa6d3f5acc2882e8b09b0eb31ff8763a075acae18105ab541b0de67c2c09156e55a92586dc9e1b9dee2dfd3564e884dbe66aeb9493d83aac4be937ce1cbb96590f79960f96da5bb044f360138440b42840c6a28bdf2400d0f5bbcb9a4cf8f47668001950fa6b061d658eeaef231e3dd1ce7c08d98e205a2add5d7560999118f2b7eb7374e66c09c3653b66d862d952c75e22b95a650e25b4a5a961869dacb182ca73cee5515a96890bf18718375ed715eb18918b252b978dd0c7b0922d6e511a1d465f002269e7abbd7171b8a462a725c8a48622448ebeb74d08608471137a09644308934df69b54f0344057965dc90634269ef8ce2984e5ed213ae4c1f9a4fbb171e45ccadb7a9a3e30101ec7e603c5be40f6ffa2e6017053f07cfe0a121e9213edd25114a6b5c4cf53715a67ece08bba0021f61e14ee0b162f6e8b8df353c2bee4f872dd1a4c7b255a7d476c6cf6d079b4b61480ec40c91661601691b58af7e17686852c17fd1c9e94a062f82c2e882bf43343e1d4cf2beb41db75874f744e881827a4cea8d2e215f7e6a459a8d05a292b07c20239c73d56cebbc2a911a7f6d33ae1aedfd3b267582cf1bba41e9dc7d9206c51e93d636f284ad126c0e055b58083ef48ccf3a1f1c181fee620cb0990eea69a246311b5fbb21d95272163cf2d7cdc0476eb7fe53c5319cc40a73788586766ea586e6c8b88b5499a4aca902099d27cf37448308e9ee73af34084db2856d4079ad817e4a8ab7cf620aee73c86ca92a29187674dcafcac66372fe3b2d1a5c5fbc65f299af8bb0b780e5af2aa9cf510d47a42619adb9df1d37129ff01f3dc5c6fdac38a98f54a9abd6931b20973affb9e0f482c57694e7038fcf4b9c206e4f1f7bc93e18665d54f49096a1bd02ad0b455e537cbd1edcf865ca109e634f2b38f2ecc967dc1c8e0cc8a8b75b5f01948a5dab3a23a62f46d06392ae0e164d742c153a22269e4d81bf4fbf40f66454746a4fd35b21f380d8d1c8dcf103d747755403ec8e6c564c575b0703aa634f640336b30f4c31b106139f88096bad417901469c5a08bb7cecc45c1aec36b645285eda37a367a5e67f4a5690e4e51f5e38786f6ec6df5886c6854bcbd1ed77fb0a4612ba3a22766865829ddc201e10c6643122085cd4eaef262bc7138b57cd320747b97f2c3eca9d56e8c7e0b250d6b8324bfd92ee9bf6bdc950faa4d89bc6a48b6cda87726af58fd192be91917f4a0f9140b82c312824e39cdaa1729410469f3db9088a5f4cf3d00b4d1fb8d859340d09e2481d551df73ae448c7536db21cbf5a9dba70b164e57eb17e315d302a9146b68b1ca891a05891912b77502651095d478f66f19b368c66477b238e3902f5ece6ce5c325f411208fd5483eaa9b7bd3b5422dfbf509df7eb34a54af72086d0c074eb284526d0f7008e05515fbce00e22607e86239929b9453a73b8f997980dd0c3223369102807b2a840449be6a524ff63b644d36493a5b5a5c48c978b7fc7d472284c7e01fe57ebe3d1dcef7b0fb3328a31860fa743fa92bd85ced10f2f8da7a5ecf49a0d57258706c8c0e66f1d2de013786f91d8ae731f71cb3c95aaae4fa8f3b3413c466afb566b8873f3b19e7731f96f31764473d072af65a65adefb5a1c8d452871296dea0fd6bc9193984e25479b266a5e6184927040df1f9f1f68a39c75fcbb9cb761d123adf5754187235e913a1d8b63d7cb3675405b04e35c7c4903a58418273781642598d182cd9dd4cf44820d630655e5594177c9b3acb16881ff944d643568c9aec3815b0a7e81973ed60a317a2aefe9d163823b1e0017e3f4019c1689be66d64ec10991e665af9907f5c9b07a3a07795a634b0f7ccc7564fb2e8d86dca8c3f918a0afbdfa11a7cd54b79630a67e7ad81351f053002f6c1c0b30dbf38dae29d6e3a490080038d75e1ac4ce4bb6f2be987703970293346212bc47939e3fa55a6cec762fe30b8f87764d7a29652a2890dde4f5b7dc2a5058bb8f5a4a9cb95981e2f72f0377115962f91088e628198f041d0fa036c8048cfbc56cfebde88d8b35648f788a17c9cb30d66eb7fb414d558d5de05a68e1d66f9e3fc40a9a713c7f4d2cb88a8723983283cdc70575accc00d05e0eec18dd08653d9538c01c932eb48c7c7214cc4fa7a9184db1752bdd410e5e321e61b2b93e4fe4793a50b378fcc7a61c14dd8697b363c8e978883898e4209068db4d889de85799e62395041d52e64a1adc93eec3d2d1ee3439625c170c8f8d33afa2140e8ee198e7c0b617baf328bb0806d6db781e79900d3296a4b034089ae50fff101757e4231afa3c23575e7e24300592176ef354ef6dc55a18dce7d6b647603a42d5f8581e68fe72c0a6440f9178cb7ba64f59bc7416b8106f5822b4fb5575c3601d0d32432604109e73d032ad84a2c58c9f16021c5ab2d29e2e6218370d722448a5af4775bfdab94455e92dc1d67c6c498b593c40927628faaa4f19b51fb5b6f90cc9be2ac3d6c5259367c3783108aaf06fd889ea3dcdcaee8baf4a0ba84b9cb4e957bd72b637c9f6706545bc45f5c2f5f9d9167fbce20c9bde9a02dcbfcd73ce8cdb87f6ca205d33d8529d3ffc42ae4ec561af57410d18d84f5bc18120ac896f5f7315adf4ac096541cd2291d9a2771a4818fadfe0b88801330db7bd8d867034c52a1d02cb4419d6dd26a0e1b727c498e893546edc06fbba7d6ac5333bb9c8782f0cdbf9a27a241ff4f5be57e153bdc935c4c9329e7057ebb3c9dfc3d5025bb76c55b0f88ef8a8bf1704dd19429465568efe4dea1e16f5b65a065e132ff0fb1fd6603cc28076636fa4f4b5bb65ce05bd80031a9e823ec1373fe61741efe1d030ed35b182d79b8d61f2003d3a8e7119f742edf3ff715881b6052c297c96f7c8ca59ad5a7e89b39dd7197cb63e08cd1f510e7c466839c2ce24295c0f5589dfc5411d348d4777307777c61e6e5d1a2624936ced8ea888343655c329bef49b4514df36142cb777300ead8b864d246d23b111140467b62ac859a8f110340e983f1ed2f2e151ddc7354a73e5f8fa2ccc99dbec77bf72921b2d4410b0296607300e8029c346f11c6ca36f17f2bf82391f55834dc3901c1ef5698efc3313217c7cb07cac69c410df91aa47bd7421b6cfab0adbb7498fdad419130a12f5b280c1ed884adb0e2dfaa5def8b0be44b6056b76a6b1ef7cde75160b7a32768d05df9c56c76b0f1fa3e5c4f146662f6093792dcbeafecbfed6b6ecbfa809c5466412d50ea3736f1e71c2f536ccd6d73eddb268e32744d2a6863eccd83fa5041f30242728e7cd137ff1aee95b9178efafa7f58a7b573872a167f06918b7921f4bfe4b5c67dc644e0f0326959eb78427c7c427b7d6a56781d913f0097674919707666626d75f064accf8cd5406bdf6de557c04f28d74596e175b8226cb859759ca76aa2bec7f0687cbed811a9d6742b2e4a243d878e63760de4b43dac1bec3ae6b6cca8116fb3273f1512e85055bd1244ce592b7759c320d6fefe7c4ba8a8158f51d1d7efc5daa640935a88b8a7b4f5fd514d07cc2b68505536a9cebc19d82b23d2920a97b131041128584d70afe455d5e057296e1c0cb9fbeba5f87d01584858874c5beb1df176fac9be8bb4886965d79a0e5a5296aef0feaea0458144e114f940bcad554d2c15d0b3195daea986ebac891a3497d19adde048409d3eed6dfc4f07d9dc370d614ad16001b453cc0153ca6a14bb32d4e4590fe30b6751eaf476c2f732f18ba39045dcb7d264b4efdc7671a77113b0ef2f984eea2ae3c8b6f3de40b07c053a53a6767b4bad1ca92225c5f7b9e55f3c04572814e7f08f3750a0253ce9fc9dca358a16a2ecf29b9dd872e4f52630a3f402b58e7b06045b413152726a629c12e74a629e0400148d2a2f4950afd069faea2f7e6b6399fcdcae10c911be9843acb4d5c5461d724ddd4e52fbafc15b3022a83e5521def1bdf25e696dff6d8c960527b52f8f135bcc0dd107218d3a74d378c5bef55e1818344e9b6cd5e13b376e1565433c7c99a2106e84ccf70bd5a627e916b6f2c7d40c0d5cd278be955137b5215281c2e6f9437fb0c78da28a8e4581b9e42ff7cd42d35f6ff593508473f92f59486b4b107b88e36b411004787022b940c141eb21381d436af87ea9260fa2aa48729eb6cc94f773e66088997cafc5c3bfb0ab410d8a761b67278053eefe6f498b27ed3d1dac13345fcac1cd7ad5f70ea25b6ee4a996de95a4ef12f8002dad60b8dc91ca16af09a1067f522ac16bd457eb8efc9a9833c9a6d71f4309e4a84c7664d4658458c5de1d521a449822268a593df48e449e84aa2b383c4880ccf4f9c567ca92877762eecf6ee6ab9fab9ca16b01761c22cec36c49474619be18ef85588f9ffd069f12c071c767ec85d8d3f9149d79056b588fb5f29681e32bf4b4812a47067be30c26112ee056a09d55b45566c033ceb94c5e56448478d6c07abd4ddb7f627183911e43a097dcdd7a9bfb5c67608ddeb3a90af3fd0b85c715d79bbccf6ba6830487dfc40eabc6549294a383bd83266f6c082452272cb05b07ec1b19ab81e52065d4792aed34c0f2564adcb93ed6ef89c46b242e6e6b686547e63396b559fa1ded4618b601e0b7309943c2961a79fd59002b9404860341b6e00c163c21413c68fab8411b82d6a182c1e15a41f196a7b374af0b98b8b3d09fc6cf114803a43ab13a71815bb1a9d3c5097a3b5598935cc59db8b458fe6b3b992f02fbae457b776294c589bd6fa5f208bfeaed552c7f7d0704447dff3812a901cd149eb44850bad2aadf93d63b4910e8155701dd562f368944816104f753d41a15f0d6cab6ab9c791209eadedffb8c76ba7cc6158d4a146ebf4f55e6f54fa8df286c1b6182b6b31f99967cee1b088503155b6d423f1122d36b7a0d800b3eef44e9569287e3d9bd660f8a934b53531ec24d72a90ea174abfad31390e34785f06715b56ecd5e304df0399946410331217ae67b85c8ce3f9ab010da834fc47a7dc36209de13b923197d46fa696d697b98ce188a4fde216777df66e7eef15fb08e057bbd348395e701a5a22488c8e9ac783fd96c0d241087a92b5d61c8ef66dfb5a874fe76d8aaa1329a124bcb08b82c25cc244aec6552a202f9547abf5223578c92c00a146d2b23cba9e622cfffd30b7e9492ca3679869e0651cd48b28f65247c2a8d5f017471585a3aae670e7f1964f3c9ace89df0bf31e50b0dcf4c82b0c98a850dda8b0c0aae52d671419a7199ee816aa3fcaa6f96498288e51cdc906c17479e5ecfa9b724525939b54e288916e09849983cc25f26435f76fbebbe8693f79fdceff2b1d628f434fe1d8344c07ac6e4e80d35f465362f99a6d71af602154f94fd83be5b9b6df33101525a74af16f10d1be7d676cc3c87fb4a15cfdbf5b811ffc1f842a6b2f8622154e897c57a20e872a157be3fabde9cccfc50e6d9881346b4dfb8f2bec93768441b08e28f9045de6349e18a6032a16e006fd9696a57f50dc2bb48e38d1dbca1a80aa6b8fa19ccdc49e3cae6a3242021ca1c94a30d847e740ebda5ecb4b2bd0e0994c32715022fe911547f22a06481d39e8a25456248ec0dbde6688f95367f7e07096ce8ba71c14f78b016dfa9e2dc3d56e9ba775bd41bf996bfc65cb5573167d8a2bc02f92a9d0766bd9b4843e79d22a0e9db45cabd07d9b21a3872660aa830160c52dc59996d89ebfe99daac7e3bbfdb96c7093a275b4b13501af5fe9debe983b55e22697894288d63decfff1f5dd236b7fc8261c04fff0bbcab30f88f649f6d8fa55badb868b2c76b848a1d0b991ce0b9e3d785dbd2308491178c3125b83229759272c49007e39ac376ebf0d4ed681b98fc8ae8f5a49440cc1303ab795593bad61ec433593aa72d693b622aadfa06f431eeaec5875369dcb05bfe3890e4d7e871e4fd9eab2742b5b7a1bda3ffc078ad2b97119b191167135738ea4e55c8cd20c365a3bd14da16a5cdf4a8bdb702c483f6b6802b0eac8a39857dc1448e8abf4782ac00b7405fce7b1dc01592aabb13d3df97b45717063f94e90a4082a45aad7a431085b4ddeac1c9340c2a1adac03192df32bf1099d13233465ec0e51b8b73ac12e5a04b0d4f417794d5a4b34861efc8de9882e272e84d31424c87fad204fff91bfdadf1b7293c58e01d41a59db0175057fee548e366fc4f39ab7b179f44899e7f230854c9c3155d2a65270df83211e537b547d8a5102b5e44fcb757e4eaf3e839729b0850390908cc84e76ab1550661ec1f25b121c20f8e28de9baa3fc17e70aa5bfa2a7722c3b710cdc9524f8c814085eaf02bba3726705ec1400c1362c3abfb26af29a1a0a06a1493e31da53678a14c2ac9527c8627aff1b0038bc0ebf42158a152af987347389315ab5287117bf34630fca5c8f30728d087033ff799b23ae2b7a492b1c6399ff0aa7b3e4ba6c1f48b39d14e9cc4adcb31e44dbd2241391b6e52020ca0c988c9fffe0717997aa3d3c84a5d4aa6c96175919562e3537bddf7d5b0cd70f553829425314bc0215132d7f5972a15ad9c1aeeefa66fa4fe10eae64dcb89af64b63306cd29aa6be155394d3ed655f1723c2deea821a68969bb04bf9a5fb51cae3a8a8592e156b887c1686cc143decb9e0d74b976dab6f2c42bef75b68d25634135b199faf7e6702295582121a74924068524976bc342f7c370426521b63639c941b9db341b97d857e10b7748a0b13a3a04c84be2e3e7a1f61080b82905fefe52f3dc42ed39c61e40bfb1709547bf56c5b22be7eae2032c2f72c2afc777dc3a56da22c53f745cb80e89a9e084719cb42e566984887eefb4b8c9d31fe4a63816065341846dee0d89f150fe41b7aa7b496632ef15abe1fb5bd47ef5659e7df7ee61cd3611e932cd8d34c1ba12bde0dcbe86ae8807c1516aa8aee44b9f776a78db0280d2f5b4d7f1ee07b361bc35a375e5e1191e785307b034f4a51d58420f85fef8a3a99ca7fca4c504a66688e9da6c8a6659012775fc72df2703513fca506c0d3d9470037e98008a025a51dc712a481eb2b9437549cb659a21b451dca971ea672c4ef37e2c04dfcb283035061ac77c28cade661b3a84cf377b36127be1e8759c4ca62b1bb684258571283a32c7fcb9f2445495de1adec46a971840718f34ef727e9b23b5d8e61667290583efa445ade3e54767159e9bf9370a09493f1dc811e6726e38a750381a0c4a438b3b77c9c463ce3b84bf0c6190ff9067e0caf6d20708148e9126cc812c771a1770025654cc8d4aa33141de433ad78cb5871c9ac16c45a908b3a11f9eb0d0c87fc4fae92d865802f40e60d4da5e6d5c8de3e8264797c87a15d81aed8d35cd8c29233c77c1054678d28642d915f67fd390b322e671d838f0ed3364ef646f83b2c3f11d553a54e0e3637f1c5c2e29ad61616d60c441f8ec49c3e0fdc0ba9f0d38811db12fa29246291570ee33866a497c7a93ddefc1a519159dd574c29bc4edf1c258eefd52fd7aed801cb0eda3adef10722d392a99ec5d4d0b0bcc8a7a5f5e239e4d6a49cc43839823c59b1bd913aea015ce18e49f4742bac5dd59549c65f597a952a8eebd8eef9fa2d97119d52e07310aa738e34239ff0daa402654307806c8693307ed01d29d05f2309b9159be91b8d7c9a69c2177fcaac0555096314d1d8257fcccbf7b782450cbd833673a03071cda7a427f4b9987d515f0f7960c808d5bde288891885f06ffca250ab2fe020a66353edb280f909de6e2492e20800583e45fc1edef75c27aa47b929afd9fc6f53f10ddfeff1460e0c88b9589e53334af8e1526a3fdcbbcfc2a3ea032a6c4c8cf2b580b223b08a63ed877093daa10bc2868e345b3804c39b53fd764ac6a9bcb7ce2418f69e555439af1c1e62f570258577b7a6fb2110c33cf085faaf512602df0392601c1c9c308386aebf2b0c03604aa3872ddebaded69955358661eff898bb758177c29f75f47687b28debc3c22c97eb0d7ca543ee7a54531dc0b05dcb1070c95f2d54a4f6de37d97f35a9631d760a0b220962099e2878101616e4f0ad93642c8a9e7905e11381f3c71ce3b41bdbc65a5227ad80403503fd9abdfbf950c2363ed7bc23c4569c3f3035f096a245036528a8acb466379063e6ee5d6cff2ab6ab0abaebcc960c151e18dff67cb07e825a28de4b8566f40c7649ed953a03e0888202de0949dd0fa41de7b3a2121578e1367bab752b789f53023f41b71f5090843a5cf38d21bc1b17255e5dff281921b45efaaf537a401103adb5a8a82761d908a0f431ac26b7042ac31dddbb0e7720e07197504628ed42aa1b1ad5c819c90d916907de2979557434b7c7fb214db3caee655bb3d8bd489f82581637e3479ed9235cb5b6a2633d2c2e0eeaa67d05760217fcc9750735dc648fabd445fb8474985a212f89086772e5873fd928264d2258a48d4808fe182c1f6c31a03acd89c2ae57b4c6e1c6bd13a1292cdbc85c8f3c530c8d10055830c5677b90d4ec0292f5337cbe8f13685348661f7eaddfff79ff7c028b011c76598fbaaad357472a24c36dc110d0b264ad7ea3393d2811443deb64fcd941a0839115d5e3a33934927cfaf2a3d77652a3bb4b90fa3e49a6e05b4e991a9241ed23cebe1bb43ea33bffc5990a7f50eae00770717f039c7d23b4a041bcf3780134cccb48bb960b5683a6aca03d93b119e9da60011d87894c8fed936e3e9de60e09208ebc04affa0283670d70ac74d73ecb2d18a1edab3e21dab2082d7226f37f28b921f8149ba1a4c66526fd67bba395a57ad52cf45f2718295ca9cb541f80cbd8c4f083ccf409b6fed2405f08f26f9acf045c4430ea1c55e1a3462ff9a73b567f3856319c0d6730e5083b6d456398835f13946f92b9db86120375c1dc670a5a85a70d0a4355b3f368efbf0d2a32ea7ca9df56c6674db5b0472246c8f56051740e90b2c6ff701b83ea9efa815dc4e0d8204e49e1970956b6a92c93545c3bf8aa5d93c2c572e469c23af35b5a59a5423bfc29cc04ce310fb813bdcc82d13f6b91d9ebb6a6b5c54393a16733aa72ca09ae7a60886894083d36d36dce12a3e09f9af88a3a516ce52de05ea41ab2e471d3756e88156edb5c10ceab71bb87416415c2396b702ecf591526bbcc36d3b735188ba5620197198c9c617132c0e64091a329acbf9dbfd6badf449d8af98f4e94b869905837e3220ad1e8ec39183a2a409e395cff4662d4d6da29837a9cc5e2accc78b5d01f1b131c7c38ead4bf0b23f5068d4ae78a3a5428a9b1d5576485c46c8bc0162679c22c2741db99f5d82669d32aa9b4181c84ee3217737e4370363164fb50c15a6dfe143b6296d5e020890fb43b29d26bb821d4302eb1f4c59a86b891a53fbdda2ce28f03fba39da50e87c81219073df88fa36619b9e43dbdfda14c36f74a24fe9d02511a1a59bc5fbabc6b2f59177cd7d37f672f17db3af2723f346650612e83e87ec5c5d28746b8b8e3f40542edf822fd4d96ffb8812b4cbe82a0f4b8d557a80a4c363793d4bfd3720b238ab822dcf795aa171864d3e9d273a288c53fece6e3e65fc935f385f3fa2c4618bf266a5d7486f9598481377dea183faa4cf47da3eb8aff2d652664867b9fe6d7e0f7a427608963a62570191d68c2f2661e079afad22616526e0df3841af3c813f9fa9524277abc013c95542ccb6558f996e3292722090501625fdefb37db6e34751908b45be9e421974f1a387ee59de7178695156ded7d3ee6e86546f0bdd9029eda827e1b2287f95f47f2b626bc2eb66f6a8e2e3365cc42b0832be20ac7fcf92fa4d38d9d9caaf327a893ca61a32c4ccd7e58c6444d77ce7155919d25dd4b277ca38c4c1db320a70872e4386c335bf97d6091660aef4ab0a05b3e386952f8b5dadb1fe43961347eeb1ab00ae551e03505983fce4e1aa58c08c951e8723a4f6fec8c976f588dab22c7fe2ddc13b6901588bfc800b6623350d90eda291e37187a99d4b3cc4a1deaf3828dcf022e03b29da23a71a3a45f0f262a3e4699839bd3a12567cc5278fa269e0a868e625cd0e2c41a17cfbe31a869669f1e7653d0a8da689baf2f52300534d21e5523a9c50faa556088de0533993b0138b5f10f3f7c1a0050fa14725e053891a9d7b968e9e0b02d51896fc16681561a8c36dcf6de36361a793c07ef8838f5a4aec4fb712edc2e7705816f47fba0be77d3cb6d078f22d302547f34bf1e405d45ffe31a5d4404ca10ef058d358681840d73c1dd9cf29227c2bfc63216bfae1d76ac0ef3c68022767fa5b5dc3484c2b6df8ce78a16469dbe3bf6067bd26285719dddd17ee9591fd53cacf6e9f874113a5eea03d1805860a59583d30920fea775588aab7fa5319f8447bd1d7c38296773c817fc4629efe1205c572cd3cafec88dbcedd23008cd562271fc914df9e4d4b9638ac1938c9b6ce390bbfff98e54c9e1829a1278e9f8e4cc724b8e582efb39cbbed48c6ca2e80104d335c2c811f11aab2ca86a84e4a1ceb099e733ef29aa46d42b4e0285d06cf054328abe9d5dc38c60697bba07f4bcc461f7bba6a592806bd9af73590e1ed8216432c329c58e5b405f47b118ea8d137e6047130f24bbdd0e841358ddf3591af7c6088d3f0c50789a02a8a3be6ce8ad6b558baa69d0506b88afce70d728754941d7077ca4f2a49730439de29fe0e03f0af99e5da4f15e267717ebf8e14fa16909026dc5852c675fdfd5059beb33a945dc0a0375ad225000e41e83761d6c0b5a6f2f02b3e6c33e8e7c6ba0d32466387c51b4954bc9f406cec48b2ab28a7f932cc43bbe06d2c56a1733f2e3da590114ba55a350b54d5a0aed98d37f22ee4b043118c115a726a9a2d5571895ebb57c4d06a3c1fc284b8e337582a26fe2481f6a4c822dc5d0d93222a52f472d7ecb45da5aad24a67f03a7c1cd0fe11affaa79427300b1c087e9988161e101ae1a9878020788c13284c60fc185f2eba8179fd3a7a55a8cfbe87acfbf307b909b7ac819287d8c5db78e04916bd8add86a83029d79516aeac0075b71c3a35115510ea35c39d0ba254c5a7fc43ba3f822efac7d9c360c3c0e033195ab882d9402e2c08cf2ee7bc1062e18fcda49fb50f3879ce62f0de97d0cabf139856dcb21543938a14e84304cb5c30a914cc1c5aef1e3c8bc50b6a1dbeb7981a3206e79874a956d80e9b8b63c0c943a22e066b2f5fc3e5c1ba118036f0c803b94950ed1a13f1380344c4122b82a567673ec11eca31771a0b55cc7856a5d0d61c41a716d8efc5dd92ce32a429fbf3f339a2a780c5d5fbf38356b5c0d35a1029bc8ce5e6e9aa5b0df98e4ac7e0ef3e00c5a9ddfe2b32e3eeede819d9e37a08b7cfc6726d2effac061b439b2f8e33fa01525f6e36b319ff6e7ec628b3c46072696c4a31dea5b9be2df9a91b5da9b5903c08abbd16cb7f0f57e3bfacb664728e8894cd485bfb15ea85315934c3bda677fb02cbfa3c1b1e78e1e0c2a8764874b1f939658606c1ff91afd089478033b354aa4c146f0e2ccbab37a45e99fcc186e01c38b5094d662b71663a2e66582107753199f87443efe07b74fe4d743a33883854238ee706225b037d6746d4d3f04415a102831102d863053cc9b77dc59e3c8002e63f42003f22dc6d20ffa57b32129a0b943c45dc01a104a48fc63a2162a4ab7a46ec7891b9b8b6116d54b6f7160ecc757910b49a88dfa3648970a7df0c505fcf84d0c78f229214db8f387985af07234ec0d46cffa7dfd6f2e22de0d85c37bc28e6c6e37da6fddb9d9628df8d55611977247166c25cd98d0633983f7dae8a3aec26d8a3dbf97a57902a121d4a8331c5b3c5b17f8b95d0590ce51e0d3819577b15f66514cdc2313ff141000257afa5a861f9baa09f6a7ce35478f8f2ef14414eac012a0170d2897d503d0c4cf8b7377c301f14bb6439eaad3ea589f8e5d868156c9e3681ed9c30b3a0a521cd0f4d127163e3fb8802e93419f321446c823c2e79d2fd9b8ae0cba18bf34ffee7b7708ce4b7cae7683a3407d0cc915193b5a6f157b295c953f0044a81e88c9c1c48e07a66e0026589fbbfc3b4537e9c5d49a0b894187b6af1b8f659ee2979ad7e2a01dcecca74352e68f3428cb872540f2d420f37f60329c95a9ed3d2e8512c8b11e79af97ff3b4de6294c6476e6cdfbef65932b716b25883c148700c278b7211c37cc2728d48ed33d8c3acdb5996356af9660d83a2ae95e331a348bdfeccbd2b227bf20dea0512b56d6c049098a6caacf91347ea21ca1074cd93b891287d6c09e55d7cb0a25a74f336627156eda927d6e0efd48d18e0269949c6ec622cc6202e3a184763d7fcdd6b196741604b9998de9201958ea162e1a1c3dc72da3858d9ebc7e747faf90f2c4af2b32c3bd35d760451ff7666c07ca34d9b0dfbcf773dc82ed49591e2809d7e9be9ce5ac3d2849f3e310f452591c8c394d1f37d2b331f66d45547c7f6250ff11abe890475e8ba98498b747a22ed86929d203af37cc43185966656e6811dd5c155d591cae5317324a2a6a26e8aabc855ce2a06d1cbb89999ca2d21ecc4ba837abc8ce79293f3b94ac83b5a298ca52e38795cff50c0ca0b5a5bcdaf742011d04213333058ff350329acc2e16ebae5ac3f6b065bcf2048e406e3a2630f97bf9e19eca8ee164e6eb8b77abe18d009e0a2657ea19e1d1add545d1c6c420171a133389b66697b76249f680fef6cfd317cdaa8db79fe8cc3adb486ffc0445f6d4d925bfb47f150bf46f65e6022676c1f1a648e141792a48d6b6756ba0960422a23de761a755f9927691fd2c946150a5bf1eee55a45a3136845762a9ffb5d8dbdb2fe3c07b5b35a201c8005d8894eb5e0409d8539497aabda96ea849e8cb26799b631e42b35be4f34e166ae9f1de24107a6ff41fd995f8aac27875261efe647514dbe77017cda36757014cba6f5e633109f46d7a95f8ac858929c190b3c08a86bf8e96cc2f649dda727437404b6f7479107bc340933deed1a69a2cd11a3ce06868b31a43a29891a7f04e3de4bc66d6c04d6193e9fbbc9ac16fbcd54e4457a9fc69299835d1baca5d9875efba64d6650c7a61c33f799a0bc5d1e4fcd26cfc304e4322dafadcd16888eff230099c68e60da1e577532d3752c8df08a941fca65446e6afe04b9b1a3f7d650a7aba2d4863548636788ebad5f4990fe1f53c1e9809498858623ef029c36f5f06aaddab9dd407d2fd52bfddb22f0e9393122b42464cd6003be4525ab4da792c0929dbb0b041c277ce27c31fa65dd12c9546fef5e3c8a094769f9391eb07f7e03749b5ca90aba0ec485e810f9edfeecc8dc408b2641a17ab0d03292bfc5ad05504dd262aeaf4d336521b15aebec8f41410cd49b299868be3b4b8059be244a5c4db11e9a47189101520ddba5d5b81ba3c97207c7530e9320d4384c14cb5b61f4bd758a8f221b5b94c52f1e828028dd0d5bba50715a137662ccc6f161d9ec69e6b5c662424d6dd3acb22f1e92c4a70797465b34e09f8ab51858204ac80b917b126617364967d909b7cecbfd5d6582f62157610db978d439c65f0f02b121ab61a9004d48497c617d41f5a3aea151ae02182dbc2ae42c9416baf5511757e58b4c45d9adaecc5566e293ead42c18086d30d3482514022bbd155ab6531f9eabbaa1f9de66f16ba5de02705e75e2340c018f5766f2a5382a8dcccfd9f69bd41367f0a245a4020394f74b4080b70608f8b0cb404fe50ab3ac9feea758a3f0e264f7ff6e990ecf83a15ee186a20e10d42be50b75067aae078d225aca098aee9159a31bb9a825a02fdda11d529ea9825dae241fcf390ba3729b110c1e46462326da35372d1bd2ec59d2d099536df03bb8fe599b4574ec27e03e89e5c2c924c729ee76b4e7abcc8e439c397716095468d6262b65d0080a229f5fbfb6c01868bb062ae8cd1717427d06af9c80d0b523ae552caac34341bf9f49e1f7ff5280b4082ee5018a84988ee6c10cbd39ddbdfd66664669cd73599451992198b8f6d4eeb929bea3f6f65882163ccadb0d58ac071e75c85b602af576696dd84d9a808fdeec112b5e41f71a35cfa0e380cc625071cd62fd37db584e3c6a6cd0ad3b8d1c0bf253c310a53ea1b8a695271f7e0c14562e9207e26f9c6dac41fbd641a6512e7266cf5854e362ff670efa7cc2afd4a89e13927b893ceddc9190ec305e03ac23332dff53744097503482a7d8d30f3288375e37e4bcbcdac0e3b7a12f3f7fdf9d0b80792357bef95d5a6002d9a9fcbd19a7b25762d341df17e20c3f2254e148dd51e6f126ac6c6403417761afdd2d168e9b24d4dc5af162c9081589b8e680f07ef4e59b2b46156ccb6a9ab0e1d3f0c17af701fb2b88ef0bff838666d49220a113e2550628a08170f907b8b1008d52baf4f8611939f024fb3edeccda65301ddd7d3ebd5d4fbec1143670624a2ee83afdd44384ce9c0d5557767ffd00c4cba4e9802d3d95dafa42658fe7324df45e323a46c3e61ce9915f4a6589ba67fa4e9d9795a77084793bb536149cde3bbde5aef6f402df9108e2a5fc29766c50a00a1397471b763b4ab067e046e71f1e40dc2e4c3b0776dc9496db44d5fd978152963e387bbd94f6c92e5a2d33bd5f38f79a781e7fcb17b7190b4c0e61f6c00ecf95b10ef232385e376b56179779e032772d58b104833d9bff340da9b3250d97ff4f2a95358eb67b4e3ad423c1fe38f1e2653f717dd2426807c5167539c2342e54677307d5f35f9caeba9357c5df98214e602f977e3d944963f1e64f3b60cc3f680f4d8b822ff88be4700fe655fb513d8db360dcfa0ce9250cecf32a8cb129e789c7aa5e91024c8988943018bf900c70980a3ee74bc0c0d5bb01a0bb8206f0674784609e1ec73f77b051bf1b7dabf2948b4f42fe000d8496c0345fcac7f57e98ebb1e64554f4399c0f18c60053fa8cb62747688c9f6665ae1d928c907ecd4c44027583b79ef6a7cda09ecbeefd9f8cc21e379887a4a7380a9f981dc4df47654eed8b3ba30beddbb140cee42a1b86906346d36f7bc29455c658761fd3ee42dc4eee723c2dee7e441138d20897894482cd85df6a1319ecf88c5f38e93426781e62ecfa78f4744fb9a7d91195f835b00acf64a6c1634d998e796fd1fff7287fdcc36b85dc5a9a0a7cbd4642824f790bcbbb996ee9f2a170150fd0ab77f914dc9be1e55de7689858c012badd91ea2c995b635a7925feb612ad29aa5601987b47e900ba90a743763d9361431a9bdb0f0b907e2160c1595d21e899d9df85955ef35f56d6874ed0b9f28b96cd0e6861e7cf1273031ba651c5fb41211a3ad7eb25d92bb23c96970b62a2fc0d85f99e19a4ff0bbd306b0435ee4a015df4f3b302f2f72149b9a9122feba26aeb8a2295e3d1990ae48c191f143f062a85af063b34c5ea300430e150d8e674e9dcd66535c072ec2d364f12b4047c1776c6f38b7343de192e56c8501bbf2da07f23469b6607a7b375b558011ad4323efde8c53ededc4211a7f194ec00e0ea6e8666dc35ce9d5c467aaa4a1d9572d0adc91e851c42f7a99bc0fd871fe63659d854ba31235f658364d3c490946d6c96bdf6ee84f6987e52189300ce1f465e9bcf23f1c8f39d6fe765cd0417b6b5faaf3100beb1bfda7691c6b3436ec0598f10c75d018142fd02f41c4e2112205d010a3d9f654520f05bcf17188dea49e3c76ac7a5af7a0c461340bd6332edb89dd528d75a48a745cf14b8ecef6a73b43c70dad284f1ea2f78e56d9cbac8466645369ea8bb83ec0b2457936f402f68d534dee1e172efcc75431ec37bdf34446617ae239ac080d71c836b20e99b5c3c9bd98bd60ed32fc326a677d909dd4524ea02dcb1ff83ed3e0e9930752f1a99ba5b2046919e23abc6cd0414058cbd590b3db3293ce1802ce916a96e1ba008e19be3fb50848d2431c15ae3bdf522ea60ddc1059e9e9bb0c55c830cdfbcabf74603d51e481f1f91ae2010e4d05af95f68da7e0a25fe83f7b2e9ae6155c12f143105b1c7e32a1ce4cc36bea9a9eaf0726f3eb368748c759c4075806a264f04290627d6100affbc4b31ca40bf338c20cac2f5575c04e9fd652775833f09b5756c156cba720eee7ae317832e7bb8ac859f780152f90a8c87ff7818d5869ffbe0796b84b65f0d5b06d1f318400915fdac87f94dd4e543e7518a97283af9e1a470b90c9dbb378fb968f9e55a32cbbb55322209533388fdddae04bb14158dd8a9aa75731099e456a0791e3c9b98a3262ad37fcb0b88c777af19a07ba8a0caf7c944f4b0da3817b16e83e4812fcc28953a4735ac619a0e2d5add3eb5eb44d8589c9dbe75603f7f44cde166bb66cea1f6b311ddf594fcfe4af46174496a933d408ac2727ca0f3fabf29d8a580e2e719ee159b29b008b6f0ae3e2047e98891d6c47472529f64ff79bbfe73fab117297e83dc638b4304831a5dc9a741301d734f383c7384c5ba6c6d86a33037c0ddef47cc73885b7e21216ee5f263cbe17bd35ae9acade7cdb740b1c35772daf5b52e78c2e592252cc9977a7d5c223247c27a3bf52fbf89468a3d1c913c7d62651f52632704d0826f7eb37fecf831f67516dc4390dab1b281e90b3b555206e5b39e86b178d2fec3650740c8665cf0f92d089deda47c2b6d9bcf56a183e1941334c3151e1f68459c547949223907686a635a5092bf3b2c51c518544b18e6989d738e758cfaf22f144cf5a05c2da8681d55d6ff28c919dac1877079681b34a347038b9e78de3e2ab0779cb56ad67a0fb5e29830cdddc8109e4335f23ac04391f7055d7f8a03bcfe07d1f7be3d1e6fcf1afd883b361e953170341eabe632342d7f21348e93de6f2a20426719a7274bdc312f2e8b525567326446790b4c58b01e72317be9e394af0763e6e299fa714fe946c9f272e0703a01d056e843f58c9fd5b26ceb465aefe7c64f2487663d6ce2bfb14b4a62470ccc5527bbfff19d42957013385716e056fc2e55968a357dff5de1187bfd923b61eb15e453cc108d8c66d022568f65011a445eae47d2d1d41944024af670cff0d92492e2bccc1b46cc48cb1f44bcb5417994377e309728dd9f9862aacd286ec44ba73fa6cd7ea2fcfdfed7851761db512d717ef5296c5f1d4f5410c0c5d12bbee983316f5e0d081c0905ae022757d0113ded323c3836a6a53178f0a82ad3b2073713992ccb07c63e5c6cc653a6f93e0eea97dcf1c84220a34617061f415dc449b6fd1732a4bd92d084a6d3d48c9a19e4908a57407b19f86b5480207ecf722112d0e95735f45ea79fef45e7fe9cd6e20443d2454a4302061793e71f3dcce247491f4fc1bb041feb64eb6ac2d4bf0b3a7611e17beb70acb08b6a63477914df4d7a147c684ea65b9f22df68e1b66aeca27456669042df915cce0a3e3af7fe848241d651eea9e410fd8de79699ccc26160102c72be0fa3a3e21bd969a5930f2992b40629ce6b97e0917106dcf0c313ce05a992c25bcfcdf6adbaba44a60f27c2a0d8268cbc8f4275d447960a52fb60467e49f2b538c486389fe662ccbd42fdc7076494ac4ad02138e67535bdeee6dbf4678f071cc65a1d29db4d733330434b0bb3f3dbdcd41dc6b174fcfecebc1cda86bad31590cfe73245133fe4532c7235c0f5707ef3e81eedf4f548c1010da0c7c7a5a38bf6de99a55c0b7e939c8a1d636a57c3f14ec1c5b210e6a8df873c7516d59b18be51f3aa4fdaea2777fdd69768ac3afa0c506303fc83d73462fbd7148b7e01b666a395a7625b2bdd948ad6311f6a023f0361acfa1bab5222876273caae462d39f11893be76e7ede16aa8273c533711be71a2b0227c0352ea122114a420dcd6c3dc5a02315517f64d024840ae30fda5a9131094ca7191b06f4700476cdc7d9ba25c7d1bfdaf13ed17ed85a0569738b2bdf04a15885458a6e82a6e73445dbe04478d45b13cfac8f5dfd63a3948059643f875739a11be474f53991339aa0eabb49c916a2069b9ecf50ce4ff0cf222efe55b8f06a3d97be14c8a7368045480eaf67ea301b9614d1427442b01b3f0d5054d720d0cc7df44255ef057a921e66b816d75daad9abd789dd07da5c701ec81dc473292b58329390b6be7fbca1b2cd5c1f6820c4f1085ca6c30635c1b14179d0f94ad4c8f9bfa6a94823ba968380d5ac16e003ddc1865746b61fb0412e2b59d983c78af6512276b6e33cf2da635da1c01f87d2e15ac1195fd0076dfdcd6e16a206e42dbf802d47d891a0267e7eacbaeac3b6a7f02ce0daaa1d22d87f8fa5bebd03b8fa685f8296c9406fa6ca45e90a81d9e212915347d63fdfba5f58665ee22158f9fb364622e1671f08cc636c70ce71ae5a9e7a1c22ab18875ad9d82314ab45eba4ee4925f618bf7c013c4cbf4aee367b0de1e8376aad8e28085a95a1b7dd2a5fbb48fb0a4ee0db3a00bfa41adf4f383f718ebde186b82184c175e674fc445d7176917ea89838bd3ce5c942e4f316664c23cfde830924469953a7b81e5d0472c1c4ac6819525eaaedc12cd3e7e9dd3cd8cbe8296af4043f70da752fef91711ed6611a9506ffe2d4bd7add175549ded631760e2de10cc053bf5b83079d279b0d42ada9aafdac2f8cca5a96ab151c6bddd3479b6932daacf48ffcd916d338ed154d276515133d876f81116cf5c64827623a7bf62f16ba97c9895f501c0635157e77c27a4f530e044bc87c741abb14d91076b745589d185e90052ac47ecdce237b3740aeb8c7c2896656bd221828c729ad496f24acd8537cb152de4e5f4334678fc1b809531ed8458e114c2a316ce29fe943254de66df726055d83e1a18e9b7046fa155218b3e4e55a82cb7f80d832219247498d2c555bb0ba7df9e12fae4b73f6d57c7ac7b214f9728f9e80219c8d72355734b00609a748203cf7f6f1dda37ee268bb312449037c145963c39deef2f6b19e1bc12f12e7c0eca9b513e78fd35d34f5a00d7a0fee6825cbb6e9a5e61ea16a23fd605234a88b6c3db030749007b9a51db41090e14cf0a227e7f31722d10dba980094eef48cc703c1b1d7b7c90f6707b6b67b601f5a71c1af2d8dca08ffcd33c412cb08030925156a3b82bfb50ca8813182008538b0f7a9c650a2bfc17902188eb7b1e01cc458f7e34b6b1ae5fde637dd6162a62dd30427cb896f11381917caaac8d2bd0a8152153d4d7441b9efb90ee7886b72512abf9a39f8be1273fbb0adadbb0df6d4a28876e30c5c203a57e4dc8cbfceaf7a1d384fcb2cc8e4662b31738ebd1910092e6023b326995f3b755b7b2c0f6ec72e948295ab92f960baf95f5362ecf1873236520df9688c9c130422d72ae277a8be65442a2e3dbace14c3bfc698706a764e6c2a2922d927562773779c8cd8d5bbabcb1d20f882f6a7035574c78329f49a97d3b1cad556c053a9c4842e62f9c8ad205f3d9389bd53ae5843ad4c33329971a3155896ba356b771618797faebf4995deb9be3fae6818e0b67e66fe2141987af90f8e717b757bdd93a1b4f0ab60019a948967fde6797590c9fa2b08855cd7c10dae9f4a13fcc8b9fd3d6576b431bb3519c97e7be08954c1993b12b6752d999a49b83709cc81248ec6a4f177f6044e910fa15d0fe477a71e296dbbcffafe39220a0afa880c0605b93a6f97213e0dbf0647dbc5607177397ec19fb68fac34b155af014b757480e785d98c1c3d82b4f37b323e7ba8eabd3e962c2cec9a230d96439f3b25f8768f5370acf5a876853ce76d211f31c08eb94d74a98405af7d3d18da953e3159f16a58b795d7f0cc4b4d352c75c43bd0002bf345bce9e999abefc00a2aa6fb642b11d9bdb25744cb5c15d12168cc28d2af58c80560b2d0209d93796f3d723f8b2c45526b030a900dcebd025a56c4ee329d5cd5e0e60dc186b4ca99fa9cc375ed6b69ea9359b6fd7a895ad934a64ceb654c894de89be11208517f55e07c1d787b67c9a1f4f6db5eb9f538f30c1b37b8a61265562d14dfb052a327dbf32bc5af4b74ebdce50b0b4c57ac36aebb34ef791359dc5f2dc9c99cc686f351e57b1853c59aca20bce860e75091711219abd527d4518774393498d4d7aede196c8bbaa8280d33321e01d855d01493f20cb0afbf0d38815bb7f7ffe692a4a3d0446291c32814f480d4aea076ae58f3bb0937a5e4299b4153f3a74eba848988d15aa48f0e25320112101b1028867da356297e9032660b8e2c2e84fb58409bd4bdd112f0d2a9061e5cf0601fac04e5a64ca8a460f4efc5d371afb22476101c8332f0dd689d6a96f775c6d0dc65f133665ae520083596fff166888e214d16e6fdf9aadf3525b6ed4aba7d6c6a186a37b22b27aefcf9ca871a95e63a5ec47bab3864fd08f702a228b400a5b4b320d95408757185f604491c1afb9ab09b33f621ca3cec11ecfa8a49aded181a75b576cc276bc09adf7cc09f2691cb9909d16c27935a79b7388adb276d4bc41930157f4228d5106f4c0fc57e6b592575ba1a1f284fdc8a448f8d24b3fbc1a6838ff300d4b5c72b383141899c0f712a00d3bb2a8650ca770cb21b6e952e03ceae05b1da0e949892daec1faf2a807da0ce69e590c93c53feec175b4a4b160bd0ae9977d39d0731942abae25083e42db6637d818f55fc430683821609cc8d2a889847b1c90029a19c6c1e4dd6a1d902ccfcf1c2004a2f90f26d9a9b20bb8e6907b49067a5e06d1c9cb2c73a1c6b3bb45e25af1bcf43af1f838e064701211f1037d35ba7c98116547a4b3ab27560dfd852df1ae9d5a011d1fd585d0e59ac930580ab6a64d0fdc5275c88238411008decd02d58d0cf6d19cd388c837f17d3adc922109cd26f8d42171e99577b457b018dca3f5de5caabbb68021b2c53b51516207b0a6d881598f94f226eac9ee9db41e27a9078d2d84952821d0bc67e4eca42475e288d9d29c2ab8222822db75ea4855c4d1a4eb0da6918a431eabbf5edcae6c44583e0dd1658888c38a855bc5ed74507b79a7f56ebbae2aa2e10cc979a2b2e5d2bec00eac6e14fa0f46fb836e7aedc28eabbe43f7f5d0bdf544f569c9af9c08e2e6ec16e49804cdf610aa6182cb371fa8129190a6b7f03195cf54aa301e3fcaf8f20e5400ff731bc14916070387d3c9a64113998324a87669536513d601dab2e8b7c8708a2c270235a4fb3521026d831ca557784793a1da0a6a6461d9c08e8dc667f93d2834808b0fb1f1186b2942aa4c46c1ffc5b3d46f10928fd94ddca4a052c4dc790c43ba653c5f584380a134318b42b0db23dcdabf4630fa1f9eb0d3f7ffdb248d1b7abd8250c44f3f0223b4e652aa1190acced4165b77639e38c8045368bf10169ce61d4358aecd199e1417aa1faf8f3e51146df9f5f3b8ff8c2dd2d4577f97b453ea2ea3c8de78a1c3e3119bf6dbd092e48c3e6913cd230c01bb4df8737ff8324b56c8c8d092fe493466dc1adfc96808b02a5b19dc7fd903751797f07e80c73925014f78e8910bbd9085ea0c2b29a488ea98b2debeeb690a7b5467eec1629e9df5b4e258c724f97e41a15b5a5566c2ddf41d84e3570f764829526b15abb21c3474841677c785a6692417b624e77af090232778348d2b0e7137e8fc6be7f5576cd0c1c90aa33ec958a73ba581951fe122d13a78f6c97beec700041467838cfc71182e2145549d11d0827193320e8c6e2223bb6e3d6179ccc1fc6a352b05aea414d6a9afe578698f3757a16345281bc9a896409823744e5a79f4e3af9aa246169679157bc544cab643ddc9de0292f34c9740cfc3707995154a5b187267f4cbce5b05202f959d9905f7ee6afab09a6bd24d34f4b81ad2ec37f461c4bb96243dbc92a467c785e35e3aa8ad739cc150026f9fb5886de0bf7592f4b0956853875061834ff61f9bbd7272799a02ddb75edd5824babf6e84a79996dd9f617e43994416dafaf83db8f5e57e7ad9714758f42aad6b9127db52f8e30943f2933c551d873dcc13dd314346de1644b35c95111040c5b4a3480bc61c16749a0cffa8b4954791c4bce3ed09a8d1dea42d057e7466077a247d3e2c68906abdd4c2658a8cd915c2357306c9d933593a6736701d96595bebb614c2476e06e21ad98fbacb54b5575fae8894a591816c1cad97e6f2afc56acca3e35517df147f799066b83dade18e17bafeb09c13e0cdf41bcf4db62144c8ef31fb24aad9682c0b02c7ab6377713b2e40fe89918dc9075e67d7ecc9030a6942a9cafc8d568a1ea53991826a8da14ec75d7fec4be60abc5ce9d458fab86f4dfcfa912ea7b33b80a8d60512b3e73fdb4f224a5b66b7b89935f66b85b651e697654536a6b12b72619ec10bf76f26fda03ab0d83eee4732a5e541f5e61a4863514597049af41e26d4ec13b2dd024b1313a08c2be86e4297b661860a76efd299338190ec0092e54a560152eb52c81bcff9cb15c6b12ba208262f93e53560ac8d10f61cea156796717396d3304c88885ddc6da1ced86a2dacb70b87d62a3b581e9198719632946a989995d74bb77781e57ac2159e5d670c53fc2d76836667a55ec002bd8075cfae5b753308c9ef819631ed5687a73676b312d61a9f64b6e7456ba40738008e1e19e422171960bd524dc1a80ae8d9478155623e8f47f30186b786ecb9169e244c7907e48d1272a6344d5a4f78a98120fd885146cfa56536260c64976dc791e929c440519d451c3d10ddd264f12dc99e5e3c75d20c975267979d3e7a3cf1542d041b4e0b33b1a9784f17c8dea1a0d64c64f50202b58aa6870a586b2122e31a891bae0b3b2448afbff75094056783726011d11a211dd1ddde986eebdac38123530dc8e995d4c40d0cc128e4124916e63779f17a0bd70cc82cc58f75804952ee7217a7366513035b435f1015224a7fc7ad00c074f72f3bbed94e3ff04fe0d38c5bd442fb97a60c79e7915de2a2f1fa6e11490f0c8bc657fc454a580cf1d038d185dbe089297ca409eff9dcc1bf8e858f618ba6ad831ffb79c98ec329250cd514ac03ea5bd87d53f6c001f9b33b39c560bbbe934ab3acc436f1874eb890704a7cddc5d8e883c8b9e674bd7b3ecc47d10cdc26d6a5a528d13e9c86d3856f76ade2f8d08c96bcd83966ddcba9a2338cc9af2a7736ac8d1e64727ed7828fc4576167e1af0474f8da6ee1e3871e13c83aa967d2a93f6be68a99b8c86ef37d8fabd4523f83196822f39c88ebf2125252cccfba7dabd688ae4237aca1fb8ee4c317748baf7e7b7ba70450c1bbf97368e6be7072f3338cb9274043692cc0114f703fba538fdb5fbad9b9b29cc15cbd9a7c55dc2fb0e615ff6b1e79fb3b82a7266026689a04ab4767c3f826330172022e07e15d38092acc486e5de0050aafaf86110a6e70864dc9aeb84ef345cb36173f36b5e4d8de85de05e3217a8accae0d0aded38dd551d1700f61692a43b0f768163011dacad141e8ed7e1a8801df1c08a60d24709d39c40e5a8e027c52903e7dd784dcaec0e61f18461fa02c6e5343cc45d4b94299eb7155a016124345402bda713a424bc4abfb0b24e052c01f45a8fac63c584b574d4a673ac3f17406e3fc0e735c9ef7a565a4a8084cd8c4534c7945e76e0fdea1f6ff7bdfdab525bc69e273130bc64d10baea47d97b8d76eca960b6373b39707f04d6242eb5c01da66fb40495a28da9eef3d35192ad9a38dbe2cea9c19307228280f9b48ebe15124445ed1e314fbdd9f3aa7e95a4152a49a373c325d42bac50a12a7a67ed631bda53d66230190bd6656d6d732541efed444cb560e9bc8f688609197b7e627973e415762ad75574addf5b2f55b2db43ace823f56b3fa3765a52b8a99c899a558c022d57bd0e03abca8835474470736d754bebb43f228ec337d663721e1a3dae8d01a77aaa7c53198a7e908984df9495801d31d1f9eaafaa818d07b77200e8dcd2d5339e77934407a59dcf2a75486217fa2f2ce749827bcbde25e9f2a63389493ed480a072c815fbfe4e7259cea43f0af5cb940fc718e3364ac613aaa963245da07c9fce9becda18e0eeb40d3d4e775eaea7f18c88a266358cee3991c6204eaf6502599d4d8107e42ee106891d554a5009317866a9c68192307cc65e24585ee272c06a7eccf467e1aceea459fbb7f37d89ff666434e778161026e916db7464b524d3e78b134cbfdf60ad1ab2fd74f8c3c32cb83e53a40fc80f841ad6cfcae41099832b8ded8c3c642127e45d825f338f71acaf6c3180f2eec33a96791016a6d567b385c0231fcea5d24a607beddab2caae534412397676e7c2d13753b824e140a9ea7714620f72258910f5227e05d27a3381c0b20b7226fac44b9023c146fdb827c2b2b2797cf0e66333ffcd09caa2c0c477aa8ba7b93bdb93fa6fd1920963b6ff7594fb0d2a1583418dfc6798e216c5dba95a5424ea31436fc9efca30cade698ff344fa94aff789e251a5751fbe358430fdfb7852cf888bd74c531487889c2fc8da6dad7fabe8d7c0edbb8b20eb6ff155e1ec0c0cc72d444f88ba18b9d8c1366e91e08b0903ac50c3a25227c40c145229c4bf1addabeb6c9664d8d1b6887994dcefadf00b3326056e6208b72c378b09562a207d00c21ba2d04a0e07211104065d79d16e2fb52de093175b3002f4c74555be6f6e0874256a18efd2fe3d3315912fc4aa141d4efda6b05e0f75bbaf58ab7975ba9d3848746a2e0751192448a2c1846fa1d4539554a8d948956282061a692da080434a2c0c8f63516c097f6416991e433e398240067782841195e92a66f0b70747f457b19cc7e610703acbb6b7cc7bd74f035c44dc040477a69bce1911764ab0befb12c69f59a6ad393d48b25a5a1d51ecf95776e84c9e94d23b412751fef0e574284b385d769551fd1cc5e1a9355fdc12992856fb1e3a7897592499ec4c5e44aad838b88cfdef4badcdfac1808959cfc1a21f3fb463e19ad4b3bff0764dc74a14179f0690483ed6429d3b4278997e04ad87a3d347207d571dc67d4fa701d0cba0b9be6d27363a66760727a6df079f177eadf49c425273bb40ec3c62906273e2645a4aaad24494b15b243c63dea6b26a25422f8a1b132e207dd18c5a4022a1866e1c76fcce8540a999fca6714d455bc29cc0b7452c1f78e63c1b5adb11935c71bf348acb7b0b15a5d68765ae69a3e4c42e69c6cc72c05cfb06c4cfafd90cf0ef31ba95745ea6b5490d9eb2b0dd1f43a09e49aec17574e73f9a6f4f2e365e2c6323f3ca275257704b09be7c000f7014577ca1db60bdcaf5f4750d48c347e0fdc74015c0ce31966ab7954f17719b89defa2b7349f1b0f22897897ff3bbfb27ead3973ef8aabb86959a8e577a054c9196e60784de1dd03fdd10b7dfc7f91ed1d988d19a6e69bf8ae92fe99778dafd45707a32b0a4b770faad83f42025fa6d96f2394a8bcf158b3c758ff4062bccbc70e51df37bf42e0d5e17a1fbd744d7d1a3f82e9b35d567600cdc385d79b91a8a6da342ec91f575bca0ab111da745f4f546e511d634aadf57f3d76c873ac03df731039485e549d492d48adae4c38ef84f353a0cf7e9761390f6584b96549be0a9ed83abb32a7ff1cb8ea8cff0d39a5bee6b125a30f185365ab87c22fb9f9a7732441259a55b51e7dbb3e6c243a058dec69f5da721b41a07dd691cc8fa507bf128b38b5d4d56797a9fda0f77bb4736be336f8106c37e34dc0a173a1e2247c3e6f8a02d44a6df12d41100a97ec8589483c1b9536d8c01cfeb9aea1b93c2f2bd512a23873bdce9c45c933f529eb51909782da7b7f5ec746502768c9616fd7cb5d1a0069d2df6da24cd2da05633460ed957f3cabb48dc05f1381c2e37457dc3b0f495d6695c72433a03a826ca966e9dcc8e9c782ce0c0888e1cf2146961b23b815c2c2ca702172200140f415997657ee1cc467927070dd17c84f11b071a2bc5475866b93024bdb61b343a6d610e6bf8ba533e2873e68c22cfe934245600bbbc614e0d7f55e8d9f823603407ff34ef92796993833fcec988e147c08e622fc6c8f564dbc8b773602eb19225015af4dfd98f36eb89e7300393849bbef155bd2d611a91b8ad0e9d6812cadab1363e794b0abcf1d9b1a51b91fc150a72b2e9ed064a0e0d6e84b3a2a785842ebc57522962cb88a75a8d452798f5395a6851d2edcff613de82d0adc2eb2815193afb9815751607f05eceb46c5b7cf3b49754ffd3e97b086c2bef3bad961ef2184928de26514be8ed74efd53c0a51054674d6bd657accdabf722a70de6a4a447312002380a9c2ce9f89653bdf7f0b4b8de80289ecd9186ee59ecd62075c81a42739c5ff5561798b02ae92a818c6eebaadb550db40e180b57964b0f05c40e479c4d4ffdc4765df7ab6c94f6b5288331a95a2decf58c3a69024593d579e845b0700568a60b2a9d606d682d1923de2d05d974ee8324e1d086d485acdd27496b960da17203f995b8359e82055768e016f591c2fb2d5b06f5ddc27fa02f91204935fff7b5b403f622fcb71f6c4eefc8fd1b9bac872e3c60ab068b63c7178ea6c16b169a4da35c2f74fe39acdd3d3c64d06177b6228e42f0aee8e2c8f6752bc7e8fd88dc3fc86f3e9e512306a632bf40161509bfeb6bd5ae03b48ce54950329a5f56b4d443f40feaa5e072715603d058510bb7ffa44b093de2fbbe0fb760d618e1e6b890ebf48cab655b94810bc855526e6dfa8365b5db1bf6cd4bc77c1cba37a200367daaaaaf90d83f8cae10f1b80570377e9980bd4ccf3985642fd7dcaad84571ce063be6e002e09be7e6c9fe4e63a479ba48e9900c6749dc8e9e6ad062316c4124c4383dc15f0454c2449c6bed6617e4e51712ac55510e2ddbf427875d53db56fb18174d16f4bcccde01fcf6a4d4ae5ea55b5dd4f8242d44e7be74e9758cea36eff4cc2e5d6ca85f8f3116b963f9a605800668b48999910fd38fc2f9dfad14ae9c3371cfb2fbe945c8dacdafdb0b9fd0afd06d1d880f0b638ca912c877e9233ce9344e59d779e1ad0ab3201bd0761c593137bac336dd4d2d344afc1c8fd3bb70239291284aef57b128950402bf015302b903abe09f1211aab6fcc707fd490e62e3b88cefdd91e0e6868d7f6ed6b7fe95b4c2584382782110a336d7e4558dce48a2f21074216117fd667acc57aba2329edeedaef0ef0c8d87217b8d2bdf798f76c3964480c89e6da909d9fa0f14a0150c981f7f3056892b9eda42798003fb1fab0e7e70e102241700149abbf3c153eae8687b1793789a0e909f915dd831857e0594007b655879d24e03a23b1c7149e13405f81877ba709f8302e8cb7caf6582f916409eadc5edfb985e77413954612069c2a33e9803e9114e19461a155a3e000eed74414f19b19a300632b160d7da0503611d1fdb30436dcd8f7f09a656718ce762d2a549558ff5eeca21804377362d6a609028f383ab92a73dba5df4e6d20518d64a1d5116495a5237783b6f65bc62550f4b897fd03d6eda5bab1a6f91172a7b1af8ddc0c1cb7105020fa22a1450874c5013f7c2c64d4c7e45aceb8931773ce341a296ca9b3dcecb7a64929edf53d4da41a453c277fbbc7683927145f8698aa5e6c5f1ef7568f461aad1862c70adccf043410cf9c816ed0c723dc8955910e866ef65c2de4a97a115da2aaf3b3d5bfdb21ac1fe97baf57ac38104350b94e483d95c6e3a600c26090488b1fcdd75d8809cc921b0e1465c4f95534165c55e9ae8923cf14b19185d15138da45f0ccb8654e512c760d9b1185bca05b10aee547dd3fa6dc62efe8c52eb70549a6303f93afc1f4027819b91bbca50976f094a59a74042329d275c16879bffe602cad6aab477a29489eb75c71b2e5ac600f3b0db7b555799a3d6508c2ebdedb47e3103618b82396566b13bfac5dbb9a698114b76ca66c20f6e4f1fbadeca08d12aad17e287b55a9fa68922f6a7e61846b16a43e845466f38941e7b44df0d7e95f5b8c918f2ffd8b2945e0c60fe37d7599dfa18ca38f0080c71ceab6cb8be7d3c48e5cc319283073c0077033cefe80941dd4c29d408194aee746e9e18c25ae194d9f931c4790f2e89453e4d3028cd4296f93500c49220d6f68b2eb04ee4fe066afaaa364cd6fca26ac9348569d2d3ff95b5045b3f62d8af18264b5a34bf12746e9ab598dd1f5973e3e851460d9f6c4e1b57856d84b79716d6980d1fd32c25eac0e05a3d1df475c7e82c78592bf02418ebf7f429946c99edc176b7f411f5399e4acab7d980c467c33ebb08a7f405ea89187da49d4a25801f2ec26bd5a725780e891e2c60c35c99d77507bd19364f3cb3c0202a6e8dbe43da5e7c2c8771666078b42bb8ac9179feb20df971535d5a2357dc12e4e78d1d135df0401969f86e49dff4ba42c220e1f829c5709730c6f8ba9b78241af1c7fd9fe5fcd70c8585b2542638acc1d9c31fbfe72e6d3cee3cb30b9460fb44ae3e9005e70bd28fa6e6dc4d9ceb67a76fa51a9b257f2b84a368a6f620be8cc8781ef184ab65e7521ee8a03c041037d349b12ff9c1ce600af6aa38e68ce8100387abcbac497fb36bacd159be5912a1a0568f12d95ce053e8574e61948b231858e5eef9415d53e398d9fff5a944fec160008c554eccae94ecfcd6ac5223e4660f1d00190d80f88c2f80f757680f31394c32f1d85138901326208eb32a15c12d8b83951b99f7a5d1358db65e01cc7e484088b03a00f17b78bf1f3ef8e2fe2ea6f5db6024ce4d7692749788642d9126ac3247f1b9cef791652a2a8baaa9edae1cc64ef12d553d031041b86e51f602532240f982cfc19a7754df342c376977fe46f0d6200939ab66348edbba67e4049e4f6d9a606e95a2cfcf682e07be8012229a3dac4770c8c074b024d242c703f356ba76b7a91dd6bf374c66344b58803e9c17298fa1f9cb2ef4507221cbcd602c5d73bd1878c82605834373fbb4bb84b6c1fe0e5ce140f9f65b966e51be8549fdb43913462007c609a458b862d8c8e5ef2a5382393d71f68036538854fab36b845f50956dd4dc451e4d575a00f4dcf70768efd0254dc328103372fc3f0b6d7881432fa8927f1b8d4a14a1618c9d54e2bf07cc573eae32ec6946032236201390a8c552384e719ec4167cb77a9ac9f22e10d76645797bf5119ab28106a563cafb59520f5aadf09be5d4dc220ad7a67cde1501bf2ec9a7432d5714dc266b56d3db644282c6bc1344a00843259c421b61449cc3f6d1031debd3cc7dcc3b985d8b9dc4789b8670c0ffb90ef6d649ea9d2879716e9b638c1b2c154fb3b7c2e82179a094a39656a44df7b9c9fce6b44efdc001e3bffe59970efeee44599b3a1e621d57a4a8b724cec34087ba216534bcddbb39c7ada5f13d624b094918698d405dcf30d2deaf3d02462a9b3cb87eb034e28a0cb8ada3d75133bcf9237a2c6bf2b95c29b695ef08db68f4aa1470ba0f6c8621e81d08c0bbec32236a5024b178cd081090423c66f39a79e9d48ba3708502a22a1e472a24187644a7e95cfad2706ff075bc825121aa997e9650e0e7fe6635063654648ed4aa48183c6426f35644567440ce2508d02bacbe466f862cd49835bebbab387251e272ea4d4b98e20726a8daeb5c5e9dd25284a61d38ec68e4cb8038cdab5af5e2db1091b4204460b6734a83234ada6fd21c131ad95ccd0a3076bbc457e49b4afa3d4343ef3d00162259f5a5a9ffe1e4fb22daa356f8c146d602519676784fceffd4ebbe944e5b5fb6994762602fb06c2339f9d2799f189f66e77d340ecd0df4c1ad031b24bfc63611470b48304a0e5442aa7833dc5cbbe845b12ac38b0df1293284d07a1811301d6ba5abb99215f388e18057981866c58e5d71627b31b5dd86cac9001bc9e61854916ed3da30be7b5c42aef854722368cc2c20ede747b45db6c90887170617ec0bdab10ba063eeaed60cdb001056f7b39eab06327dca5c3ff7f94e01d6cb1e6132a4ca02b17814d55c15596598a376044b16e843fc96b3e96fb4c844fdb5dd3068d6b48c69e8483f3288c547b8fda44a39cc82dbbd8caaaa3472cc7d348086487f0c813e69ab5b13d2ca0de86fad21edfb7260abcd5b95cdfbada9ce3285839d5a9b99c25a62f484a825ef273de77fcdb89bfd58052fc4a3207aae8438003236ea314cf7c258a5c4b5c3c18a3f8911d78c673e17535302006ff55aa5a6cd14459aafb76adfd040bc8df9e39a3a45717468477f0a588b69f6d6d739e0f5b1391d52e2b4149800092be7be0f7d9c81b6dbcbd13ac3cb8d2d91f9fe2360f2d198fa9ca81eaa07e25901f824a6051b04d1a9289586ca3458f11f855fba4d1f3b94bea16fcdf3e158f1914bd55e60f9a9af1f665b16bd4ecdc5aaa796798f93e08ba38bc0fc704ae7ed19a5cb847f2bef9e08cd37a5d1e082646ad99eb8e98ec4071d03bd6fc1b4ba9fb32c1a9d6581ddae0838345e51f13f1f6fa9563f79edead6148b046fc2b38b14f37c33c6d7613c63a0c2070a79c5eca25099d400a711d7c1e2d8f9ddf9612b010b3a2cd8997f4144fc5bcda5084341a2048c88e65f9a1f57cbb1764a5a0044d05b7231773b29d7709cb857484f877fe6fec7fc2038300964af6d9ccff35efb115dd6c9d4ca0aef199cf83fd56b68a3e59ec58b339453e242bdd4b17ae81e8e7f349e58e872bd88b2a4980781d04ebd65d6c7c87b600793832fbb032977b5339cbf51d2acfef9ccf68c41b94ab575faa057290e751594b6795a798f4d3a52b95b76051f8af322fa5f06c7d3b69fecb08dc12b5870078746ab147c63d7e7373453b9d4e93e20eae0e6560569d9751084bb544c1f1c12b23ad47d27ad63611a2ed0f31b519206f87bbcd05a7c6bf1405f9f4849801b718be9f7de17eb86c31034dfd2aa5ea1e1e07ddd770bd60e89d0304f0fd2b399368b1c0a71d6485be9708a1b116f17e3249368bea14ce8f2d18e39b3c4ef2906bedd1abe381fcb23467df7e8effd5cbab9fe0d970d49def0a382ae52324c027f6820452eb2d563032f1829f2aeb482baa3960f2dd98b2cb6c428829c4a905b307a37a6d772719e0a389c258248b4c900da291e844b674c583fdbadeab6dd2e1a15d2fba1c2dec34576c88badde16a78605804728680d21e0a71f0ed2f2d0da78fefe67804905404bd873c12c36257735ae6381579432d5e78332f1619a8845a4378fb10f6bf75acdb5ca7dff900ee0938811aa8e8a2ba65cfe5f61d0a82c0068dac3c33122694a71aca60c66c39706994e2c190c4d36d883c66b36707a0f76f68a5f0cc315a665b9f76ea0ff944d5575fe1a2e848a80e17f3127dbb1705412889f4151b3b64300b8479ce3596dbe47c493af7eb220f2841c3886b3eba9bc8fad50c42d857e7e368c9b995738cbb94d9a7dcdb14721177ee01536ddafb4d37aadadf9fd860fc5c63af73034aeb917b70f11cf56f777089342595d52450dbd36585862c81e3a3a5c9fc9d381e59bdb0f6c326488f0c9eafe9b641aaa5e1d6ef0065fe13325e238343654d99e04dd05d2a64d887a316417e164479750fd9d52a4152b0adeb0cf54b3610f235ad4813dcd674dd51799f86d830a35725dc32646c28a9e4c7dc0ac9077059670ba1e69e38759d26db94580f9f882a5cbdd1bf325517b485477639a50787d312102dc87d9218034b0a754ebbbcf8ca0612a0066fdfdfa53efe13bf401da0141a6d562b3e697a976a5f6ab9de45fb68bd8f00a6ec3a542edbc49c85ab6fc5278dfbb0ae001c8a8273721da31f9670ec1727b64d5a98893076797de4c91085eba4b3338c0c049f027fd60297c759d0589a6aa4795303b57c5bb018ca89866d2aff92c1e1f18bf8053bbe9b8ab19215e95caba6e5a5bb9612cefcba08cdf448b41832a27fcdb5adf9aa80197572f02a9098ade281e1bcaace5857912f0d1dfeb3be9729d846959b187236024bda89e5714b7a5430b2ccd26b9d8f0e0bc7e766c74e3c0946cf95d77d01f244937d6200f8cc3876e8c7afee8b1eb899d4d73f0cd7d7710ead15ddca063fd52333fa716c3d802cf675646d066886de4e14d37e5a23a30989211c996e6eb1196f99f1fd3296c84b5be7ac3737ad043c9520538bffa4a858eea134def31859d67946fa5dfb8dc49a4f23f7146e37457036b22fe5f4f9ebd9e5b45940144d0e7aa339ef985e138964f96e8ed8fb35ca6ef7d4542e8261d0ca3017f6bc37abe9700a8f0ed1fb0a236abb828e74aeb83ab4d0f50238cf05fe6da3e02abbf948e543382366137cc33aaa617f21ef16ee34d64f3bb0f9b3e11a8dc9c5761237c9373a39660abeb2abe563739bea56c0f62b37cf43a2aaae2cb2a0e2187decf6353a6a69a46f5f8fafad86955f9baa71cd6811648d2caa853652067a4d7a24b780d5a98be94691d2dac1683ee683c4308bd731523d0162056f29aa3efc4b0e447d49ae72783a0243673941f4b7b689d7f300034bd8020607aa29a26026168ca4604883e75b5f8bf2542430ed873024aa6b39c7cdc9bf5e25e44ff74ac155fda4b5c9633e58d7694a89a0fdf8771a06b429c9b7fe1423ecf0f96be223ff8be93e2b34cfa5a1819ec166af4a43b6d5496d0365fbcc9eab1dc87068dc9cadc21049fd0ecbc177a5dda8e8ba4bfb87781aec939da9a567bd3fa04d3a8b0e7d86b18b5529509c261a0b6182a7ee5ff8dfb65a10bc3acf9e901a065a59c5547f4705b74ca7f6a711f3e72a2083c8f3eb8f3c1d3cec1efb4bffed02bda901e962a421b0925914709b5df9357b629cfd74603288d7b3c893479b06bcd1783f8a1052da86e993aef47d67452519b2148616e571e2455a51f96a05c1e1551d1aa55209f4270b67b2fd2eccc596e1130d9128add9f523114973f3adca915be954265ffe9e50565ae8bcfb61bc262b8d4d74f3f9bba1685791ab4ea6eaf8fdb1abe53d1f9022964023007c1804625b7a93b1ea270756266ca2f7593f4d20c488f1a135b5308021eedb0700db28a5eb932b0624892f95da4d65591787c3fd3da19d4a7a8e8e52d166a3ee91ff42f80d0e7cdeb60fa2bcbce14db127219f108b8447e523e0dc03300614b07d5b34f6ea7a8f0672b559601226c312f41d74dbb9ab38995236bf90cccadbd2bd38c80096df18c1343112416b5045d1cfd221ca26040425bfe3d9efa7ef597a58f4f13f3a15d5b245838d0c759c7986a5b2d674b7f5af387df21db7480ac98bf529222e07c60f1cb4246f695445e47bb1ac1fb503d68374f0646a92d206a228f051d208c900e50c2819ab1535f75572aa75408043c8ceeeac97dd33939c1d0ce74e930a5b6562e16487c537de2aa86df26e267fb8e5b13afcb2e07ca3665e123cce36f235328411d269b243eae4ec16e3d83f35fd676e44add32675e1e92c818f9672870e177a1364a2c0884886ebdeba897d8485480d49201043d1b70ff6aa4c425a47fac2e79a148708ce0ad76af3fab9dc1069554b67cb7736868522fb1a184b0a9c68ad7c8e6e92d98c9b2abc46f44ce73fa4987fc1f2255c10b6d1e72676d97e5519f31006e0bdf9b0e19d650c502ee76d9634a4e62b3d861e5bf51acb8b749b53ababef82ae3711c21f1f08663e3287f980fcff91928edb5fc13a62c98aa9e24f2e970b92e3cf8189ee325335d095c3ca0e02b7f2bea47e9909bb545c3682c1fd3fcff5ed0c4e9b50f09d5c8c5276aff4083b941149955a81b3392ecf6b87de80cc769ef919d3141d45e508fba8314a3e4839daa7aff69036dd860218fe192b743669ddad6ae5306397078e4f2d7e0c5f671ecf589f67d3cc40418415093c8c8ee68471427889e3081c866178b42cd937c3049b95b4773a20e0428e92a273a18f25c45eb278ccae57876c816c02c97713ac97ef3fc060d52240e5e21f5074202291f306f5a2cd928a6892bfa894432bbb8cb03f2a3198ab2e429c0d4f2b51da66c263dcb59d20661ca82d384f69c210a4a9feb76ecf39a082c1aee2ceb84c3c68b45470d6dfbbdb564e846b0fd547b7780f707cd5192b7af681274c8c11eff24bc48216a2f31ae8bd89b1500a1ee7c8636fd7dcaaa1ecac66c4c075b6a97f7856f8410c4aae76e43e4f181fff7cbee56769d220ff337488f689d3f4076ab748ebc73d8c9b468d219184bb031ddd580187df1b72644155bee043c58792ba17adb9b94fd2bff91af5ca1948a3e7f30ac08f7a5872af94ef53ee37463d11ca87342f030488d45a6f01c360476802fe285d75a44403b49e13fb4bb394b0b13f91e363cea8433cc9fa81d08d01b91f686e2ac9870e684d2ea32236ab0ed56296b2939836e5359b2a74949e479122709f376bd37cad7449bc93f18500f87e6b616554dd71443986b843dc759dca740b6ebcc285e3c8dc1308aecca2bf61a575b48682daeda8a9ad7b138eba965712af5ff3df26f5feaf68f2a739d9dcb31b7ebcda3d652d5e6dc94f8ecb1165624d11f3a1b2640f6bcebc5cb3d889e8b0e675ad6109122acd22ee80b30cdb2d1e0fe30aeace14afff7714e818912a87f6cc51de8870188c70def7e2ab227e5c2159e482dbc9db2254c9594260f3cf645be7ba4c2e7c71475fa353e2206a4cf19b86fe501a924ea9cb4d87f48d2462fb858cc2a4fba127605f33df67dcd9d6e1799b8c4ea443bd23e11d40b29fc4f57aaff29f68ff20b6ca9bd41757841a3430411c169e382a064cbd2875ec68b5fb03e23c44d63fe6856cdafdf333fa3d6ef4d731adc3a84330f7eeae085c4ace53e64b1851802ccd465daf8af8faea4f0b66870788b51371e072d8904d0b47a531dc69fc36e6c1fd1d924a85eca5b564e1d118567700e000f024b11dff99567da9eaa5c91c76352bb19350d5dfe7bb1728719ed43676128ad6b0ec400c1d10cbaaf885558696662be821f47c59a724b2af80c56e5aa67b6b66c438a0c95fd6802627f7c498bfff933a7153023489f4365ba49c5de5db0dd6559782eabf0c3b0537be4d17de82b138f7724a31afb5ae21821bb1af76e8fbf50e61c51b5f0a6fb983036b238998919a4b81a86914ec9291c0587f1746717f03bcc6096eaa95cf5b7ea04e762c02f795dfa83f64aa2101ab99c526e92ef3570f6633757199e7f76ad74f95dc6edd09a842f26e5cfe24e8ae298cc018fe52807cb890eacd2da5036be80ecc002302f7e662a4f2120b93294111ef79d08d1635fb153369538eb1f6462c9cee716b8eecc82ad6beb7f2c10cb5c6bffa645ed88e1618748275ff22bda49c10d0f05ed42b3b7c1c2a2f1cba88884ffb4de814188f3600e303cce4a4097a58e3cbfc015834bee78a91ea4cfacf98f8d497da07006fd1e0f6b0f514bcb3d34a9a1c0f936fed982dcdc7be6c6038e68b870952195299235da72bf8b436bcd96fc2fb4de0d0975d094734abb78b89c2f4cc97f40325c168bd4bf7d7843fd916ce6b07c1851af47aa08149ce9931cbd89390f029587e814623acbce14e9f23f70a58a3bc5edfa6f27f5a7387731cc48c25275a42daa9cf562a081ca3625703350cd565f5ec2b0ed7fdee8b934e255a099ff8bac16c1e81e589f215e45a622002ba68a8c34475a5faf02f510f53d220256e4e7bd1f7c6761da94a579c4761d2ed8ecd55b00376a8445abf57006a730b01534d61d7616aaf3addaacf5ffe9053872e9dd8a3c10379060857987aa8207d212c3332321961f5c264299658d4bea4653c8827a9e9374a026ae5bf21b424cd0888c8fc75b8cab6d9a4e4d9e883a5f840ff29cf1ef7d5137ba9fe395ad9c40d0bb6dba305469d501e75f767127155e5fdb0d923b99ae41cc11ce02aa4c7e81c46762e16c6433f0ccfce04361d871c40f8b6542b8aa1566c91e3a7e7eb1d9b55c0f8ec2c782960ae6eef34253cc0b2c549f83c20c5926d49a9ecec623504b208cef25221c8c5359e4ae1d955e18fcda3657b1d27a81be193542ed908b78613c65cd859bbb3fe76176c0080dbf0f18d2113d0c97a0b944e5e001f2ec9bee2f4c645603d79ec6b4851586798b7520912c7a68b5728e93595138e60286e423be443ed2267e72c45e1e5b791b5cb35d287b69573e76d5fe67ba25c2262069c92b3da028cf308e81520132cf12416616f04a78cd5cf0a2c71a357f42f87bc17fa75962a4a99814d55b0c79cb0dd756e3c6466d1b2b8a2befa797757d8ccb7635571ede8b017e77bf331fcb20f645b4e10ac701b1b6f6b1c90a50ae11ef0eaab1e4a9e96c9ebaf2b378c103c664bfbc4dbfddab49d29196617c5577d088e86f66604a29d2eadb5605cb4ebc919fc8fa95b5c6bdb3db13e7ce516b8297b66195f48f713e22c011be4312b2ee1975be688a1149319c7593c1f3c95ca4d76da4df992868645f07d13cf8e319d873ceb72c62b957fa893bde013880af670039aba6413d8dee9c8f1fa16c8690f12b07ae390f4a964a00a48f7a42f65e637e5aff2b1320a15b05fb134b6df50fe62da9c939691983c6a22a90e1ffa4e68d8d598028a856c77841677c8f0e4c9e3012d7d81521c19e537dd73e7b389785bd34f78dde28e3c6df384c52f408f1e3ee31d87a38e074859efb6e5ecdb24f561502e2a1c8294d626427c49d2f9394295fa199ddfe28d275375e995f17472d6baf52720bb06dcb9da4d77913170c30c69e1591d1ec00bcc58dfe882aac02c62c1b572300e0bbb7de83ed4b0d1908a108dd090ddab2f4b443bbe84abfd58b12d71e0e77c1ceda3ee21f894380b99dae8897ee3eef169d91a204280250d97e3049bd6f24e5537774f5536c6f7e9c9433d92ff53b9b14e082fa9f5680f1468934b9ced0f7666de9f92472aba8051c9ffa236e0f69745f01f8a971beefd0b066d0643ad3dda0e7579677eb3956c1baa244f2972655097010cf3d6c546b7e1723306c7141a9bd23611248d38afe62b650a349392e39f2c5886d10993ab7d7969e491553d82844f09f8fb9366ffbe8b3b8eacc260433a9da4fe97b689b4791ecab0b3ebf3ed24fd1e17f2452b30045b8fd30202c3ee4009fd13ec3344fcab176d88367c5db19beb1f95d89da3ee634bdfb855e25131eb7a0b6613f595805d8167294b7007abb6f3d5a68a46d3b85df6266689b85159e0d705c7a707e9306599ca6ce8ddc9b085618a80109a9df23fdb0ff527ba31ad8be7a7b615a89273a0922e88db18ac6c8913f1fa9bd597337b9caa8b36f998f98a2e3f0d4a55723a792857f94d0351464316b26e588340de621860c7fe840595b45d2e2edeb569e41e83f1a5630e4964e1433d6463362b8ec7cc15e4bebd1b6c3d2aa3542be52410e96536c72c234085fa35d664879015a0bc5fbcb04d8414e450982fe4d6feecbd7006ce5701eae06205fccbef4fdf85670b60c8c13f5750801c6394b40a2ae15c78c4728a3b516e466011ab85a00bb1cca329251bd9a06e536d41d556bdf420a805671eea5a97feb55e77ae85c9f59d8cb4188a61d6e316b8534b54a76b1ac7ebba414abd5897ca1e98b9d04782f65f87f833de497c80be980c5e5aba74ece78f8edcc6ee78e172ea78af5b44c94270087160c97f022d71e3eac934e5745304dca32d19cbb5dfbc1da993314c80ac536f71cd47d2a3dc285c14d824c5d143d191702868899d43f20ac990d973c32a650d79ab2eeccc0ecf03db7856719a9480bc73bb7a3567800e193872dfc570ad83539618d2e43f561635337e57a887c4d03adb9c6faaf76e37000bb4b7cc569fce06889cc9620cb49d2b3e41d352faa4d2abfaf1aedc97cb10d78d27bd421dcefeed3c7735a37842b9d1e9b506c8330450d55763c592b2f9400a3f8c93539a510b2e87e55ec93e91b049ccfd3fb6d88d1b9d7bd1c3d80f05bd63aa3eb1088f291997cec2830c130b18663611896834122b00ac52d5526f20b6edcb834ceb3bf0772a4ee15c9bd9c293a4dc6a31da91958bb968d1da824fbc65dde03df41b8dcfa2d74a6f35f02f6c4ce4da3ac73221835dfb50e4179a3d924e83c03c8dba191deb1724a92198f8e53e8461df5039ca578c340e2955ce40d23b6ed6ea4847cd14864c2896a9ba2552bf566d4eb9f74e0cce9a4ecc66b74fdb5626d136d30f56da30d0abd0c754b04006ca14a3d0a7de63f5705092c7d26ae62c8993f69fe69fd19dd02eaf4a89d55654a43648dab840aa8ca6bda650d5d75587e38f367ed0e5cdaab0a7c8229ce2dc3e637b2528997bdc86dbc8adce29475f5acfff193f2d430820ed2d54700d2e66839060632cc033464d7008697cd28350bb790e2c9bea61fe94005ab6b166711818a8a99230e1d38a609e5fec93d92fbb3e86326f584f7c1f5501f62f4ac26f7a262af79b65ec617166230bfc810016a057106c780694b2556dc458c420cd67d91449157b8135b90c087e220e05aea6a46b0670d3b17dc012cdad27b8123638cc4673d146d7806aac2ba057a4ff1decf872665e7f41a220c5e2cc60682c4b3430227084f716d72c5027a8d9c358eb74fc6d10085c71449bada13b17be0eac003c693715859c97071f838673b0053d581708e04596dba8cebd1dfa61fbdbc7dd3f7702c69f838749dd641e2445c6db994a201ee82168401a0332e2b5b0a5065df55f83147befb9ca2fcc5900d8812d872b013d6f67aecc939305accd65c40f24235f888c8e5182c7ae163c2800fc4a8dfa3a3252a5d387187f211808ffd4217101372e059fd9b97a7f837a9415914bab983994ae5bb63dad653a428928048e9de400ace56d189b11106084364997bdb41ada152cd82e6372e752c9e379ba08ae06f1045cad846160d7343c7627cbf0c335936ef15358a1898f7bac2ad4bcc76687bc96d6a4bb8740b26cb55fa3537cecedab2bc80964eb1a4b034ba430a8c5a690b9e87a3127234c849458d8405937c2182c6cc813e924fd4d6367428ae9539b0e43e1f4ae91c9943b7556fe7fae28e0f7c405380cc9aa146db9b9447ce71a5106f893ca7aba30c2dae79d48a75f6d7f9ee5db13c8f8b3a9592bd16c28e25af7b8c1d0bddef9a6324ed1a703e69ad3ff8e65736be15b9d6b0c835c8cbab809a2acebb34614f0d9d46d77bb44741b353fe5eed43546ffe7ba6fbee60be11920daf9e1a25e84e381777db980157b1833cc86c755b597d08a8a694158c75297ef80300d7d1435b9e453c2c59c76633bccb5ec1c257416cfe705cd17d83b2a4254f71346339c9f9a4235d261feffd109cd8460c2a6f696ea7c58c3a9195576a21bc7d55d0d556b60237dc3b198af9516bf494ae58b3a6f83554564fe7a24ece58b59a7470311925ef6b6bd3716ff491b82ba1f008b40e9b5cb980f4227a398f31c04e23d73a5a5374c621091706459b32b13932cb1f7107d4943c4958bcbf642a426437403d5724ff07063506bd40c7b70064b457c905eab4b9772ef730491323eb89efa81b540cdda2c48076968e3d076144a71379e0d5a727ee82475bf38e790a9a699213e1cccb0d49fa64053dd98ace5136290fd90bec18a5b1e4a0b48a3e0662446784091abddd15dd23ad850ad039f03b13faef0b30d583174ca729ddfd7f1dc85483f10e36f537440f11c672eb3032a3166758f0df9d899f1d0a555a3543904a5a9b4219339f1cfe7291f3c1c85c2e67396abd475d5f5478a2a24cd66cc5e74eb0d00d6bc038b86cecd00b398a26ac4fc50ad09d30d013f3201062c9c8bc52c01def08a1af6469a8786aa9ab560a472323f692d2f9ad53c9eaf5b4db6362e19d6c47c3c47e7820b0f5680750dd810c55f1c55e184106b0bcc20391d8bf51b8f6e94c775f1bd795f9e2b84276acbe0f933a4adbb86be6791205baed4f1650f9c273f5d155ec7fc0474a024353a4ecf274834f10a74cd99d042f207542b369b5b7a9a417fc5cb3614f14c554aa5c1f8dc7fa21ca20f9aecb71a11e5ca282515baa71d23d2ec36ca60ed9357236c2090838f71b1132905b493e66cf689224bc5e54ade3c39e51ffec23b9dd39e7bf4f46e497cc53ceb68dc3b791035c35c772f91051a762c2a5d4fb4714f18413a931fc710b45a8f7be4695af1f1cee74cc570857761f808ede68c4fb169bda2c2867088e593c18abf06656b6a63535b6a7e65581617176c4aa68ae8a98a1d8b34c45411d152ca29a0d45138c8e4e5237070884afe23cd33d3a47c8eb34c6af698f87bac59e6dbd7b18cdc79538186ade9ae0a4d2bd2521719d63b70378ecc70b0e12c1bca8af66596eadeffe87034b1866c26ba98b22f27c299ec6ed5504b61382b968acc39b54429272ede14681561b570aa2dd452dc4b6fc32acfa41f09bd99e00226e7f3364490aa5ceae8c26e348ff2f11dafd5455be3cf55fcf74570a242b0f3fe44e667c5edf0005e6ae72c4fe0a13c846e23af6c5ebc2a6d7336ac32d34b03ca46412411d23c5c3fc1b5c526df23226098383a8c57ce37a60edbbd23215d93fb4ec37a0e23898f01e48eb2f70c398609a667613693439b1c09eaae066bd7311b77a79eed3319e852aff9736750630fd6b20815d2a20c8a05831950fa66a224951b822301ce1f6916cd97ab03de85fc50cce262bead708a616f926ee31713880bb874503514fbe1ebd4aa8ba68bd60f2502007ee6740f87cf4bd147c6cc6f37841af4b9eb40d97d513ad17ceb888231cf50793e0a084b97c5531a8e03fd377c6e1f90173eb0c018c376060668c5af930a1106266eb7cb395a05f145fb0ce6dadbd37ad2d6231227e30c2ceb64d971888c27a0e9aa541d9eef5f2bf0fea6a4ca7d3eba37cd2bc2b6ad43234c6ab944f61a9e30c101ab449ad958c0a7363822c43a073e0ebdcf7454220738bfda994afd71a6455e7de55f8801a4d6f9d08dbb3583d4ce0464df489a665979adda1bf6a34340d759d04
  
    
      
      
        请输入正确密码后查看
      
    
  

]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android逆向</tag>
      </tags>
  </entry>
  <entry>
    <title>闪不动校园</title>
    <url>/2021/11/05/%E9%97%AA%E4%B8%8D%E5%8A%A8%E6%A0%A1%E5%9B%AD/</url>
    <content><![CDATA[写在前面&ensp;&ensp;2021年11月的教程，早已经过时了，以后不会有更新，没必要再试。
温馨提示&ensp;&ensp;本教程仅供学习研究程序设计思路，请勿用于任何违法作弊用途，并于下载后的24小时内删除，如作他用所承受的法律责任一概与作者无关（使用即代表同意上述观点）
更新日志&ensp;&ensp;11月6日首次逆向并发布&ensp;&ensp;11月16日去除“自由跑”虚拟机检测&ensp;&ensp;11月21日去除“服务器验签”
环境准备&ensp;&ensp;硬件准备：电脑(手机+vmos或者虚拟环境的多开软件？不行！)&ensp;&ensp;软件准备：安卓模拟器（推荐与教程中同步使用雷电模拟器，点击下载）&ensp;&ensp;环境准备：开启vt虚拟化技术https://www.ldmnq.com/article/290.html
软件安装&ensp;&ensp;1.下载完毕后双击雷电模拟器安装包&ensp;&ensp;请点击右下角“自定义安装”尽量不要安装在C盘
&ensp;&ensp;2.等待程序自动下载扩展文件，下载完毕后会自动执行安装
&ensp;&ensp;3.安装完毕后双击打开雷电模拟器，将其运行在后台
配置雷电配置文件下载&ensp;&ensp;1. 闪不动校园(11月22日新)：点击下载&ensp;&ensp;2. fakeLocation：点击下载&ensp;&ensp;3. 配置文件：点击下载
导入至雷电&ensp;&ensp;将三个文件依次拖入到雷电模拟器的屏幕上
导入完毕&ensp;&ensp;三个文件中有两个安装包和一个配置文件，配置文件不会显示在雷电模拟器的桌面，所以桌面仅显示两个图标
开始操作&ensp;&ensp;1.首先打开fake Location(软件别人开发的，VIP得自己花钱开)&ensp;&ensp;2.点击左上角，登录账号&ensp;&ensp;3.点击右上角按钮→点击Settings→向下滑到低，点击数据导入(若与我本人不在同一学校，可以跳过导入步骤，使用自定义打卡点，自定义方式自行研究！)&ensp;&ensp;4.点击中间空白部位&ensp;&ensp;5.找到Pictures，点击&ensp;&ensp;6.找到fakeLocationConfig.bak，点击&ensp;&ensp;7.这时候会弹出一个新窗口，所有的对号默认是全选的，不要动它，直接点击右下角的“导入”&ensp;&ensp;8.提示“导入操作会覆盖现有已勾选的数据…”，不要理会，点击右下角继续导入&ensp;&ensp;9.退出清理fake Location后台并重新打开&ensp;&ensp;10.点击左上角，点击“路线模拟”&ensp;&ensp;11.打开“闪不动校园”，正常登录即可，然后打开fake Location，同时闪不动校园的后台不要关，一定要用我提供给你的“闪不动校园”，它是经过特殊处理的&ensp;&ensp;12.在fake Location中点击启动模拟&ensp;&ensp;13.不管它要什么权限，我们都给它&ensp;&ensp;14.点击启动模拟之后，稍等片刻会出现这个，说明已经开始运行了，马上切到闪动校园，点击中间的“Go”&ensp;&ensp;15.看一下我的电脑全屏，说明它正在自动执行&ensp;&ensp;16.OK，这个时候已经在自动执行了，尽量不要进行任何操作，如果成绩已经达标可以暂停并结束（上个教程中的版本是不能点暂停的，说明我变强了haha），和我同校的同学们由于在前面添加过点位配置，所以程序会自动跑遍每一个打卡点，执行完毕后会自动暂停，大概15分钟左右，等待执行完毕后点击“结束”即可。同学们记得在一小时内务必将它暂停或关闭。如果想要刷多号，去到fake Location中点击“停止模拟”，然后点击“启动模拟”就好了&ensp;&ensp;17.效果图

]]></content>
      <categories>
        <category>菜鸡手记</category>
      </categories>
      <tags>
        <tag>软件与工具</tag>
      </tags>
  </entry>
  <entry>
    <title>雷电64位模拟器安装xp框架</title>
    <url>/2022/03/18/%E9%9B%B7%E7%94%B564%E4%BD%8D%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%AE%89%E8%A3%85xp%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[文件准备装载xp环境所需文件：点击下载安卓终端模拟器：点击下载
文件导入&ensp;&ensp;&ensp;&ensp;启动雷电模拟器，可以看到现在是没有安装xp框架的
&ensp;&ensp;&ensp;&ensp;点击“更多” -&gt; “共享文件” -&gt; “打开电脑文件夹”，将下载的xposed.rar复制到这个目录并解压，解压完毕如下图，该文件夹中包含了一个.sh文件和一个“system”文件夹
安装框架&ensp;&ensp;&ensp;&ensp;回到雷电模拟器，点击“更多” -&gt; “共享文件” -&gt; “打开安卓文件夹”，可以看到文件夹中存在“xposed”文件夹，记住这个文件夹的路径
&ensp;&ensp;&ensp;&ensp;安装终端模拟器并打开，输入以下命令aosp:/ $ su #获取管理员权限aosp:/ # cd storage/emulated/0/Pictures/xposed #进入到存有.sh文件的文件夹aosp:/storage/emulated/0/Pictures/xposed # sh script.sh #执行script.sh
&ensp;&ensp;&ensp;&ensp;成功的话将会得到以下信息
&ensp;&ensp;&ensp;&ensp;reboot或者手动重启模拟器，打开xposed install即可看到xp环境已经安装成功
参考：https://www.52pojie.cn/forum.php?mod=viewthread&amp;tid=1308953&amp;extra=page%3D1%26filter%3Dauthor%26orderby%3Ddateline
]]></content>
      <categories>
        <category>菜鸡手记</category>
      </categories>
      <tags>
        <tag>软件与工具</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象之多态</title>
    <url>/2021/07/15/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E5%A4%9A%E6%80%81/</url>
    <content><![CDATA[多态:同一个类型的多个实例，在执行同一个方法时，呈现出多种的行为特征//“铠甲勇士”类public class 铠甲勇士 &#123;    public void skill(String name)&#123;        System.out.println(name + &quot;:普通攻击&quot;);    &#125;&#125;

//“刑天铠甲”类继承了“铠甲勇士”类public class 刑天铠甲 extends 铠甲勇士&#123;    private static String name = &quot;刑天铠甲&quot;;    //重写“铠甲勇士”类skill方法    @Override    public void skill(String name)&#123;        System.out.println(name + &quot;:火光剑法&quot;);    &#125;&#125;
//“飞影铠甲”类继承了“铠甲勇士”类public class 飞影铠甲 extends 铠甲勇士&#123;    //新增features方法    public void features()&#123;        System.out.println(&quot;飞影铠甲特征:蓝色&quot;);    &#125;&#125;
//“铠甲功能”类public class 铠甲功能 &#123;    private static String name;    public static void main(String[] args)&#123;        铠甲功能.技能释放();        铠甲功能.铠甲特征();    &#125;//向上转型，子类对象直接赋值给父类对象    public static void 技能释放()&#123;//        动态绑定“刑天铠甲”类的skill方法，编译类型是“铠甲勇士”，实际类型是“刑天铠甲”        铠甲勇士 刑天技能 = new 刑天铠甲();        name = &quot;刑天铠甲&quot;;        刑天技能.skill(name);//        动态绑飞影铠甲类的skill方法，若无，则向父类查找，编译类型是”铠甲勇士“，实际类型是飞影铠甲        铠甲勇士 飞影技能 = new 飞影铠甲();        name = &quot;飞影铠甲&quot;;        飞影技能.skill(name);    &#125;//向下转型，父类对象赋值给子类对象，需要强转类型    public static void 铠甲特征()&#123;        铠甲勇士 飞影技能 = new 飞影铠甲();//        于编译器而言，“飞影技能”是“铠甲勇士”类型（实际运行时是“飞影铠甲”类型），由于“铠甲勇士”类下并没有features方法，所以编译报错，实际可以运行//        飞影技能.features();//        强制类型转换，将“铠甲勇士”类型的“飞影技能”强转为“飞影铠甲”类型，“飞影铠甲”类有features()方法，故不会报错        飞影铠甲 铠甲类型强转 = (飞影铠甲)飞影技能;        铠甲类型强转.features();    &#125;&#125;
运行“铠甲功能”类，输出：刑天铠甲:火光剑法飞影铠甲:普通攻击飞影铠甲特征:蓝色//小类赋值给大类称为向上转型，子类对象直接赋值给父类对象//大类赋值给小类称为向下转型，父类对象赋值给子类对象，需要强转类型
ClassCastException错误public static void 铠甲特征()&#123;    铠甲勇士 飞影技能 = new 飞影铠甲();//    于编译器而言，“飞影技能”是“铠甲勇士”类型（实际运行时是“飞影铠甲”类型），由于“铠甲勇士”类下并没有features方法，所以编译报错，实际可以运行    飞影技能.features();//    强制类型转换，将“铠甲勇士”类型的“飞影技能”强转为“飞影铠甲”类型，“飞影铠甲”类有features()方法，故不会报错    飞影铠甲 铠甲类型强转 = (飞影铠甲)飞影技能;    铠甲类型强转.features();//    ClassCastException//    将刑天铠甲类型变量(实际类型)转换为飞影铠甲类型变量时，将会发生错误//    报错：刑天铠甲 cannot be cast to 飞影铠甲    铠甲勇士 刑天技能 = new 刑天铠甲();    飞影铠甲 铠甲类型强转2 = (飞影铠甲)刑天技能;&#125;//    结论：强转运算运算符只能给具有继承关系的编译类型做强转，否则编译错误
第二种ClassCastException错误public static void test()&#123;//    value1编译时类型为Object，实际类型为String    Object value1 = &quot;123&quot;;//    Integer继承于Object，所以编译时不会报错    Integer value2 = (Integer)value1;//    运行时报错java.lang.String cannot be cast to java.lang.Integer&#125;//    结论：具有继承关系的编译类型强制转换时，如果被转变量的实际类型不是要转的目标类型，则运行错误
instanceof运算符:避免ClassCastException异常//运用该运算符，可以将test()方法改写为如下public static void test()&#123;    Object value1 = &quot;123&quot;;    if (value1 instanceof Integer)&#123;        Integer value2 = (Integer)value1;    &#125;    else&#123;        System.out.println(&quot;String不能强转为Integer类型&quot;);    &#125;&#125;
//那么铠甲特征()方法可修改为如下public static void 铠甲特征()&#123;    铠甲勇士 飞影技能 = new 飞影铠甲();    if (飞影技能 instanceof 飞影铠甲)&#123;        飞影铠甲 铠甲类型强转 = (飞影铠甲)飞影技能;        铠甲类型强转.features();    &#125;    else &#123;        System.out.println(&quot;飞影技能不能强转为飞影铠甲类型&quot;);    &#125;	    铠甲勇士 刑天技能 = new 刑天铠甲();    if (刑天技能 instanceof 飞影铠甲)&#123;        飞影铠甲 铠甲类型强转2 = (飞影铠甲)刑天技能;    &#125;    else &#123;        System.out.println(&quot;刑天技能不能强转为飞影铠甲类型&quot;);    &#125;&#125;//instanceof运算符可以确保被强制转换类型的变量确实可以强制转换，从而避免ClassCastException
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象之封装</title>
    <url>/2021/07/15/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E5%B0%81%E8%A3%85/</url>
    <content><![CDATA[访问控制符的权限级别&ensp;&ensp;&ensp;&ensp;public &gt; protected &gt; default &gt; private
&ensp;&ensp;&ensp;&ensp;public:公共访问权限&ensp;&ensp;&ensp;&ensp;pritected:子类访问权限&ensp;&ensp;&ensp;&ensp;default:包访问权限&ensp;&ensp;&ensp;&ensp;private:当前类访问权限
set和get如下类，使用private将test类中的name变量封装了起来并且提供了setName和getName使其他类通过我们提供的方法修改和获取name变量public class public_test &#123;    public static void main(String[] args)&#123;        test set = new test();//        修改test类中name变量的值        set.setName(&quot;xxin&quot;);//        将会输出&quot;xxin&quot;        System.out.println(set.getName());    &#125;&#125;class test&#123;    private String name = &quot;默认名&quot;;//    修改name    public void setName(String name)&#123;        this.name = name;    &#125;//    获取name    public String getName()&#123;        return this.name;    &#125;&#125;
package和importpackage//package作为java源文件第一行代码，制定了class文件的包路径package lee.demo;//将该源程序所编译的class文件放置在lee\demo
import//impoit用于引入包路径import lee.demo.test; //引入test\demo路径下的test类import lee.demo.*; //引入lee\demo包下的所有类
import static//import static静态导入，用于导入指定类的某个静态成员变量、方法或全部的静态成员变量、方法//方法导入import static lee.demo.test.method1;  //引入lee\demo包下，test类的method1方法//引入后可直接调用method1method1();//变量导入import static lee.demo.test.a;  //引入lee\demo包下，test类的a变量//引入后可直接调用aSystem.out.println(a);//引入全部静态变量方法import static lee.demo.test.*;  //引入lee\demo包下，test类的全部静态变量方法
java常用包&ensp;&ensp;&ensp;&ensp;java.lang: 这个包下包含了Java语言的核心类，如String、Math、Sytem和Thread类等，使用这个包无需使用import语句导入，系统会自动导入这个包中的所有类。&ensp;&ensp;&ensp;&ensp;java.util: 这个包下包含java的大量工具类/接口和集合框架类/接口。如Arrays和List、Set等。&ensp;&ensp;&ensp;&ensp;java.net: 这个包下包含了一些Java网络编程相关的类/接口。&ensp;&ensp;&ensp;&ensp;java.io: 这个包含了一些Java输入/输出编程相关的类/接口。&ensp;&ensp;&ensp;&ensp;java.text: 这个包下包含一些Java格式化相关的类。&ensp;&ensp;&ensp;&ensp;java.sql: 这个包下包含了java进行JDBC数据库编程的相关类/接口。&ensp;&ensp;&ensp;&ensp;java.awt: 这个包下包含了抽象窗口工具集(Abstract Window Toolkits) 的相关类/接口，这些类主要用于构建图形用户界面(GUI)程序。&ensp;&ensp;&ensp;&ensp;java.swing:这个包下包含了Swing图形用户界面编程的相关类/接口，这些可用于构建平台无关的GUI程序。
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象之继承</title>
    <url>/2021/07/15/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[类继承注意，被final标记的类不能被继承
&ensp;&ensp;创建一个Person类，public class Person &#123;&#125;
&ensp;&ensp;Boy类继承Person类public class Boy extends Person &#123;    &#125;

&ensp;&ensp;在Person类中添加方法public class Person &#123;    public void age() &#123;        System.out.println(&quot;年龄&quot;);    &#125;    public void height() &#123;        System.out.println(&quot;身高&quot;);    &#125;    public void width() &#123;        System.out.println(&quot;体重&quot;);    &#125;&#125;
&ensp;&ensp;因为Boy是继承Person，所以可以调用Person类中的方法public class Boy extends Person &#123;    public void name() &#123;        System.out.println(&quot;小明&quot;);    &#125;    public static void main(String[] args) &#123;        Boy boy = new Boy();        boy.height();        boy.width();        boy.age();    &#125;&#125;
&ensp;&ensp;如上代码在Boy类的main方法中调用Person类的三个方法，将会输出身高体重年龄
方法重写注意事项

private方法不能被重写
final标记的方法不能被重写
static方法不能被重写，所以static方法无需再标记final

&ensp;&ensp;在Boy类中可以对Person类已有的方法重写public class Boy extends Person &#123;    @Override    public void age() &#123;        System.out.println(&quot;年龄18&quot;);    &#125;    @Override    public void height() &#123;        System.out.println(&quot;身高180&quot;);    &#125;    @Override    public void width() &#123;        System.out.println(&quot;体重120&quot;);    &#125;    public static void main(String[] args) &#123;        Boy boy = new Boy();        boy.height();        boy.width();        boy.age();    &#125;&#125;
&ensp;&ensp;此时将会输出身高180体重120年龄18
&ensp;&ensp;如果想在子类中调用父类的方法，可以使用super关键字public class Boy extends Person &#123;    @Override    public void age() &#123;        super.age();        System.out.println(&quot;年龄18&quot;);    &#125;    @Override    public void height() &#123;        super.height();        System.out.println(&quot;身高180&quot;);    &#125;    @Override    public void width() &#123;        super.width();        System.out.println(&quot;体重120&quot;);    &#125;    public static void main(String[] args) &#123;        Boy boy = new Boy();        boy.height();        boy.width();        boy.age();    &#125;&#125;
&ensp;&ensp;此时将会输出身高身高180体重体重120年龄年龄18
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>黄粱情书</title>
    <url>/2023/07/22/%E9%BB%84%E7%B2%B1%E6%83%85%E4%B9%A6/</url>
    <content><![CDATA[&ensp;&ensp;不知怎么，最近反复的梦见你，像是我在提醒自己，提醒自己别把你忘记。
&ensp;&ensp;昨天见你，在那个破旧教室里，看到你推门而入的瞬间，埋在心底的千言万语重又迸发生机，裹挟了思念伏于胸腹，正欲一涌而出，却又迟疑不决，不知是将这满溢的思念表述给你，还是一如往常般故作高冷，这的确是个难以抉择的问题，倘若推心置腹，恐怕只是一厢情愿，感动了自己，恶心了别人，但若一言不发，又担心错过这最后一次见你的机会。
&ensp;&ensp;几经周折，内心的自我斗争仍未落下帷幕，就在迟疑不决中，你竟走了过来，出乎意料地坐在我一旁，随着你的落座，我清晰的感觉到血液流速开始加快，并迅速向大脑涌去，直到它嗡的一声短路，于是思维不再受控制，想对你说的那千言万语也更加不知从何说起。
&ensp;&ensp;“你去哪了”，“过得顺心吗”，“还喜欢打游戏吗”，“和谁一起打”，“蓄起长发了吗”，“你会梦到我吗”，“会有些瞬间想起我吗”，……。岁月带来千锤百锻，将思念中的杂质尽数去除，如此再没有太多内容修饰它，剩下这炙热纯粹，留人昼夜深思，久而凑成灵魂的一部分，魂牵梦萦，挥之不散。可笑世事玩味，旧时讥人，今番讽己，万千思念尽数押在口中，如箭在弦而不发，全无向前一步的勇气，直至你起身离开。
&ensp;&ensp;挽留的话也随即嚼碎，摆出胜利者的姿态，将结局归咎于天命，妄图开脱人事的罪过。寻一处幽静，守着教室里你离开后的座位，待尘埃落定，权当那没说出口的话都因为脑短路而消失了吧，能看到你很好，已经足够给我所有幻想画上一个句号。只是人去楼空后，凌乱的思绪愈发难以自抑，神鬼不觉中撬开回忆，崩碎十分怀念，残垣零落满地，两分不甘、三分留恋、五分虚情假意，刺痛了麻木的神经，颠覆了倒悬的灵魂。
&ensp;&ensp;前天见你，在熙熙攘攘的人群里，其实不能确定那真的是你，因为随着时间推移，记忆中的面孔已经有些模糊，所以看到的你也显得朦胧，像被一层薄雾笼罩着，但凭着熟悉的身影，又觉得那的确是你，不过无论如何，我都期待能和那个身影再见一面，以此告慰无数次在人山人海中的觅迹寻踪。
&ensp;&ensp;与那个身影，或者说我们，我们之间的距离并不算远，虽身处两个世界，却只隔了一层楼梯，尽管那为数不多的台阶上，淤塞着乌泱泱的杂人。我想跨越我们之间的咫尺千里，打破旁人的桎梏去见你，却少了一个见你的理由，伪装太过于拙劣，见一个人何曾需要什么理由，所以它更像是掩饰懦弱的借口，不过我的确需要这个借口，借着它说服自己放下最后的尊严，然后恬不知耻的去见你。
&ensp;&ensp;而今这等次第，早已失去了往日的不可一世，反倒更像是心虚的贼，不停低眉四下打量着，确认没有人注意我，转而贪婪的窥窃着那层薄雾后的朦胧，同时又要强装镇定，不敢让任何人发现我内心的悸动，怕有一日传到那群屌毛的耳朵里，定然引得他们哄堂大笑，笑我那么没出息。
&ensp;&ensp;当朦胧的身影愈发朦胧，便知你正在远去，期待的奇迹未曾降临，你依旧坚定的凝视着前方。形形色色的人阻断我最后的视线，我所有祈愿都化为乌有，想必我们最后的联系只剩下量子纠缠。那么你是怎么离开的？是坦然的笑着？还是略有惋惜？亦或是不屑一顾？甚至是嗤之以鼻？希望没有愁容满面吧，那将成为你我最大的遗憾。
&ensp;&ensp;再往前一天，迎接我的是一双澄澈的眼，温柔的目光中充斥着不满，催促我解释那无人可知的故事。几句含糊其辞潦草搪塞，余下的部分便定义为“忘了”，即使存在于记忆中。实际上我编造过太多谎言，只为逃避那些狼狈与不堪，而为了掩饰谎言，不得不编造更多谎言，你与那些最关心我的人一样，都在一个个不真实的故事中晕头转向，所以我再也寻不着通透的解释，于是决定讲一个新的谎言。
&ensp;&ensp;你把目光转过一边，久久不发一言，怅然若失的盯着远处风景，我的话像风一样从耳边吹过，随后消失无踪，风却能像棉花糖，被你温热的脸融化，头发就这样黏在脸颊上，如果我敢大胆一些，近向前去，不难数清那几根乖戾，再顺手帮你撩拨开来。你又低头摆弄指甲，换做一副漫不经心的神态，似要叫我明白，那些谎话从来没能骗过谁，始终是在坑害自己。
&ensp;&ensp;期待与无奈在沉寂中交织，慢慢扭曲变态，遮蔽天日不见了光彩，忽然一声轻叹，谴退万里阴霾，见没有翅膀的鸟潜入碧波荡漾的天，鲤鱼拱进土地，替小麦树松散了土壤，螃蟹把树梢上的麦穗钳下，贮在蟹巢里。那是你的叹息荡涤了污浊，给缥缈绘制声色，给抽象塑封形影，不露声色的缔造了我理想的乌托邦，这是个只属于我的新世界，可惜我带不走任何东西。
&ensp;&ensp;人言我薄情，人道我寡义，虽有百口莫辩，且以今日为镜，鉴明悠悠之心，暂借昨日之印，封起万里悲秋，愿有明日星辰，引我沧海一粟。
]]></content>
      <categories>
        <category>随笔一记</category>
      </categories>
  </entry>
  <entry>
    <title>高德定位与坐标系转换</title>
    <url>/2022/10/26/%E9%AB%98%E5%BE%B7%E5%AE%9A%E4%BD%8D%E4%B8%8E%E5%9D%90%E6%A0%87%E7%B3%BB%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[&ensp;&ensp;下载定位包并引入
配置权限&ensp;&ensp;配置AndroidManifest.xml&lt;application    android:allowBackup=&quot;true&quot;    android:dataExtractionRules=&quot;@xml/data_extraction_rules&quot;    android:fullBackupContent=&quot;@xml/backup_rules&quot;    android:icon=&quot;@mipmap/ic_launcher&quot;    android:label=&quot;@string/app_name&quot;    android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;    android:supportsRtl=&quot;true&quot;    android:theme=&quot;@style/Theme.XAT&quot;    tools:targetApi=&quot;31&quot;&gt;    ...    &lt;meta-data android:name=&quot;com.amap.api.v2.apikey&quot; android:value=&quot;您的Key&quot;/&gt;    &lt;service android:name=&quot;com.amap.api.location.APSService&quot;/&gt;    ...&lt;/application&gt;
&ensp;&ensp;配置权限&lt;!--允许访问网络，必选权限--&gt;    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;    &lt;!--允许获取精确位置，精准定位必选--&gt;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_FINE_LOCATION&quot; /&gt;    &lt;!--允许获取粗略位置，粗略定位必选--&gt;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_COARSE_LOCATION&quot; /&gt;    &lt;!--允许获取设备和运营商信息，用于问题排查和网络定位（无gps情况下的定位），若需网络定位功能则必选--&gt;    &lt;uses-permission android:name=&quot;android.permission.READ_PHONE_STATE&quot; /&gt;    &lt;!--允许获取网络状态，用于网络定位（无gps情况下的定位），若需网络定位功能则必选--&gt;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;    &lt;!--允许获取wifi网络信息，用于网络定位（无gps情况下的定位），若需网络定位功能则必选--&gt;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot; /&gt;    &lt;!--允许获取wifi状态改变，用于网络定位（无gps情况下的定位），若需网络定位功能则必选--&gt;    &lt;uses-permission android:name=&quot;android.permission.CHANGE_WIFI_STATE&quot; /&gt;    &lt;!--后台获取位置信息，若需后台定位则必选--&gt;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_BACKGROUND_LOCATION&quot; /&gt;    &lt;!--用于申请调用A-GPS模块,卫星定位加速--&gt;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_LOCATION_EXTRA_COMMANDS&quot; /&gt;    &lt;!--允许写入扩展存储，用于写入缓存定位数据--&gt;    &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;        tools:ignore=&quot;ScopedStorage&quot; /&gt;    &lt;!--允许读设备等信息，用于问题排查--&gt;    &lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot; /&gt;
请求权限public static final int WRITE_EXTERNAL_STORAGE_CODE = 10001;public static final int ACCESS_FINE_LOCATION_CODE = 10002;public static final int READ_PHONE_STATE_CODE = 10003;/** * 申请定位权限 * * @param activity    上下文 */public static void requestLocation(Activity activity) &#123;    if (!isLocation(activity)) &#123;        ActivityCompat.requestPermissions(activity, new String[]&#123;                Manifest.permission.ACCESS_FINE_LOCATION,                Manifest.permission.ACCESS_COARSE_LOCATION        &#125;, ACCESS_FINE_LOCATION_CODE);    &#125;&#125;/** * 是否拥有定位权限 * * @param activity 上下文 * @return 结果 */public static boolean isLocation(Activity activity) &#123;    return ActivityCompat.checkSelfPermission(activity, Manifest.permission.ACCESS_FINE_LOCATION) == PackageManager.PERMISSION_GRANTED            &amp;&amp; ActivityCompat.checkSelfPermission(activity, Manifest.permission.ACCESS_COARSE_LOCATION) == PackageManager.PERMISSION_GRANTED;&#125;/** * 读取设备状态权限 * * @param activity    上下文 */public static void requestReadPhoneState(Activity activity) &#123;    if (!isReadPhoneState(activity)) &#123;        ActivityCompat.requestPermissions(activity, new String[]&#123;                Manifest.permission.READ_PHONE_STATE        &#125;, READ_PHONE_STATE_CODE);    &#125;&#125;/** * 是否拥有读取设备状态权限 * * @param activity 上下文 * @return 结果 */public static boolean isReadPhoneState(Activity activity) &#123;    if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123;        return ActivityCompat.checkSelfPermission(activity, Manifest.permission.READ_PHONE_STATE) == PackageManager.PERMISSION_GRANTED;    &#125;    return true;&#125;/** * 请求外部储存权限，安卓6.0之前不需要动态申请 * * @param activity    上下文 */public static void requestWrite(Activity activity) &#123;    if (!isWrite(activity)) &#123;        ActivityCompat.requestPermissions(activity, new String[]&#123;                Manifest.permission.WRITE_EXTERNAL_STORAGE,                Manifest.permission.READ_EXTERNAL_STORAGE        &#125;, WRITE_EXTERNAL_STORAGE_CODE);    &#125;&#125;/** * 是否拥有外部储存写入权限，安卓6.0之前不需要动态申请 * * @param activity 上下文 * @return 结果 */public static boolean isWrite(Activity activity) &#123;    if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123;        return ActivityCompat.checkSelfPermission(activity, Manifest.permission.READ_EXTERNAL_STORAGE) == PackageManager.PERMISSION_GRANTED                &amp;&amp; ActivityCompat.checkSelfPermission(activity, Manifest.permission.WRITE_EXTERNAL_STORAGE) == PackageManager.PERMISSION_GRANTED;    &#125;    return true;&#125;
初始化定位&ensp;&ensp;新建AMapLocation类，initAMapLocation()方法初始化定位，getAMapLocation()获取高德定位点public class AMapLocationUtils &#123;    // 高德地图点位对象    private AMapLocation aMapLocation;    private static AMapLocationUtils AMapLocationUtils;    public static AMapLocationUtils getInstance()&#123;        if (AMapLocationUtils == null)&#123;            AMapLocationUtils = new AMapLocationUtils();        &#125;        return AMapLocationUtils;    &#125;    /**     * 初始化     */    public void initAMapLocation(Context context)&#123;        AMapLocationClient.updatePrivacyShow(context, true, true);        AMapLocationClient.updatePrivacyAgree(context, true);        //声明AMapLocationClientOption对象        AMapLocationClientOption mLocationOption = new AMapLocationClientOption();        //声明AMapLocationClient类对象        AMapLocationClient mLocationClient = null;        try &#123;            // 初始化定位            mLocationClient = new AMapLocationClient(context);        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;        if(mLocationClient != null)&#123;            //设置定位回调监听            mLocationClient.setLocationListener(                    aMapLocation -&gt; this.aMapLocation = aMapLocation);            // 设置定位模式为AMapLocationMode.Hight_Accuracy，高精度模式。            mLocationOption.setLocationMode(AMapLocationClientOption.AMapLocationMode.Hight_Accuracy);            // 设置定位模式为AMapLocationMode.Battery_Saving，低功耗模式。            // mLocationOption.setLocationMode(AMapLocationClientOption.AMapLocationMode.Battery_Saving);            // 设置定位模式为AMapLocationMode.Device_Sensors，仅设备模式。不需要连接网络，必须在室外环境下            // mLocationOption.setLocationMode(AMapLocationClientOption.AMapLocationMode.Device_Sensors);            // 获取一次定位结果            // 该方法默认为false。            // mLocationOption.setOnceLocation(true);            // 获取最近3s内精度最高的一次定位结果            // 设置setOnceLocationLatest(boolean b)接口为true，启动定位时SDK会返回最近3s内精度最高的一次定位结果。            // 如果设置其为true，setOnceLocation(boolean b)接口也会被设置为true，反之不会，默认为false。            mLocationOption.setOnceLocationLatest(true);            // 设置定位间隔,单位毫秒,默认为2000ms，最低1000ms。            mLocationOption.setInterval(1000);            // 设置是否返回地址信息（默认返回地址信息）            mLocationOption.setNeedAddress(true);            //设置是否允许模拟位置,默认为true，允许模拟位置            mLocationOption.setMockEnable(false);            //单位是毫秒，默认30000毫秒，建议超时时间不要低于8000毫秒。            mLocationOption.setHttpTimeOut(8000);            //关闭定位缓存机制            mLocationOption.setLocationCacheEnable(false);            //给定位客户端对象设置定位参数            mLocationClient.setLocationOption(mLocationOption);            //启动定位            mLocationClient.startLocation();            AMapLocationClientOption option = new AMapLocationClientOption();            // 设置定位场景，目前支持三种场景（签到、出行、运动，默认无场景）            option.setLocationPurpose(AMapLocationClientOption.AMapLocationPurpose.SignIn);            mLocationClient.setLocationOption(option);            //设置场景模式后最好调用一次stop，再调用start以保证场景模式生效            mLocationClient.stopLocation();            mLocationClient.startLocation();        &#125;    &#125;    public AMapLocation getAMapLocation()&#123;        if (aMapLocation != null) &#123;            if (aMapLocation.getErrorCode() == 0) &#123;                return aMapLocation;            &#125;            else &#123;                //定位失败时，可通过ErrCode（错误码）信息来确定失败的原因，errInfo是错误信息，详见错误码表。                Log.e(&quot;AmapError&quot;,&quot;location Error, ErrCode:&quot;                        + aMapLocation.getErrorCode() + &quot;, errInfo:&quot;                        + aMapLocation.getErrorInfo());                return null;            &#125;        &#125;        return null;    &#125;&#125;
坐标转换&ensp;&ensp;通常GPS获取的是WGS84坐标体系，包括很多国外地图厂商提供的地图数据也是WGS84坐标体系，但是在我国，由于政策原因，在地图发布和出版的时候，坐标至少需要经过国家测绘局加密，也就是对WGS84坐标进行一次非线性加偏，得到GCJ02坐标系，俗称火星坐标
&ensp;&ensp;GCJ02转WGS84private static final double PI = 3.14159265358979324;/** * 将高德地图SDK获取到的GCJ02坐标系转换为WGS84坐标系 * @param lat 维度 * @param lon 经度 * @return 转换后的坐标 */public static Location GCJ02ToWGS84(double lat, double lon) &#123;    double a = 6378245.0; //克拉索夫斯基椭球参数长半轴a    double ee = 0.00669342162296594323; //克拉索夫斯基椭球参数第一偏心率平方    double dLat = transformLat(lon - 105.0, lat - 35.0);    double dLon = transformLon(lon - 105.0, lat - 35.0);    double radLat = lat / 180.0 * PI;    double magic = Math.sin(radLat);    magic = 1 - ee * magic * magic;    double sqrtMagic = Math.sqrt(magic);    dLat = (dLat * 180.0) / ((a * (1 - ee)) / (magic * sqrtMagic) * PI);    dLon = (dLon * 180.0) / (a / sqrtMagic * Math.cos(radLat) * PI);    Location location = new Location(&quot;&quot;);    location.setLatitude(lat - dLat);    location.setLongitude(lon - dLon);    return location;&#125;/** * 转换经度 */public static double transformLon(double x, double y) &#123;    double ret = 300.0 + x + 2.0 * y + 0.1 * x * x + 0.1 * x * y + 0.1 * Math.sqrt(Math.abs(x));    ret += (20.0 * Math.sin(6.0 * x * PI) + 20.0 * Math.sin(2.0 * x * PI)) * 2.0 / 3.0;    ret += (20.0 * Math.sin(x * PI) + 40.0 * Math.sin(x / 3.0 * PI)) * 2.0 / 3.0;    ret += (150.0 * Math.sin(x / 12.0 * PI) + 300.0 * Math.sin(x / 30.0 * PI)) * 2.0 / 3.0;    return ret;&#125;/** * 转换纬度 */public static double transformLat(double x, double y) &#123;    double ret = -100.0 + 2.0 * x + 3.0 * y + 0.2 * y * y + 0.1 * x * y + 0.2 * Math.sqrt(Math.abs(x));    ret += (20.0 * Math.sin(6.0 * x * PI) + 20.0 * Math.sin(2.0 * x * PI)) * 2.0 / 3.0;    ret += (20.0 * Math.sin(y * PI) + 40.0 * Math.sin(y / 3.0 * PI)) * 2.0 / 3.0;    ret += (160.0 * Math.sin(y / 12.0 * PI) + 320 * Math.sin(y * PI / 30.0)) * 2.0 / 3.0;    return ret;&#125;
参考：Android定位SDK
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android开发手记</tag>
      </tags>
  </entry>
</search>
